<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wj-Blog</title>
  
  
  <link href="http://wangjin1996219.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangjin1996219.github.io/"/>
  <updated>2021-06-03T14:10:37.495Z</updated>
  <id>http://wangjin1996219.github.io/</id>
  
  <author>
    <name>老王家的小王呀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试准备知识清单</title>
    <link href="http://wangjin1996219.github.io/2021/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95/"/>
    <id>http://wangjin1996219.github.io/2021/06/03/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95/</id>
    <published>2021-06-03T08:13:46.000Z</published>
    <updated>2021-06-03T14:10:37.495Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-笔试"><a href="#1-笔试" class="headerlink" title="1.笔试"></a>1.笔试</h1><h1 id="2-面试"><a href="#2-面试" class="headerlink" title="2.面试"></a>2.面试</h1><h2 id="2-1手撕代码相关"><a href="#2-1手撕代码相关" class="headerlink" title="2.1手撕代码相关"></a>2.1手撕代码相关</h2><h3 id="2-1-1手撕算法"><a href="#2-1-1手撕算法" class="headerlink" title="2.1.1手撕算法"></a>2.1.1手撕算法</h3><p>CodeTop 前 200</p><p>牛客上周考过（极有可能出题）</p><h3 id="2-1-2手撕-SQL"><a href="#2-1-2手撕-SQL" class="headerlink" title="2.1.2手撕 SQL"></a>2.1.2手撕 SQL</h3><p>牛客在线 SQL 编程 80 题</p><h3 id="2-1-3手撕设计模式（单例模式）"><a href="#2-1-3手撕设计模式（单例模式）" class="headerlink" title="2.1.3手撕设计模式（单例模式）"></a>2.1.3手撕设计模式（单例模式）</h3><p>懒汉单例</p><p>饿汉单例</p><p>线程安全（加锁、双重判断检测、Volatile 防止重排序）</p><p>防止反射破坏</p><h3 id="2-1-4手撕多线程"><a href="#2-1-4手撕多线程" class="headerlink" title="2.1.4手撕多线程"></a>2.1.4手撕多线程</h3><p><strong>简单的 ABAB 交替运行：</strong></p><p>Thread</p><p>Runable</p><p>lambda 表达式和 stream 流</p><p><strong>多线程银行取钱 Demo</strong></p><h2 id="2-2八股技术核心"><a href="#2-2八股技术核心" class="headerlink" title="2.2八股技术核心"></a>2.2八股技术核心</h2><h3 id="2-2-1-Java-基础"><a href="#2-2-1-Java-基础" class="headerlink" title="2.2.1 Java 基础"></a>2.2.1 Java 基础</h3><p>面向对象三大特性</p><p>覆盖、重载与多态</p><p>JDK、JRE 与 JVM</p><p>抽象类与接口</p><p>注解与反射</p><p>异常与错误</p><p>值传递与引用</p><h3 id="2-2-2-Java-三大集合"><a href="#2-2-2-Java-三大集合" class="headerlink" title="2.2.2 Java 三大集合"></a>2.2.2 Java 三大集合</h3><p><strong>List 集合：</strong></p><p>链表</p><p>数组</p><p><strong>Map 集合（HashMap）：</strong></p><p>JDK1.7 与 1.8 的区别（链表红黑树、头插法尾插法）</p><p>HashMap 与 ConcurrentHashMap （线程安全问题）</p><p><strong>Set 集合</strong></p><p><strong>三大集合的实现类</strong></p><h3 id="2-2-3-Java-多线程"><a href="#2-2-3-Java-多线程" class="headerlink" title="2.2.3 Java 多线程"></a>2.2.3 Java 多线程</h3><p>线程与进程</p><p>线程的状态</p><p>线程池阻塞队列</p><h3 id="2-2-4-JVM-相关"><a href="#2-2-4-JVM-相关" class="headerlink" title="2.2.4 JVM 相关"></a>2.2.4 JVM 相关</h3><p><strong>内存回收：</strong></p><p>回收策略</p><p>回收算法</p><p>垃圾收集器</p><p><strong>类加载机制：</strong></p><p>findClass</p><p>classLoader</p><h3 id="2-2-5-Spring框架相关"><a href="#2-2-5-Spring框架相关" class="headerlink" title="2.2.5 Spring框架相关"></a>2.2.5 Spring框架相关</h3><h4 id="2-2-5-1-IOC-和-AOP"><a href="#2-2-5-1-IOC-和-AOP" class="headerlink" title="2.2.5.1 IOC 和 AOP"></a>2.2.5.1 IOC 和 AOP</h4><p><strong>常用注解：</strong></p><p>@Autowired</p><p>@Resource</p><p>@Controller</p><p>@Service</p><p>@Responsitory</p><p>@Component</p><p><strong>Spring 的优点：</strong></p><p>IOC 控制反转，依赖注入</p><p>AOP 面向切面编程</p><p><strong>AOP 的实现（两种动态代理）：</strong></p><p>JDK 动态代理</p><p>cglib</p><p><strong>IOC 容器初始化过程</strong></p><p><strong>Bean 的生命周期</strong></p><h4 id="2-2-5-2-SpringMVC"><a href="#2-2-5-2-SpringMVC" class="headerlink" title="2.2.5.2 SpringMVC"></a>2.2.5.2 SpringMVC</h4><p><strong>MVC 框架是什么</strong></p><p><strong>MVC 的消息处理流程</strong></p><h4 id="2-2-5-3-SpringBoot"><a href="#2-2-5-3-SpringBoot" class="headerlink" title="2.2.5.3 SpringBoot"></a>2.2.5.3 SpringBoot</h4><p><strong>自动装配</strong></p><p><strong>核心注解：</strong></p><p>@SpringBootConfiguration</p><p>@EnableAutoConfiguration</p><p>@SpringBootApplication</p><p>@ComponentScan</p><h4 id="2-2-5-4-Mybatis"><a href="#2-2-5-4-Mybatis" class="headerlink" title="2.2.5.4 Mybatis"></a>2.2.5.4 Mybatis</h4><p><strong>连接 MySQL 数据库</strong></p><p><strong>JDBC、Mybatis 和 Hibernate</strong></p><p><strong>四大核心组件</strong></p><p><strong>动态 SQL</strong></p><p><strong>符号：# 和 &amp;</strong></p><p><strong>接口绑定：</strong></p><p>注解绑定</p><p>XML 映射文件</p><p><strong>缓存机制</strong></p><h3 id="2-2-6-网络相关"><a href="#2-2-6-网络相关" class="headerlink" title="2.2.6 网络相关"></a>2.2.6 网络相关</h3><p><strong>浏览器中输入一个网址经历的过程</strong></p><p><strong>OSI 七层模型</strong></p><p><strong>TCP/IP 五层模型</strong></p><p><strong>应用层：</strong></p><p>Http 状态响应码</p><p>Http 和 Https 的区别</p><p>SSL协议</p><p>cookie、session 和 token</p><p><strong>传输层：</strong></p><p>TCP 三次握手以及四次挥手</p><p>流量控制（滑动窗口）</p><p>拥塞避免四种算法</p><p>TCP 和 UDP 的应用场景</p><p>TCP 和 UDP 协议的区别</p><p>Socket 相关</p><p>子网掩码的求法</p><p><strong>安全相关：</strong></p><p>XSS 跨站脚本攻击</p><p>CSRF 跨站请求伪造</p><p>SQL注入（预编译语句、存储过程、数据类型检查）</p><h3 id="2-2-7-操作系统相关"><a href="#2-2-7-操作系统相关" class="headerlink" title="2.2.7 操作系统相关"></a>2.2.7 操作系统相关</h3><p>内存管理</p><p>多线程相关</p><h3 id="2-2-8-结构化-SQL-数据库（MySQL）"><a href="#2-2-8-结构化-SQL-数据库（MySQL）" class="headerlink" title="2.2.8 结构化 SQL 数据库（MySQL）"></a>2.2.8 结构化 SQL 数据库（MySQL）</h3><h4 id="2-2-8-1-MySQL-索引"><a href="#2-2-8-1-MySQL-索引" class="headerlink" title="2.2.8.1 MySQL 索引"></a>2.2.8.1 MySQL 索引</h4><p>最左前缀匹配原则</p><p>聚簇索引与非聚簇索引</p><p>B 树、B+ 树与红黑树</p><h4 id="2-2-8-2常用存储引擎"><a href="#2-2-8-2常用存储引擎" class="headerlink" title="2.2.8.2常用存储引擎"></a>2.2.8.2常用存储引擎</h4><p>InnoDB（默认）</p><p>MyISAM</p><p>区别：MyISAM 不支持外键、不支持事务、不支持外键</p><h4 id="2-2-8-3-MySQL-日志模块"><a href="#2-2-8-3-MySQL-日志模块" class="headerlink" title="2.2.8.3 MySQL 日志模块"></a>2.2.8.3 MySQL 日志模块</h4><p>binlog</p><p>redo log</p><h4 id="2-2-8-4事务与隔离级别"><a href="#2-2-8-4事务与隔离级别" class="headerlink" title="2.2.8.4事务与隔离级别"></a>2.2.8.4事务与隔离级别</h4><p><strong>事务特性：</strong></p><p>原子性</p><p>一致性</p><p>隔离性</p><p>持久性</p><p><strong>并发问题：</strong></p><p>脏读</p><p>丢失修改</p><p>不可重复读</p><p>幻读</p><p><strong>隔离级别：</strong></p><p>读取未提交</p><p>读取已提交</p><p>可重复度</p><p>可串行化</p><h4 id="2-2-8-5-MySQL-的锁机制"><a href="#2-2-8-5-MySQL-的锁机制" class="headerlink" title="2.2.8.5 MySQL 的锁机制"></a>2.2.8.5 MySQL 的锁机制</h4><p><strong>表级锁和行级锁</strong></p><p><strong>独占锁和共享锁</strong></p><p><strong>悲观锁和乐观锁：</strong></p><p>乐观锁的 CAS</p><p>乐观锁的 ABA（基于数据版本（Version）记录机制解决）</p><p>==<strong>死锁解决？</strong>==</p><p>业务逻辑：</p><p>指定锁的获取顺序</p><p>大事务拆分成各个小事务</p><p>在同一个事务中，一次锁定尽可能多的资源，减少死锁概率</p><p>给表建立合适的索引以及降低事务的隔离级别等</p><p>数据库配置：</p><p>超时时间 innodb_lock_wait_timeout</p><p>死锁检测主动回滚</p><h4 id="2-2-8-6-SQL-优化，线上故障排查"><a href="#2-2-8-6-SQL-优化，线上故障排查" class="headerlink" title="2.2.8.6 SQL 优化，线上故障排查"></a>2.2.8.6 SQL 优化，线上故障排查</h4><p>explain</p><p>开启慢查询日志</p><h4 id="2-2-8-7建表约束"><a href="#2-2-8-7建表约束" class="headerlink" title="2.2.8.7建表约束"></a>2.2.8.7建表约束</h4><p>主键约束：唯一性、非空性</p><p>唯一约束：唯一性，可以为空，但只能有一个</p><p>检查约束：对该列数据的范围、格式的限制</p><p>默认约束：该数据的默认值</p><p>外键约束：需要建立两表间的关系并引用主表的列</p><h4 id="2-2-8-8-MVCC-多版本并发控制"><a href="#2-2-8-8-MVCC-多版本并发控制" class="headerlink" title="2.2.8.8 MVCC 多版本并发控制"></a>2.2.8.8 MVCC 多版本并发控制</h4><h3 id="2-2-9-非结构化-NoSQL-数据库（Redis）"><a href="#2-2-9-非结构化-NoSQL-数据库（Redis）" class="headerlink" title="2.2.9 非结构化 NoSQL 数据库（Redis）"></a>2.2.9 非结构化 NoSQL 数据库（Redis）</h3><h4 id="2-2-9-1介绍"><a href="#2-2-9-1介绍" class="headerlink" title="2.2.9.1介绍"></a>2.2.9.1介绍</h4><p>高性能的 keyvalue 分布式内存数据库</p><p>基于内存运行并支持持久化的 NoSQL 数据库</p><p>支持丰富的数据类型</p><h4 id="2-2-9-2丰富的数据类型"><a href="#2-2-9-2丰富的数据类型" class="headerlink" title="2.2.9.2丰富的数据类型"></a>2.2.9.2丰富的数据类型</h4><p><strong>五种基本类型及其应用场景：</strong></p><p>String：</p><p>List：</p><p>Set：</p><p>Sorted set：</p><p>Hash：</p><p><strong>三种特殊数据类型：</strong></p><p>暂无</p><p><strong>底层数据结构：</strong>简单动态字符串，链表，字典，跳表，整数集合以及压缩列表</p><h4 id="2-2-9-3-Redis-的线程模型"><a href="#2-2-9-3-Redis-的线程模型" class="headerlink" title="2.2.9.3 Redis 的线程模型"></a>2.2.9.3 Redis 的线程模型</h4><h4 id="2-2-9-4四大问题"><a href="#2-2-9-4四大问题" class="headerlink" title="2.2.9.4四大问题"></a>2.2.9.4四大问题</h4><p><strong>缓存雪崩：</strong>海量数据</p><p><strong>缓存击穿：</strong>热点数据过期</p><p><strong>缓存穿透：</strong>查询没有的数据</p><p><strong>一致性问题：</strong></p><p>双删延时的解决办法</p><p>更新数据库产生的 binlog 订阅（使用canal）</p><h4 id="2-2-9-5持久化方式"><a href="#2-2-9-5持久化方式" class="headerlink" title="2.2.9.5持久化方式"></a>2.2.9.5持久化方式</h4><p><strong>RDB（快照方式）（全量持久化）</strong></p><p><strong>AOF（增量持久化）</strong></p><p><strong>持久化策略选择</strong></p><h4 id="2-2-9-6数据的过期回收策略与内存淘汰机制"><a href="#2-2-9-6数据的过期回收策略与内存淘汰机制" class="headerlink" title="2.2.9.6数据的过期回收策略与内存淘汰机制"></a>2.2.9.6数据的过期回收策略与内存淘汰机制</h4><h4 id="2-2-9-7主从复制机制"><a href="#2-2-9-7主从复制机制" class="headerlink" title="2.2.9.7主从复制机制"></a>2.2.9.7主从复制机制</h4><p>哨兵</p><h4 id="2-2-9-8分布式系统CAP思想"><a href="#2-2-9-8分布式系统CAP思想" class="headerlink" title="2.2.9.8分布式系统CAP思想"></a>2.2.9.8分布式系统CAP思想</h4><p><strong>C：</strong>Consistent 一致性 </p><p><strong>A：</strong>Availability 可用性 </p><p><strong>P：</strong>Partition tolerance 分区容忍度 </p><p><strong>网络分区：</strong>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，网络断开也就意味着发生了网络分区。 </p><p><strong>最终一致性：</strong>Redis可以保证最终一致性，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。 </p><h4 id="2-2-9-9事务"><a href="#2-2-9-9事务" class="headerlink" title="2.2.9.9事务"></a>2.2.9.9事务</h4><p><strong>隔离性不中断</strong> </p><p><strong>事务内命令序列化</strong> </p><h3 id="2-2-10系统设计"><a href="#2-2-10系统设计" class="headerlink" title="2.2.10系统设计"></a>2.2.10系统设计</h3><p><strong>设计模式：</strong></p><p>工厂模式</p><p>单例模式</p><p>代理模式</p><p>==以下内容都在《大型网站技术架构》中找到==</p><p><strong>分布式</strong></p><p><strong>缓存</strong></p><p><strong>消息队列</strong></p><p><strong>具体应用：</strong></p><p>红包</p><p>秒杀</p><p>扫码登录</p><p>短网址</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="面试" scheme="http://wangjin1996219.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="知识清单" scheme="http://wangjin1996219.github.io/tags/%E7%9F%A5%E8%AF%86%E6%B8%85%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>手写实现SpringMVC</title>
    <link href="http://wangjin1996219.github.io/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/"/>
    <id>http://wangjin1996219.github.io/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/</id>
    <published>2021-06-01T08:40:53.000Z</published>
    <updated>2021-06-02T02:39:05.305Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-Spring-与-SpringMVC-的区别"><a href="#1-Spring-与-SpringMVC-的区别" class="headerlink" title="1. Spring 与 SpringMVC 的区别"></a>1. Spring 与 SpringMVC 的区别</h1><p><strong>Spring 框架：</strong>两大特性 IOC 和 AOP 。</p><ul><li>SpringIOC 特性：让 Spring 可以理解为一个管理 Bean 的容器</li><li>SpringMVC 特性：提供了面向切面编程，可以在不改变源代码的基础上，将模块通用的功能提取出来，不仅降低了代码的冗余，还大大降低了模块间的耦合性</li></ul><p><strong>SpringMVC 框架：</strong>核心类是 DispatcherServlet ，其实 SpringMVC 的本质就是一个 Servlet ，用来拦截前台的请求，调用 Service 层和 持久层 ，返回数据再通过 SpringMVC 把数据渲染成视图并返回给前台。而且 SpringMVC 要基于 Spring 框架才能跑起来。</p><h1 id="2-SpringMVC-的执行流程"><a href="#2-SpringMVC-的执行流程" class="headerlink" title="2. SpringMVC 的执行流程"></a>2. SpringMVC 的执行流程</h1><h2 id="2-1流程图"><a href="#2-1流程图" class="headerlink" title="2.1流程图"></a>2.1流程图</h2><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p><img src="/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/GitHub\MyBlogs\source\_posts\2021-06-01-手写实现SpringMVC\SpringMVC执行流程.png" style="zoom:80%;"><h2 id="2-2组件作用"><a href="#2-2组件作用" class="headerlink" title="2.2组件作用"></a>2.2组件作用</h2><ul><li><p><strong>DispatcherServlet：</strong>前端控制器。</p><p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p><p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p></li><li><p><strong>HandlerMapping：</strong>处理器映射器</p><p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p></li><li><p><strong>HandlerExecution：</strong>具体的Handler</p><p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p></li><li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p></li><li><p><strong>HandlAdapter：</strong>处理器适配器</p><p><strong>作用1：</strong>按照特定的规则去执行Handler；</p><p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p><p><strong>注：</strong>Model表示具体的数据，View表示视图</p></li><li><p><strong>View Resolver：</strong>视图解析器</p><p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p></li><li><p><strong>View：</strong>视图</p><p><strong>作用：</strong>向用户展示结果</p></li></ul><h2 id="2-3执行流程"><a href="#2-3执行流程" class="headerlink" title="2.3执行流程"></a>2.3执行流程</h2><ol><li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li><li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li><li>HandlerExecution就是具体的Controller；</li><li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li><li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li><li>HandlAdapter找到相应的Controller去执行；</li><li>Controller将执行结果返回给HandlAdapter；</li><li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li><li>dispatcherServlet调用View Resolver得到相应的页面地址；</li><li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li><li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li></ol><h1 id="3-项目概况"><a href="#3-项目概况" class="headerlink" title="3.项目概况"></a>3.项目概况</h1><img src="/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/GitHub\MyBlogs\source\_posts\2021-06-01-手写实现SpringMVC\项目概况.png" alt="image-20210601171822437" style="zoom: 67%;"><p>前一章中，我们在写 SpringIOC 框架时，采用的是自下而上的方式，这里我们采用自上而下的方式来写 SpringMVC 框架。</p><h2 id="3-1-pom-xml-导包"><a href="#3-1-pom-xml-导包" class="headerlink" title="3.1 pom.xml(导包)"></a>3.1 pom.xml(导包)</h2><p>我们都知道，SpringMVC 是基于 Java 的 Servelt 技术实现的，那么我们就需要导入 Servlet 的支持包，将这个项目改造成为一个 Web 项目。</p><p>在 Maven 中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-web-xml"><a href="#3-2-web-xml" class="headerlink" title="3.2 web.xml"></a>3.2 web.xml</h2><p>在项目的根目录下建立一个 web 文件夹，再在 web 文件夹下建立 WEB-INF 文件夹，再在其中新建 <code>web.xml</code> 文件。这就是这个 web 项目的配置文件，即 Servlet 的配置文件。内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xmlns=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> xmlns:web=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;3.0&quot;</span>&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">top</span>.<span class="title">wangjin</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">application</span>.<span class="title">properties</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">MySpringMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在 web.xml 文件中配置了一个 Servlet ，也就是 SpringMVC 的核心 DispatcherServlet ，并且设置这个 Servlet 处理所有的 URL 请求。</p><p>在这里我们配置了一个参数 contextConfigLocation ，参数的值为 application.properties 。这个文件作为我们的 SpringMVC 的配置文件，我们的 SpringMVC 并不需要太多配置，只需要知道 Controller 的扫描路径就可以了。在 resources 文件夹下新建这个文件，里面我只写了一行：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scanPackage</span>=<span class="string">top.guoziyang.main.controller</span></span><br></pre></td></tr></table></figure><p>表示我的所有的 Controller 都会放在<code>top.guoziyang.main.controller</code>包及其子包下，到时候启动时 SpringMVC 会去扫描这个包。</p><h2 id="3-3-package-springframework"><a href="#3-3-package-springframework" class="headerlink" title="3.3 package-springframework"></a>3.3 package-springframework</h2><h3 id="3-3-1-package-web"><a href="#3-3-1-package-web" class="headerlink" title="3.3.1 package-web"></a>3.3.1 package-web</h3><p>增加一个 web 包，用来放我们的核心类 DispatcherServlet ，表示与 web 处理应用有关。</p><p><strong>DispatcherServlet 类：</strong>重写了父类 HttpServlet 中三个重要的方法：init 方法、doGet 方法、doPost 方法</p><p>**<code>init 方法：</code>**初始化了一个 Spring 容器，调用方法完成：读取配置文件、扫描包下所有的 Controller、实例化所有 Controller 、并绑定 URL 路由</p><p><code>doGet 方法：</code>初始化之后，<strong>当一个请求到来，首先到达 doGet 和 doPost 方法。</strong></p><p><code>doPost 方法：</code>略</p><p>**<code>doDispatch 方法：</code>**我们自定义的实际处理请求的方法，主要逻辑就是从请求中获取请求的 Url 也就是请求的方法，然后用一个数组存放请求的参数，最后方法和方法的参数都获取到之后，通过反射的方式调用方法处理参数。</p><p><code>doLoadConfig 方法：</code>读取配置文件，获取 web.xml 文件中 DispatcherServlet 的配置文件路径</p><p><code>doScanner 方法：</code>扫描包下所有的 Controller，获取要扫描包的范围，并将范围内所有类放入 classNames 集合中</p><p><code>doInstance 方法：</code>实例化所有 Controller ，遍历 classNames 集合中所有的类，如果是加了 @Controller 注解的类就将 BeanDefinition 先注入到容器中，那么容器中有 Bean 是没有被实例化的，再调用 refreshBeanFactory 方法手动刷新，也就是将 BeanDefinition 中的 Bean 属性进行注入就将所有的 Controller 进行实例化了。</p><p><code>initHandlerMapping 方法：</code>遍历类集合 classes 如果类上有 RequestMapping 注解，根据注解的值来拼接 URL，并将 URL 与类（Controller）的映射存储在 controllerMap 中，将 URL 与 方法 的映射存储在 handlerMapping 这个 map 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Class&gt; classes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; controllerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPathXmlApplicationContext xmlApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取SpringIOC容器</span></span><br><span class="line">            xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application-annotation.xml&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>));</span><br><span class="line">        doScanner(properties.getProperty(<span class="string">&quot;scanPackage&quot;</span>));</span><br><span class="line">        doInstance();</span><br><span class="line">        initHandlerMapping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求HttpServletRequest，并返回结果HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;500!! Server Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际处理请求的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取请求的URL</span></span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        <span class="comment">//获取项目的相对路径</span></span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        url = url.replace(contextPath, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//如果请求的URL不存在，返回404错误</span></span><br><span class="line">        <span class="keyword">if</span> (!handlerMapping.containsKey(url)) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;404 NOT FOUND!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要请求的方法</span></span><br><span class="line">        Method method = handlerMapping.get(url);</span><br><span class="line">        <span class="comment">//获取请求方法的参数类型</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//获取请求中的参数键值对</span></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        <span class="comment">//存放请求中的参数</span></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            String requestParam = parameterTypes[i].getSimpleName();</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletRequest&quot;</span>)) &#123;</span><br><span class="line">                paramValues[i] = request;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletResponse&quot;</span>)) &#123;</span><br><span class="line">                paramValues[i] = response;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;String&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">                    <span class="comment">//获取实际的请求值</span></span><br><span class="line">                    String value = Arrays.toString(param.getValue()).replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;,\\s&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    paramValues[i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过方法名和参数，反射调用方法</span></span><br><span class="line">            method.invoke(controllerMap.get(url), paramValues);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取web.xml文件中DispatcherServlet的配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把web.xml中的contextConfigLocation对应value值的文件加载到流里面</span></span><br><span class="line">        InputStream resourceAsStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用Properties文件加载文件里的内容</span></span><br><span class="line">            properties.load(resourceAsStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resourceAsStream) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resourceAsStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取DispatcherServlet要扫描包的范围，并将范围内所有类放入classNames集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把所有的.替换成/</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;/&quot;</span> + packageName.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">//递归读取包</span></span><br><span class="line">                doScanner(packageName + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String className = packageName + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化Controller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合中的所有类</span></span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//把类搞出来,反射来实例化(只有加@Controller需要实例化)</span></span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(Controller.class)) &#123;</span><br><span class="line">                    classes.add(clazz);</span><br><span class="line">                    BeanDefinition definition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">                    definition.setSingleton(<span class="keyword">true</span>);</span><br><span class="line">                    definition.setBeanClassName(clazz.getName());</span><br><span class="line">                    xmlApplicationContext.addNewBeanDefinition(clazz.getName(), definition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            xmlApplicationContext.refreshBeanFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取RequestMapping这个注解的值，并且拼接出完整的URL:</span></span><br><span class="line"><span class="comment">     * 1.将URL与方法的映射存储在handlerMapping这个map中</span></span><br><span class="line"><span class="comment">     * 2.将URL与类的映射存储在controllerMap中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classes.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">                String baseUrl = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(RequestMapping.class)) &#123;</span><br><span class="line">                    baseUrl = clazz.getAnnotation(RequestMapping.class).value();</span><br><span class="line">                &#125;</span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!method.isAnnotationPresent(RequestMapping.class)) <span class="keyword">continue</span>;</span><br><span class="line">                    String url = method.getAnnotation(RequestMapping.class).value();</span><br><span class="line">                    url = (baseUrl + <span class="string">&quot;/&quot;</span> + url).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    handlerMapping.put(url, method);</span><br><span class="line">                    controllerMap.put(url, xmlApplicationContext.getBean(clazz));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-package-context"><a href="#3-3-2-package-context" class="headerlink" title="3.3.2 package-context"></a>3.3.2 package-context</h3><p>因为我们已经在获取 Bean 工厂时，就完成了读取 BeanDefinition 并注入 Bean 属性的过程，在 SpringMVC 框架中我们还要向容器中注入添加了 @Controller 注解的 Bean ，那么就要在 Spring 中的核心类 ApplicationContext 的实现类中开一个口子，能够调用方法，实现先向容器中添加 BeanDefinition ，再注入 Bean 属性的操作，因此我们在 <strong>ClassPathXmlApplicationContext</strong> 类中添加了下面两个方法：</p><p><code>addNewBeanDefinition 方法：</code>向容器中注册 BeanDefinition（解析过程在 DispatcherServlet 类中的 doInstance 方法中完成）</p><p><code>refreshBeanFactory 方法：</code>手动刷新，注入 Bean 的属性值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader.processAnnotationProperty(beanDefinition.getBeanClass(), beanDefinition);</span><br><span class="line">        beanFactory.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    prepareBeanFactory((AbstractBeanFactory) beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-package-annotation"><a href="#3-3-3-package-annotation" class="headerlink" title="3.3.3 package-annotation"></a>3.3.3 package-annotation</h3><p>新建几个注解：</p><p><strong>Controller 注解：</strong>说明实体类是一个 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RequestParam 注解：</strong>放在参数上，说明是请求需要传入的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RequestMapping 注解：</strong>放在类和方法上，用来表示请求的路由 Url</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-package-main"><a href="#3-4-package-main" class="headerlink" title="3.4 package-main"></a>3.4 package-main</h2><h3 id="3-4-1-package-controller"><a href="#3-4-1-package-controller" class="headerlink" title="3.4.1 package-controller"></a>3.4.1 package-controller</h3><p>我们写了一个 Controller，同时还注入了一个对象 HelloWorldService ，这个test1方法还需要传入一个参数param，用于测试传参。</p><p><strong>TestController ：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@RequestParam(&quot;param&quot;)</span> String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = helloWorldService.getString();</span><br><span class="line">            response.getWriter().write(text + <span class="string">&quot; and the param is &quot;</span> + param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-Test"><a href="#3-5-Test" class="headerlink" title="3.5 Test"></a>3.5 Test</h2><p>把项目通过Tomcat启动在8080端口后，访问<a href="http://localhost:8080/test/test1?param=abc%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8080/test/test1?param=abc，出现如下结果：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world and the param is abc</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Spring项目" scheme="http://wangjin1996219.github.io/tags/Spring%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>手写实现SpringIOC</title>
    <link href="http://wangjin1996219.github.io/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/"/>
    <id>http://wangjin1996219.github.io/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/</id>
    <published>2021-05-27T00:51:38.000Z</published>
    <updated>2021-06-01T11:44:15.401Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-SpringIOC-与-DI"><a href="#1-SpringIOC-与-DI" class="headerlink" title="1.SpringIOC 与 DI"></a>1.SpringIOC 与 DI</h1><h2 id="1-1-SpringIOC-是什么"><a href="#1-1-SpringIOC-是什么" class="headerlink" title="1.1 SpringIOC 是什么"></a>1.1 SpringIOC 是什么</h2><p><strong>IoC（Inversion of Control，控制反转）</strong>。这是 <strong>spring 的核心</strong>，贯穿始终。<strong>所谓 IoC ，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</strong>这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的 mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如 Connection 等），对象始终会和其他的接口或类藕合起来。</p><p>那么 IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：<strong>婚姻介绍所</strong>。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。<strong>Spring 所倡导的开发方式</strong>就是如此，<strong>所有的类都会在 spring 容器中登记，告诉 spring 你是个什么东西，你需要什么东西，然后 spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 spring 。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被 spring 控制，所以这叫控制反转。</strong></p><p>所以<strong>控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方</strong>，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p><h2 id="1-2-DI-是什么"><a href="#1-2-DI-是什么" class="headerlink" title="1.2 DI 是什么"></a>1.2 DI 是什么</h2><p><strong>DI（Dependency Injection，即“依赖注入”）</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h2 id="1-3-SpringIOC-与-DI-之间的关系"><a href="#1-3-SpringIOC-与-DI-之间的关系" class="headerlink" title="1.3 SpringIOC 与 DI 之间的关系"></a>1.3 SpringIOC 与 DI 之间的关系</h2><p><strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>总结：<strong>DI 就是 SpringIOC 的另一种说法</strong>。</p><h1 id="2-XML-注入方式"><a href="#2-XML-注入方式" class="headerlink" title="2.XML 注入方式"></a>2.XML 注入方式</h1><h2 id="2-1项目概况"><a href="#2-1项目概况" class="headerlink" title="2.1项目概况"></a>2.1项目概况</h2><p><img src="/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/GitHub\MyBlogs\source_posts\2021-05-27-手写实现SpringIOC\XML1.png" alt="image-20210530215030327"></p><h2 id="2-2-packaeg-main"><a href="#2-2-packaeg-main" class="headerlink" title="2.2 packaeg-main"></a>2.2 packaeg-main</h2><h3 id="2-2-1-package-service"><a href="#2-2-1-package-service" class="headerlink" title="2.2.1 package-service"></a>2.2.1 package-service</h3><p>存放需要 SpringIOC 管理的 Bean 实例</p><p><strong>HelloWorldService 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HelloWorldServiceImpl 类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WrapService 类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloWorldService.saySomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好地说明在实例化 Bean 时的过程，在需要注入 IOC 的两个 Bean 中，HelloWorldServiceImpl 的属性都是<strong>基本类型</strong> String ，而 WrapService 的属性是<strong>引用类型</strong> HelloWorldService。</p><h2 id="2-3-package-Springwork"><a href="#2-3-package-Springwork" class="headerlink" title="2.3 package-Springwork"></a>2.3 package-Springwork</h2><p>springIOC 实现的核心部分，我们将采用<strong>自下而上</strong>的步骤来解释项目每部分的功能。</p><h3 id="2-3-1-package-entity"><a href="#2-3-1-package-entity" class="headerlink" title="2.3.1 package-entity"></a>2.3.1 package-entity</h3><p>通常描述 Bean 包括：这个 Bean 是不是单例、它对应的类和类名、Bean的具体属性等，我们将其定义为 BeanDefinition。</p><p><strong>BeanDefinition 类：</strong>Bean 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bean的实例</span></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line">    <span class="comment">//Bean所对应的类</span></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">    <span class="comment">//Bean所对应的类名</span></span><br><span class="line">    <span class="keyword">private</span> String beanClassName;</span><br><span class="line">    <span class="comment">//是否是单例模式</span></span><br><span class="line">    <span class="keyword">private</span> Boolean singleton;</span><br><span class="line">    <span class="comment">//Bean的属性</span></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSingleton</span><span class="params">(Boolean singleton)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singleton = singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，PropertyValues 是 Bean 具体属性的集合，它的定义如下：</p><p><strong>PropertyValues 类：</strong>它是一个 ArrayList 集合，存放的元素是 PropertyValue 类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValues</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span><span class="params">(PropertyValue propertyValue)</span> </span>&#123;</span><br><span class="line">        propertyValueList.add(propertyValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PropertyValue 类：</strong>只有两个属性，一个是 Bean 的字段名，一个是 Bean 的字段值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bean的属性名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//Bean的属性值（可能是基本类型也可能是引用类型）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean 的属性值可能为基本类型，也可能为引用类型，当 Bean 的属性值为引用类型时，也就是它的值应该是一个对象，我们将这个对象定义为 BeanReference：</p><p><strong>BeanReference 类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanReference</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清楚 Bean 的定义后，我们在配置文件中定义我们要传入的两个 Bean。</p><h3 id="2-3-2-package-io"><a href="#2-3-2-package-io" class="headerlink" title="2.3.2 package-io"></a>2.3.2 package-io</h3><p>配置文件中对于Bean的配置如下：我们只将 scope=”prototype” 加到配置文件中，在程序读取配置文件时，只判断是不是 prototype 即可，不是就是单例的 Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.wangjin.main.service.HelloWorldServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello World&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;wrapService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.wangjin.main.service.WrapService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloWorldService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了从 resources 包下获取配置文件的内容，我们将读取配置的功能抽象为一个接口：</p><p><strong>Resource 接口：</strong>将配置文件中的内容读取到输入流中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UrlResource 类：</strong>实现了 Resource 接口，通过 URL 的方式获取配置文件的内容</p><blockquote><p><strong>Note：</strong>有了 URLConnection 对象后，可以通过 getInputStream() 来获取一个 InputStream ，由此读取 URL 所引用的资源数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlResource</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URLConnection urlConnection = url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        <span class="keyword">return</span> urlConnection.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ResourceLoader 类：</strong>将 UrlResource 封装成资源加载器，构造时要传入 URL ，构造 UrlResource 对象，然后调用 getInputStream 方法获取配置文件内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(location);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-package-reader"><a href="#2-3-3-package-reader" class="headerlink" title="2.3.3 package-reader"></a>2.3.3 package-reader</h3><p>调用上面实现的资源加载器，从配置文件中读取对于 BeanDefinition 的定义信息，我们还是先把这个功能抽象为一个接口：</p><p><strong>BeanDefinitionReader 接口：</strong>接口中只有一个方法，方法的参数是一个文件路径，我们大体上猜一下就知道这个方法大概就是根据路径创建资源加载器然后再从输入流 InputStream 中提取出 BeanDefinition 注册到一个容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AbstractBeanDefinitionReader 抽象类：</strong>通过抽象类来实现接口，抽象类中的 registry 作为容器来存放读取到的 Bean 名称和 BeanDefinition 的键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XmlBeanDefinitionReader 实现类：</strong>该实现类具体来实现 BeanDefinitionReader 接口中的 loadBeanDefinitions 方法。</p><p>注册 BeanDefinition 的流程：</p><ol><li><p>根据配置文件的路径将配置文件准换成 InputStream 输入流</p></li><li><p>根据配置文件的输入流解析出 BeanDefinition ，具体的解析过程为：</p><ul><li><p>从配置文件的根 root ，递归地解析每个节点</p></li><li><p>对于 BeanDefinition 的实际解析过程，也就是获取 BeanDefinition 实体类的每个属性，其中在给 BeanDefinition 的 PropertyValues 赋值时，存在两种情况：</p><p>1.当属性值为基本类型时，可以直接赋值；</p><p>2.当属性值是引用类型时，不是立即初始化，而是创建一个只有名称的 BeanReference 引用对象，因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已。</p></li></ul></li></ol><blockquote><p><strong>Note：</strong>通过抽象类实现接口，然后抽象类的子类继承抽象类来具体实现接口中的方法，这是一种思想。比如当我们想用接口中的某个特定方法时（不是所有的方法），那么我们通过抽象类来实现接口（方法体中为空），然后再用子类继承这个抽象类，重写我们想要实现的方法即可。如果我们直接实现接口，就要重写接口中的所有方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的路径获取BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location 配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据配置文件的路径，获取配置文件的文件输入流</span></span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的输入流解析出BeanDefinition，并注册到临时Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件的根root，递归地将每个节点解析成BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i ++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于BeanDefinition的实际解析过程，也就是获取实体类的每个属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值：</span></span><br><span class="line"><span class="comment">     * 1.当是基本类型时直接赋值</span></span><br><span class="line"><span class="comment">     * 2.当是引用类型时不是立即初始化，而是创建一个只有名称的引用对象，</span></span><br><span class="line"><span class="comment">     * 因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i ++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-package-factory"><a href="#2-3-4-package-factory" class="headerlink" title="2.3.4 package-factory"></a>2.3.4 package-factory</h3><p>上面我们在 reader 包中完成了 BeanDefinition 的读取和注册，下面我们要完成 Bean 的实例化。我们将这个实例化的操作抽象成工厂接口。</p><p><strong>BeanFactory 接口：</strong></p><p><code>getBean 方法：</code>两个，分别是通过实例名称和类名获取 Bean 实例</p><p><code>registerBeanDefinition 方法：</code>注册 BeanDefinition ，在获取 BeanFactory 时，将 reader 包读取到容器中的 BeanDefinition 注册到工厂容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AbstractBeanFactory 抽象类：</strong>实现了工厂类，重写了根据名称返回 Bean 实例的方法，具体 Bean 的创建由它的子类实现</p><p>根据名称来获取 Bean 实例，因此我们选用 Map 结构来作为实际容器，为了保证线程安全，最后选取 ConcurrentHashMap 作为底层的容器结构。</p><p>在实际调用获取 Bean 实例的方法之前，我们已经调用 registerBeanDefinition 方法，将 BeanDefinition 装载到了容器中。</p><p><code>getBean（Bean 名称）方法：</code>先通过名称获取 BeanDefinition ，如果 Bean 不是单例的，或者 Bean 此时为空，调用 doCreateBean 方法创建一个 Bean，否则，也就是这个 Bean 是单例的并且已经实例化的，直接返回 Bean 即可</p><p><code>getBean（Class 名称）方法：</code>遍历容器中的 BeanDefinition ，并将其对应的类和要查询的类名匹配，匹配成功将获取 BeanDefinition ，也就是还是通过 BeanDefinition 的方式来获取实例</p><p><code>registerBeanDefinition 方法：</code>向工厂容器中注册 BeanDefinition 的方法</p><p><code>doCreateBean 方法：</code>实际创建 Bean 实例的方法，由子类实现具体的逻辑</p><p><code>populateBeans 方法：</code>批量创建 Bean 的方法，将容器中的 BeanDefinition 全都实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!beanDefinition.isSingleton() || beanDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> doCreateBean(beanDefinition);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取beanDefinitionMap容器中所有映射关系的集合，并遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取每组映射的Bean所对应的类</span></span><br><span class="line">            Class tmpClass = entry.getValue().getBeanClass();</span><br><span class="line">            <span class="keyword">if</span>(tmpClass == clazz || clazz.isAssignableFrom(tmpClass)) &#123;</span><br><span class="line">                <span class="comment">//得到对应的BeanDefinition</span></span><br><span class="line">                beanDefinition = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!beanDefinition.isSingleton() || beanDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> doCreateBean(beanDefinition);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateBeans</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) &#123;</span><br><span class="line">            doCreateBean(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AutowiredCapableBeanFactory 类：</strong>将实现的 BeanFactory ，变成可以自动注入属性的 BeanFactory ，可以通过<strong>反射</strong>的方式创建完成实例对象后，注入其中的属性，如果属性是一个对象引用，那么就去创建那个被引用的实例对象，并<strong>递归地完成属性注入</strong>。</p><p>具体的实现逻辑如下注释所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体创建Bean的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果对象是单例的并且已经创建完成，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton() &amp;&amp; beanDefinition.getBean() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则通过反射的方式，获取Bean的实例</span></span><br><span class="line">        Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">        <span class="comment">//根据Bean属性，如果是单例的，也就是第一次创建该对象时，将Bean set进beanDefinition，便于下次直接获取</span></span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton()) &#123;</span><br><span class="line">            beanDefinition.setBean(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为新创建的Bean注入属性</span></span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为新创建的Bean注入属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 待注入属性的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean的定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 反射异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">//获取Bean属性的字段名</span></span><br><span class="line">            Field field = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            <span class="comment">//获取Bean属性字段值</span></span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="comment">//如果Bean的属性字段值是引用类型时，递归地创建所有引用对象</span></span><br><span class="line">            <span class="comment">//instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span></span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) propertyValue.getValue();</span><br><span class="line">                BeanDefinition refDefinition = beanDefinitionMap.get(beanReference.getName());</span><br><span class="line">                <span class="keyword">if</span>(refDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    value = doCreateBean(refDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-package-context"><a href="#2-3-5-package-context" class="headerlink" title="2.3.5 package-context"></a>2.3.5 package-context</h3><p>BeanFactory 创建完成之后，我们就来实现 Spring 框架中最核心的类，也是 Spring 的入口类 ApplicationContext ，即应用程序上下文。我们只实现其核心的功能，也就是获取 Bean 的功能。我认为这个类可以视为将 BeanFatory 做了一次封装，传入一个 BeanFactory 对象，在内部调用工厂类的获取 Bean 的方法。</p><p><strong>ApplicationContext 接口：</strong>应用程序上下文接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类名从SpringIOC中获取实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过实例的名称从SpringIOC中获取对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AbstractApplicationContext 抽象类：</strong>实现ApplicationContext中获取实例的两个方法,运用代理模式（静态代理）的思想，内部保存一个BeanFactory实例来实现其功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ClassPathXmlApplicationContext 类：</strong></p><p>我们在子类中创建 BeanFactory ，在创建时先初步将 BeanDefinition 注册到工厂容器中，然后再通过创建的工厂对象 beanFactory 调用 populateBeans 来将所有的 Bean 实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">            AbstractBeanFactory beanFactory = obtainBeanFactory();</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanFactory <span class="title">obtainBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowiredCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : beanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanFactory.populateBeans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-Test"><a href="#2-4-Test" class="headerlink" title="2.4 Test"></a>2.4 Test</h2><p>测试类的代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        WrapService wrapService = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService.say();</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        HelloWorldService helloWorldService2 = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;prototype验证：&quot;</span> + (helloWorldService == helloWorldService2));</span><br><span class="line">        WrapService wrapService2 = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService2.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton验证：&quot;</span> + (wrapService == wrapService2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">prototype验证：false</span><br><span class="line">Hello World</span><br><span class="line">singleton验证：true</span><br></pre></td></tr></table></figure><p>这里验证了一下 prototype 和 singleton ，这里首先获取了两次 HelloWorldService 的实例，由于这个 Bean 在配置文件中被标为 prototype ，所以两次获取到的都不是同一个对象，使用等号比较时得到了 false 。而后面获取的 wrapService ，和第一次获取的 WrapService 比较，由于是 singleton 的，所以使用等号比较时返回 true 。</p><h1 id="3-注解注入方式"><a href="#3-注解注入方式" class="headerlink" title="3.注解注入方式"></a>3.注解注入方式</h1><h2 id="3-1项目概况"><a href="#3-1项目概况" class="headerlink" title="3.1项目概况"></a>3.1项目概况</h2><p><img src="/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/GitHub\MyBlogs\source_posts\2021-05-27-手写实现SpringIOC\注解1.png" alt="image-20210531223813945"></p><p>还是自底向上的思想来重构项目</p><h2 id="3-2-package-Springwork"><a href="#3-2-package-Springwork" class="headerlink" title="3.2 package-Springwork"></a>3.2 package-Springwork</h2><h3 id="3-2-1-package-annotation"><a href="#3-2-1-package-annotation" class="headerlink" title="3.2.1 package-annotation"></a>3.2.1 package-annotation</h3><p>注解的注入方式就是省去了 XML 文件对于 Bean 的配置，而是在需要注入的 Bean 上直接加注解，Spring 通过扫描特定范围下的类将实体类实例化注入到 SpringIOC 容器中。因此我们先定义几个注解常用注解：</p><p>在定义注解时，我们通常用到<strong>元注解</strong>，它用来描述我们定义的注解使用在什么地方、什么时间范围有效等。常用的两种元注解及其参数值如下：</p><p><strong>@Target：</strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p><p>取值(ElementType)有：</p><ol><li>CONSTRUCTOR:用于描述构造器</li><li>FIELD:用于描述域</li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ol><p><strong>@Retention：</strong>表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p><p>取值（RetentionPoicy）有：</p><ol><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ol><p><strong>在项目中，我们定义了以下几个常用的注解：</strong></p><p><strong>Autowired 注解：</strong>默认根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Qualifier 注解：</strong>如果有<code>多个类型一样</code>的Bean候选者，则需要 Qualifier 注解限定其中一个候选者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Component 注解：</strong>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Scope 注解：</strong>描述 Bean 的作用域，singleton 或者 prototype</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Value 注解：</strong>把对应的值注入到变量中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Value &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-package-reader"><a href="#3-2-2-package-reader" class="headerlink" title="3.2.2 package-reader"></a>3.2.2 package-reader</h3><p>因为我们不是 SpringBoot ，所以还是要自定义注解的扫描范围，也就是哪些包下有需要注入的 Bean，自定义一个 XML 文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!--该配置文件声明扫描包的范围--&gt;</span><br><span class="line">    &lt;component-scan base-package=&quot;top.wangjin.main&quot;&gt;&lt;/component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>通过上面的分析我们知道 reader 包下类的作用是读取并解析配置文件中的 BeanDefinition ，那么换成注解注入方式后，功能仍然是不变的，但是在解析配置文件时，要进行判断，如果配置文件的节点标签是 component-scan 时，就要调用解析注解的方法来解析对应包下实体类的 BeanDefinition。</p><p><strong>XmlBeanDefinitionReader 类：</strong>注解注入和 XML 方式注入的判断在 parseBeanDefinitions 方法中，循环遍历配置文件中的节点，如果发现节点的标签名是 component-scan 时，就会调用注解解析方法来向容器中注入 BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的路径获取BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location 配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据配置文件的路径，获取配置文件的文件输入流</span></span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的输入流解析出BeanDefinition，并注册到临时Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件的根root，递归地将每个节点解析成BeanDefinition</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="comment">//先判断是否是注解配置：</span></span><br><span class="line">        <span class="comment">//1.是，选用注解解析成BeanDefinition</span></span><br><span class="line">        <span class="comment">//2.否，选用XML文件解析成BeanDefinition</span></span><br><span class="line">        String basePackage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeList.item(i) <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) nodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span> (ele.getTagName().equals(<span class="string">&quot;component-scan&quot;</span>)) &#123;</span><br><span class="line">                    basePackage = ele.getAttribute(<span class="string">&quot;base-package&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (basePackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parseAnnotation(basePackage);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseAnnotation</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取basePackage包下所有类，放入Set集合中</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">            processAnnotationBeanDefinition(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据注解来解析BeanDefinition，并将其注册到注册表Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationBeanDefinition</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Component注解表示需要注入到SpringIOC中</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Component.class)) &#123;</span><br><span class="line">            <span class="comment">//通过反射的方式获取注解的值</span></span><br><span class="line">            String name = clazz.getAnnotation(Component.class).name();</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                name = clazz.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line">            <span class="comment">//确定Bean是Singleton还是prototype</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Scope.class) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(clazz.getAnnotation(Scope.class).value())) &#123;</span><br><span class="line">                singleton = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            <span class="comment">//给Bean的属性赋值</span></span><br><span class="line">            processAnnotationProperty(clazz, beanDefinition);</span><br><span class="line">            <span class="comment">//给BeanDefinition实体类赋值</span></span><br><span class="line">            beanDefinition.setBeanClassName(className);</span><br><span class="line">            beanDefinition.setSingleton(singleton);</span><br><span class="line">            <span class="comment">//将BeanDefinition注册到注册表Map中</span></span><br><span class="line">            getRegistry().put(name, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationProperty</span><span class="params">(Class&lt;?&gt; clazz, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取Bean所对应类的字段</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">//获取属性的名称</span></span><br><span class="line">            String name = field.getName();</span><br><span class="line">            <span class="comment">// 属性上的注解有两种情况：</span></span><br><span class="line">            <span class="comment">// 1.如果属性上添加了Value注解，属于基本类型，将Value上的值赋给该属性</span></span><br><span class="line">            <span class="comment">// 2.如果属性上添加了Autowired注解，属于引用类型，又分为两种情况：</span></span><br><span class="line">            <span class="comment">// a.如果属性上有Qualifier注解，根据注解值将对应名称的Bean注入beanDefinitionMap</span></span><br><span class="line">            <span class="comment">// b.如果属性上没有Qualifier注解，就根据Autowired注解，将对应类型的类名注入beanDefinitionMap</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Value.class)) &#123;</span><br><span class="line">                Value valueAnnotation = field.getAnnotation(Value.class);</span><br><span class="line">                String value = valueAnnotation.value();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.isAnnotationPresent(Autowired.class)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(Qualifier.class)) &#123;</span><br><span class="line">                    Qualifier qualifier = field.getAnnotation(Qualifier.class);</span><br><span class="line">                    String ref = qualifier.value();</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of Qualifier should not be null!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = field.getType().getName();</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取packageName包下所有的类，并返回一个Set集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件，并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以文件的形式获取包下所有的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> recursive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者 也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于BeanDefinition的实际解析过程，也就是获取BeanDefinition实体类的每个属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值：</span></span><br><span class="line"><span class="comment">     * 1.当是基本类型时直接赋值</span></span><br><span class="line"><span class="comment">     * 2.当是引用类型时不是立即初始化，而是创建一个只有名称的引用对象，</span></span><br><span class="line"><span class="comment">     * 因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note：</strong>在 processAnnotationProperty 方法中，根据注解的值对 Bean 属性进行注入时有几种情况：<br>             1.如果属性上添加了Value注解，属于基本类型，将Value上的值赋给该属性<br>             2.如果属性上添加了Autowired注解，属于引用类型，又分为两种情况：<br>                a.如果属性上有Qualifier注解，根据注解值将对应名称的Bean注入beanDefinitionMap<br>                b.如果属性上没有Qualifier注解，就根据Autowired注解，将对应类型的类名注入beanDefinitionMap</p><p>注意最后一种情况，如果引用类型我们没有添加Qualifier注解时是根据类名添加的，这时根据 Bean 的名称是找不到对应的 Bean 的，所以要进行空值判断，当根据 Bean 的名称找不到时，就要根据类名找，所以有了下面代码的改写。</p></blockquote><h3 id="3-2-3-package-factory"><a href="#3-2-3-package-factory" class="headerlink" title="3.2.3 package-factory"></a>3.2.3 package-factory</h3><p><strong>AutowiredCapableBeanFactory 类：</strong>主要改写的是为创建的 Bean 注入属性的方法，两种注入方式：通过 Bean 名称注入和通过类名注入，分别对应在 reader 中注册 BeanDefinition 时，两种注册属性的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体创建Bean的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton() &amp;&amp; beanDefinition.getBean() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton()) &#123;</span><br><span class="line">            beanDefinition.setBean(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为新创建的Bean注入属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 待注入属性的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean的定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 反射异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field field = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) propertyValue.getValue();</span><br><span class="line">                <span class="comment">// 优先按照自定义名称匹配（字段上有Qualifier注解，按照注解值注入beanDefinitionMap的情况）</span></span><br><span class="line">                BeanDefinition refDefinition = beanDefinitionMap.get(beanReference.getName());</span><br><span class="line">                <span class="keyword">if</span>(refDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!refDefinition.isSingleton() || refDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = doCreateBean(refDefinition);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value = refDefinition.getBean();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按照类型匹配，返回第一个匹配的（字段上没有Qualifier注解，按照类型名称注入beanDefinitionMap的情况）</span></span><br><span class="line">                    Class clazz = Class.forName(beanReference.getName());</span><br><span class="line">                    <span class="keyword">for</span>(BeanDefinition definition : beanDefinitionMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(clazz.isAssignableFrom(definition.getBeanClass())) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!definition.isSingleton() || definition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                value = doCreateBean(definition);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                value = definition.getBean();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;无法注入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-package-main"><a href="#3-3-package-main" class="headerlink" title="3.3 package-main"></a>3.3 package-main</h2><h3 id="3-3-1-package-service"><a href="#3-3-1-package-service" class="headerlink" title="3.3.1 package-service"></a>3.3.1 package-service</h3><p>添加注解后的实体类：</p><p><strong>HelloWorldService 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HelloWorldServiceImpl 类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(name = &quot;helloWorldService&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;Hello, world&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>WrapService 类：</strong></p><blockquote><p><strong>Note：</strong>字段上加了 @Qualifier(“helloWorldService”) 注解与不加都可以，但是在 reader 进行 BeanDefinition 注册添加属性时是不一样的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(name = &quot;wrapService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;helloWorldService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloWorldService.saySomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Test"><a href="#3-4-Test" class="headerlink" title="3.4 Test"></a>3.4 Test</h2><p>测试类的代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application-annotation.xml&quot;</span>);</span><br><span class="line">        WrapService wrapService = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService.say();</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        HelloWorldService helloWorldService2 = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;prototype验证：相等&quot;</span> + (helloWorldService == helloWorldService2));</span><br><span class="line">        WrapService wrapService2 = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton验证：相等&quot;</span> + (wrapService == wrapService2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br><span class="line">prototype验证：相等false</span><br><span class="line">singleton验证：相等true</span><br></pre></td></tr></table></figure><p>结果没有问题，而且在 WrapService 类的 helloWorldService 属性上加不加 @Qualifier(“helloWorldService”)  注解都是可以实现注入的。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Spring项目" scheme="http://wangjin1996219.github.io/tags/Spring%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（八）RPC项目总结</title>
    <link href="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-13T07:18:02.000Z</published>
    <updated>2021-05-27T14:23:52.436Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-项目模块概述"><a href="#1-项目模块概述" class="headerlink" title="1.项目模块概述"></a>1.项目模块概述</h1><ul><li><strong>roc-api</strong>    ——    通用接口（供消费者调用）</li><li><strong>rpc-common</strong>    ——    实体对象、工具类等公用类</li><li><strong>rpc-core</strong>    ——    框架的核心实现</li><li><strong>test-client</strong>    ——    服务消费侧</li><li><strong>test-server</strong>    ——    服务提供侧</li></ul><h2 id="1-1roc-api模块"><a href="#1-1roc-api模块" class="headerlink" title="1.1roc-api模块"></a>1.1roc-api模块</h2><blockquote><p>模块间添加依赖就可以导入被依赖模块的package</p></blockquote><p>这个模块下的接口可以供给消费侧调用，而在服务侧实现。</p><p>两个通用接口：</p><ol><li><p><strong>HelloService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ByeService</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2test-server模块"><a href="#1-2test-server模块" class="headerlink" title="1.2test-server模块"></a>1.2test-server模块</h2><p>作为服务的提供者，完成的功能就是实现服务和向Nacos中注册服务</p><p><strong>一、两个服务的实现类</strong></p><ol><li><p><strong>HelloServiceImpl</strong></p><p>对传入的对象处理后返回处理结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Impl1方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ByeServiceImpl</strong></p><p>返回传入的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByeServiceImpl</span> <span class="keyword">implements</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bye, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>二、编写服务提供者</strong></p><p>选用 Netty 传输方式，并且指定序列化方式为 Google Protobuf 方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选用 Socket 传输方式，并且指定序列化方式为 HESSIAN 方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> SocketServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9998</span>, CommonSerializer.HESSIAN_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也体现了 Java 语言中的优越性，将 RpcServer 抽象成接口，不同的实现类来实现它，创建不同的实现类对象就会得到不同的服务端</p><h2 id="1-3test-client模块"><a href="#1-3test-client模块" class="headerlink" title="1.3test-client模块"></a>1.3test-client模块</h2><p>服务侧主要是通过<strong>动态代理方式</strong>远程调用服务，看起来调用本地方法一样简单</p><p><strong>编写服务消费者</strong></p><p>客户端选用 Netty 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端选用 Socket 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = proxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4rpc-common模块"><a href="#1-4rpc-common模块" class="headerlink" title="1.4rpc-common模块"></a>1.4rpc-common模块</h2><p>存放一些服务端和客户端都能用到的实体对象、枚举、工具类等等</p><h3 id="1-4-1package-entity"><a href="#1-4-1package-entity" class="headerlink" title="1.4.1package-entity"></a>1.4.1package-entity</h3><p>包括请求实体类和响应实体类</p><p><strong>RpcRequest 实体类：</strong>封装了请求接口的定位信息以及接口需要的参数信息</p><p>同时可以作为心跳包，验证客户端是否假死。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是心跳包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean heartBeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcResponse 实体类：</strong>封装了调用服务后处理的结果和状态信息，其中包含了两个静态构造方法，分别是处理成功和失败的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应对应的请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2package-enumeration"><a href="#1-4-2package-enumeration" class="headerlink" title="1.4.2package-enumeration"></a>1.4.2package-enumeration</h3><p>包括包的类型、响应状态码、异常以及序列化码等的枚举类型类</p><p><strong>PackageType：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PackageType</span> </span>&#123;</span><br><span class="line">    REQUEST_PACK(<span class="number">0</span>),</span><br><span class="line">    RESPONSE_PACK(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ResponseCode：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;调用方法成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">&quot;调用方法失败&quot;</span>),</span><br><span class="line">    METHOD_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定方法&quot;</span>),</span><br><span class="line">    CLASS_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定类&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcError：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RpcError</span> </span>&#123;</span><br><span class="line">    UNKNOWN_ERROR(<span class="string">&quot;出现未知错误&quot;</span>),</span><br><span class="line">    SERVICE_SCAN_PACKAGE_NOT_FOUND(<span class="string">&quot;启动类ServiceScan注解缺失&quot;</span>),</span><br><span class="line">    CLIENT_CONNECT_SERVER_FAILURE(<span class="string">&quot;客户端连接服务端失败&quot;</span>),</span><br><span class="line">    SERVICE_INVOCATION_FAILURE(<span class="string">&quot;服务调用出现失败&quot;</span>),</span><br><span class="line">    SERVICE_NOT_FOUND(<span class="string">&quot;找不到对应的服务&quot;</span>),</span><br><span class="line">    SERVICE_NOT_IMPLEMENT_ANY_INTERFACE(<span class="string">&quot;注册的服务未实现接口&quot;</span>),</span><br><span class="line">    UNKNOWN_PROTOCOL(<span class="string">&quot;不识别的协议包&quot;</span>),</span><br><span class="line">    UNKNOWN_SERIALIZER(<span class="string">&quot;不识别的(反)序列化器&quot;</span>),</span><br><span class="line">    UNKNOWN_PACKAGE_TYPE(<span class="string">&quot;不识别的数据包类型&quot;</span>),</span><br><span class="line">    SERIALIZER_NOT_FOUND(<span class="string">&quot;找不到序列化器&quot;</span>),</span><br><span class="line">    RESPONSE_NOT_MATCH(<span class="string">&quot;响应与请求号不匹配&quot;</span>),</span><br><span class="line">    FAILED_TO_CONNECT_TO_SERVICE_REGISTRY(<span class="string">&quot;连接注册中心失败&quot;</span>),</span><br><span class="line">    REGISTER_SERVICE_FAILED(<span class="string">&quot;注册服务失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SerializerCode：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    KRYO(<span class="number">0</span>),</span><br><span class="line">    JSON(<span class="number">1</span>),</span><br><span class="line">    HESSIAN(<span class="number">2</span>),</span><br><span class="line">    PROTOBUF(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3package-exception"><a href="#1-4-3package-exception" class="headerlink" title="1.4.3package-exception"></a>1.4.3package-exception</h3><p><strong>RpcException：</strong>根据参数选择不同的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error, String detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage() + <span class="string">&quot;: &quot;</span> + detail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SerializeException：</strong>序列化异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4package-factory"><a href="#1-4-4package-factory" class="headerlink" title="==1.4.4package-factory=="></a>==1.4.4package-factory==</h3><p>==这里的HashMap中是提前存好了所有类吗？==</p><p>包括两个工厂：创建单例对象的工厂和创建线程池的工厂</p><p><strong>SingletonFactory：</strong>返回一个类对应的单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class, Object&gt; objectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Object instance = objectMap.get(clazz);</span><br><span class="line">        <span class="keyword">synchronized</span> (clazz) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instance = clazz.newInstance();</span><br><span class="line">                    objectMap.put(clazz, instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadPoolFactory：</strong>创建 ThreadPool(线程池) 的工具类，根据是否给定了线程的前缀名创建线程池</p><ol><li><p><strong>createDefaultThreadPool方法：</strong>返回一个ExecutorService对象，该对象能够执行实现 <code>Runnable</code>/<code>Callable</code>接口的对象</p></li><li><p><strong>createDefaultThreadPool方法（两个参数）：</strong>设置了是否为守护线程，都是false，也就是不会创建守护线程。通过 <code>computeIfAbsent</code> 方法判断是否已经创建了能够产生线程名的前缀为 threadNamePrefix 的线程池</p><blockquote><p><strong>computeIfAbsent：</strong>存在时返回存在的值，不存在时返回新值</p></blockquote></li><li><p><strong>createThreadPool方法：</strong>实际创建线程池</p></li><li><p><strong>createThreadFactory方法：</strong>线程池中线程的创建对象，如果threadNamePrefix不为空则使用自建ThreadFactory，否则使用defaultThreadFactory</p></li><li><p><strong>shutDownAll方法：</strong>关闭所有线程池</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ThreadPoolFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ExecutorService&gt; threadPollsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDefaultThreadPool(threadNamePrefix, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = threadPollsMap.computeIfAbsent(threadNamePrefix, k -&gt; createThreadPool(threadNamePrefix, daemon));</span><br><span class="line">        <span class="keyword">if</span> (pool.isShutdown() || pool.isTerminated()) &#123;</span><br><span class="line">            threadPollsMap.remove(threadNamePrefix);</span><br><span class="line">            pool = createThreadPool(threadNamePrefix, daemon);</span><br><span class="line">            threadPollsMap.put(threadNamePrefix, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService <span class="title">createThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = createThreadFactory(threadNamePrefix, daemon);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE_SIZE, KEEP_ALIVE_TIME, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory <span class="title">createThreadFactory</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadNamePrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).setDaemon(daemon).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Executors.defaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutDownAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭所有线程池...&quot;</span>);</span><br><span class="line">        threadPollsMap.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">            ExecutorService executorService = entry.getValue();</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            logger.info(<span class="string">&quot;关闭线程池 [&#123;&#125;] [&#123;&#125;]&quot;</span>, entry.getKey(), executorService.isTerminated());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executorService.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;关闭线程池失败！&quot;</span>);</span><br><span class="line">                executorService.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-5package-util"><a href="#1-4-5package-util" class="headerlink" title="1.4.5package-util"></a>1.4.5package-util</h3><p>存放通用的工具类</p><p><strong>NacosUtil 工具类：</strong>管理Nacos连接等工具类（Nacos运行在端口8848）</p><p><strong>静态代码块：</strong>类只要完成加载就能连接上 Nacos</p><p><strong>getNacosNamingService方法：</strong>通过 NamingFactory 连接 Nacos 并返回 NamingService 对象</p><p><strong>registerService方法：</strong>通过 namingService 向 Nacos 中注册服务，分别是服务名、地址和端口号，并将服务名保存在 Set 集合中</p><p><strong>getAllInstance方法：</strong>通过 namingService 获取所有服务的名称</p><p><strong>clearRegistry方法：</strong>从 Nacos 中清空服务，也就是防止服务器关闭时，服务仍然保存在 Nacos 中（其实 Nacos 本身是有保活机制的，一小段时间联系不上服务器就会自动注销），一般将这个方法称为钩子，当 JVM 关闭时执行该方法，这样 Nacos 就会清空服务列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReflectUtil 类：</strong></p><p><strong>getStackTrace 方法：</strong>StackTraceElement存储了java代码堆栈调用轨迹，通过这个对象可以获取调用栈中的调用过程信息，包括类名、方法名、文件名、调用行数等，main 方法是第一个被加入栈中的，所以是最后一个</p><p><strong>getClasses 方法：</strong>传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回<strong>（ReflectUtil中最重要的方法）</strong></p><p><strong>findAndAddClassesInPackageByFile 方法：</strong>以文件的方式扫描整个包下的文件 并添加到集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过调用栈来获取main方法所在的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] stack = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">        <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>].getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件 并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcMessageChecker 工具类：</strong>检查响应与请求</p><p>主要是检验响应数据包是否正确：是否为空值，是否与请求包的 Id 一致等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcMessageChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTERFACE_NAME = <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcMessageChecker.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RpcMessageChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rpcRequest.getRequestId().equals(rpcResponse.getRequestId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.RESPONSE_NOT_MATCH, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || !rpcResponse.getStatusCode().equals(ResponseCode.SUCCESS.getCode())) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;,RpcResponse:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5rpc-core模块（核心）"><a href="#1-5rpc-core模块（核心）" class="headerlink" title="1.5rpc-core模块（核心）"></a>1.5rpc-core模块（核心）</h2><p>框架的核心实现</p><h3 id="1-5-1package-transport"><a href="#1-5-1package-transport" class="headerlink" title="1.5.1package-transport"></a>1.5.1package-transport</h3><p>本项目中主要有两种传输方式：Netty 和 Socket </p><p><strong>我们将客户端和服务端抽象成两个接口，在接口中定义客户端和服务端要实现的功能</strong></p><p><strong>RpcClient接口：</strong>客户端类通用接口，只有一个方法发送请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcServer接口：</strong>服务器类通用接口</p><p>**<code>start 方法：</code>**启动服务端</p><p>**<code>publishService 方法：</code>**发布服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcClientProxy 类（工厂类，用于获取代理对象）：</strong>RPC客户端动态代理类，通过动态代理类来屏蔽网络传输的细节。当我们去调用一个远程方法的时候，实际上是通过代理对象调用的。</p><p>其实也好理解，就是代理模式能够在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，那么扩展的这些功能其实就是实际的网络传输细节，当被代理的对象方法被调用时，实际上是按照我们重写的 invoke 方法中的逻辑执行的。</p><p><code>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</code></p><p><code>Proxy</code> 类中使用频率最高的方法是： <code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><p>这个方法一共有 3 个参数： </p><ol><li>loader :类加载器，用于加载代理对象；</li><li>interfaces : 代理需要实现的接口，可指定多个； </li><li>h : 实现了 InvocationHandler 接口的对象；</li></ol><p><code>InvocationHandler</code> 接口的实现主要是来自定义处理逻辑。当我们的动态代 理对象调用一个方法时候，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法来调用。当你使用代理对象调用方法的时候实际会调用到这个 invoke 方法。</p><p>这个方法一共有 3 个参数： </p><ol><li>proxy :动态生成的代理类 </li><li>method : 与代理类对象调用的方法相对应 </li><li>args : 当前 method 方法的参数</li></ol><p><strong>getProxy 方法：</strong>RpcClientProxy就是一个工厂类，该方法就是用于获取代理对象</p><p><strong>invoke 方法：</strong>当调用一个代理对象的方法时，按照该方法中的逻辑执行，该方法的逻辑主要是：</p><p>生成 RpcRequest 对象，根据不同的传输方式选择不同的逻辑来接收响应对象 RpcResponse ，调用 RpcMessageChecker 工具类来检验数据的正确性，通过检验后，将返回数据提取，返回给用户</p><p> ==CompletableFuture怎么用？==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;方法调用请求发送失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理对象在客户端的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AbstractRpcServer 抽象类：</strong>因为项目中使用了注解功能，无论使用 Netty 传输还是 Socket 传输方式，都要用到 <code>scanServices</code> 这个公共方法，所以通过抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自  AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p><blockquote><p><strong>Note：</strong></p><ul><li>抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现；</li><li>而普通类即非抽象类则必须实现接口里的全部方法。 </li></ul></blockquote><p><strong>scanServices 方法：</strong>扫描启动类所在包下所有的有Service注解的类，通过反射创建对象，并向Nacos中注册服务</p><p>通过调用 ReflectUtil 工具类中的 getStackTrace 的方法来获取栈底的 main 方法的类，并判断 main 方法所在类的注解值，当确定是加了 ServiceScan 注解后，获取 ServiceScan 注解的值，并获取启动类所在的包，然后就是扫描这个包下所有类的注解，只要是 Service 注解的类通过反射创建该对象，并且调 publishService 注册即可</p><p><strong>publishService 方法：</strong>向Nacos中注册服务，包括服务名还有服务所在的地址信息</p><p>向本地服务表中添加服务名和服务实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取启动类，也就是main方法所在的类</span></span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Class.forName(xxx.xx.xx) 返回具体类</span></span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到所有的 Class ，逐个判断是否有 Service 注解</span></span><br><span class="line">        <span class="comment">//如果有的话，通过反射创建该对象，并且调用 publishService 注册即可</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service.class).name();</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-1package-netty-client"><a href="#1-5-1-1package-netty-client" class="headerlink" title="1.5.1.1package-netty-client"></a>1.5.1.1package-netty-client</h4><p>Netty 客户端的实现</p><p><strong>NettyClient 类：</strong>主要是重写sendRequest的代码逻辑，通过 CompletableFuture 异步获取 Netty 请求的响应结果，并将 CompletableFuture 实例返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ChannelProvider 类：</strong>将客户端创建 channel 的逻辑分离出来，按照自定义的逻辑创建 Channel</p><p>这里有一个属性是 Map ，这里以服务提供者的地址和序列化器编码作为键， Channel 作为键值，只要已经有这样一个 Channel 并且是活跃状态就直接返回，否则按照自定义的方案来创建一个 Channel ，并放到 Map 中。如果 Map 中 Key 对应的 Channel 失效了，就将 Key 移除，并重新创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接客户端时有错误发生&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//是否开启 TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyClientHandler 类：</strong></p><p>与NettyServerHandler类似，不做介绍，只不过由于客户端没有设置读超时时间，所以不用对服务端的心跳包做识别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UnprocessedRequests 类：</strong>将每个请求对应的CompletableFuture实例都保存在一个Map中，key为请求ID，value为创建的CompletableFuture实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-2package-netty-server"><a href="#1-5-1-2package-netty-server" class="headerlink" title="1.5.1.2package-netty-server"></a>1.5.1.2package-netty-server</h4><p><strong>NettyServer 类：</strong></p><p>主要的步骤为：</p><ol><li>创建 ServerBootstrap 实例</li><li>设置并绑定 Reactor 线程池</li><li>设置并绑定服务端 Channel</li><li>创建并初始化 ChannelPipeline</li><li>添加并设置 ChannelHandler</li><li>绑定并启动监听端口</li></ol><p>下面通过注释的方式来说明整个流程：</p><blockquote><p>其中ServerBootStrap提供的方法有：</p><p>group：设置 ServerBootstrap 要用的 EventLoopGroup</p><p>channel：设置将要被实例化的 ServerChannel 类</p><p>attr：可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性，然后我们可以通过channel.attr()取出这个属性，比如，上面的代码我们指定我们服务端channel的一个serverName属性，属性值为nettyServer，其实说白了就是给NioServerSocketChannel维护一个map而已</p><p>childAttr：可以给每一条连接指定自定义属性，然后后续我们可以通过 channel.attr() 取出该属性</p><p>childOption：给每条连接设置一些TCP底层相关的属性</p><p>option：给服务端channel设置一些属性</p><p>handler：用于指定在服务端启动过程中的一些逻辑</p><p>childHandler：指定处理新连接数据的读写处理逻辑</p><p>bind：绑定 ServerChannel</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在服务器启动时，注册一个钩子，用于自动注销服务</span></span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        <span class="comment">// 创建Netty服务端的两个线程组： boos 和 worker</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ServerBootStrap实例</span></span><br><span class="line">            <span class="comment">// ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 给ServerBootstrap绑定两个线程组，这样Netty的线程模型就确定了</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 设置服务端Channel的IO模型,指定使用的NIO传输的Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 打印服务端启动过程的日志信息</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// BACKLOG用于构造服务端套接字ServerSocket对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度为256</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    <span class="comment">// 启用心跳保活机制。在双方TCP套接字建立连接后（即都进入ESTABLISHED状态）并且在两个小时左右上层没有任何数据传输的情况下，这套机制才会被激活。</span></span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// TCP_NODELAY就是用于启用或关于Nagle算法</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// 处理新连接数据的读写处理逻辑</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 为Channel绑定ChannelPipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 将用于数据处理的Handler添加到ChannelPipeline中</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定服务器端的端口，同步等待成功</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 优雅地关闭两个线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyServerHandler 类：</strong></p><p>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，当读取完成后会调用方法 <code>fireChannelReadComplete()</code> 通知 pipline 读取完成，然后触发 <code>channelRead</code> 方法，在 <code>channelRead</code> 方法中对读取到的数据进行消息类型检验，判断当前的 <code>message</code> 是否需要传递到下一个 <code>Handler</code> ，（如果需要传递到下一个Handler，执行的语句是：ctx.fireChannelRead(msg); ），不需要就调用 <code>channelRead0</code> 方法。</p><p><strong>channelRead0 方法：</strong>这里我们通过重写 <code>channelRead0</code> 方法来自定义我们对消息的处理逻辑：当消息是心跳包时，不用处理，当消息是其它请求包时，要调用<code>requestHandler</code> 中的 <code>handle</code> 方法对消息进行处理，其实就是通过方法名反射调用方法，然后获取结果。获取结果后通过语句 <code>ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()</code> 来判断channel是否正常的可写状态，调用 <code>writeAndFlush</code> 方法来将结果和消息ID写入 <code>ChannelHandlerContext</code> 中。</p><p><strong>userEventTriggered 方法：</strong>超过读超时时间被调用，实现心跳机制，来判断客户端是否假死状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;接收到客户端心跳包...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;通道不可写&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-3package-socket-client"><a href="#1-5-1-3package-socket-client" class="headerlink" title="1.5.1.3package-socket-client"></a>1.5.1.3package-socket-client</h4><p><strong>SocketClient 类：</strong>Socket 的客户端类，完成的任务也是发送一条请求数据，包括了建立 Socket 连接，将请求包按照 ObjectWriter 定义的方法进行编码，获取收到的数据，并对数据进行解码，返回给用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">            socket.connect(inetSocketAddress);</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            ObjectWriter.writeObject(outputStream, rpcRequest, serializer);</span><br><span class="line">            Object obj = ObjectReader.readObject(inputStream);</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) obj;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-4package-socket-server"><a href="#1-5-1-4package-socket-server" class="headerlink" title="1.5.1.4package-socket-server"></a>1.5.1.4package-socket-server</h4><p><strong>SocketServer 类：</strong>通过注解自动将服务注册到 Nacos 上，然后将钩子注册到 JVM 中，监听客户端的请求信息，若是发现请求时，将该请求分配线程池中的一个线程并按照 SocketRequestHandlerThread Socket传输方式自定义的消息处理方式，对数据进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        threadPool = ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;socket-rpc-server&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        <span class="keyword">this</span>.serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket()) &#123;</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> SocketRequestHandlerThread(socket, requestHandler, serializer));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SocketRequestHandlerThread 类：</strong>自定义的消息处理逻辑，包括将消息处理完后，返回给 Socket 客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketRequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketRequestHandlerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketRequestHandlerThread</span><span class="params">(Socket socket, RequestHandler requestHandler, CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = socket.getInputStream();</span><br><span class="line">             OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) ObjectReader.readObject(inputStream);</span><br><span class="line">            Object result = requestHandler.handle(rpcRequest);</span><br><span class="line">            RpcResponse&lt;Object&gt; response = RpcResponse.success(result, rpcRequest.getRequestId());</span><br><span class="line">            ObjectWriter.writeObject(outputStream, response, serializer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-1-5package-socket-util"><a href="#1-5-1-5package-socket-util" class="headerlink" title="1.5.1.5package-socket-util"></a>1.5.1.5package-socket-util</h4><p>我们希望让 Socket 与 Netty 使用的传输协议保持一致，也就是按照我们自定义的传输协议来对数据包进行封装和拆包，这意味着Socket也要用到序列化器。</p><p><strong>ObjectReader 类：</strong>类似于 Netty 中自定义的解码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ObjectReader.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] numberBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> magic = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> packageCode = bytesToInt(numberBytes);</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> serializerCode = bytesToInt(numberBytes);</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> length = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.read(bytes);</span><br><span class="line">        <span class="keyword">return</span> serializer.deserialize(bytes, packageClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytesToInt</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        value = ((src[<span class="number">0</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">24</span>)</span><br><span class="line">                |((src[<span class="number">1</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">16</span>)</span><br><span class="line">                |((src[<span class="number">2</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">                |(src[<span class="number">3</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ObjectWriter 类：</strong>类似于 Netty 中自定义的编码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(OutputStream outputStream, Object object, CommonSerializer serializer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.write(intToBytes(MAGIC_NUMBER));</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.REQUEST_PACK.getCode()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.RESPONSE_PACK.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.write(intToBytes(serializer.getCode()));</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(object);</span><br><span class="line">        outputStream.write(intToBytes(bytes.length));</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToBytes(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] src = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        src[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">16</span>)&amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">3</span>] = (<span class="keyword">byte</span>) (value &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2package-annotation"><a href="#1-5-2package-annotation" class="headerlink" title="1.5.2package-annotation"></a>1.5.2package-annotation</h3><p>定义的两个注解类：ServiceScan 和 Service</p><p><strong>ServiceScan 注解类：</strong>@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Service 注解类：</strong>@Service 放在一个类上，标识这个类提供一个服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设注解的值都为空的字符串即可</p><h3 id="1-5-3package-codec"><a href="#1-5-3package-codec" class="headerlink" title="1.5.3package-codec"></a>1.5.3package-codec</h3><p>存放的是编码器和解码器类，对请求包和发送包进行编码和解码工作（与序列化区分开，这里是我们自定义的传输协议的数据包，数据部分才是序列化的内容）</p><h4 id="传输协议（MRF）"><a href="#传输协议（MRF）" class="headerlink" title="传输协议（MRF）"></a>传输协议（MRF）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>解释</th></tr></thead><tbody><tr><td>Magic Number</td><td>魔数，表识一个 MRF 协议包，0xCAFEBABE</td></tr><tr><td>Package Type</td><td>包类型，标明这是一个调用请求还是调用响应</td></tr><tr><td>Serializer Type</td><td>序列化器类型，标明这个包的数据的序列化方式</td></tr><tr><td>Data Length</td><td>数据字节的长度</td></tr><tr><td>Data Bytes</td><td>传输的对象，通常是一个<code>RpcRequest</code>或<code>RpcClient</code>对象，取决于<code>Package Type</code>字段，对象的序列化方式取决于<code>Serializer Type</code>字段。</td></tr></tbody></table><p><strong>CommonEncoder 类：</strong>将数据包转换成自定义协议的数据包，继承了MessageToByteEncoder，顾名思义就是将数据包转化成字节数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CommonDecoder 类：</strong>将字节数组解码成对象</p><p>通过魔数来判断是不是符合我们自定义协议的数据包，下面获取包的类型，获取数据部分使用的序列化器，通过相应的序列化器将数据部分按照对应的类型反序列化为相应的实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4package-exception"><a href="#1-5-4package-exception" class="headerlink" title="1.5.4package-exception"></a>1.5.4package-exception</h3><p>自定义的一些异常信息（略）</p><h3 id="1-5-5package-handler"><a href="#1-5-5package-handler" class="headerlink" title="1.5.5package-handler"></a>1.5.5package-handler</h3><p><strong>RequestHandler 类：</strong>运行过程中，服务端调用 invoke 方法，通过方法名反射调用相应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-6package-hook"><a href="#1-5-6package-hook" class="headerlink" title="1.5.6package-hook"></a>1.5.6package-hook</h3><p>由于我们的服务会一直存在于Nacos中（实际Nacos有超时机制，会过期删除），如果我们将服务端关闭后，但是服务名还存在于Nacos中，当客户端调用时就会出错，所以我们要在服务端关闭时，自动注销服务。</p><p>但是由于我们并不知道服务端何时关闭，这时我们就要使用钩子（钩子就是一个方法）。</p><p><strong>ShutdownHook 构子类：</strong></p><p><strong>addClearAllHook 方法：</strong>方法中有一句语句：**<code>Runtime.getRuntime().addShutdownHook();</code>**这个方法的意思就是在jvm中增加一个关闭的钩子，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。</p><p>在这里的意思就是在JVM关闭前，开启一个新线程调用钩子方法，来实现服务的自动注销。</p><blockquote><p>项目中我们是在服务器启动的时候就将钩子类的对象并调用 <code>addClearAllHook</code> 方法，将钩子注册到了 JVM中，在关闭时执行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-7package-loadbalancer"><a href="#1-5-7package-loadbalancer" class="headerlink" title="1.5.7package-loadbalancer"></a>1.5.7package-loadbalancer</h3><p>实现负载均衡的接口和类</p><p>因为我们在Nacos获取服务提供者时可能不止一个，如果多个客户端总是访问一个服务端的话会造成服务端的压力过大，通过简单的算法可以实现均匀选择服务器，也就实现了服务器端的负载均衡。</p><p><strong>LoadBalancer 接口：</strong>只有一个方法，从获取到的服务器列表中选择一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现两个比较经典的算法：随机和转轮</p><p><strong>随机算法：</strong>顾名思义，就是随机选一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转轮算法：</strong>按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p><p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-8package-provider"><a href="#1-5-8package-provider" class="headerlink" title="1.5.8package-provider"></a>1.5.8package-provider</h3><p><strong>ServiceProvider 接口：</strong>保存和提供服务实例对象</p><p><strong>addServiceProvider 方法：</strong>将一个服务注册进注册表</p><p><strong>getServiceProvider 方法：</strong>根据服务名称获取服务实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceProviderImpl 实现类：</strong>每个服务提供者维护一个Map和一个Set</p><ul><li><strong>Map</strong> 来存放服务名称和服务实体的键值对</li><li><strong>Set</strong> 用来存放服务名</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-9package-registry"><a href="#1-5-9package-registry" class="headerlink" title="1.5.9package-registry"></a>1.5.9package-registry</h3><p>主要是向 Nacos 注册服务，和从 Nacos 中获取服务的接口和实现类</p><p> <strong>ServiceRegistry 接口：</strong>服务注册中心通用接口，将服务名称和提供服务的地址注册进服务中心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceDiscovery 接口：</strong>根据服务名查找服务的提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NacosServiceRegistry 实现类：</strong>实现了 ServiceRegistry 接口，服务注册功能的具体实现</p><p>基本就是调用NacosUtil工具类中的方法实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NacosServiceDiscovery 实现类：</strong>实现了 ServiceDiscovery 接口，主要用于发现服务</p><p>这里调用 NacosUtil 工具类中的 getAllInstance 方法得到所有的服务实例，然后根据所选的负载均衡算法，找到一个实例并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;找不到对应的服务: &quot;</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-10package-serializer"><a href="#1-5-10package-serializer" class="headerlink" title="1.5.10package-serializer"></a>1.5.10package-serializer</h3><p>序列化器的相关接口和类，本项目共引用了四个序列化器：Kryo、Json、Hessian、Protobuf</p><p><strong>CommonSerializer 接口：</strong>通用的序列化反序列化接口</p><p>主要是根据不同的序列化器所对应的编码来选择合适的序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer KRYO_SERIALIZER = <span class="number">0</span>;</span><br><span class="line">    Integer JSON_SERIALIZER = <span class="number">1</span>;</span><br><span class="line">    Integer HESSIAN_SERIALIZER = <span class="number">2</span>;</span><br><span class="line">    Integer PROTOBUF_SERIALIZER = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Integer DEFAULT_SERIALIZER = KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KryoSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProtobufSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有就是序列化器的实现类，这里不做介绍，基本就是实现了序列化与反序列化的两个方法。主要是对常见序列化器作比较：</p><ul><li><p><strong>JDK自带的序列化方式：</strong></p><p><strong>优点：</strong>使用简单，只需实现 java.io.Serializable 接口即可。</p><blockquote><p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一 致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成默认的序列化号</p></blockquote><p><strong>缺点：</strong></p><ol><li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li>性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ol></li><li><p><strong>JSON序列化方式：</strong></p><p><strong>优点：</strong>JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 xml，Json 比 xml更小、更快更容易解析。</p><p><strong>缺点：</strong>JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。（所以通常借助类的参数信息来反序列化）</p></li></ul><p>下面是基于字节的序列化方式</p><ul><li><p><strong>Kryo ：</strong>是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。</p><p>（Kryo解决了Json反序列化要借助类参数信息的问题，因为它在序列化的时候会记录对象的类型信息）</p></li><li><p><strong>Hessian ：</strong>是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、python、<a href>c++</a>,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效。速度较慢，序列化后的体积较大。</p></li><li><p><strong>protobuf（<a href>Proto</a>col Buffers）：</strong>是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p></li></ul><h1 id="2-项目相关问题"><a href="#2-项目相关问题" class="headerlink" title="2.项目相关问题"></a>2.项目相关问题</h1><h2 id="2-1RPC相关"><a href="#2-1RPC相关" class="headerlink" title="2.1RPC相关"></a>2.1RPC相关</h2><h3 id="2-1-1什么是RPC"><a href="#2-1-1什么是RPC" class="headerlink" title="2.1.1什么是RPC"></a>2.1.1什么是RPC</h3><p><strong>RPC（Remote Procedure Call）</strong>—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 <code>HTTP请求</code> 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p><p><strong>最终解决的问题：</strong><code>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单</code>。</p><h3 id="2-1-2RPC原理是什么"><a href="#2-1-2RPC原理是什么" class="headerlink" title="2.1.2RPC原理是什么"></a>2.1.2RPC原理是什么</h3><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\RPC1.png" style="zoom:100%;"><p><strong>一次完整的RPC调用流程（同步调用，异步另说）如下：</strong></p><p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p><p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p><p><strong>RPC实现的基本流程：</strong></p><p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p><h3 id="2-1-3常见的RPC框架"><a href="#2-1-3常见的RPC框架" class="headerlink" title="2.1.3常见的RPC框架"></a>2.1.3常见的RPC框架</h3><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、 Motan、gRPC这些。  如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p><ul><li><strong>Dubbo:</strong> Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。它提供了三大核心能力：<ol><li>面向接口的远程方法调用 </li><li>智能容错和负载均衡 </li><li>服务自动注册和发现。</li></ol></li><li><strong>Motan：</strong>motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</li><li><strong>gRPC：</strong>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf  序列化协议开发，并且支持众多开发语言。</li><li><strong>Hessian：</strong> Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 </li></ul><h3 id="2-1-4为什么要用RPC，不是HTTP"><a href="#2-1-4为什么要用RPC，不是HTTP" class="headerlink" title="2.1.4为什么要用RPC，不是HTTP"></a>2.1.4为什么要用RPC，不是HTTP</h3><p>首先需要指正，这两个并不是并行概念。RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p><p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p><p>使用 TCP 和使用 HTTP 各有优势：</p><p><strong>传输效率</strong>：</p><ul><li>TCP，通常自定义上层协议，可以让请求报文体积更小 </li><li>HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容 </li></ul><p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p><ul><li>TCP，可以基于各种序列化框架进行，效率比较高 </li><li>HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能 </li></ul><p><strong>跨平台</strong>：</p><ul><li>TCP：通常要求<a href>客户端</a>和服务器为统一平台 </li><li>HTTP：可以在各种异构系统上运行 </li></ul><p><strong>总结</strong>：<br>  RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><h2 id="2-2Java相关"><a href="#2-2Java相关" class="headerlink" title="2.2Java相关"></a>2.2Java相关</h2><h3 id="2-2-1动态代理与静态代理（客户端无感调用）"><a href="#2-2-1动态代理与静态代理（客户端无感调用）" class="headerlink" title="2.2.1动态代理与静态代理（客户端无感调用）"></a>2.2.1动态代理与静态代理（客户端无感调用）</h3><h4 id="明确静态代理和动态代理的区别："><a href="#明确静态代理和动态代理的区别：" class="headerlink" title="明确静态代理和动态代理的区别："></a>明确静态代理和动态代理的区别：</h4><ul><li><strong>静态代理：</strong>程序运行前，代理类的.class文件就已经存在了，也就是写死了代理对象；</li><li><strong>动态代理：</strong>在程序运行期间，运用反射机制动态创建需要代理的对象，也就是说要代理的对象是在运行期间确定的。</li></ul><p><strong>为什么要用动态代理？</strong></p><ol><li>由于静态代理中的代理类是针对某一个类去做代理的，那么假设一个系统中有100个Service，则需要创建100个代理类</li><li>如果一个Service中有很多方法需要事务（增强动作），发现代理对象的方法中还是有很多重复的代码</li></ol><p>由第一点和第二点可以得出：静态代理的重用性不强</p><h4 id="动态代理：JDK-动态代理和-CGlib-动态代理"><a href="#动态代理：JDK-动态代理和-CGlib-动态代理" class="headerlink" title="==动态代理：JDK 动态代理和 CGlib 动态代理=="></a>==动态代理：JDK 动态代理和 CGlib 动态代理==</h4><p><strong>二者区别：</strong>JDK动态代理产生的代理类和目标类实现了相同的接口；cglib动态代理产生的代理类是目标对象的子类。</p><p><strong>1. JDK动态代理</strong>：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 中的 invoke 方法来处理。</p><p><strong>动态代理步骤：</strong></p><ol><li>创建一个实现接口InvocationHandler的类作为拦截器，它必须实现invoke方法，让每个被代理类的方法执行时，都必须执行 invoke 方法体中的逻辑</li><li>创建被代理的类以及接口</li><li>通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li><li>通过代理调用方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;保存成功！&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransaction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;开启事务 &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在动态代理在生成代理对象的时候需要一个拦截器 InvocationHandler 因此咱们需要写一个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="comment">//目标类</span></span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"><span class="comment">//增强类</span></span><br><span class="line"><span class="keyword">private</span> MyTransaction myTransaction;</span><br><span class="line"><span class="comment">//构造函数注入目标类和增强类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersonServiceInterceptor</span><span class="params">(Object target,MyTransaction myTransaction)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line"><span class="keyword">this</span>.myTransaction = myTransaction;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//代理类的每一个方法被调用的时候都会调用下边的这个invoke方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.myTransaction.beginTransaction();</span><br><span class="line">Object returnValue = method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line"><span class="keyword">this</span>.myTransaction.commit();</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、当客户端执行代理对象.方法时，进入到了拦截器的invoke方法体</p><p>2、拦截器中invoke方法体的内容就是代理对象方法体的内容</p><p>3、拦截器中invoke方法的method参数是在调用的时候赋值的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Object target = <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">MyTransaction myTransaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line">PersonServiceInterceptor interceptor = <span class="keyword">new</span> PersonServiceInterceptor(target, myTransaction);</span><br><span class="line">PersonService personService = (PersonService)Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),interceptor);</span><br><span class="line">String returnValue = (String)personService.savePerson();</span><br><span class="line">System.out.println(returnValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<strong>2.CGlib动态代理</strong>：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。（没看懂）==</p><h3 id="2-2-2序列化"><a href="#2-2-2序列化" class="headerlink" title="2.2.2序列化"></a>2.2.2序列化</h3><p>上面有</p><h2 id="2-3Netty相关"><a href="#2-3Netty相关" class="headerlink" title="2.3Netty相关"></a>2.3Netty相关</h2><h3 id="2-3-1Netty-是什么"><a href="#2-3-1Netty-是什么" class="headerlink" title="2.3.1Netty 是什么"></a>2.3.1Netty 是什么</h3><ol><li>Netty 是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li><li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程,并且性能以及安全性等很多方面甚至都要更好。</li><li><strong>支持多种协议</strong> 如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li></ol><p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p><h3 id="2-3-2特点和优势"><a href="#2-3-2特点和优势" class="headerlink" title="2.3.2特点和优势"></a>2.3.2特点和优势</h3><p>因为 Netty 具有下面这些优点，并且相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。</p><ul><li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li><li>功能强大：预置了多种编解码功能，支持多种主流协议。 </li><li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li><li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li></ul><h3 id="2-3-3为什么-Netty-性能高"><a href="#2-3-3为什么-Netty-性能高" class="headerlink" title="2.3.3为什么 Netty 性能高"></a>2.3.3为什么 Netty 性能高</h3><ul><li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li><li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li><li>串行化处理读写：避免使用锁带来的性能开销。 </li><li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li></ul><h3 id="2-3-4BIO、NIO和AIO"><a href="#2-3-4BIO、NIO和AIO" class="headerlink" title="2.3.4BIO、NIO和AIO"></a>2.3.4BIO、NIO和AIO</h3><p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I/O模型在很大程度上决定了框架的性能</p><h4 id="BIO模型介绍"><a href="#BIO模型介绍" class="headerlink" title="BIO模型介绍"></a>BIO模型介绍</h4><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信。由于ServerSocket 的 accept（）方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>这种方式下有一个问题：每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作。 如下图所示：</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\BIO.png" style="zoom:80%;"><p><strong>问题：</strong></p><ul><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li></ul><p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p><p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p><p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p><h4 id="NIO模型介绍"><a href="#NIO模型介绍" class="headerlink" title="NIO模型介绍"></a>NIO模型介绍</h4><p>NIO基于Reactor（事件驱动思想），当socket有流可读或可写入socket时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>BIO与NIO一个比较重要的不同：<strong>我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong></p><p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\NIO.png" style="zoom:80%;"><p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p><h4 id="AIO模型介绍"><a href="#AIO模型介绍" class="headerlink" title="AIO模型介绍"></a>AIO模型介绍</h4><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 </p><p>相比于NIO，AIO才是完全的异步IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p><h4 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h4><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p><p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p><p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>AIO：一个有效请求一个线程，[客户端]的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p><p><strong>但是由于使用同步非阻塞的I/O模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p><h3 id="2-3-5Netty的线程模型"><a href="#2-3-5Netty的线程模型" class="headerlink" title="2.3.5Netty的线程模型"></a>2.3.5Netty的线程模型</h3><p>Netty 通过 Reactor 模型基于多路复用器（Selector）接收并处理用户请求。我们实现服务端的时候，一般会初始化两个线程组：</p><ol><li><strong><code>bossGroup</code></strong> :接收连接。</li><li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li></ol><p>其它的线程模型：</p><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a><strong>单线程模型</strong></h4><p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件，即多路复用、事件分发和处理都是在一个Reactor 线程上完成的。一个NIO 线程同时处理成百上千的链路，对于高负载、高并发，并且对性能要求比较高的场景不适用。</p><p>对应到 Netty 代码是下面这样的</p><blockquote><p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a><strong>多线程模型</strong></h4><p>一个 NIO 线程（Acceptor ）线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p><p>对应到 Netty 代码是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;"><h4 id="主从多线程模型（没看懂）"><a href="#主从多线程模型（没看懂）" class="headerlink" title="==主从多线程模型（没看懂）=="></a>==<strong>主从多线程模型（没看懂）</strong>==</h4><p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;"><h3 id="2-3-6解决-TCP-的粘包拆包问题"><a href="#2-3-6解决-TCP-的粘包拆包问题" class="headerlink" title="2.3.6解决 TCP 的粘包拆包问题"></a>2.3.6解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p><p><strong>TCP 粘包/分包的原因：</strong>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；</p><p><strong>解决方式：</strong></p><p>1.Netty 自带解决方式：</p><ul><li>消息定长：FixedLengthFrameDecoder 类，固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。</li><li>包尾增加特殊字符分割：<ul><li>行分隔符类：LineBasedFrameDecoder ，<code>LineBasedFrameDecoder</code> 的工作原理是它依次遍历 <code>ByteBuf</code> 中的可读字节，判断是否有换行符，然后进行相应的截取。</li><li>自定义分隔符类 ：DelimiterBasedFrameDecoder ，**<code>LineBasedFrameDecoder</code>** 实际上是一种特殊的 <code>DelimiterBasedFrameDecoder</code> 解码器。</li></ul></li><li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li></ul><p>2.自定义序列化编解码器：</p><p>自定义协议，其中有字段标明包长度。</p><h3 id="2-3-7Netty长连接、心跳机制"><a href="#2-3-7Netty长连接、心跳机制" class="headerlink" title="2.3.7Netty长连接、心跳机制"></a>2.3.7Netty长连接、心跳机制</h3><h4 id="Netty长连接与短连接"><a href="#Netty长连接与短连接" class="headerlink" title="Netty长连接与短连接"></a>Netty长连接与短连接</h4><p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p><p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p><p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p><h4 id="Netty中的心跳机制"><a href="#Netty中的心跳机制" class="headerlink" title="Netty中的心跳机制"></a>Netty中的心跳机制</h4><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 <strong>心跳机制</strong> 。</p><p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p><p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<code>SO_KEEPALIVE</code>。<code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 keepAlive 设置。</p><p>但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 <code>IdleStateHandler</code> 。</p><p><code>IdleStateHandler</code> 的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,TimeUnit unit)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p><p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p><p>第三个参数是全能型参数，隔多久检查读写事件；</p><p>第四个参数表示当前的时间单位。</p><p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p><p><strong>项目中的使用：</strong></p><p>通过服务器端的空闲检测，也就是服务器端每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可。</p><p>在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p><p>所以我们需要在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包。</p><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">             .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure><p>当客户端超过 5 秒没有写事件时，也就是 <code>write</code> 方法超过给定时间没被调用时，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p><p>方法逻辑主要就是看是否超过了 <strong>写空闲超时时间设定</strong> ，如果是就获取Channel创建一个心跳包并发送给服务器端。（这里主要是通过ctx中的事件是否为IdleStateEvent事件，再通过事件的状态来实现定时发送）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">            RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">            rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure><p>当服务端超过 30 秒没有读到数据时，表示连接假死，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p><p>方法逻辑主要就是看是否超过了 <strong>读空闲超时时间设定</strong> ，如果是就判定客户端为假死状态，断开连接，不是的话不予响应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==这里其实还有一个提升，就是双方都开始读写超时参数，这样两边假死状态都能判定。==</p><h3 id="2-3-8Netty-的零拷贝"><a href="#2-3-8Netty-的零拷贝" class="headerlink" title="2.3.8Netty 的零拷贝"></a>2.3.8Netty 的零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>内部工作流程：</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝1.png" alt="image-20210526152344320" style="zoom:80%;"><ol><li><p>Java 本身不具有 IO 读写能力，因此在 read 方法调用后，要从<strong>用户态切换至内核态</strong>，去调用系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程会被阻塞，操作系统使用 <strong>DMA</strong> 来实现文件读，也不会使用 CPU；</p><blockquote><p>DMA 是在磁盘和内核缓冲区之间建立起一个通道，可以解放 CPU 直接进行数据交换</p></blockquote></li><li><p><strong>内核态切换回用户态</strong>，将数据从内核缓冲区读入用户缓冲区，这期间 CPU 会参与拷贝，无法利用 DMA</p></li><li><p>调用 write 方法，这时<strong>将数据从用户缓冲区，写入 Socket 缓冲区</strong>，CPU 会参与拷贝</p></li><li><p>接下来要向网卡写数据，这时 Java 同样不具备写的能力，因此<strong>又得从用户态切换至内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡。</p></li></ol><p>可以看到这个过程中，Java 并不具备物理设备级别的读写能力，而是缓存的复制，底层的真正读写是由操作系统完成的：</p><ol><li>用户态与内核态切换发生了3次</li><li>数据拷贝发生了4次</li></ol><h4 id="NIO优化"><a href="#NIO优化" class="headerlink" title="NIO优化"></a>NIO优化</h4><p>通过 DirectByteBuf ：使用的是操作系统内存（而且这块内存 Java 和操作系统都能访问）</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝2.png" alt="image-20210526154313921" style="zoom:80%;"><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuf 将堆外内存（系统内存）映射到 jvm 内存中来直接访问使用</strong></p><ol><li><p>这块内存不受 jvm 垃圾回收机制影响，因此内存地址固定，有助于 IO 读写</p></li><li><p>Java 中的 DirectByteBuf 对象仅维护了该内存的虚引用，内存回收分为两部分：</p><ul><li>DirectByteBuf 对象被垃圾回收，阿静虚引用加入引用队列</li></ul></li></ol><ul><li>通过专门的线程访问引用队列，根据虚引用释放堆外内存</li></ul><ol start="3"><li>减少了一次数据拷贝，但是由于还是有 Java 参与数据拷贝，没有减少用户态与内核态的切换次数</li></ol><h4 id="进一步优化（Linux2-1）"><a href="#进一步优化（Linux2-1）" class="headerlink" title="进一步优化（Linux2.1）"></a>进一步优化（Linux2.1）</h4><p>在上面的优化中，都需要通过 Java 提供一个 xxByte 来作为媒介，将数据从操作系统的内核缓冲区复制到socket缓冲区，也就是需要 Java 参与的，这样就多了两次用户态与内核态的切换。</p><p>（底层采用了Linux 2.1 后提供的 sendFile 方法），Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝3.png" alt="image-20210526160129569" style="zoom:80%;"><ol><li>Java 调用 transferTo 方法后，要从 Java程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入内核缓冲区，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ol><p>可以看到：</p><ul><li><p>只发生了一次用户态与内核态的切换（不需要 Java 参与）</p></li><li><p>数据拷贝了 3 次</p></li></ul><h4 id="进一步优化（Linux2-4）"><a href="#进一步优化（Linux2-4）" class="headerlink" title="进一步优化（Linux2.4）"></a>进一步优化（Linux2.4）</h4><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝4.png" alt="image-20210526161411076" style="zoom:80%;"><ol><li>Java调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷贝到 Socket 缓存</li><li>也就是使用 DMA 将内核缓冲区的数据写入网卡，不会使用 CPU</li></ol><p>整个过程只发生了一次用户态与内核态的切换，数据拷贝了两次。所谓的<strong>零拷贝</strong>，不是不需要拷贝，而是不会拷贝重复数据到 JVM 内存中。零拷贝的优势有：</p><ol><li>更少的用户态和内核态的切换</li><li>不利用 CPU 计算</li><li>零拷贝适合小文件传输（因为太大了会占满缓存，影响其它文件的传输）</li></ol><h4 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h4><blockquote><p>1.传统的 IO 就有使用 DMA 的方式优化了  </p><p>2.传统零拷贝的概念是数据buffer不用再复制到用户空间，但是从内核缓存复制到 socket  buffer，但还是有一次多余的复制（因此需要 CPU 参与复制），于是出现了优化后的零拷贝，去掉在内核中那次多余的复制。 </p><p>3.<strong>netty 使用了优化后的零拷贝的 IO 方式，但是 netty 特性中的零拷贝主要是指复制方式与一般复制方式不同</strong>，因此API也不同了。netty 可以将多个ByteBuf 直接组装成一个 Netty ByteBuf，不用自己一个个添加到 buffer 里，还可以不需要拷贝地将一个 buffer 分割成多个小的 buffer 并且提供了更灵活的操作 buffer 的 API。</p></blockquote><p><strong>体现一：slice</strong></p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝5.png" alt="image-20210526162556972" style="zoom:80%;"><p>对原始的 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原来的 ByteBuf 的内存，只是切片后的 ByteBuf 维护独立的 read 和 write 指针。（也就是通过索引访问原来的 ByteBuf ，并没有申请新的内存来存放分片的 ByteBuf）</p><p><strong>体现二：duplicate</strong></p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝6.png" alt="image-20210526171439539" style="zoom:80%;"><p>与 slice 不同，这个是拷贝了原始 ByteBuf 的所有内容，也是与原始的 ByteBuf 使用同一块内存，只是读写指针是独立的。</p><p><strong>体现三：composite</strong></p><p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。（我认为传统的方式是申请一块更大的内存来存放多个小的 Buffer）</p><h3 id="2-3-9核心组件"><a href="#2-3-9核心组件" class="headerlink" title="2.3.9核心组件"></a>2.3.9核心组件</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等</p><p>比较常用的<code>Channel</code>接口实现类（或者说Channel类型）是：</p><ul><li><code>NioServerSocketChannel</code>（异步的服务器端 TCP Socket 连接）</li><li><code>NioSocketChannel</code>（异步的客户端 TCP Socket 连接）</li></ul><p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p><p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p><h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty 所有的 I/O 操作都为异步的。因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p><p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p><code>ChannelHandler</code> 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p><p><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p><ul><li>ChannelInboundHandler用于处理入站I / O事件，对从客户端发往服务器的报文进行处理，一般用来执行解码、读取客户端数据、进行业务处理等</li><li>ChannelOutboundHandler用于处理出站I / O操作，对从服务器发往客户端的报文进行处理，一般用来进行编码、发送报文到客户端</li></ul><p><strong>执行顺序：</strong> <strong>ChannelInboundHandler按照注册的先后顺序执行；ChannelOutboundHandler按照注册的先后顺序逆序执行</strong></p><blockquote><p><strong>附：ChannelHandler的类继承体系</strong></p></blockquote><p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source_posts\2021-05-13-（八）RPC项目总结\ChannelHandler.png"></p><p>下面一一对上述类做一个简单的介绍：</p><ul><li><p><strong>ChannelHandler</strong><br>Netty Channel事件的基础接口，只定义与 Handler 的管理接口相关，具体如下：</p><ol><li>void handlerAdded(ChannelHandlerContext ctx)<br> 在调用 DefaultChannelPipeline 的 addLast(add) 将事件监听器添加到事件处理链条时调用。</li><li>void handlerRemoved(ChannelHandlerContext ctx)<br> 在调用DefaultChannelPipeline 的 addLast(add) 发生异常时被调用；当通道关闭后，通道取消注册后，同时会触发通道移除事件，具体调用入口：DefaultChannelPipeline 的内部类 HeadContext 的 channelUnregistered。</li></ol></li><li><p><strong>ChannelInboundHandler</strong><br>入端类型的事件处理器。</p><ol><li><p>void channelRegistered(ChannelHandlerContext ctx)<br>通道注册到 Selector 时触发。客户端在调用 connect 方法，通过 TCP 建立连接后，获取 SocketChannel 后将该通道注册在 Selector 时或服务端在调用bind 方法后创建 ServerSocketChannel，通过将通道注册到 Selector 时监听客户端连接上时被调用。</p></li><li><p>void channelUnregistered(ChannelHandlerContext ctx)<br>通道取消注册到Selector时被调用，通常在通道关闭时触发，首先触发channelInactive 事件，然后再触发 channelUnregistered 事件。</p></li><li><p>void channelActive(ChannelHandlerContext ctx)<br>通道处于激活的事件，在 Netty 中，处于激活状态表示底层 Socket 的isOpen() 方法与 isConnected() 方法返回 true。</p></li><li><p>void channelInactive(ChannelHandlerContext ctx)<br>通道处于非激活（关闭），调用了 close 方法时，会触发该事件，然后触发channelUnregistered 事件。</p></li><li><p>void channelRead(ChannelHandlerContext ctx, Object msg)<br>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，将读取的字节通过事件链进行处理，NIO 的触发入口为AbstractNioByteChannel 的内部类 NioByteUnsafe 的 read 方法。</p></li><li><p>void channelReadComplete(ChannelHandlerContext ctx)<br>处理完一次通道读事件后触发，在 Netty 中一次读事件处理中，会多次调用SocketChannel 的 read方法。触发入口为AbstractNioByteChannel 的内部类NioByteUnsafe 的 read 方法。</p></li><li><p>void userEventTriggered(ChannelHandlerContext ctx, Object evt)<br>触发用户自定义的事件，目前只定义了ChannelInputShutdownEvent（如果允许半关闭（输入端关闭而服务端不关闭））事件。</p></li><li><p>void channelWritabilityChanged(ChannelHandlerContext ctx)<br>Netty 写缓存区可写状态变更事件（可写–》不可写、不可写–》可写），入口消息发送缓存区ChannelOutboundBuffer。</p></li><li><p>void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)<br>异常事件。</p></li></ol></li><li><p><strong>ChannelOutboundHandler</strong><br> 出端类型的事件处理器。</p><ol><li>void bind(ChannelHandlerContext ctx, SocketAddress add, ChannelPromise p)<br>调用ServerBootstrap 的 bind 方法的处理逻辑。绑定操作，服务端在启动时调用bind方法时触发（手动调用bind）。</li><li>void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, ChannelPromise promise)<br>连接操作，客户端启动时调用connect方法时触发（手动调用connect）。</li><li>void disconnect(ChannelHandlerContext ctx, ChannelPromise promise)<br>断开连接操作（手动调用disconnect）</li><li>void close(ChannelHandlerContext ctx, ChannelPromise promise)<br>关闭通道，手动调用Channel#close方法时触发。(手动调用close)</li><li>void deregister(ChannelHandlerContext ctx, ChannelPromise promise)<br>调用Channel#deregister时触发。（手动调用deregister)。</li><li>void read(ChannelHandlerContext ctx) throws Exception<br>注册读事件，并不是触发网络读写事件。</li><li>void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception<br>调用调用 Channel 的 write(底层 SocketChannel 的 write)时触发。</li><li>void flush(ChannelHandlerContext ctx)<br>调用调用Channel#flush(SocketChannel#flush)时触发。</li></ol></li><li><p><strong>ChannelDuplexHandler</strong><br>双向 Handler，包含 Inbound 和 outbound 事件。 </p></li><li><p><strong>ByteToMessageDecoder</strong><br>解码器：字节流解码成一条一条的消息(Message、协议对象)。</p></li><li><p><strong>MessageToByteEncoder</strong><br>编码器：消息（协议对象）编码成二进制字节流。</p></li><li><p><strong>AbstractTrafficShapingHandler</strong><br>流量整形，将在后续章节中详细介绍。</p></li></ul><p>上述详细的介绍了NettyChannel的类继承体系，并重点介绍了ChannelInboundHandler 与 ChannelOutboundHandler 每个方法的含义已经触发时机，接下来再谈一点我对这两个 Handler 的一些理解。</p><p><strong>ChannelInboundHandler：</strong>入端操作，可以看出基本上是都是由事件选择器(NIO Selector事件就绪选择)进行触发,事件名称以 channel 开头，例如channelRead。</p><p><strong>ChannelOutboundHanlder：</strong>出端操作，其触发点除了 read 事件外都是通过调用api(例如bind、connect、close、write)。</p><h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。</p><p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\ChannelPipeline.png" style="zoom:80%;"><p>在 <code>Netty</code> 整个框架里面，一条连接对应着一个 <code>Channel</code>，这条 <code>Channel</code> 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面，<code>ChannelPipeline</code> 是一个双向链表结构，他和 <code>Channel</code> 之间是一对一的关系。</p><p><code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 <code>Channel</code> 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。入站事件和出站事件在一个双向链表中，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code> ，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code> ，两种类型的 <code>handler</code> 互不干扰。</p><h3 id="2-3-10其它组件"><a href="#2-3-10其它组件" class="headerlink" title="2.3.10其它组件"></a>2.3.10其它组件</h3><h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p><h4 id="EventloopGroup"><a href="#EventloopGroup" class="headerlink" title="EventloopGroup"></a>EventloopGroup</h4><p>下图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）：</p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\EventloopGroup.png" style="zoom:80%;"><p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>bossGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>workerGroup</code> 来处理，然后 <code>workerGroup</code> 负责处理其 IO 相关操作。</p><p><code>EventLoopGroup</code> 为 <code>Netty</code> 线程池，它实际上就是 <code>EventLoop</code> 的数组容器。<code>EventLoop</code> 的职责是处理所有注册到本线程多路复用器 <code>Selector</code> 上的 <code>Channel</code>，<code>Selector</code> 的轮询操作由绑定的 <code>EventLoop</code> 线程 <code>run</code> 方法驱动，在一个循环体内循环执行。通俗点讲就是一个死循环，不断的检测 I/O 事件、处理 I/O 事件。</p><h4 id="Bootstrap-和-ServerBootstrap"><a href="#Bootstrap-和-ServerBootstrap" class="headerlink" title="Bootstrap 和 ServerBootstrap"></a>Bootstrap 和 ServerBootstrap</h4><p><strong>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件</strong></p><p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServerBootstrap</code> 客户端的启动引导类/辅助类，具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的示例中，我们可以看出：</p><ol><li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li><li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li><li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li></ol><h4 id="EventLoopGroup-默认的构造函数会起多少线程"><a href="#EventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="EventLoopGroup 默认的构造函数会起多少线程"></a>EventLoopGroup 默认的构造函数会起多少线程</h4><p>回顾我们在上面写的服务器端的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 <strong><code>CPU核心数*2</code>**。</strong>（两倍的CPU数目）**</p><p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p><h3 id="2-3-11Netty执行全过程"><a href="#2-3-11Netty执行全过程" class="headerlink" title="2.3.11Netty执行全过程"></a>2.3.11Netty执行全过程</h3><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\Netty执行全过程.png" style="zoom:80%;"><ol><li><p>ServerBootStrap作为Netty的服务端入口，会对BossGroup和WorkGroup进行相关初始化操作，在BossGroup中，主要是对客户端的新连接请求进行处理（即OP_ACCEPT事件，但其实OP_ACCEPT事件的具体处理也会涉及到读写事件，因为数据不是读就是写），在WorkGroup中，则负责处理IO读写、编解码、业务逻辑等（即OP_READ事件、OP_WRITE事件）。服务端启动的时候会绑定一个端口，作为后续客户端连接入口，绑定端口的时候会在BossGroup(由NioEventLoopGroup类创建的对象）的其中一个NioEventLoop的Selector（多路复用器）上注册一条NioServerSocketChannel通道，后面的连接处理就是在通道中进行的。</p></li><li><p>BootStrap则作为Netty的客户端入口，会对ClientGroup进行相关初始化操作，在ClientGroup中，第一就是创建与服务端的连接（即OP_CONNECT事件），第二就是进行IO读写、编解码、业务逻辑等操作（即OP_READ事件、OP_WRITE事件）。</p></li><li><p>服务端和客户端启动之后，当服务端收到客户端发来的连接请求，由于属于OP_ACCEPT事件，在BossGroup中处理。BossGroup(由NioEventLoopGroup类创建的对象）管理着若干个NioEventLoop，每个NioEventLoop持有一个线程（就好比线程池中的一组线程并发处理若干个连接请求），每个NioEventLoop上会创建一个Selector，一个Selector上可以注册多个通道（所以叫多路复用器），且它会以不断轮询的方式同时监听每个通道上是否有IO事件发生，每个通道里都会有个ChannelPipeline管道，管道里全是Handler，包括管道头Head和管道尾Tail，以及进行IO读写、编解码，业务处理的若干个Handler，Handler也可以自定义，把需要的Handler注册进管道就可以执行了。当请求到达Head时，代表“请求数据”已准备好，OP_ACCEPT事件已就绪，Selector监听到事件已就绪，就会让持有的线程对事件进行处理，处理过程是在Handler中进行。首先会创建一个NioSocketChannel实例，然后交给ServerBootStrapAcceptor这个Handler，它是Netty底层代码注册的，Acceptor具体操作就是向WorkGroup中的某个Selector注册刚才创建好的NioSocketChannel，自此客户端连接请求处理结束。</p></li><li><p>客户端发出连接请求的同时会自己创建一条NioSocketChannel通道与服务端NioSocketChannel进行互通，连接完之后就是WorkGroup的事了，不需要BossGroup管了，一个客户端连接对应一条服务端NioSocketChannel。比如现在客户端要进行一个远程方法的调用，将方法参数传给服务端后，服务端处理完将结果返回给客户端。首先请求从客户端通道传输到WorkGroup中的对应通道，然后Head会申请一块堆外内存来缓冲请求内容，缓冲完之后，代表数据已准备好，OP_READ事件已就绪，selector监听到就绪事件之后，让持有的线程对事件进行处理，这里我定义了Decode解码，Compute方法调用处理和Encode编码三个Handler进行操作，其中Inbound入站Handler包括Decode和Compute（从Head到Tail就是入站），Outbound出站Handler包括Encode（从Tail到Head就是出站），每一个Handler被注册到Pipeline中的时候都会创建一个与之对应的ChannelHandlerContext，它包含着Handler的上下文信息，主要负责管理和其他在同一管道里的Handler之间的交互，它有一个前指针和后指针，可以与其他ChannelHandlerContext关联，这样Handler处理就变得更加灵活，比如这次请求需要三个Handler，而下次请求只涉及到Decode和Encode，那下次就可以执行完Decode然后指针直接指向Encode，next指针具体指向谁是依靠ChannelHandlerContext中的数据类型与其他Handler类型进行匹配得出的。在处理完读事件之后，接着处理Handler中涉及到的写事件，将处理结果写到ByteBuf中，回到Head，执行flush操作将ByteBuf内容写到SocketBuffer中，然后再到网卡buffer，通过互联网把结果传回给客户端，客户端拿到结果之后同样要进行解码，反序列化等操作，那么回过头发现客户端在发送调用请求之前在Pipeline中也进行了Encode处理的。（Head的主要作用：从SocketBuffer读请求内容到ByteBuf，从ByteBuf写返回结果到SocketBuffer）</p></li><li><p>假设又有另外一个客户端连接了服务端，且和之前那个NioSocketChannel注册到了同一个Selector上，当线程正在处理另一个通道上的事件的时候，这时该客户端也发起了一个处理请求，请求到达服务端通道之后会被Head读到堆外内存中缓冲着，此时OP_READ事件已就绪，Selector监听到了就绪事件，但由于线程正在处理另外一个通道上的事件，所以就要等当前通道的事件处理完，下一轮循环监听再处理了（这也是堆外内存的作用体现之一，数据可以先在缓冲区放着）。当两个通道被注册在不同的Selector上的时候就互不影响了，因为是在不同的线程中并行处理的。另外补充两点，第一个TaskQueue任务队列中的任务都是非IO任务，从性能上来考虑，千万不要将一个需要长时间来运行的任务放入到任务队列中，因为事件任务在一个线程中是串行执行的，这样会阻塞其他任务。解决方案是使用一个专门的EventExecutor来执行它（ChannelPipeline提供了带有EventExecutorGroup参数的addXXX()方法，该方法可以将传入的ChannelHandler绑定到你传入的EventExecutor之中），这样它就会在另一条线程中执行，与其他任务隔离。第二个Channel注册到Selector后返回的是一个SelectionKey，这个SelectionKey有以下几个重要属性：</p><ul><li>interest set，通道感兴趣的事件集，就是会把该通道可能执行的事件类型都告诉Selector</li><li>ready set，感兴趣的事件集中的“就绪事件集”</li><li>保存着的Channel</li><li>保存着的Selector</li></ul></li></ol><p>IO事件类型：</p><ul><li>SelectionKey.OP_READ </li><li>SelectionKey.OP_WRITE </li><li>SelectionKey.OP_ACCEPT </li><li>SelectionKey.OP_CONNECT </li></ul><p>因此Selector每次循环监听的其实就是SelectionKey中的就绪事件集，看是否存在已就绪的事件，存在就进行处理。SelectionKey相当于是Selector和Channel之间的桥梁。</p><h3 id="2-3-12从-BIO-演进到-NIO，再到-Netty"><a href="#2-3-12从-BIO-演进到-NIO，再到-Netty" class="headerlink" title="2.3.12从 BIO 演进到 NIO，再到 Netty"></a>2.3.12从 BIO 演进到 NIO，再到 Netty</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO是阻塞IO，也称之为传统IO，在Java的网络编程中，指的就是ServerSocket、Socket套接字实现的网络通信，这也是我们最开始学Java时接触到的网络编程相关的类。<strong>服务端在有新连接接入时或者在读取网络消息时，它会对主线程进行阻塞</strong>。下面是通过BIO来实现上面场景的代码。</p><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            InputStream inputStream = accept.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="comment">// read()方法是一个阻塞方法，当没有数据可读时，线程会一直阻塞在read()方法上</span></span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端的代码中，创建了一个ServerSocket套接字，并绑定端口8080，然后在while死循环中，调用ServerSocket的accept()方法，让其不停的接收客户端连接。accept()方法是一个阻塞方法，当没有客户端来连接时，main线程会一直阻塞在accept()方法上（现象：程序一直停在accept()方法这一行，不往下执行）。当有客户端连接时，main线程解阻塞，程序继续向下运行。接着调用read()方法来从客户端读取数据，read()方法也是一个阻塞方法，如果客户端发送来数据，则read()能读取到数据；如果没有数据可读，那么main线程就又会一直停留在read()方法这一行。</p><p>这里使用了两个while循环，外层的while循环是为了保证能不停的接收连接，内层的while循环是为了保证不停的从客户端中读取数据。</p><p><strong>客户端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 采用具有定时执行任务的线程池，来模拟客户端每隔一段时间来向服务端发送消息</span></span><br><span class="line">        <span class="comment">// 这里是每隔3秒钟向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="comment">// 向服务端发送消息（消息内容为：客户端的ip+端口+Hello World，示例：/127.0.0.1:999999 Hello World）</span></span><br><span class="line">                String message = socket.getLocalSocketAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                outputStream.write(message.getBytes());</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端的代码中，创建了一个Socket套接字，并指定要连接的服务器地址和端口号。然后通过使用一个具有定时执行任务功能的线程池，让客户端每隔3秒钟向服务端发送一条数据。</p><p>然后我们分别启动服务端和一个客户端，从服务端的控制台就可以看到，每个3秒钟就会打印一行 <code>客户端的ip+端口+Hello World</code>的日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br></pre></td></tr></table></figure><p>为了模拟多个客户端的接入，然后我们再启动一个客户端，这个时候我们期待在服务端的控制台，会打印出两个客户端的<code>ip+端口+Hello World</code>，由于服务端和两个客户端都是在同一台机器上，因此这个时候打印出来的两个客户端的ip是相同的，但是端口口应该是不一样的。我们期望的日志输出应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure><p>然而，这只是我们期望的，实际现象，并非如此，当我们再启动一个客户端后，发现控制台始终只会出现一个客户端的端口号，并非两个。</p><p>那么为什么呢？原因就在于服务端的代码中，read()方法是一个阻塞方法，当第一个客户端连接后，读取完第一个客户端的数据，由于第一个客户端一直不释放连接，因此服务端也不知道它还有没有数据要发送过来，这个时候服务端的main线程就一直等在read()方法处，当有第二个客户端接入时，由于main线程一直阻塞在read()方法处，因此它无法执行到accept()方法来处理新的连接，所以此时我们看到的现象就是，只会打印一个客户端发送来的消息。</p><p>那么我们该怎么办呢？既然知道了问题出现main线程阻塞在read()方法处，也就是在读数据的时候出现了阻塞。而要解决阻塞的问题，最直接的方式就是利用多线程技术了，因此我们就在读数据的时候新开启一条线程来进行数据的读取。升级之后的服务端代码如下。</p><p><strong>服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServerV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">          Socket accept = serverSocket.accept();</span><br><span class="line">           <span class="comment">// 用另外一个线程来读写数据</span></span><br><span class="line">            handleMessage(accept);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新创建一个线程来读取数据</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码不变，依然使用BioClient。在服务端的代码BioServerV2中，读数据的操作我们提取到了handleMessage()方法中进行处理，在该方法中，会新创建一个线程来读取数据，这样就不会造成main线程阻塞在read()方法上了。启动服务端和两个客户端进行验证。控制台打印结果如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure><p>虽然解决了多个客户端同时接入的问题，但是其中的缺点我们也很容易发现：每当有一个新的客户端来连接服务端时，我们都需要为这个客户端创建一个线程来处理读数据的操作，当并发度很高时，我们就需要创建很多的线程，这显然这是不可取的。线程是服务器的宝贵资源，创建和销毁都需要花费很长时间，当线程过多时，CPU的上线文切换也更加频繁，这样就会造成服务响应缓慢。当线程过多时，甚至还会出现句柄溢出、OOM等异常，最终导致服务宕机。另外，我们在读取数据时，是基于IO流来读取数据的，每次只能读取一个或者多个字节，性能较差。</p><p>因此BIO的服务端，适用于并发度不高的应用场景，但是对于高并发，服务负载较重的场景，使用BIO显然是不适合的。</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>为了解决BIO无法应对高并发的问题，JDK从1.4开始，提供了一种新的网络IO，即NIO，通常称它为非阻塞IO。然而NIO的代码极为复杂和难懂，下面简单介绍写NIO中相关的类。</p><p>NIO相关的类均在<code>java.nio</code>包下。与BIO中ServerSocket、Socket对应，NIO中提供了ServerSocketChannle、SocketChannel分别表示服务端channel和客户端channel。与BIO中不同的是，NIO中出现了Selector轮询器的概念，不同的操作系统有不同的实现方式（在windows平台底层实现是select，在linux内核中采用epoll实现，在MacOS中采用poll实现）。另外NIO是基于ByteBuffer来读写数据的。</p><p>看看如何用NIO来实现上面的场景：</p><p><strong>NIO 服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 轮询器，不同的操作系统对应不同的实现类</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">       serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 将服务端channel注册到轮询器上，并告诉轮询器，自己感兴趣的事件是ACCEPT事件</span></span><br><span class="line">       serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用轮询器的select()方法，是让轮询器从操作系统上获取所有的事件（例如：新客户端的接入、数据的写入、数据的写出等事件）</span></span><br><span class="line">           selector.select(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">// 调用select()方法后，轮询器将查询到的事件全部放入到了selectedKeys中</span></span><br><span class="line">           Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">           <span class="comment">// 遍历所有事件</span></span><br><span class="line">           Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">           <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果是新连接接入</span></span><br><span class="line">               <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                   SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                   System.out.println(<span class="string">&quot;有新客户端来连接&quot;</span>);</span><br><span class="line">                   socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="comment">// 有新的客户端接入后，就样将客户端对应的channel所感兴趣的时间是可读事件</span></span><br><span class="line">                   socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果是可读事件</span></span><br><span class="line">               <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                   <span class="comment">// 从channel中读取数据</span></span><br><span class="line">                   SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                   ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                   channel.read(byteBuffer);</span><br><span class="line">                   byteBuffer.flip();</span><br><span class="line">                   System.out.println(Charset.defaultCharset().decode(byteBuffer));</span><br><span class="line">                   <span class="comment">// 读完了以后，再次将channel所感兴趣的时间设置为读事件，方便下次继续读。当如果后面要想往客户端写数据，那就注册写时间：SelectionKey.OP_WRITE</span></span><br><span class="line">                   channel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 将SelectionKey从集合中移除，</span></span><br><span class="line">               <span class="comment">// 这一步很重要，如果不移除，那么下次调用selectKeys()方法时，又会遍历到该SelectionKey，这就造成重复处理了，而且最终selectionKeys这个集合的大小会越来越大。</span></span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：</p><ul><li><p>首先通过<code>ServerSocketChannel.open()</code>这行代码创建了一个服务端的channel，也就是服务端的Socket。（在计算机网路的7层模型或者TCP/IP模型中，上层的应用程序通过Socket来和底层沟通）</p></li><li><p>通过<code>Selector.open()</code>创建了一个轮询器，这个轮询器就是后续用来从操作系统中，遍历有哪些socket准备好了。这么说有点抽象，举个栗子。坐火车时，通常都会有补票环节。每过一站后，乘务员就会在车厢中吼一嗓子，哪些人需要补票的？需要补票的人去几号车厢办理。这个乘务员就对应NIO中轮询器，定时去车厢中吼一嗓子（也就是去操作系统中“吼一嗓子”），这个时候如果有人需要补票（有新的客户端接入或者读写事件发生），那么它就会去对应的车厢办理（这些接入事件或者读写事件就会跑到selectKeys集合中）。而对应BIO，每对应一个新客户端，都需要新建一个线程，也就是说每出现一个乘客，我们都要为它配备一个乘务员，这显然是不合理的，不可能有那么多的乘务员。因此这就是NIO对BIO的一个巨大优势。</p></li><li><p>然后为服务端绑定端口号，并设置为非阻塞模式。我们使用NIO的目的就是为了使用它的非阻塞特性，因此这里需要调用 <code>serverSocketChannel.configureBlocking(false)</code>设置为非阻塞</p></li><li><p>然后将ServerSocketChannel注册到轮询器selector上，并告诉轮询器，它感兴趣的事件是ACCEPT事件（服务端的Channel就是用来处理客户端接入的，因此它感兴趣的事件就是ACCEPT事件。为什么要把它注册到轮询器上呢？前面已经说到了，轮询器会定期去操作系统中“吼一嗓子，谁要补票”，如果不注册到轮询器上（不上火车），轮询器吼一嗓子的时候，你怎么听得见呢？）</p></li><li><p>接着就是在一个while循环中，每过一段时间让轮询器去操作系统中轮询有哪些事件发生。select()方法就是去操作系统中轮询（吼一嗓子），它可以传入一个参数，表示在操作系统中等多少毫秒，如果在这段时间中没有事件发生（没有人要补票），那么就从操作系统中返回。如果有事件发生，那么就将这些事件方法放到轮询器的<code>publicSelectedKeys</code>属性中，当调用<code>selector.selectedKeys()</code>方法时，就将这些事件返回。</p></li><li><p>接下来就是判断事件是哪种事件，是接收事件还是读事件，亦或是写事件，然后针对每种不同的事件做不同的处理。</p></li><li><p>最后将key从集合中移除。为什么移除，见代码注释。</p></li></ul><p>上面是服务端NIO的写法，这个时候，可以直接利用BIO的客户端去进行测试。当然NIO也有客户端写法。虽然NIO的写法很复杂，但一回生，二回熟，多见几回就习惯了，所以下面还是贴出了NIO客户端的写法。</p><p><strong>NIO 客户端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">       socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">boolean</span> connect = socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">       <span class="comment">// 因为连接是一个异步操作，所以需要在下面一行判断连接有没有完成。如果连接还没有完成，就进行后面的操作，会出现异常</span></span><br><span class="line">       <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">           <span class="comment">// 如果连接未完成，就等待连接完成</span></span><br><span class="line">            socketChannel.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 每个3秒向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               String message = socketChannel.getLocalAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                <span class="comment">// 使用ByteBuffer进行数据发送</span></span><br><span class="line">               ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">               socketChannel.write(byteBuffer);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO客户端的写法相对比较简单，利用SocketChannel进行IP和端口的绑定，然后调用connect()方法进行连接到服务端。最后利用ByteBuffer装载数据，通过SocketChannel将数据写出去。</p><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>相比BIO而言，NIO不需要为每个连接去创建一个线程，它是通过轮询器，定期的从操作系统中获取到准备好的事件，然后进行批量处理。同时NIO是通过ByteBuffer来读写数据，相比于BIO中通过流来一个字节或多个字节的对数据，NIO的效率更高。但是ByteBuffer的数据结构设计，有点反人类，一不小心就会出BUG。</p><p>BIO在高并发下不适合用，而NIO虽然可以应对高并发的场景，但是它一方面因为写法复杂，掌握难度大，更重要的是还存在空轮询的BUG（产生空轮询的原因是操作系统的缘故），因此Netty出现了。Netty是目前应该使用最广泛的一款网络框架，用官方术语讲就是：它是一款基于事件驱动的高性能的网络框架。实际上它是一款将NIO包装了的框架，同时它规避了JDK中空轮训的BUG。虽然它是对NIO的包装，但是它对很多操作进行了优化，其性能更好。目前在很多Java流行框架中，底层都采用了Netty进行网络通信，比如RPC框架中Dubbo、Motan，Spring5的异步编程，消息队列RocketMQ等等都使用了Netty进行网络通信。</p><p>接下来就用Netty实现上面的场景：</p><p><strong>Netty 服务端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责处理连接的线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 负责处理IO和业务逻辑的线程组</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 添加日志打印，用来观察Netty的启动日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 添加用来处理客户端channel的处理器handler</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 字符串解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    <span class="comment">// 自定义的handler，用来打印接收到的消息</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            System.out.println(message);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;有新客户端连接&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，并启动</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码虽然看起来也很长，但是这段代码几乎是不变的，它几乎适用于所有场景，我们只需要修改childHandler()这一行相关的方法即可。这里面的代码才是处理我们自定义的业务逻辑的。</p><p>启动NettyServer，可以直接使用BioClient或者NioClient来测试NettyServer。当然，Netty也有客户端的写法。代码如下。</p><p><strong>Netty 客户端代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个线程组即可</span></span><br><span class="line">        NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 采用Bootstrap而不是ServerBootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(nioEventLoopGroup)</span><br><span class="line">                    <span class="comment">// 设置客户端的SocketChannel</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 添加一个字符串编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line"></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">            executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">                String message = channel.localAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                channel.writeAndFlush(message);</span><br><span class="line">            &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            nioEventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码也几乎是固定的，所有场景都可以复用这段代码，唯一需要修改的就是handler()方法这一块，需要针对自己的业务逻辑去添加不同的处理器。</p><p>相比于NIO的写法，Netty的写法更加简洁，代码量相对更少，几行简单的代码就搞定了服务的启动，新连接接入，数据读写，编解码等问题。这也是为什么Netty使用这么广泛的原因。相比于NIO，Netty有如下几点优点：</p><ul><li>JDK的NIO存在空轮询的BUG，而Netty则巧妙的规避了这一点；</li><li>JDK的API复杂，开发人员使用起来比较困难，更重要的是，很容易写出BUG；而Netty的API简单，容易上手。</li><li>Netty的性能更高，它在JDK的基础上做了很多性能优化，例如将selector中的<code>publicSelectedKeys</code>属性的数据结构由Set集合改成了数组。</li><li>Netty底层对IO模型可以随意切换，针对Reactor三种线程模型，只需要通过修改参数就可以实现IO模型的切换。</li><li>Netty经过了众多高并发场景的考验，如Dubbo等RPC框架的验证。</li><li>Netty帮助我们解决了TCP的粘包拆包等问题，开发人员不用去关心这些问题，只需专注于业务逻辑开发即可。</li><li>Netty支持很多协议栈。JDK自带的对象序列化性能很差，序列化后码流较大，而是用其他方式的序列化则性能较高，例如protobuf等。</li><li>优点还有很多…</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（七）RPC实现服务端自动注册服务</title>
    <link href="http://wangjin1996219.github.io/2021/05/12/%EF%BC%88%E4%B8%83%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1/"/>
    <id>http://wangjin1996219.github.io/2021/05/12/%EF%BC%88%E4%B8%83%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-05-12T14:46:06.000Z</published>
    <updated>2021-06-01T11:44:23.125Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>到目前为止，客户端看起来挺完美了，但是在服务端，我们却需要手动创建服务对象，并且手动进行注册，如果服务端提供了很多服务，这个操作就会变得很繁琐。本节就会介绍如何基于注解进行服务的自动注册。</p><h1 id="1-如何定义自己的注解"><a href="#1-如何定义自己的注解" class="headerlink" title="1.如何定义自己的注解"></a>1.如何定义自己的注解</h1><p><strong>元注解：</strong>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p><ol><li>@Target</li><li>@Retention</li><li>@Documented</li><li>@Inherited</li></ol><p><strong>每个元注解的作用和相应分参数的使用说明：</strong></p><p><strong>@Target：</strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p><p>取值(ElementType)有：</p><ol><li>CONSTRUCTOR:用于描述构造器</li><li>FIELD:用于描述域</li><li>LOCAL_VARIABLE:用于描述局部变量</li><li>METHOD:用于描述方法</li><li>PACKAGE:用于描述包</li><li>PARAMETER:用于描述参数</li><li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li></ol><p><strong>@Retention：</strong>表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p><p>取值（RetentionPoicy）有：</p><ol><li>SOURCE:在源文件中有效（即源文件保留）</li><li>CLASS:在class文件中有效（即class保留）</li><li>RUNTIME:在运行时有效（即运行时保留）</li></ol><h1 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2.定义注解"></a>2.定义注解</h1><p>我们需要定义两个注解：Service 和 ServiceScan</p><p><strong>Service.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceScan.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。Service 注解的值定义为该服务的名称，默认值是该类的完整类名，而 ServiceScan 的值定义为扫描范围的根包，默认值为入口类所在的包，扫描时会扫描该包及其子包下所有的类，找到标记有 Service 的类，并注册。</p><h1 id="3-工具类-ReflectUtil"><a href="#3-工具类-ReflectUtil" class="headerlink" title="3.工具类 ReflectUtil"></a>3.工具类 ReflectUtil</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] stack = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">        <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>].getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件 并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者 也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是 <code>getClasses</code> 方法，传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回。</p><h1 id="4-扫描服务"><a href="#4-扫描服务" class="headerlink" title="4.扫描服务"></a>4.扫描服务</h1><p>扫描服务这一步是一个比较公共的方法，无论是 Socket 还是 Netty 的服务端都需要这个方法，于是我对项目做了一点重构，使用了一个抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自 AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取启动类，也就是main方法所在的类</span></span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Class.forName(xxx.xx.xx) 返回具体类</span></span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到所有的 Class ，逐个判断是否有 Service 注解</span></span><br><span class="line">        <span class="comment">//如果有的话，通过反射创建该对象，并且调用 publishService 注册即可</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service.class).name();</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要获得要扫描的包的范围，就需要获取到 ServiceScan 注解的值，而我们前面说过，这个注解是加在启动类上的，那么，我们怎么知道启动类是哪一个呢？答案是通过调用栈。方法的调用和返回是通过方法调用栈来实现的，当调用一个方法时，该方法入栈，该方法返回时，该方法出站，控制回到栈顶的方法。那么，main 方法一定位于调用栈的最底端，在 ReflectUtils 中，我写了一个 getStackTrace 方法（名字起得不好），用于获取 main 所在的类。通过 Class 对象的 isAnnotationPresent 方法来判断该类是否有 ServiceScan 注解。如果有，通过startClass.getAnnotation(ServiceScan.class).value(); 获取注解的值。</p><p>当获得扫描的范围后，就可以通过ReflectUtil.getClasses(basePackage) 获取到所有的 Class 了，逐个判断是否有 Service 注解，如果有的话，通过反射创建该对象，并且调用 publishService 注册即可。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（六）RPC实现自动注销服务和负载均衡策略</title>
    <link href="http://wangjin1996219.github.io/2021/05/12/%EF%BC%88%E5%85%AD%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://wangjin1996219.github.io/2021/05/12/%EF%BC%88%E5%85%AD%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</id>
    <published>2021-05-12T14:45:20.000Z</published>
    <updated>2021-05-20T15:04:46.395Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>上一章我们实现了服务的注册和发现，但是我们发现，启动完成服务端后把服务端给关闭了，并不会自动地注销 Nacos 中对应的服务信息，这样就导致了当客户端再次向 Nacos 请求服务时，会获取到已经关闭的服务端信息，最终就有可能因为连接不到服务器而调用失败。</p><p>那么我们就需要一种办法，<strong>在服务端关闭之前自动向 Nacos 注销服务</strong>。但是有一个问题，我们不知道什么时候服务器会关闭，也就不知道这个方法调用的时机，就没有办法手工去调用。这时，我们就需要钩子。</p><p><strong>钩子：</strong>是在某些事件发生后自动去调用的方法。那么我们只<strong>需要把注销服务的方法写到关闭系统的钩子方法里就行了</strong>。</p><h1 id="1-服务自动注销功能"><a href="#1-服务自动注销功能" class="headerlink" title="1.服务自动注销功能"></a>1.服务自动注销功能</h1><h2 id="1-1rpc-common-创建工具类NacosUtil"><a href="#1-1rpc-common-创建工具类NacosUtil" class="headerlink" title="1.1rpc-common 创建工具类NacosUtil"></a>1.1rpc-common 创建工具类NacosUtil</h2><p>先写向 Nacos 注销所有服务的方法 <code>clearRegistry</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String host = address.getHostName();</span><br><span class="line">        <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">        Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            String serviceName = iterator.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的服务名称都被存储在 NacosUtils 类中的 serviceNames 中，在注销时只需要用迭代器迭代所有服务名，调用 deregisterInstance 即可。</p><h2 id="1-2-rpc-core-创建钩子"><a href="#1-2-rpc-core-创建钩子" class="headerlink" title="1.2 rpc-core 创建钩子"></a>1.2 rpc-core 创建钩子</h2><p>新建一个类 <code>ShutdownHook</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool = ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;shutdown-hook&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 addShutdownHook 方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p><p>这样在 RpcServer 启动之前，只需要调用 addClearAllHook，就可以注册这个钩子了。例如在 NettyServer 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure><h1 id="2-负载均衡策略"><a href="#2-负载均衡策略" class="headerlink" title="2.负载均衡策略"></a>2.负载均衡策略</h1><p>在上一节中客户端在 lookupService 方法中，从 Nacos 获取到的是所有提供这个服务的服务端信息列表，我们就需要从中选择一个，这便涉及到客户端侧的负载均衡策略。也就是说我们在选择服务器时要尽量避免集中访问同一个服务器。</p><p><strong>LoadBalancer 接口：</strong>只有一个方法，从获取到的服务器列表中选择一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现两个比较经典的算法：随机和转轮</p><p><strong>随机算法：</strong>顾名思义，就是随机选一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转轮算法：</strong>按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p><p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 NacosServiceRegistry 中集成就可以了，这里选择外部传入的方式传入 LoadBalancer：</p><p><strong>ServiceDiscovery 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称查找服务实体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NacosServiceDiscovery 实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;找不到对应的服务: &quot;</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个负载均衡策略，也可以在创建客户端时指定，例如无参构造 NettyClient 时就用默认的策略，也可以有参构造传入策略</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（五）RPC实现基于Nacos的注册中心</title>
    <link href="http://wangjin1996219.github.io/2021/05/07/%EF%BC%88%E4%BA%94%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://wangjin1996219.github.io/2021/05/07/%EF%BC%88%E4%BA%94%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2021-05-07T06:14:16.000Z</published>
    <updated>2021-05-24T15:23:56.634Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-countdownlatch工具类的使用"><a href="#1-countdownlatch工具类的使用" class="headerlink" title="1.countdownlatch工具类的使用"></a>1.countdownlatch工具类的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch begin = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(begin,end),String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the race begin&quot;</span>);</span><br><span class="line">            begin.countDown();</span><br><span class="line">            end.await();<span class="comment">//await() 方法具有阻塞作用，也就是说主线程在这里暂停</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the race end&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    Player(CountDownLatch begin,CountDownLatch end)&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start !&quot;</span>);;</span><br><span class="line">            begin.await();<span class="comment">//因为此时已经为0了，所以不阻塞</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; arrived !&quot;</span>);</span><br><span class="line"></span><br><span class="line">            end.countDown();<span class="comment">//countDown() 并不是直接唤醒线程,当end.getCount()为0时线程会自动唤醒</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程main被end.await();阻塞，两个副线程继续往下运行，因为benin已经为0，所以不阻塞，操作两次end的downcount（每次减1）之后，主线程继续往下执行。</p><p>如果 <code>CountDownLatch end = new CountDownLatch(3)</code>  因为只操作两次 end 的 downcount ，所以主线程 main 会一直被阻塞。</p><h1 id="2-实现基于Nacos的注册中心"><a href="#2-实现基于Nacos的注册中心" class="headerlink" title="2.实现基于Nacos的注册中心"></a>2.实现基于Nacos的注册中心</h1><h2 id="2-1获取Nacos"><a href="#2-1获取Nacos" class="headerlink" title="2.1获取Nacos"></a>2.1获取Nacos</h2><p>下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>本文版本：1.3.0</p><p>下载完成之后，解压。根据不同平台，执行不同命令，启动单机版Nacos服务：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Linux/Unix/Mac：sh startup.sh -m standalone</span><br><span class="line">Windows：<span class="built_in">cmd</span> startup.<span class="built_in">cmd</span> -m standalone</span><br></pre></td></tr></table></figure><blockquote><p><code>startup.sh</code>脚本位于Nacos解压后的bin目录下。</p></blockquote><p>启动完成之后，访问：<code>http://127.0.0.1:8848/nacos/</code>，可以进入Nacos的服务管理页面，具体如下:</p><img src="/2021/05/07/%EF%BC%88%E4%BA%94%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/GitHub\MyBlogs\source\_posts\2021-05-07-（五）RPC实现基于Nacos的注册中心\nacos1.png" alt="image-20210508110300724" style="zoom:80%;"><h2 id="2-2-rpc-core-引入-Nacos-依赖"><a href="#2-2-rpc-core-引入-Nacos-依赖" class="headerlink" title="2.2 rpc-core 引入 Nacos 依赖"></a>2.2 rpc-core 引入 Nacos 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-rpc-core-创建-ServiceProvider-接口"><a href="#2-3-rpc-core-创建-ServiceProvider-接口" class="headerlink" title="2.3 rpc-core 创建 ServiceProvider 接口"></a>2.3 rpc-core 创建 ServiceProvider 接口</h2><p>将第二章中本地保存服务的接口 <code>ServiceRegistry</code> 改写为<code>ServiceProvider</code>，作为服务的提供者：</p><p><strong>ServiceProvider接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ServiceProviderImpl实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务名与提供服务的对象的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存当前有哪些对象已经被注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务的注册功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务对象实现的接口的完整类名作为注册的服务名（ConcurrentHashMap中的键值）</span></span><br><span class="line">        String serviceName = service.getClass().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//当服务不存在时，注册服务</span></span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        <span class="comment">//获取该对象实现的接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将服务实现的接口的类名</span></span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务获取功能的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据服务的名称，从ConcurrentHashMap中获取服务并返回对应服务</span></span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-rpc-core-创建-ServiceRegistry-接口"><a href="#2-4-rpc-core-创建-ServiceRegistry-接口" class="headerlink" title="2.4 rpc-core 创建 ServiceRegistry 接口"></a>2.4 rpc-core 创建 ServiceRegistry 接口</h2><p><code>ServiceRegistry</code> 作为远程注册表（Nacos）使用，也就是在远端存储<strong>服务的名称和服务对应的地址、端口号</strong>，并能够根据名称找到对应的服务提供地址信息。</p><p><strong>ServiceRegistry接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将服务的名称和地址注册进服务注册中心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inetSocketAddress 提供服务的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称从注册中心获取到一个服务提供者的地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NacosServiceRegistry实现类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过 NamingFactory 创建 NamingService 连接 Nacos</span></span><br><span class="line">            namingService = NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//registerInstance方法直接向 Nacos 注册服务</span></span><br><span class="line">            namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//getAllInstances方法可以获得提供某个服务的所有提供者的列表</span></span><br><span class="line">            List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br><span class="line">            <span class="comment">//通过 getAllInstance 获取到某个服务的所有提供者列表后，需要选择一个</span></span><br><span class="line">            Instance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nacos 的使用很简单，通过 NamingFactory 创建 NamingService 连接 Nacos（连接的时候没有找到修改用户名密码的方式……是不需要吗），连接的过程写在了静态代码块中，在类加载时自动连接。namingService 提供了两个很方便的接口，registerInstance 和 getAllInstances 方法，前者可以直接向 Nacos 注册服务，后者可以获得提供某个服务的所有提供者的列表。所以接口的这两个方法只需要包装一下就好了。</p><p>在 lookupService 方法中，通过 getAllInstance 获取到某个服务的所有提供者列表后，需要选择一个，这里就涉及了负载均衡策略，这里我们先选择第 0 个，后面某节会详细讲解负载均衡。</p><h2 id="2-5-rpc-core-注册服务"><a href="#2-5-rpc-core-注册服务" class="headerlink" title="2.5 rpc-core 注册服务"></a>2.5 rpc-core 注册服务</h2><p><strong>RpcServer 接口：</strong></p><ul><li>在 RpcServer 接口中新增一个方法 publishService，用于向 Nacos 注册服务</li><li> setSerializer 用于设置序列化器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(Object service, Class&lt;T&gt; serviceClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyServer 实现类：</strong></p><p>主要是上面两个新增方法的实现</p><p>通过<code>ServiceRegistry</code>、<code>ServiceProvider</code>两个实例对象实现提供服务和向远程nacos注册表注册服务的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(Object service, Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            serviceProvider.addServiceProvider(service);</span><br><span class="line">            serviceRegistry.register(serviceClass.getCanonicalName(), <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程组：bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//3.给引导类配置两大线程组,确定了线程模型（多线程模型）</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">//option()是提供给NioServerSocketChannel用来接收进来的连接</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> KryoSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 6.绑定端口,调用 sync 方法阻塞直到绑定完成</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host,port).sync();</span><br><span class="line">            <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publishService 需要将服务保存在本地的注册表，同时注册到 Nacos 上。我这里的实现是注册完一个服务后直接调用 start()  方法，这是个不太好的实现……导致一个服务端只能注册一个服务，之后可以多注册几个然后再手动调用 start() 方法。</p><h2 id="2-6-rpc-core-发现服务"><a href="#2-6-rpc-core-发现服务" class="headerlink" title="2.6 rpc-core 发现服务"></a>2.6 rpc-core 发现服务</h2><p><strong>创建 ChannelProvider 类用于获取 Channel 对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line">    <span class="comment">//最大重新连接次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRY_COUNT = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                <span class="comment">//自定义序列化编解码器:RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//用于线程通信</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取channel</span></span><br><span class="line">            connect(bootstrap, inetSocketAddress, countDownLatch);</span><br><span class="line">            <span class="comment">//线程在这里阻塞</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取channel时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        connect(bootstrap, inetSocketAddress, MAX_RETRY_COUNT, countDownLatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress, <span class="keyword">int</span> retry, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                channel = future.channel();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (retry == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端连接失败:重试次数已用完，放弃连接！&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.CLIENT_CONNECT_SERVER_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第几次重连</span></span><br><span class="line">            <span class="keyword">int</span> order = (MAX_RETRY_COUNT - retry) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 本次重连的间隔</span></span><br><span class="line">            <span class="keyword">int</span> delay = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">            logger.error(<span class="string">&quot;&#123;&#125;: 连接失败，第 &#123;&#125; 次重连……&quot;</span>, <span class="keyword">new</span> Date(), order);</span><br><span class="line">            bootstrap.config().group().schedule(() -&gt; connect(bootstrap, inetSocketAddress, retry - <span class="number">1</span>, countDownLatch), delay, TimeUnit</span><br><span class="line">                    .SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回客户端启动引导/辅助类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建单线程组</span></span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//3.指定线程组</span></span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//是否开启 TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>get 方法：</strong>用于获取 channel</p><p>通过<code>handler</code>方法给这个引导类创建一个<code>ChannelInitializer</code>，这里主要就是定义后续每条连接的数据读写，业务处理逻辑。</p><p>通过<code>CountDownLatch</code>工具，实现主线程的唤醒</p><p>调用<code>connect</code> 方法，获取channel</p></li><li><p><strong>connect 方法：</strong></p><p>在网络情况差的情况下，客户端第一次连接可能会连接失败，这个时候我们可能会尝试<strong>重新连接</strong>，相应的代码逻辑如下：</p><ol><li>如果连接成功则打印连接成功的消息</li><li>如果连接失败但是重试次数已经用完，放弃连接</li><li>如果连接失败但是重试次数仍然没有用完，则计算下一次重连间隔 <code>delay</code>，然后定期重连</li></ol><p>我们定时任务是调用 <code>bootstrap.config().group().schedule()</code>, 其中 <code>bootstrap.config()</code> 这个方法返回的是 <code>BootstrapConfig</code>，他是对 <code>Bootstrap</code> 配置参数的抽象，然后 <code>bootstrap.config().group()</code> 返回的就是我们在一开始的时候配置的线程模型 <code>workerGroup</code>，调 <code>workerGroup</code> 的 <code>schedule</code> 方法即可实现定时任务逻辑。</p><p>在 <code>schedule</code> 方法块里面，前面四个参数我们原封不动地传递，最后一个重试次数参数减掉一，就是下一次建立连接时候的上下文信息。</p></li><li><p><strong>initializeBootstrap 方法：</strong>返回客户端启动引导/辅助类对象</p><p>通过<code>group</code>方法给客户端启动引导类对象指定线程组，因为是客户端，所以只需要给定一个线程组。</p><p>通过<code>channel</code>方法指定 IO 模型</p><p>通过<code>option</code>方法给channel设置其它属性</p></li></ul><p>前面几章是直接使用传入的 host 和 port 直接构造 channel ，现在是首先从 ServiceRegistry 中获取到服务的地址和端口，再构造。以 NettyClient 为例，在过去创建 NettyClient 时，需要传入 host 和 port，现在这个 host 和 port 是通过 Nacos 获取的，sendRequest 修改如下：</p><p><strong>修改NettyClient类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Object&gt; result = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceRegistry.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span>(channel.isActive()) &#123;</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                        logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                channel.closeFuture().sync();</span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span> + rpcRequest.getRequestId());</span><br><span class="line">                RpcResponse rpcResponse = channel.attr(key).get();</span><br><span class="line">                RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">                result.set(rpcResponse.getData());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7测试"><a href="#2-7测试" class="headerlink" title="2.7测试"></a>2.7测试</h2>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（四）RPC实现Kryo序列化</title>
    <link href="http://wangjin1996219.github.io/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://wangjin1996219.github.io/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-05-06T13:39:24.000Z</published>
    <updated>2021-05-26T10:11:38.348Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>上一章我们实现了一个通用的序列化框架，使得序列化方式具有了较高的扩展性，并且实现了一个基于 JSON 的序列化器。</p><p><strong>基于 JSON 的序列化器的问题：</strong></p><ol><li>在某个类的属性反序列化时，如果属性声明为 Object 的，就会造成反序列化出错，通常会把 Object 属性直接反序列化成 String 类型，就需要其他参数辅助序列化。</li><li>并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。</li></ol><p><strong>Kryo</strong> 是一个快速高效的 Java 对象序列化框架，主要特点是高性能、高效和易用。</p><p><strong>最重要的两个特点：</strong></p><ol><li>基于字节的序列化，对空间利用率较高，在网络传输时可以减小体积；</li><li>序列化时记录属性对象的类型信息，这样在反序列化时就不会出现之前的问题了。</li></ol><h1 id="1-序列化介绍以及序列化协议选择"><a href="#1-序列化介绍以及序列化协议选择" class="headerlink" title="1.序列化介绍以及序列化协议选择"></a>1.序列化介绍以及序列化协议选择</h1><h2 id="1-1序列化和反序列化相关概念"><a href="#1-1序列化和反序列化相关概念" class="headerlink" title="1.1序列化和反序列化相关概念"></a>1.1序列化和反序列化相关概念</h2><p>如果我们需要持久化Java对象比如将Java对象保存在文件中，或者在网络传输Java对象，这些场景都需要用到序列化。 </p><p>简单来说： </p><ul><li><strong>序列化：</strong> 将数据结构或对象转换成二进制字节流的过程 </li><li><strong>反序列化：</strong>将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程 对于Java这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型， 而class 对应的是对象类型。</li></ul><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中</strong>。</p><p><strong>实际开发中有哪些用到序列化和反序列化的场景</strong></p><ol><li>对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； </li><li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li></ol><h2 id="1-2常见序列化协议对比"><a href="#1-2常见序列化协议对比" class="headerlink" title="1.2常见序列化协议对比"></a>1.2常见序列化协议对比</h2><p>JDK自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 <strong>hessian、kyro、protostuff</strong>。 </p><p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML这种属于文本类序列化方式。虽然 JSON 和 XML可读性比较好，但是性能较差，一般不会选择。</p><p><strong>JDK自带的序列化方式</strong></p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code> 接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一 致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成 默认的序列化号</p></blockquote><p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p><ol><li>**不支持跨语言调用 : ** 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差 ：</strong>相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li></ol><p><strong>kyro</strong></p><p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p><p><strong>Protobuf</strong></p><p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵 活，但是，另一方面导致protobuf没有序列化漏洞的风险。</p><blockquote><p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p></blockquote><p>一个简单的 proto 文件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// protobuf的版本</span></span><br><span class="line"><span class="number">2</span> syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="number">3</span> <span class="comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span></span><br><span class="line"><span class="number">4</span> message Person &#123;</span><br><span class="line"><span class="number">5</span> <span class="comment">//string类型字段</span></span><br><span class="line"><span class="number">6</span> string name = <span class="number">1</span>;</span><br><span class="line"><span class="number">7</span> <span class="comment">// int 类型字段</span></span><br><span class="line"><span class="number">8</span> int32 age = <span class="number">2</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>ProtoStuff</strong></p><p>由于Protobuf的易用性，它的哥哥 Protostuff  诞生了。 </p><p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p><p><strong>hession</strong></p><p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p><img src="/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/GitHub\MyBlogs\source\_posts\2021-05-06-（四）RPC实现Kryo序列化\hession.png" style="zoom:60%;"><h1 id="2-Kryo序列化"><a href="#2-Kryo序列化" class="headerlink" title="2.Kryo序列化"></a>2.Kryo序列化</h1><h2 id="2-1-rpc-core添加-kryo-依赖"><a href="#2-1-rpc-core添加-kryo-依赖" class="headerlink" title="2.1 rpc-core添加 kryo 依赖"></a>2.1 rpc-core添加 kryo 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-rpc-core-序列化接口"><a href="#2-2-rpc-core-序列化接口" class="headerlink" title="2.2 rpc-core 序列化接口"></a>2.2 rpc-core 序列化接口</h2><p>序列化接口中增加一个选项，返回Kryo序列化序列化器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">    <span class="comment">//通过序列化名称获取序列化码，比如Kryo对应0</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="comment">//把 Kryo 的编号设为 0，后续会作为默认的序列化器</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KryoSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在<code>SerializerCode</code>类中加入Kryo的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerCode</span> </span>&#123;</span><br><span class="line">    KRYO(<span class="number">0</span>),</span><br><span class="line">    JSON(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据接口<code>CommonSerializer</code>，我们的主要任务就是实现其中的主要两个方法，<code>serialize()</code> 和 <code>deserialize()</code> ，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(KryoSerializer.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过ThreadLocal来保证Kryo的线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//初始化Kryo对象</span></span><br><span class="line">        Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">        <span class="comment">//Kryo对象中注册RpcResponse类和RpcRequest类</span></span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="comment">//开启循环引用</span></span><br><span class="line">        kryo.setReferences(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//关闭注册行为</span></span><br><span class="line">        kryo.setRegistrationRequired(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             <span class="comment">//创建output对象，序列化的目标数组为byteArrayOutputStream字节数组</span></span><br><span class="line">             Output output = <span class="keyword">new</span> Output(byteArrayOutputStream))&#123;</span><br><span class="line">            <span class="comment">//得到线程对应的kryo对象</span></span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">//将对象序写入output对象，完成序列化</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            <span class="comment">//防止内存泄漏（因为ThreadLocal中的key是弱引用，value是强引用）</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="comment">//调用output的toByte()方法，返回一个字符数组</span></span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializeException(<span class="string">&quot;序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">             <span class="comment">//创建input对象，反序列化的目标数组为byteArrayOutputStream字节数组</span></span><br><span class="line">             Input input = <span class="keyword">new</span> Input(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="comment">//得到线程对应的kryo对象</span></span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">//将字节数组的数据转换成对应的实体类对象</span></span><br><span class="line">            Object o = kryo.readObject(input, clazz);</span><br><span class="line">            <span class="comment">//防止内存泄漏</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializeException(<span class="string">&quot;反序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;KRYO&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal-保存-kryo-对象"><a href="#ThreadLocal-保存-kryo-对象" class="headerlink" title="ThreadLocal 保存 kryo 对象"></a>ThreadLocal 保存 kryo 对象</h3><ul><li><p>由于 kryo 不是线程安全的，所以每个线程都使用独立的 kryo，用ThreadLocal作为容器，当每个线程访问这个 <strong>Kryo</strong> 对象时，ThreadLocal 会为每个线程提供一个对象，各个线程互不影响。</p><p><code>withInitial</code> 是一种 Lambda 构造方式，为每个线程创建一个 kryo 局部对象。</p></li><li><p>另一方面，因为 Kryo 实例的创建/初始化是相当昂贵的，所以在多线程的情况下，您应该池化 Kryo 实例。一个非常简单的解决方案是使用 ThreadLocal 将 Kryo实例绑定到 Threads。</p></li></ul><h3 id="Kryo-使用"><a href="#Kryo-使用" class="headerlink" title="Kryo 使用"></a>Kryo 使用</h3><p><strong>IO</strong></p><p>Kryo 的 Input 和 Output 接收一个 InputStream 和 OutputStream，Kryo  通常完成字节数组和对象的转换，所以常用的输入输出流实现为 ByteArrayInputStream/ByteArrayOutputStream。</p><p><strong>Reading and writing（读与写）</strong></p><p>Kryo有三组读写对象的方法：</p><p>1.如果不知道对象的具体类，且对象可以为null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kryo.writeClassAndObject(output, object);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Object object = kryo.readClassAndObject(input);</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> SomeClass) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果类已知且对象可以为null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kryo.writeObjectOrNull(output, someObject);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">SomeClass someObject = kryo.readObjectOrNull(input, SomeClass.class);</span><br></pre></td></tr></table></figure><p><strong>3.如果类已知且对象不能为null:（项目中使用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kryo.writeObject(output, someObject);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">SomeClass someObject = kryo.readObject(input, SomeClass.class);</span><br></pre></td></tr></table></figure><p><strong>Register（注册）与References（引用）</strong></p><p>当Kryo写出一个对象的实例时，首先可能需要写出一些标识对象类的东西。默认情况下，写入完整类名，然后写入该对象的字节。后续出现的同一类对象图的对象用变长的int来写（using a variable length int）。写类的名字有点低效，所以类可以事先注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">kryo.register(SomeClass.class);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Output output = ...</span><br><span class="line">SomeClass someObject = ...</span><br><span class="line">kryo.writeObject(output, someObject);</span><br></pre></td></tr></table></figure><p>这里，SomeClass 注册到了 Kryo，它将该类与一个 int 型的 ID 相关联。当 Kryo 写出 SomeClass 的一个实例时，它会写出这个 int  ID。这比写出类名更有效。在反序列化期间，注册的类必须具有序列化期间相同的 ID 。上面展示的注册方法分配下一个可用的最小整数  ID，这意味着类被注册的顺序十分重要。注册时也可以明确指定特定 ID，这样的话注册顺序就不重要了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">kryo.register(SomeClass.class, <span class="number">10</span>);</span><br><span class="line">kryo.register(AnotherClass.class, <span class="number">11</span>);</span><br><span class="line">kryo.register(YetAnotherClass.class, <span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>两个值得注意的点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kryo.setRegistrationRequired(<span class="keyword">false</span>);<span class="comment">// 关闭注册行为</span></span><br><span class="line">kryo.setReferences(<span class="keyword">true</span>);<span class="comment">// 支持循环引用</span></span><br></pre></td></tr></table></figure><ul><li><p>Kryo 支持对注册行为，如 <strong>kryo.register(SomeClazz.class)**，这会赋予该 Class 一个从 0 开始的编号，但 Kryo 使用注册行为最大的问题在于，其不保证同一个 Class 每一次注册的号码相同，这与注册的顺序有关，也就意味着在</strong>不同的机器<strong>、</strong>同一个机器重启前后**都有可能拥有不同的编号，这会导致序列化产生问题，所以在分布式项目中，一般关闭注册行为。</p></li><li><p>还有需要注意的就是 Kryo 对循环引用的支持。References即引用，对A对象序列化时，默认情况下 Kryo会在每个成员对象第一次序列化时写入一个数字，该数字逻辑上就代表了对该成员对象的引用，如果后续有引用指向该成员对象，则直接序列化之前存入的数字即可，而不需要再次序列化对象本身。</p><p>而 “循环引用” 是指，假设有一个 JavaBean，假设是一个销售订单（SalesOrder），这个订单下面有很多子订单，比如 List<SalesOrderLine> ，而销售子订单中又有其中一个包括一个销售订单，那么这就构成了”循环引用”。Kryo 默认是支持循环引用的，当你确定不会有循环引用发生的时候，可以通过 kryo.setReferences(false); 关闭循环引用检测，从而提高一些性能。关闭后虽然序列化速度更快，但是遇到循环引用，就会报 “栈内存溢出” 错误。</SalesOrderLine></p><p>所以，我并不认为关闭它是一件好的选择，**大多数情况下，请保持 kryo.setReferences(true)**。</p></li></ul><h1 id="2-3测试"><a href="#2-3测试" class="headerlink" title="2.3测试"></a>2.3测试</h1><p><strong>替换序列化器</strong></p><p>我们只需要把 NettyServer 和 NettyClient 责任链中的 CommonEncoder 传入的参数改成 KryoSerializer 即可使用 Kryo 序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()));</span><br><span class="line"><span class="comment">//将序列化器变成 KryoSerializer</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> KryoSerializer()));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（三）RPC实现Netty网络通信</title>
    <link href="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    <id>http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</id>
    <published>2021-05-03T12:09:43.000Z</published>
    <updated>2021-05-21T14:13:34.992Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-BIO、NIO与AIO"><a href="#1-BIO、NIO与AIO" class="headerlink" title="1.BIO、NIO与AIO"></a>1.BIO、NIO与AIO</h1><p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I/O模型在很大程度上决定了框架的性能</p><h2 id="1-1BIO模型介绍"><a href="#1-1BIO模型介绍" class="headerlink" title="1.1BIO模型介绍"></a>1.1BIO模型介绍</h2><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信。由于ServerSocket 的 accept（）方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>这种方式下有一个问题：每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作。 如下图所示：</p><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\BIO.png" style="zoom:80%;"><p><strong>问题：</strong></p><ul><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li></ul><p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p><p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p><p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p><h2 id="1-2NIO模型介绍"><a href="#1-2NIO模型介绍" class="headerlink" title="1.2NIO模型介绍"></a>1.2NIO模型介绍</h2><p>NIO基于Reactor（事件驱动思想），当socket有流可读或可写入socket时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p><p>BIO与NIO一个比较重要的不同：<strong>我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong></p><p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\NIO.png" style="zoom:80%;"><p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p><h2 id="1-3AIO模型介绍"><a href="#1-3AIO模型介绍" class="headerlink" title="1.3AIO模型介绍"></a>1.3AIO模型介绍</h2><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 </p><p>相比于NIO，AIO才是完全的异步IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p><h2 id="1-4三者比较"><a href="#1-4三者比较" class="headerlink" title="1.4三者比较"></a>1.4三者比较</h2><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p><p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p><p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>AIO：一个有效请求一个线程，[客户端]的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p><p><strong>但是由于使用同步非阻塞的I/O模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p><h1 id="2-Netty-介绍（同步非阻塞）"><a href="#2-Netty-介绍（同步非阻塞）" class="headerlink" title="2.Netty 介绍（同步非阻塞）"></a>2.Netty 介绍（同步非阻塞）</h1><ol><li>Netty 是一个<strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。 </li><li>它极大地简化并<strong>简化了 TCP 和 UDP 套接字服务器等网络编程</strong>,并且性能以及安全性等很多方面甚 至都要更好。</li><li><strong>支持多种协议</strong>如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。 </li></ol><p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p><h1 id="3-Netty-特点"><a href="#3-Netty-特点" class="headerlink" title="3.Netty 特点"></a>3.Netty 特点</h1><ul><li>统一的 API，支持多种传输类型，阻塞和非阻塞的。 </li><li>简单而强大的线程模型。 </li><li>自带编解码器解决 TCP 粘包/拆包问题。 </li><li>自带各种协议栈。 </li><li>真正的无连接数据包套接字支持。</li><li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。 </li><li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。 </li><li>社区活跃。</li><li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接 触的 Dubbo、RocketMQ </li></ul><p>等等…..</p><h1 id="4-Netty-能做什么"><a href="#4-Netty-能做什么" class="headerlink" title="4.Netty 能做什么"></a>4.Netty 能做什么</h1><p>理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。</p><p>Netty 主要用来做网络通信：</p><ol><li><strong>作为 RPC 框架的网络通信工具 ：</strong> 我们在分布式系统中，不同服务节点之间经常需要相互调用， 这个时候就需要 RPC 框架了。不同服务之间的通信是如何做的呢？可以使用 Netty 来做。比如：我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！ </li><li><strong>实现一个自己的 HTTP 服务器 ：</strong>通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个 大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。 一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请 求等等。 </li><li><strong>实现一个即时通讯系统 ：</strong> 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这 方面的开源项目还蛮多的，可以自行去 Github 找一找。 </li><li><strong>消息推送系统 ：</strong>市面上有很多消息推送系统都是基于 Netty 来做的。 </li></ol><p>等等…..</p><h1 id="5-Netty-的核心组件"><a href="#5-Netty-的核心组件" class="headerlink" title="5.Netty 的核心组件"></a>5.Netty 的核心组件</h1><h2 id="5-1Channel"><a href="#5-1Channel" class="headerlink" title="5.1Channel"></a>5.1Channel</h2><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等。还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop。</p><p>比较常用的<code>Channel</code>接口实现类是<code>NioServerSocketChannel</code>（服务端）和<code>NioSocketChannel</code>（客户端），这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 <code>API</code>，大大地降低了直接与 Socket 进行操作的复杂性。</p><h2 id="5-2EventLoop"><a href="#5-2EventLoop" class="headerlink" title="5.2EventLoop"></a>5.2EventLoop</h2><p>这么说吧！<code>EventLoop</code>（事件循环）接口可以说是 Netty 中最核心的概念了！</p><p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p><p>为了说明Channel、EventLoop、Thread、EventLoopGroup之间的关系，我们可以看下图：</p><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\eventloop.png" style="zoom:80%;"><p>上图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）。</p><p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>Boss EventloopGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>Worker EventloopGroup</code> 来处理，然后 <code>Worker EventloopGroup</code> 负责处理其 IO 相关操作。</p><p><strong>EventloopGroup 和 EventLoop 的关系：</strong></p><p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code></p><p><strong>EventLoop 和 Thread 的关系：</strong></p><p>每一个 <code>EventLoop</code> 通常内部包含一个线程，上面我们已经说了 <code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。 <code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 1 : 1 的关系，从而保证线程安全。</p><p><strong>那 Channel 和 EventLoop 的关系：</strong></p><p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p><ul><li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li><li>一个 EventLoop 可被分配至一个或多个 Channel 。</li></ul><p>当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p><h2 id="5-3ChannelFuture"><a href="#5-3ChannelFuture" class="headerlink" title="5.3ChannelFuture"></a>5.3ChannelFuture</h2><p>Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。</p><p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。（异步）</p><p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作变成同步的。</p><h2 id="5-4ChannelHandler-和-ChannelPipeline"><a href="#5-4ChannelHandler-和-ChannelPipeline" class="headerlink" title="5.4ChannelHandler 和 ChannelPipeline"></a>5.4ChannelHandler 和 ChannelPipeline</h2><p><strong>ChannelHandler</strong> </p><p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p><p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p><p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。</p><p><strong>ChannelPipeline</strong></p><p>ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p><p>我们可以在 ChannelPipeline 上通过 <code>addLast()</code> 方法添加一个或者多个 ChannelHandler ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 ChannelHandler 处理完之后就将数据交给下一个 ChannelHandler 。</p><p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <code>ChannelHandler</code> 处理消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> KryoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>ChannelPipeline的工作流程如下图所示：</p><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\ChannelPipeline.png" style="zoom:80%;"><p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p><p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 过程如下：</p><ol><li>一个 ChannelInitializer 的实现被注册到了 ServerBootStrap中</li><li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li><li>ChannelInitializer 将它自己从 ChannelPipeline 中移除</li></ol><h2 id="5-5-Bootstrap-和-ServerBootstrap（不是核心组件）"><a href="#5-5-Bootstrap-和-ServerBootstrap（不是核心组件）" class="headerlink" title="5.5 Bootstrap 和 ServerBootstrap（不是核心组件）"></a>5.5 Bootstrap 和 ServerBootstrap（不是核心组件）</h2><p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，主要作用是配置整个Netty程序，串联各个组件。具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServerBootstrap</code> 服务端的启动引导类/辅助类，具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的示例中，我们可以看出：</p><ol><li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li><li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li><li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li></ol><h1 id="6-NioEventLoopGroup-默认的构造函数会起多少线程"><a href="#6-NioEventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="6.NioEventLoopGroup 默认的构造函数会起多少线程"></a>6.NioEventLoopGroup 默认的构造函数会起多少线程</h1><p>NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的 EventLoopGroup 的实现用来处理不同传输协议。</p><p>回顾我们在上面写的服务器端的代码，服务端会创建两个线程组：</p><ol><li>bossGroup 用于接收连接</li><li>workerGroup 用于具体的处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 *<em>CPU核心数</em>2**。</p><p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p><h1 id="7-Netty-线程模型"><a href="#7-Netty-线程模型" class="headerlink" title="7.Netty 线程模型"></a>7.Netty 线程模型</h1><p>在 Netty 主要靠 <code>NioEventLoopGroup</code> 线程池来实现具体的线程模型的 。</p><p>我们实现服务端的时候，一般会初始化两个线程组：</p><ol><li><strong><code>bossGroup</code></strong> :接收连接。</li><li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li></ol><p>下面我们来详细看一下 Netty 中的线程模型吧！</p><p>1.<strong>单线程模型</strong> ：</p><p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。</p><p>对应到 Netty 代码是下面这样的</p><blockquote><p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>2.<strong>多线程模型</strong></p><p>一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p><p>对应到 Netty 代码是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;"><p><strong>3.主从多线程模型</strong></p><p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure><img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;"><h1 id="8-Netty-实现网络通信"><a href="#8-Netty-实现网络通信" class="headerlink" title="8.Netty 实现网络通信"></a>8.Netty 实现网络通信</h1><h2 id="8-1在-pom-xml-中加入-Netty-依赖"><a href="#8-1在-pom-xml-中加入-Netty-依赖" class="headerlink" title="8.1在 pom.xml 中加入 Netty 依赖"></a>8.1在 pom.xml 中加入 Netty 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;netty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-2-rpc-core-改写-Server-与-Client"><a href="#8-2-rpc-core-改写-Server-与-Client" class="headerlink" title="8.2 rpc-core 改写 Server 与 Client"></a>8.2 rpc-core 改写 Server 与 Client</h2><p>为了保证通用性，我们可以把 Server 和 Client 抽象成两个接口，分别是 RpcServer 和 RpcClient：</p><p><strong>RpcClient：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RpcServer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SocketClient 实现 RpcClient 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line">    <span class="comment">//客户端的地址和端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SocketServer 实现 RpcServer 接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一个改动，就是在 <code>DefaultServiceRegistry.java</code> 中，将包含注册信息的 serviceMap 和 registeredService 都改成了 static ，这样就能保证全局唯一的注册信息，并且在创建 RpcServer 时也就不需要传入了。==（为什么要变成静态的，跟原来的区别?）==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性serviceMap、registeredService变成静态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"><span class="comment">//变化后：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br></pre></td></tr></table></figure><h2 id="8-3-rpc-core-实现-NettyServer"><a href="#8-3-rpc-core-实现-NettyServer" class="headerlink" title="8.3 rpc-core 实现 NettyServer"></a>8.3 rpc-core 实现 NettyServer</h2><p>1.首先创建了两个 <code>NioEventLoopGroup</code> 对象实例：<code>bossGroup</code> 和 <code>workerGroup</code>。</p><ul><li><code>bossGroup</code> : 用于处理客户端的 TCP 连接请求。</li><li><code>workerGroup</code> ： 负责每一条连接的具体读写数据的处理逻辑，真正负责 I/O 读写操作，交由对应的 Handler 处理。</li></ul><p>举个例子：我们把公司的老板当做 bossGroup，员工当做 workerGroup，bossGroup 在外面接完活之后，扔给 workerGroup 去处理。一般情况下我们会指定 bossGroup 的 线程数为 1（并发连接量不大的时候） ，workGroup 的线程数量为 <strong>CPU 核心数 *2</strong> 。另外，根据源码来看，使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p><p>2.接下来 我们创建了一个服务端启动引导/辅助类： <code>ServerBootstrap</code>，这个类将引导我们进行服务端的启动工作。</p><p>3.通过 <code>.group()</code> 方法给引导类 <code>ServerBootstrap</code> 配置两大线程组，确定了线程模型，这里我们使用的是多线程模型。</p><p>4.通过<code>channel()</code>方法给引导类 <code>ServerBootstrap</code>指定了 IO 模型为<code>NIO</code></p><ul><li><code>NioServerSocketChannel</code> ：指定服务端的 IO 模型为 NIO，与 BIO 编程模型中的<code>ServerSocket</code>对应</li><li><code>NioSocketChannel</code> : 指定客户端的 IO 模型为 NIO， 与 BIO 编程模型中的<code>Socket</code>对应</li></ul><p>5.通过调用<code>.childHandler()</code>方法给引导类创建一个<code>ChannelInitializer</code> ，然后指定了服务端消息的业务处理逻辑 <code>HelloServerHandler</code> 对象</p><p>Netty 中有一个很重要的设计模式——<strong>责任链模式</strong>，责任链上有多个处理器，每个处理器都会对数据进行加工，并将处理后的数据传给下一个处理器。代码中的 CommonEncoder、CommonDecoder和NettyServerHandler 分别就是编码器，解码器和数据处理器。因为数据从外部传入时需要解码，而传出时需要编码，类似计算机网络的分层模型，每一层向下层传递数据时都要加上该层的信息，而向上层传递时则需要对本层信息进行解码。</p><p>6.调用 <code>ServerBootstrap</code> 类的 <code>bind()</code>方法绑定端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程组：bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//3.给引导类配置两大线程组,确定了线程模型（多线程模型）</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">//option()是提供给NioServerSocketChannel用来接收进来的连接</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 6.绑定端口,调用 sync 方法阻塞直到绑定完成</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-rpc-core-实现-NettyClient"><a href="#8-4-rpc-core-实现-NettyClient" class="headerlink" title="8.4 rpc-core 实现 NettyClient"></a>8.4 rpc-core 实现 NettyClient</h2><p>客户端的创建流程：</p><p>1.创建一个 <code>NioEventLoopGroup</code> 对象实例</p><p>2.创建客户端启动的引导类是 <code>Bootstrap</code></p><p>3.通过 <code>.group()</code> 方法给引导类 <code>Bootstrap</code> 配置一个线程组</p><p>4.通过<code>channel()</code>方法给引导类 <code>Bootstrap</code>指定了 IO 模型为<code>NIO</code></p><p>5.通过 <code>.childHandler()</code>给引导类创建一个<code>ChannelInitializer</code> ，然后指定了客户端消息的业务处理逻辑 <code>HelloClientHandler</code> 对象</p><p>6.调用 <code>Bootstrap</code> 类的 <code>connect()</code>方法进行连接，这个方法需要指定两个参数：</p><ul><li><code>inetHost</code> : ip 地址</li><li><code>inetPort</code> : 端口号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(remoteAddress, <span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.validate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doResolveAndConnect(remoteAddress, <span class="keyword">this</span>.config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>connect</code> 方法返回的是一个 <code>Future</code> 类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功，进而打印出连接信息。具体做法很简单，只需要对代码进行以下改动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个 NioEventLoopGroup 对象实例</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//3.指定线程组</span></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">// 5.这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()))</span><br><span class="line">                                .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6.尝试建立连接</span></span><br><span class="line">            ChannelFuture future = bootstrap.connect(host, port).sync();</span><br><span class="line">            logger.info(<span class="string">&quot;客户端连接到服务器 &#123;&#125;:&#123;&#125;&quot;</span>, host, port);</span><br><span class="line">            Channel channel = future.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isSuccess()) &#123;</span><br><span class="line">                        logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 7.等待连接关闭（阻塞，直到Channel关闭）</span></span><br><span class="line">                channel.closeFuture().sync();</span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">                RpcResponse rpcResponse = channel.attr(key).get();</span><br><span class="line">                <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态代码块中就直接配置好了 Netty 客户端，等待发送数据时启动，channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 AttributeKey 的方式阻塞获得返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">RpcResponse rpcResponse = channel.attr(key).get();</span><br></pre></td></tr></table></figure><p>通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 NettyClientHandler 中看到放入的过程。</p><h2 id="8-5-rpc-core-自定义传输协议和编码、解码器"><a href="#8-5-rpc-core-自定义传输协议和编码、解码器" class="headerlink" title="8.5 rpc-core 自定义传输协议和编码、解码器"></a>8.5 rpc-core 自定义传输协议和编码、解码器</h2><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。</p><p>我们定义的协议是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><strong>魔数（4 bytes）：</strong>魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li><li><strong>Package Type（4 bytes）：</strong>标明这是一个调用请求还是调用响应</li><li><strong>Serializer Type（4 bytes）：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化 方式。</li><li><strong>Data Length（4 bytes）：</strong>实际数据的长度，设置这个字段主要防止<strong>粘包</strong></li><li><strong>Data（Length: ${Data Length} ）：</strong>经过序列化后的实际数据，可能是 RpcRequest 也可能是 RpcResponse 经过序列化后的字节，取决于 Package Type。</li></ul><h2 id="8-6-rpc-core-编码器"><a href="#8-6-rpc-core-编码器" class="headerlink" title="8.6 rpc-core 编码器"></a>8.6 rpc-core 编码器</h2><p>CommonEncoder 继承了MessageToByteEncoder 类，见名知义，就是把 Message（实际要发送的对象）转化成 Byte 数组。CommonEncoder 的工作很简单，就是把 RpcRequest 或者 RpcResponse 包装成协议包。 根据上面提到的协议格式，将各个字段写到管道里就可以了，这里 serializer.getCode() 获取序列化器的编号，之后使用传入的序列化器将请求或响应包序列化为字节数组写入管道即可。</p><p><strong>CommonEncoder 编码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-7-rpc-core-解码器"><a href="#8-7-rpc-core-解码器" class="headerlink" title="8.7 rpc-core 解码器"></a>8.7 rpc-core 解码器</h2><p>CommonDecoder 继承自 ReplayingDecoder ，与 MessageToByteEncoder 相反，它用于将收到的字节序列还原为实际对象。主要就是一些字段的校验，比较重要的就是取出序列化器的编号，以获得正确的反序列化方式，并且读入 length 字段来确定数据包的长度（防止粘包），最后读入正确大小的字节数组，反序列化成对应的对象。</p><p><strong>CommonDecoder 解码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-8-rpc-core-序列化接口"><a href="#8-8-rpc-core-序列化接口" class="headerlink" title="8.8 rpc-core 序列化接口"></a>8.8 rpc-core 序列化接口</h2><p>序列化器接口（<code>CommonSerializer</code>）如下：</p><p>主要就是四个方法，序列化，反序列化，获得该序列化器的编号，已经根据编号获取序列化器，这里我已经写了一个示例的 JSON 序列化器，Kryo 序列化器会在后面讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON 的序列化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsBytes(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">                obj = handleRequest(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型</span></span><br><span class="line"><span class="comment">        需要重新判断处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handleRequest</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将要反序列化的对象obj传入</span></span><br><span class="line">        RpcRequest rpcRequest = (RpcRequest) obj;</span><br><span class="line">        <span class="comment">//遍历参数的类型数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">            <span class="comment">//获取参数的类信息</span></span><br><span class="line">            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">            <span class="comment">//isAssignableFrom判断参数类型和反序列化后的参数类型是否匹配（不匹配说明反序列化有问题）</span></span><br><span class="line">            <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">                <span class="comment">//把rpcRequest.getParameters()[i]转成json序列，并把结果输出成字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">                <span class="comment">//将不正确的参数，转换成 clazz 类的 Java 类型</span></span><br><span class="line">                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;JSON&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON 序列化工具我使用的是 Jackson，在 pom.xml 中添加依赖即可。序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。</p><p>上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的类型信息。</p><blockquote><p>注：isAssignableFrom方法</p><p>有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a），以及方法中作为参数的这个类对象（称之为对象b），这两个对象如果满足以下条件则返回true，否则返回false：</p><ul><li>a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口</li><li>a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口</li></ul></blockquote><blockquote><p>注：ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</p><p><strong>序列化：</strong>ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</p><ul><li>writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</li><li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</li><li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</li><li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</li></ul><p><strong>反序列化：</strong></p><ul><li><p>readValue() 方法：将 json 数据源转换成指定格式的 Java 类型</p><p>第一个参数是JSON数据源(字符串, 流或者文件), 第二个参数是解析目标Java类</p></li></ul></blockquote><h2 id="8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler"><a href="#8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler" class="headerlink" title="8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler"></a>8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler</h2><p>NettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。</p><p><strong>NettyServerhandler</strong> 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            String interfaceName = msg.getInterfaceName();</span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            Object result = requestHandler.handle(msg, service);</span><br><span class="line">            ChannelFuture future = ctx.writeAndFlush(RpcResponse.success(result));</span><br><span class="line">            future.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyClientHandler</strong> 用于接收 RpcResponse</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">            ctx.channel().attr(key).set(msg);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-10-修改代理类-RpcClientProxy"><a href="#8-10-修改代理类-RpcClientProxy" class="headerlink" title="8.10 修改代理类 RpcClientProxy"></a>8.10 修改代理类 RpcClientProxy</h2><p>RpcClientProxy 通过传入不同的 Client（SocketClient、NettyClient）来切换客户端不同的发送方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line"></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes());</span><br><span class="line">        <span class="keyword">return</span> client.sendRequest(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-11测试"><a href="#8-11测试" class="headerlink" title="8.11测试"></a>8.11测试</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>SocketTestClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyTestClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><strong>SocketTestServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        SocketServer socketServer = <span class="keyword">new</span> SocketServer(serviceRegistry);</span><br><span class="line">        socketServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NettyTestServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry registry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        registry.register(helloService);</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer();</span><br><span class="line">        server.start(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（二）RPC实现注册多个服务</title>
    <link href="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%BA%8C%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1/"/>
    <id>http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%BA%8C%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-05-03T08:10:30.000Z</published>
    <updated>2021-05-13T14:54:09.213Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-rpc-core-服务注册表"><a href="#1-rpc-core-服务注册表" class="headerlink" title="1. rpc-core 服务注册表"></a>1. rpc-core 服务注册表</h1><p>上一节中，我们使用 JDK 序列化和 Socket 实现了一个最基本的 RPC 框架，当服务端测试时，在注册完 <code>helloService</code> 后，服务器就自行启动了，也就是说，一个服务器只能注册一个服务，这种设计大大降低了服务端的作用。</p><p>我们要实现服务端可以注册多个服务，就要实现服务注册和服务端启动的解耦。</p><p>创建一个 ServiceRegistry 接口，这个接口具有两个功能：</p><ul><li>将一个服务注册进注册表</li><li>根据服务名称获取服务实体</li></ul><p>其实就是充当一个容器，这个容器很简单，就是保存一些本地服务的信息，并且在获得一个服务名字的时候能够返回这个服务的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个服务注册进注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 服务实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称获取服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类：<code>DefaultServiceRegistry</code></p><blockquote><p>注：<code>getCanonicalName()</code>返回 Java 语言规范定义的底层类的规范名称，可以理解为返回的是正常的包含路径的类名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DefaultServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务名与提供服务的对象的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存当前有哪些对象已经被注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务的注册功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务对象实现的接口的完整类名作为注册的服务名（ConcurrentHashMap中的键值）</span></span><br><span class="line">        String serviceName = service.getClass().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//当服务不存在时，注册服务</span></span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        <span class="comment">//获取该对象实现的接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将服务实现的接口的类名</span></span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务获取功能的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据服务的名称，从ConcurrentHashMap中获取服务并返回对应服务</span></span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-tset-server-注册与启动解耦"><a href="#2-tset-server-注册与启动解耦" class="headerlink" title="2.tset-server 注册与启动解耦"></a>2.tset-server 注册与启动解耦</h1><p>上一章中我们的 RPCServer 代码逻辑为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器正在启动...&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接！Ip为：&quot;</span> + socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就使得，我们在注册一个服务时，会同时启动服务端，也就导致了一个服务器只能提供一个服务。</p><p>为了<strong>降低服务的注册和服务器启动的耦合度</strong>，我们不会把 ServiceRegistry 和某一个 RpcServer 绑定在一起，而是在创建 RpcServer 对象时，传入一个 ServiceRegistry 作为这个服务的注册表（ServiceRegistry 是已经注册好服务的）。</p><p>那么 RpcServer 这个类现在就变成了这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在创建 RpcServer 时需要传入一个已经注册好服务的 ServiceRegistry，而原来的 register 方法也被改成了 start 方法，因为服务的注册已经不由 RpcServer 处理了，它只需要启动就行了。</p><p>而在每一个请求处理线程（RequestHandlerThread）中也就需要传入 ServiceRegistry 了，这里把处理线程和处理逻辑分成了两个类：RequestHandlerThread 只是一个线程，从ServiceRegistry 获取到提供服务的对象后，就会把 RpcRequest 和服务对象直接交给 RequestHandler 去处理，反射等过程被放到了 RequestHandler 里。</p><p><strong>RequesthandlerThread类：</strong>处理线程，接受对象等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandlerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandlerThread</span><span class="params">(Socket socket, RequestHandler requestHandler, ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">            <span class="comment">//从输入流中获取rpcRequest请求的信息</span></span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            <span class="comment">//从rpcRequest中提取需要调用的接口名称</span></span><br><span class="line">            String interfaceName = rpcRequest.getInterfaceName();</span><br><span class="line">            <span class="comment">//根据接口名称从服务注册表中获取服务</span></span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            <span class="comment">//调用requestHandler来处理服务</span></span><br><span class="line">            Object result = requestHandler.handle(rpcRequest, service);</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(result));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RequestHandler：</strong>通过反射进行方法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过封装的invokeTargetMethod方法获取返回值</span></span><br><span class="line">            result = invokeTargetMethod(rpcRequest, service);</span><br><span class="line">            logger.info(<span class="string">&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke通过函数名反射调用相应的函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Method method;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><h2 id="3-1服务器端"><a href="#3-1服务器端" class="headerlink" title="3.1服务器端"></a>3.1服务器端</h2><p>实现了注册服务与服务器启动的解耦，一个服务器可以注册多个服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向注册表中注册服务</span></span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        <span class="comment">//将注册表放入服务器中</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer(serviceRegistry);</span><br><span class="line">        <span class="comment">//启动服务器</span></span><br><span class="line">        rpcServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2客户端"><a href="#3-2客户端" class="headerlink" title="3.2客户端"></a>3.2客户端</h2><p>没有变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（一）RPC的介绍及初步实现</title>
    <link href="http://wangjin1996219.github.io/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://wangjin1996219.github.io/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-01T14:30:32.000Z</published>
    <updated>2021-05-21T14:14:31.337Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p><strong>该项目文章引用自声哥和 Guide 哥！（我只是个搬运工！）</strong></p></blockquote><h1 id="1-RPC介绍"><a href="#1-RPC介绍" class="headerlink" title="1.RPC介绍"></a>1.RPC介绍</h1><h2 id="1-1什么是RPC"><a href="#1-1什么是RPC" class="headerlink" title="1.1什么是RPC"></a>1.1什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：<strong>客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样</strong>。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。那么我们至少从这样的描述中挖掘出几个要点：</p><ol><li><strong>RPC是协议：</strong>既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。这里要说明一下，目前技术的发展趋势来看，实现了RPC协议的应用工具往往都会附加其他重要功能，例如Dubbo还包括了服务治等功能。</li><li><strong>网络协议和网络IO模型对其透明：</strong>既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。</li><li><strong>信息格式对其透明：</strong>我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li><li><strong>应该有跨语言能力：</strong>为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li></ol><h2 id="1-2RPC的原理"><a href="#1-2RPC的原理" class="headerlink" title="1.2RPC的原理"></a>1.2RPC的原理</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC1.png" style="zoom:90%;"><p><strong>一次完整的RPC调用流程（同步调用，异步另说）如下：</strong></p><p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p><p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p><p><strong>RPC实现的基本流程：</strong></p><p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p><h1 id="2-常见的RPC框架"><a href="#2-常见的RPC框架" class="headerlink" title="2.常见的RPC框架"></a>2.常见的RPC框架</h1><h1 id="3-Socket-网络通信基础"><a href="#3-Socket-网络通信基础" class="headerlink" title="3. Socket 网络通信基础"></a>3. Socket 网络通信基础</h1><h2 id="3-1-Socket-套接字-介绍"><a href="#3-1-Socket-套接字-介绍" class="headerlink" title="3.1 Socket(套接字)介绍"></a>3.1 Socket(套接字)介绍</h2><p>Socket是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操 作套接字的时候，和我们读写文件很像。套接字是IP地址与端口的组合，套接字 Socket=（IP地址：端口号）。</p><p>要通过互联网进行通信，至少需要一对套接字： </p><ol><li><p>运行于服务器端的Server Socket </p></li><li><p>运行于客户机端的Client Socket 在Java 开发中使用Socket 时会常用到两个类，都在 java.net 包中：</p><p>Socket : 一般用于客户端 </p><p>Server Socket : 用于服务端</p></li></ol><h2 id="3-2-Socket-网络通信过程"><a href="#3-2-Socket-网络通信过程" class="headerlink" title="3.2 Socket 网络通信过程"></a>3.2 Socket 网络通信过程</h2><ol><li><p>建立服务端并且监听客户端请求 </p></li><li><p>客户端请求，服务端和客户端建立连接 </p></li><li><p>两端之间可以传递数据</p></li><li><p>关闭资源 </p></li></ol><p>对应到服务端和客户端的话，是下面这样的。 </p><p><strong>服务器端：</strong></p><ol><li><p>创建 ServerSocket 对象并且绑定地址（ip）和端口号(port)： server.bind(new InetSocketAddress(host, port))</p></li><li><p>通过 <strong>accept()</strong> 方法监听客户端请求 </p><p>ServerSocket 的 <strong>accept（）方法是阻塞方法</strong>，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发 送的连接请求才会继续往下执行代码。</p></li><li><p>连接建立后，通过输入流读取客户端发送的请求信息 </p></li><li><p>通过输出流向客户端发送响应信息 </p></li><li><p>关闭相关资源 </p></li></ol><p><strong>客户端：</strong></p><ol><li>创建 Socket 对象并且连接指定的服务器的地址（ip）和端口号(port)： socket.connect(inetSocketAddress) </li><li>连接建立后，通过输出流向服务器端发送请求信息 </li><li>通过输入流获取服务器响应的信息 </li><li>关闭相关资源</li></ol><h1 id="4-静态代理与动态代理-JDK-CGLIB"><a href="#4-静态代理与动态代理-JDK-CGLIB" class="headerlink" title="4.静态代理与动态代理(JDK/CGLIB)"></a>4.静态代理与动态代理(JDK/CGLIB)</h1><h1 id="5-RPC框架的设计"><a href="#5-RPC框架的设计" class="headerlink" title="5.RPC框架的设计"></a>5.RPC框架的设计</h1><h2 id="5-1简单的RPC框架"><a href="#5-1简单的RPC框架" class="headerlink" title="5.1简单的RPC框架"></a>5.1简单的RPC框架</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC2.png" style="zoom:110%;"><p><strong>一个最简单的RPC框架的实现流程：（消费者client和生产者server）</strong></p><p>Server 向注册中心注册服务，Client 能够从注册中心获取服务相关的信息，然后再通过网络请求服务提供端 Server（打 call 的过程）</p><h2 id="5-2完整的RPC框架"><a href="#5-2完整的RPC框架" class="headerlink" title="5.2完整的RPC框架"></a>5.2完整的RPC框架</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC3.png" style="zoom:90%;"><p>可以注意到，完成的RPC框架的实现需要以下几部分功能：</p><ol><li><p><strong>服务注册中心</strong></p><p>在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服务。这样客户端在发起 RPC 时，就可以直接去向注册中心请求服务提供者的信息，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现负载均衡。</p><p>常见的注册中心有 Eureka、Zookeeper 和 Nacos。</p><p>注册中心负责服务地址的注册与查找，相当于目录服务。 服务端启动的时候将服务名称及其对应的**地址(ip+port)**注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之 后，服务消费端就可以通过网络请求服务端了。</p></li></ol><ol start="2"><li><p><strong>网络传输</strong></p><p>我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端</p><p>网络传输的具体实现：</p><ul><li><p>使用 Socket ： Java 中最原始、最基础的网络通信方式。但是，<strong>Socket 是 阻塞 IO、性能低并且功能单一</strong>。</p></li><li><p>使用同步非阻塞的 I/O 模型 NIO ，但是用它来进行网络编程真的太麻烦了。可以使用基于 NIO 的网络编程框架 <strong>Netty</strong>。</p></li></ul></li><li><p><strong>序列化与反序列化</strong></p><p>要在网络传输数据就要涉及到序列化。</p><p>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够 让 Java 对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标 Java 对 象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次反序 列化。 </p><p>另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要 用到序列化和反序列化。</p><p><strong>实现序列化与反序列化的方式：</strong></p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code> 接口即可，不过这种方式不推荐，因为不支 持跨语言调用并且性能比较差。 </p><p>现在比较常用序列化的有</p><ul><li><p>hessian</p></li><li><p><strong>kyro</strong></p></li><li><p>protostuff</p></li></ul></li><li><p><strong>动态代理</strong></p><p>RPC 的主要目的就是让我们调用远程方法像调用本地方法一 样简单，我们<strong>不需要关心远程方法调用的细节</strong>比如网络传输。</p><p><strong>怎样才能屏蔽程方法调用的底层细节呢？</strong></p><p>就是动态代理。简单来说，当你调用远程方法的时候，<strong>实际会通过代理对象来传输网络请求</strong>。</p></li><li><p><strong>负载均衡</strong></p><p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当 客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务 器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就 不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。</p></li><li><p><strong>传输协议</strong></p><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方） 交流的基础。 </p><p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。</strong>这有一点像密文传输的感觉。</p><p>通常一些标准的 RPC 协议包含下面这些内容：</p><ul><li><p><strong>魔数 ：</strong> 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后， 服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协 议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </p></li><li><p><strong>序列化器编号 ：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化 方式。</p></li><li><p><strong>消息体长度 ：</strong>运行时计算出来。</p></li></ul><p>等…….</p></li></ol><h1 id="6-初步实现RPC"><a href="#6-初步实现RPC" class="headerlink" title="6.初步实现RPC"></a>6.初步实现RPC</h1><h2 id="6-1-rpc-api-包下创建通用接口"><a href="#6-1-rpc-api-包下创建通用接口" class="headerlink" title="6.1 rpc-api 包下创建通用接口"></a>6.1 rpc-api 包下创建通用接口</h2><p>在 rpc-api 包下创建通用接口，也就是<strong>服务端与客户端的公共调用接口</strong></p><blockquote><p><strong>接口HelloService</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.wangjin.rpc.api;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello方法需要传递一个对象，HelloObject对象，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//这个对象需要实现Serializable接口，因为它需要在调用过程中从客户端传递给服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象需要实现<code>Serializable</code>接口，因为它需要在调用过程中从客户端传递给服务端。</p><blockquote><p>注：</p><p>@Data 注解作用是自动生成get和set方法</p><p>@AllArgsConstructor 使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p><p>@NoArgsConstructor 使用后创建一个无参构造函数</p></blockquote><h2 id="6-2-test-server-包下实现通用接口"><a href="#6-2-test-server-包下实现通用接口" class="headerlink" title="6.2 test-server 包下实现通用接口"></a>6.2 test-server 包下实现通用接口</h2><p>接着我们在服务端对这个接口进行实现，实现的方式也很简单，返回一个字符串就行：</p><blockquote><p><strong>HelloServiceImpl 实现类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建日志对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到：&#123;&#125;&quot;</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是调用的返回值，id=&quot;</span> + object.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-rpc-common-包下定义传输协议"><a href="#6-3-rpc-common-包下定义传输协议" class="headerlink" title="6.3 rpc-common 包下定义传输协议"></a>6.3 rpc-common 包下定义传输协议</h2><p>当我们想要调用服务端的某个接口的方法时，为了让服务端唯一确定需要调用的接口的方法。我们将请求封装成实体类 <strong>RpcRequest</strong> ，然后到服务端解析，找到对应的接口中的方法，传入相应的参数。</p><blockquote><p><strong>RpcRequest 实体类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是心跳包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean heartBeat;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>@Builder标签的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦</p><p>在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数</p></blockquote><p>那么服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一个       **RpcResponse **对象：</p><blockquote><p><strong>RpcResponse 实体类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应对应的请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RpcResponse 实体类中包含两个静态的方法：</p><p>一个用于请求成功处理时，返回的 RpcResponse 对象</p><p>一个用于请求处理失败时，返回的 RpcResponse 对象</p><p>ResponseCode 枚举类，用于初始化 RpcResponse 对象中的 statusCode 和 message 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;调用方法成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">&quot;调用方法失败&quot;</span>),</span><br><span class="line">    METHOD_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定方法&quot;</span>),</span><br><span class="line">    CLASS_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定类&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-rpc-core-包"><a href="#6-4-rpc-core-包" class="headerlink" title="6.4 rpc-core 包"></a>6.4 rpc-core 包</h2><h3 id="6-4-1动态代理实现客户端"><a href="#6-4-1动态代理实现客户端" class="headerlink" title="6.4.1动态代理实现客户端"></a>6.4.1动态代理实现客户端</h3><p>客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且调用方法时生成需要的RpcRequest对象并且发送给服务端。</p><p>采用JDK动态代理，代理类是需要实现<code>InvocationHandler</code>接口的。</p><p>需要传递host和port来指明服务端的位置。并且使用getProxy()方法来生成代理对象。</p><p><code>InvocationHandler</code>接口需要实现invoke()方法，来指明代理对象的方法被调用时的动作。在这里，我们显然就需要生成一个RpcRequest对象，发送出去，然后返回从服务端接收到的结果即可：</p><blockquote><p><strong>RpcClientProxy 类</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .build();</span><br><span class="line">        RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">        <span class="keyword">return</span> ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, port)).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>@SuppressWarnings(“unchecked”)<br>告诉编译器<strong>忽略 unchecked 警告信息</strong>，如使用List，ArrayList等未进行参数化产生的警告信息。</p></blockquote><p>发送的逻辑使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去，并且接受返回的对象。</p><p>代码实现逻辑很简单，直接使用Java的序列化方式，通过Socket传输。创建一个Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即可，接收时获取ObjectInputStream对象，readObject()方法就可以获得一个返回的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-2服务端的实现"><a href="#6-4-2服务端的实现" class="headerlink" title="6.4.2服务端的实现"></a>6.4.2服务端的实现</h3><p>使用一个ServerSocket通过accep() 方法监听客户端请求，如果发来了请求就创建一个线程，在新线程中处理调用（这里创建线程采用线程池）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用一个ServerSocket通过accep() 方法监听客户端请求，如果发来了请求就创建一个线程，在新线程中处理调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器正在启动...&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接！Ip为：&quot;</span> + socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程的所进行的处理如下所示：将客户端传入的请求解析，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WorkerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> Object service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket, Object service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            Object returnObject = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(returnObject));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5测试"><a href="#6-5测试" class="headerlink" title="6.5测试"></a>6.5测试</h2><h3 id="6-5-1服务器端"><a href="#6-5-1服务器端" class="headerlink" title="6.5.1服务器端"></a>6.5.1服务器端</h3><p>服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注入HelloServiceImpl实例</span></span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        rpcServer.register(helloService, <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-2客户端"><a href="#6-5-2客户端" class="headerlink" title="6.5.2客户端"></a>6.5.2客户端</h3><p>客户端方面，我们需要通过动态代理，生成代理对象，并且调用，动态代理会自动帮我们向服务端发送请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="RPC项目" scheme="http://wangjin1996219.github.io/tags/RPC%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://wangjin1996219.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://wangjin1996219.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-04-26T14:15:54.000Z</published>
    <updated>2021-04-28T07:30:06.329Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-各种树"><a href="#1-各种树" class="headerlink" title="1.各种树"></a>1.各种树</h1><h2 id="1-1完全二叉树"><a href="#1-1完全二叉树" class="headerlink" title="1.1完全二叉树"></a>1.1完全二叉树</h2><p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p><h2 id="1-2满二叉树"><a href="#1-2满二叉树" class="headerlink" title="1.2满二叉树"></a>1.2满二叉树</h2><p>除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p><h2 id="1-3堆（实质是由二叉树实现的）"><a href="#1-3堆（实质是由二叉树实现的）" class="headerlink" title="1.3堆（实质是由二叉树实现的）"></a>1.3堆（实质是由二叉树实现的）</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h2 id="1-4平衡二叉树"><a href="#1-4平衡二叉树" class="headerlink" title="1.4平衡二叉树"></a>1.4平衡二叉树</h2><p>任意节点的子树的高度差都小于等于1。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。</p><h2 id="1-5二叉查找树（BST）"><a href="#1-5二叉查找树（BST）" class="headerlink" title="1.5二叉查找树（BST）"></a>1.5二叉查找树（BST）</h2><p>二叉查找树的性质：</p><ol><li>左子树上所有结点的值均小于或等于它的根结点的值。 </li><li>右子树上所有结点的值均大于或等于它的根结点的值。</li><li>左、右子树也分别为二叉排序树。</li></ol><p>二叉查找树的优点：这种方式正是二分查找的思想，查找所需的最大次数等同于二叉查找树的高度</p><p>二叉查找树的缺点：当先后插入的关键字有序时，BST退化成单支树结构，查找的性能会打折扣，几乎成为了线性。（因为新插入的节点不需要改变原有树的组织结构）</p><h2 id="1-6红黑树"><a href="#1-6红黑树" class="headerlink" title="1.6红黑树"></a>1.6红黑树</h2><p>红黑树为了解决这个缺陷，应运而生。</p><p>红黑树是一种自平衡的二叉查找树。除了符合二叉查找树的基本特性外，它还具有下列的附加特性：</p><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）</li><li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节）</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol><p>由于这些规则限制，才保证了红黑树的自平衡性，红黑树从根到叶子节点的最长路径不会超过最短路径的2倍。</p><p>当插入或者删除节点时，红黑树的规则就有可能被打破，这时候就需要做出一些调整（<strong>变色，左旋、右旋</strong>），来继续维持我们的规则，也就是保证了自平衡性。</p><p>下图中这棵树，就是一颗典型的红黑树：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树1.png" style="zoom:110%;"><p>向原红黑树插入值为21的新节点：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树2.png" style="zoom:110%;"><p>由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。</p><p><strong>变色：</strong>（暂时认为，当两个节点同时为红色节点，或者一条路径上黑色节点的个数与其它路径上的节点个数不同时）</p><p>为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。</p><p>下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树3.png" style="zoom:110%;"><p>但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树4.png" style="zoom:110%;"><p>此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树5.png" style="zoom:110%;"><p>此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。</p><p>变色已无法解决问题——通过<strong>左旋转</strong>进行处理：</p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树6.png" style="zoom:110%;"><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树7.png" style="zoom:110%;"><p>然后还要进行变色、右旋转、或者再进行左旋转等操作，将该红黑树变回满足要求的红黑树</p><p><strong>红黑树的应用：</strong></p><p>HashMap为了防止链表过长，查询的效率降低，当链表超过一定的长度后，将链表结构转换为红黑树。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="基础知识" scheme="http://wangjin1996219.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="数据结构" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>其它</title>
    <link href="http://wangjin1996219.github.io/2021/04/25/%E5%85%B6%E5%AE%83/"/>
    <id>http://wangjin1996219.github.io/2021/04/25/%E5%85%B6%E5%AE%83/</id>
    <published>2021-04-25T13:49:43.000Z</published>
    <updated>2021-05-06T13:36:30.666Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">主站-470. 用 Rand7() 实现 Rand10()</a></strong></p><p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。</p><p>不要使用系统的 Math.random() 方法。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>随机数的产生一定是基于等概率的，也就是说rand7方法产生（1,7）内的随机数一定是等概率的，我们可以利用这点让产生的（1,10）内的每个整数也是等概率的，一般思路如下面这样构建：</p><p>$$<br>(rand7()−1)∗7+rand7()<br>$$<br>首先 rand7()−1 得到的数的集合为 {0,1,2,3,4,5,6}</p><p>再乘 7 后得到的集合 A 为 {0，7，14，21，28，35，42}</p><p>后面 rand7() 得到的集合B为 {1,2,3,4,5,6,7}</p><p>我们得到的集合 A 和集合 B，利用这两个集合，得到的数的范围是 1～49，每个数它显然是等概率出现的，因为这两个事件是独立事件<br>$$<br>P(AB)=P(A)∗P(B)=\frac{1}{7}\ *\ \frac{1}{7}<br>$$<br>也就是说（1,49）内产生的每个数字的概率为1/49,那么我们只要范围小于10的，这时，（0,10）中每个整数产生的概率也是相等的。</p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先得到一个数</span></span><br><span class="line">        <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        <span class="comment">// 只要它还大于10，那就给我不断生成，因为我只要范围在1-10的，最后直接返回就可以了</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/palindrome-number/">主站-9. 回文数</a></strong></p><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过取整和取余操作获取整数中对应的数字进行比较。</p><p>举个例子：1221 这个数字。</p><ul><li>通过计算 1221 / 1000， 得首位1</li><li>通过计算 1221 % 10， 可得末位 1</li><li>进行比较</li><li>再将 22 取出来继续比较</li></ul><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>((x/k)&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">           k*=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> high=x/k;</span><br><span class="line">         <span class="keyword">int</span> low=x%<span class="number">10</span>;</span><br><span class="line">         <span class="keyword">if</span>(high!=low)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         x=x%k;</span><br><span class="line">         x=x/<span class="number">10</span>;</span><br><span class="line">         k/=<span class="number">100</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/reverse-integer/">主站-7. 整数反转</a></strong></p><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p></blockquote><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次取整数 x 的最后一位，拼接到 res 上</p><p>为了防止溢出，在拼接的过程中，要提前预判拼接的值是否超出了 Integer 的范围，正数最后一位是 7 ，负数最后一位是 -8</p><h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> bound=Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> bit=x%<span class="number">10</span>;</span><br><span class="line">          <span class="keyword">if</span>(res&gt;bound||res==-bound&amp;&amp;bit&gt;<span class="number">7</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(res&lt;-bound||res==-bound&amp;&amp;bit&lt;-<span class="number">8</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          res=res*<span class="number">10</span>+bit;</span><br><span class="line">          x/=<span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="其它" scheme="http://wangjin1996219.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>Spring相关</title>
    <link href="http://wangjin1996219.github.io/2021/04/23/Spring%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangjin1996219.github.io/2021/04/23/Spring%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-23T07:02:28.000Z</published>
    <updated>2021-06-01T11:44:11.842Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="Spring-IOC-amp-Spring-AOP"><a href="#Spring-IOC-amp-Spring-AOP" class="headerlink" title="Spring IOC &amp; Spring AOP"></a>Spring IOC &amp; Spring AOP</h1><p>（另一种问法是：<strong>Spring 的两大重要特性！</strong>）</p><h2 id="IOC-控制反转"><a href="#IOC-控制反转" class="headerlink" title="IOC(控制反转)"></a><strong>IOC(控制反转)</strong></h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p><strong>Spring IoC的初始化过程：</strong></p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-23-Spring相关\SpringIOC初始化过程.png" alt="Spring IoC的初始化过程" style="zoom:110%;"><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a><strong>AOP(面向切面编程)</strong></h2><p>AOP的核心思想就是：在不改变原来的代码的情况下，实现了对原有功能的增强</p><p><strong>AOP(Aspect-Oriented Programming:面向切面编程)：</strong>能够将那些与业务无关，却为<strong>业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码<strong>，</strong>降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="Spring-中的-bean-的作用域"><a href="#Spring-中的-bean-的作用域" class="headerlink" title="Spring 中的 bean 的作用域"></a>Spring 中的 bean 的作用域</h2><ul><li>singleton : 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</li><li>prototype : 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><p><strong>1.被声明为singleton的bean</strong></p><p>如果bean的作用域的属性被声明为<strong>singleton</strong>，那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。</p><p>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，singleton作用域是Spring中的缺省作用域。</p><p>可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A bean definition with singleton scope --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.被声明为prototype的bean</strong></p><p>当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。<strong>prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。</strong>根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p><p><strong>3.请求作用域</strong></p><p>请求作用域参考如下的Bean定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.LoginAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。 </p><p>当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p><p><strong>4.会话作用域</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。</p><p>Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p><p>==<strong>5.全局作用域（待定）</strong>==</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AppPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处：</p><ol><li><p>application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。</p></li><li><p>application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。</p></li></ol><h2 id="Spring-中的-bean-的生命周期"><a href="#Spring-中的-bean-的生命周期" class="headerlink" title="Spring 中的 bean 的生命周期"></a>Spring 中的 bean 的生命周期</h2><blockquote><p>在IoC容器启动之后，并不会马上就实例化相应的bean，此时容器仅仅拥有所有对象的BeanDefinition(BeanDefinition：是容器依赖某些工具加载的XML配置信息进行解析和分析，并将分析后的信息编组为相应的BeanDefinition)。只有当getBean()调用时才是有可能触发Bean实例化阶段的活动</p></blockquote><p><strong>先来看以下的图(Bean的一生)：</strong></p><p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\Bean的一生.jpg" alt="Spring Bean 生命周期"></p><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。（也就是所有对象的BeanDefinition）</li><li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p>这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。 </p><p>总之就是：Aware有很多子接口，这些接口拥有一种感知能力，把你想要的对象从spring容器中注入到你的bean中</p><p>也就是说如果两个bean的类，一个实现了BeanNameAware接口另一个没有实现时，没有实现的就获取不到自己的name属性</p><p><strong>一、先看一个最简单的一生(没有使用Bean的后置处理器)</strong></p><blockquote><p>Student.java：实现了BeanNameAware接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LinJie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:一个学生类(Bean)，能体现其生命周期的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 设置对象属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;设置对象属性setName()..&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的销毁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：销毁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：使用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写toString</span></span><br><span class="line"><span class="comment"> * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name = &quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用BeanNameAware的setBeanName()</span></span><br><span class="line"><span class="comment">//传递Bean的ID。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用BeanNameAware的setBeanName()...&quot;</span> ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//Bean的使用</span></span><br><span class="line">student.play();</span><br><span class="line">System.out.println(student);</span><br><span class="line"><span class="comment">//关闭容器</span></span><br><span class="line">((AbstractApplicationContext) context).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>applicationContext.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">&lt;!-- init-method：指定初始化的方法</span></span><br><span class="line"><span class="comment">        destroy-method：指定销毁的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initStudent&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyStudent&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LINJIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>控制台显示结果：</p></blockquote><p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\最简单的一生.png"></p><p>可以在输出结果看出bean的一生，完全与之前的一生过程图相符(除了bean后置处理器部分)，这里还需要提及的是在xml配置中的两个属性</p><ul><li>init-method：指定初始化的方法</li><li>destroy-method：指定销毁的方法</li></ul><p>说到init-method和destroy-method，当然也要提及一下在<code>&lt; beans&gt;</code>的属性</p><ul><li>default-init-method：为应用上下文中所有的Bean设置了共同的初始化方法</li><li>default-destroy-method：为应用上下文中所有的Bean设置了共同的销毁方法</li></ul><p><strong>二、加上Bean的后置处理器</strong></p><blockquote><p>bean的后置处理器，是为了<strong>对bean的一个增强</strong></p></blockquote><p><strong>用法：</strong></p><blockquote><p>分别在Bean的初始化前后对Bean对象提供自己的实例化逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 实现BeanPostProcessor接口</span><br><span class="line">- postProcessBeforeInitialization方法</span><br><span class="line">- postProcessAfterInitialization方法</span><br></pre></td></tr></table></figure><blockquote><p>Student.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 设置对象属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;设置对象属性setName()..&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的初始化方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：初始化&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的销毁方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：销毁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Bean的使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Student这个Bean：使用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写toString</span></span><br><span class="line"><span class="comment"> * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [name = &quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用BeanNameAware的setBeanName()</span></span><br><span class="line"><span class="comment">//传递Bean的ID。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;调用BeanNameAware的setBeanName()...&quot;</span> ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyBeanPostProcessor.java（实现BeanPostProcessor接口）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean的后置处理器</span></span><br><span class="line"><span class="comment"> * 分别在bean的初始化前后对bean对象提供自己的实例化逻辑</span></span><br><span class="line"><span class="comment"> * postProcessAfterInitialization：初始化之后对bean进行增强处理</span></span><br><span class="line"><span class="comment"> * postProcessBeforeInitialization：初始化之前对bean进行增强处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对初始化之后的Bean进行处理</span></span><br><span class="line"><span class="comment">//参数：bean：即将初始化的bean</span></span><br><span class="line"><span class="comment">//参数：beanname：bean的名称</span></span><br><span class="line"><span class="comment">//返回值：返回给用户的那个bean,可以修改bean也可以返回一个新的bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanname)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">Student stu = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;对初始化之后的Bean进行处理,将Bean的成员变量的值修改了&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(beanname) || bean <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">stu = (Student) bean;</span><br><span class="line">stu.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对初始化之前的Bean进行处理</span></span><br><span class="line"><span class="comment">//参数：bean：即将初始化的bean</span></span><br><span class="line"><span class="comment">//参数：beanname：bean的名称</span></span><br><span class="line"><span class="comment">//返回值：返回给用户的那个bean,可以修改bean也可以返回一个新的bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanname)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;对初始化之前的Bean进行处理,此时我的名字&quot;</span>+bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>测试类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="comment">//Bean的使用</span></span><br><span class="line">student.play();</span><br><span class="line">System.out.println(student);</span><br><span class="line"><span class="comment">//关闭容器</span></span><br><span class="line">((AbstractApplicationContext) context).close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>applicationContext.xml</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- init-method：指定初始化的方法</span></span><br><span class="line"><span class="comment">        destroy-method：指定销毁的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initStudent&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyStudent&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LINJIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置bean的后置处理器,不需要id，IoC容器自动识别是一个BeanPostProcessor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.MyBeanPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>控制台显示结果</p></blockquote><p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\有后置处理器.png"></p><p>可以在applicationContext.xml中看到配置Bean后置处理器，不需要ID，只需要其全类名，因为IoC容器自动识别一个BeanPostProcessor</p><p>在控制台显示结果可以看出,Bean的后置处理器强大之处，可以对Bean实现自己想要做的事情，比如我这里的Demo就是在postProcessAfterInitialization方法中将成员变量name偷偷修改了，最后输出的就是偷偷修改之后的值</p><h2 id="Spring-中的单例-bean-的线程安全问题"><a href="#Spring-中的单例-bean-的线程安全问题" class="headerlink" title="Spring 中的单例 bean 的线程安全问题"></a>Spring 中的单例 bean 的线程安全问题</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><p>常见的有两种解决办法：</p><ol><li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p></li><li><p>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p></li></ol><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-08-SpringMVC\SpringMVC执行流程.png" style="zoom:80%;"><h2 id="组件作用"><a href="#组件作用" class="headerlink" title="组件作用"></a>组件作用</h2><ul><li><p><strong>DispatcherServlet：</strong>前端控制器。</p><p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p><p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p></li><li><p><strong>HandlerMapping：</strong>处理器映射器</p><p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p></li><li><p><strong>HandlerExecution：</strong>具体的Handler</p><p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p></li><li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p></li><li><p><strong>HandlAdapter：</strong>处理器适配器</p><p><strong>作用1：</strong>按照特定的规则去执行Handler；</p><p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p><p><strong>注：</strong>Model表示具体的数据，View表示视图</p></li><li><p><strong>View Resolver：</strong>视图解析器</p><p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p></li><li><p><strong>View：</strong>视图</p><p><strong>作用：</strong>向用户展示结果</p></li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li><li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li><li>HandlerExecution就是具体的Controller；</li><li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li><li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li><li>HandlAdapter找到相应的Controller去执行；</li><li>Controller将执行结果返回给HandlAdapter；</li><li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li><li>dispatcherServlet调用View Resolver得到相应的页面地址；</li><li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li><li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://wangjin1996219.github.io/categories/JAVA/"/>
    
    
    <category term="Spring相关" scheme="http://wangjin1996219.github.io/tags/Spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://wangjin1996219.github.io/2021/04/22/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://wangjin1996219.github.io/2021/04/22/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-04-22T06:23:29.000Z</published>
    <updated>2021-05-06T13:36:34.120Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/add-strings/">主站-415. 字符串相加</a></strong></p><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按位相加，要注意有进位，最后还要补充处理一下进位</p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">     StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i=n,j=m;</span><br><span class="line">     <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(carry!=<span class="number">0</span>) res.append(String.valueOf(carry));</span><br><span class="line">     <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/multiply-strings/">主站-43. 字符串相乘</a></strong></p><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用字符串的nums1去乘字符串nums2的每一位，然后每次循环结束调用两个字符串相加的方法去得到新的和</p><p>（第一题就是两个字符串求和）</p><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>)||num2.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">    String res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;j++)&#123;</span><br><span class="line">            temp.append(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> bit2=num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">           <span class="keyword">int</span> bit1=(num1.charAt(k)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           <span class="keyword">int</span> produce=bit1*bit2+carry;</span><br><span class="line">           temp.append(produce%<span class="number">10</span>);</span><br><span class="line">           carry=produce/<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(carry!=<span class="number">0</span>) temp.append(carry);</span><br><span class="line">       res=addStrings(res,temp.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">     StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i=n,j=m;</span><br><span class="line">     <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(carry!=<span class="number">0</span>) res.append(String.valueOf(carry));</span><br><span class="line">     <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></strong></p><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>当我们遍历给定的字符串时，当前的字符串有下面几种可能：</p><ul><li><p><strong>空格</strong>——跳过</p></li><li><p><strong>其它字符</strong>——循环遍历结束</p></li><li><p><strong>正负号</strong>——存储到flag变量中，后面再拼接到结果中</p></li><li><p><strong>数字字符：</strong></p><p>对数字字符要进行转换和拼接工作</p><p><strong>转换：</strong>将数字字符减去字符’0’，得到数字的值</p><p><strong>拼接：</strong>前一位得到的数字应该在高位，所以拼接公式为*<em>res=res</em>10+c**</p></li></ul><p>在对数字进行拼接工作时，要<strong>预判</strong>得到的结果是不是发生了越界，之所以要进行预判是因为得到的结果可能很大，不能确定用什么样类型的变量来接收这个结果。Java中int类型的数值范围为 [−231,  231 − 1]，也就是<strong>2147483647</strong>，要在进行本轮的拼接时，判断结果是否会发生越界，也就是上一轮的结果要小于<strong>214748364</strong>或者等于<strong>214748364</strong>且本轮的数值<strong>c</strong>小于等于7，这样按照公式*<em>res=res</em>10+c**拼接时才不会发生越界，当出现越界时直接返回题目要求的结果。</p><h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bndry = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;<span class="comment">//定位第一个非空格字符</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span>(str.charAt(first)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//去除多余的空格</span></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span>(first==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>) flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>||str.charAt(first)==<span class="string">&#x27;+&#x27;</span>) first++;<span class="comment">//如果第一个非空格字符为正负号时，保存到flag，且first++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;str.length();i++)&#123;<span class="comment">//拼接数字字符</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">&#x27;0&#x27;</span>||str.charAt(i)&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//遇到非数字字符，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;bndry||(res==bndry&amp;&amp;str.charAt(i)&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;<span class="comment">//预判结果是否越界</span></span><br><span class="line">            <span class="keyword">return</span> flag==<span class="number">1</span>? Integer.MAX_VALUE : Integer.MIN_VALUE;&#125;</span><br><span class="line">        res=res*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不越界的情况下，拼接数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">主站-227. 基本计算器 II</a></strong></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>整体思路：</strong></p><p>由于乘除优先于加减计算，所以如果数字之前的符号是加减号时，将数字保存到栈中（减号要保存成负数），如果是乘除，将栈顶的元素弹出与之做乘除运算，然后再将结果保存到栈中。最后一轮循环，将所有结果相加就是最终结果。</p><p><strong>具体实现：</strong></p><p>用flag位表示前面的字符</p><p>用num表示字符串中的每个整数（整数有时不止一位）</p><p><strong>遍历字符串</strong></p><ul><li><strong>如果字符串中是数字：</strong>因为字符串中的数字可能是多位数，如果前面几位也是数字，也就是作为高位加上该位组合成整数</li><li><strong>如果字符串中不是数字，也不是空格（过滤空格），或者是倒数第一位（防止最后一个整数不能入栈）：</strong>就要判断之前的符号位是什么情况，将当前的整数相应加到栈中。结束后，因为该位置的整数已经入栈，所以将num置零，重新记录一个整数，当该位不是数字也不是空格，那就只能是符号，将flag赋值，继续作为下一个整数的符号。</li></ul><h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">char</span> flag=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+(s.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))&amp;&amp;s.charAt(i)!=<span class="string">&#x27; &#x27;</span>||i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">int</span> temp1=stack.pop();</span><br><span class="line">                    num=temp1*num;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">int</span> temp2=stack.pop();</span><br><span class="line">                    num=temp2/num;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                flag=s.charAt(i);</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res+=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数据结构篇" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>SQL编程</title>
    <link href="http://wangjin1996219.github.io/2021/04/20/SQL%E7%BC%96%E7%A8%8B/"/>
    <id>http://wangjin1996219.github.io/2021/04/20/SQL%E7%BC%96%E7%A8%8B/</id>
    <published>2021-04-20T03:12:46.000Z</published>
    <updated>2021-04-20T06:04:44.866Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="基本的查询语句"><a href="#基本的查询语句" class="headerlink" title="基本的查询语句"></a>基本的查询语句</h1><ol><li><p>查询一列：SELECT cust_id FROM customers;</p></li><li><p>查询全部列：SELECT cust_id FROM customers；</p></li><li><p>LIMIT 第一个数为开始的行数，第二个数为要检索的行数</p><ul><li>从第0行（代表第一行）开始：SELECT cust_name  FROM customers  LIMIT 5;</li><li>从第5行（实际表中的第六行）开始，显示5行：SELECT cust_name FROM customers LIMIT 5, 5;</li></ul></li><li><p>排序指令</p><ul><li>默认ASC降序：SELECT prod_name FROM products ORDER BY prod_price;</li><li>DESC升序：SELECT prod_name FROM products ORDER BY prod_price DESC;</li><li>按多个列排序 先按价格，再按名称：SELECT prod_name FROM products ORDER BY prod_price, prod_name;</li><li>DESC 降序,然后再取第0行：SELECT prod_name FROM products ORDER BY prod_price DESC LIMIT 1;</li></ul></li><li><p>WHERE 的逻辑运算符有AND ,OR, NOT,IN</p><ul><li>检索出由1003或1002供应商生成的商品：SELECT * FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10;</li></ul></li><li><p>MySQL提供了5种的聚集函数：</p><ul><li>AVG( ) 返回某列的平均值：SELECT AVG(prod_price) FROM products;</li><li>COUNT( ) 返回某列的行数</li><li>MAX( ) 返回某列的最大值</li><li>MIN( ) 返回某列的最小值</li><li>SUM( ) 返回某列值之和</li></ul></li><li><p>内链接inner join on：select * from a_table a inner join b_table bon a.a_id = b.b_id;</p></li><li><p>左连接left join on / left outer join on：select * from a_table a left join b_table bon a.a_id = b.b_id;</p></li><li><p>右连接（右外连接）right join on / right outer join on：select * from a_table a right outer join b_table b on a.a_id = b.b_id;</p></li></ol><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&tqId=29753&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找最晚入职员工的所有信息</a></strong></p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照hire_date字段降序排列</p><p>选取第一条</p><p>就是最晚入职员工</p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.* </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&tqId=29754&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey"><strong>牛客-查找入职时间排名倒数第三的员工</strong></a></p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>子查询：</p><p>通过DISTINCT指令过滤掉入职时间相同的员工</p><p>按照hire_date降序排列</p><p>通过LIMIT去掉排名倒数第一第二的时间，取倒数第三</p><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.*</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span>       <span class="comment">-- 倒序</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span>              <span class="comment">-- 去掉排名倒数第一第二的时间，取倒数第三</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&tqId=29755&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找各部门当前领导的当前薪水</a></strong></p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过inner join内连接两个表，连接的字段为两个表中的emp_no</p><p>然后按照emp_no字段默认升序排列</p><h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.emp_no,s.salary,s.from_date,s.to_date,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> salaries s <span class="keyword">inner</span> <span class="keyword">join</span> dept_manager d</span><br><span class="line"><span class="keyword">ON</span> s.emp_no=d.emp_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.emp_no;</span><br></pre></td></tr></table></figure><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/6d35b1cd593545ab985a68cd86f28671?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有已经分配部门的员工的last_name和first_name</a></strong></p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> employees e,dept_emp d</span><br><span class="line"><span class="keyword">WHERE</span> e.emp_no=d.emp_no</span><br></pre></td></tr></table></figure><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/dbfafafb2ee2482aa390645abd4463bf?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有员工的last_name和first_name以及对应部门编号dept_no</a></strong></p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为要将没有分配部门的员工也选出来</p><p>所以通过左连接，以左边的表格为基准，左边表格中没有的补NULL</p><h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.first_name,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">join</span> dept_emp d</span><br><span class="line"><span class="keyword">ON</span> e.emp_no=d.emp_no</span><br></pre></td></tr></table></figure><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/6d4a4cff1d58495182f536c548fee1ae?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</a></strong></p></blockquote><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>GROUP BY语句指示MySQL按照emp_no进行分组，这样COUNT函数在进行计算的时候就会对每个emp_no计算一次，而不是对整张表进行计算</p><p>HAVING过滤分组，HAVING的功能与WHERE很像，只不过WHERE过滤行，HAVING过滤分组，这里HAVING过滤出分组大于15的分组信息</p><h3 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="keyword">COUNT</span>(emp_no) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(emp_no)&gt;<span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/ae51e6d057c94f6d891735a48d1c2397?tpId=82&tqId=29760&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-找出所有员工当前薪水salary情况</a></strong></p></blockquote><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码及注释-6"><a href="#代码及注释-6" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/32c53d06443346f4a2f2ca733c19660c?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取所有非manager的员工emp_no</a></strong></p></blockquote><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>非manager员工，也就是员工号不在manager表中选出的工号中，所以子查询中通过not in排除</p><h3 id="代码及注释-7"><a href="#代码及注释-7" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82&tqId=29763&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取所有员工当前的manager</a></strong></p></blockquote><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>从manager表中选出的emp_no字段作为manager显示</p><p>通过内连接两个表，因为要求自己就是manager的员工不显示，所以加&lt;&gt;不等号排除</p><h3 id="代码及注释-8"><a href="#代码及注释-8" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.emp_no, ma.emp_no <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> dept_emp em <span class="keyword">inner</span> <span class="keyword">join</span> dept_manager ma</span><br><span class="line"><span class="keyword">ON</span> em.dept_no=ma.dept_no</span><br><span class="line"><span class="keyword">WHERE</span> em.emp_no &lt;&gt; ma.emp_no</span><br></pre></td></tr></table></figure><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找employees表所有emp_no为奇数，且last_name不等于Mary的员工信息</a></strong></p></blockquote><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>WHERE子查询通过AND连接题目中的两个查询条件</p><p>并且按照降序排列</p><h3 id="代码及注释-9"><a href="#代码及注释-9" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.* </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no %<span class="number">2</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> last_name!=<span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取当前薪水第二多的员工的emp_no以及其对应的薪水salary</a></strong></p></blockquote><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>将薪水降序排序</p><p>选出从1开始的第一个数，也就是薪水排名第二的员工（索引从0开始）</p><h3 id="代码及注释-10"><a href="#代码及注释-10" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no,salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找当前薪水排名第二多的员工编号emp_no</a></strong></p></blockquote><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为不能使用ORDER BY，所以考虑使用函数MAX</p><p>先通过MAX函数选出除去薪水最高的员工，再通过MAX选出的就是薪水第二高的员工信息</p><h3 id="代码及注释-11"><a href="#代码及注释-11" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_no,s.salary,e.last_name,e.first_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">inner</span> <span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">ON</span> e.emp_no=s.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> s.salary=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> salaries</span><br><span class="line">    <span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">FROM</span> salaries</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/c8652e9e5a354b879e2a244200f1eaae?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-统计出当前各个title类型对应的员工当前薪水对应的平均工资</a></strong></p></blockquote><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过emp_no字段连接两张表</p><p>通过t.title字段分组，用AVG函数对每个分组求平均值</p><p>通过s.salary字段的平均值，升序显示</p><h3 id="代码及注释-12"><a href="#代码及注释-12" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.title, <span class="keyword">AVG</span>(s.salary)</span><br><span class="line"><span class="keyword">FROM</span> titles <span class="keyword">AS</span> t <span class="keyword">join</span> salaries <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.emp_no = s.emp_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(s.salary) </span><br></pre></td></tr></table></figure><h2 id="题目十四"><a href="#题目十四" class="headerlink" title="题目十四"></a>题目十四</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/5a7975fabe1146329cee4f670c27ad55?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有员工的last_name和first_name以及对应的dept_name</a></strong></p></blockquote><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>先通过两个表的连接生成一个子表</p><p>再通过员工表与子表的左连接，选出对应的员工和部门信息</p><h3 id="代码及注释-13"><a href="#代码及注释-13" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,t.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e <span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  d.dept_name ,de.emp_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">left</span> <span class="keyword">join</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> de.dept_no = d.dept_no</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> e.emp_no= t.emp_no</span><br></pre></td></tr></table></figure><h2 id="题目十五"><a href="#题目十五" class="headerlink" title="题目十五"></a>题目十五</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/6a62b6c0a7324350a6d9959fa7c21db3?tpId=82&tqId=29774&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-统计各个部门的工资记录数</a></strong></p></blockquote><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>先通过两个表的连接生成一个子表</p><p>再按照部门名称分组，然后对每个分组的数据条数求和</p><p>输出显示</p><h3 id="代码及注释-14"><a href="#代码及注释-14" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.dept_no,d.dept_name,<span class="keyword">COUNT</span>(t.emp_no) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> d <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> de.emp_no,de.dept_no</span><br><span class="line">    <span class="keyword">FROM</span> dept_emp <span class="keyword">As</span> de <span class="keyword">join</span> salaries <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">ON</span> de.emp_no=s.emp_no</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> d.dept_no=t.dept_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> d.dept_no </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode刷题" scheme="http://wangjin1996219.github.io/categories/LeetCode%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="SQL编程" scheme="http://wangjin1996219.github.io/tags/SQL%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/"/>
    <id>http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/</id>
    <published>2021-04-16T03:26:29.000Z</published>
    <updated>2021-04-28T08:29:56.429Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-List-Set-Map三者的区别"><a href="#1-List-Set-Map三者的区别" class="headerlink" title="1.List,Set,Map三者的区别"></a>1.List,Set,Map三者的区别</h1><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h1 id="2-ArrayList与LinkedList的原理及区别"><a href="#2-ArrayList与LinkedList的原理及区别" class="headerlink" title="2.ArrayList与LinkedList的原理及区别"></a>2.ArrayList与LinkedList的原理及区别</h1><p><strong>ArrayList：</strong></p><ul><li><p><strong>原理：</strong>基于<strong>数组</strong>来实现</p></li><li><p><strong>优点：</strong>查找效率更高，内存占用更小</p></li><li><p><strong>扩容机制：</strong>ArrayList在执行插入元素是超过当前数组预定义的最大值时，数组需要扩容，扩容过程需要调用底层System.arraycopy()方法进行大量的数组复制操作。</p><p>它的扩容方式把原来的数组复制到另一个内存空间更大的数组中。</p></li><li><p><strong>ArrayList 与 Vector 区别：</strong></p><p><code>Vector</code>类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p><code>Arraylist</code>不是同步的，所以在不需要保证线程安全时建议使用Arraylist。</p></li></ul><p><strong>LinkedList：</strong></p><ul><li><strong>原理：</strong>基于<strong>双向链表</strong>实现，LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li><strong>优点：</strong>对于插入和删除操作，LinkedList优于ArrayList</li></ul><h1 id="3-HashMap、HashTable与ConccurentHashMap"><a href="#3-HashMap、HashTable与ConccurentHashMap" class="headerlink" title="3.HashMap、HashTable与ConccurentHashMap"></a>3.HashMap、HashTable与ConccurentHashMap</h1><h2 id="3-1HashMap"><a href="#3-1HashMap" class="headerlink" title="3.1HashMap"></a>3.1HashMap</h2><h3 id="3-1-1HashMap的原理"><a href="#3-1-1HashMap的原理" class="headerlink" title="3.1.1HashMap的原理"></a>3.1.1HashMap的原理</h3><p><strong>Java8之前：</strong>数组+链表（数组的查询速度快，链表的增删效率高，因此HashMap结合了两者的优势）</p><p>Hash值相同的键值对，就以链表的形式存储</p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片1.png" style="zoom:80%;"><ul><li>理想情况下，每个键位通过散列运算对应不同的值，这样查询的效率就是O(1)</li><li>当不同的键位通过散列运算总是得到相同的值，这时候就会在一个头结点后面拼接为一个很长的链表，性能就会由原来的O(1)降低为O(n)</li></ul><p>于是，<strong>Java8之后</strong>，就加入了红黑树数据结构，如下图所示：</p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片2.png" style="zoom:80%;"><p>引入一个常量TREEIFY_THRESHOLD，当链表达到一定的长度之后，就会将链表转换成红黑树，这样最坏情况就从O(n)提高到了O(logn)</p><p><strong>put方法：</strong></p><p>对Key求Hash值，如果没有碰撞直接放入数组中</p><p>如果碰撞了，就以链表的方式链接到后面</p><p>如果节点已经存在，就以新值替换旧值</p><p><strong>get方法：</strong></p><p>先对Key求Hash值找到数组的位置，再通过equals方法，在链表中找到对应的value</p><h3 id="3-1-2HashMap的扩容及问题"><a href="#3-1-2HashMap的扩容及问题" class="headerlink" title="3.1.2HashMap的扩容及问题"></a>3.1.2HashMap的扩容及问题</h3><p> <strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数组的长度乘以加载因子（默认为0.75）的值的时候，就要自动扩容啦。</p><p><strong>扩容(resize)：</strong>就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p><strong>问题：</strong></p><ul><li>多线程环境下，当几个线程中的HashMap都需要扩容时，调整大小就会存在竞争，容易造成死锁</li><li>由于需要在数组之间移动键值对，比较耗时</li></ul><h3 id="3-1-3HashMap实现线程安全"><a href="#3-1-3HashMap实现线程安全" class="headerlink" title="3.1.3HashMap实现线程安全"></a>3.1.3HashMap实现线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronizedMap方法中对public方法进行了加锁，相当于把原来的HashMap对象封装在safeHashMap对象中，再通过synchronizedMap中的公共方法对HashMap对象操作时，就是线程安全的了</span></span><br><span class="line">Map hashMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">Map safeHashMap=Collections.synchronizedMap(hashMap);</span><br></pre></td></tr></table></figure><h3 id="3-1-4Hash冲突问题"><a href="#3-1-4Hash冲突问题" class="headerlink" title="3.1.4Hash冲突问题"></a>3.1.4Hash冲突问题</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p>总结来说，就是通过 <strong>扰动函数+拉链法</strong> 来解决Hash冲突的。</p><h2 id="3-2HashTable"><a href="#3-2HashTable" class="headerlink" title="3.2HashTable"></a>3.2HashTable</h2><h3 id="HashTable线程安全的实现"><a href="#HashTable线程安全的实现" class="headerlink" title="HashTable线程安全的实现"></a>HashTable线程安全的实现</h3><p>涉及到修改HashTable的方法，使用synchronized修饰，即多个线程在调用HashTable的同步方法时是串行的方式运行，性能较差</p><p>与HashMap实现的线程安全不同的是锁定的对象不一致</p><h2 id="3-2-1ConccurentHashMap"><a href="#3-2-1ConccurentHashMap" class="headerlink" title="3.2.1ConccurentHashMap"></a>3.2.1ConccurentHashMap</h2><p>由于在多线程环境下，HashMap、HashTable都是串行执行的，因此效率比较低，ConccurentHashMap便应运而生了</p><p><strong>Java8之前：</strong></p><p>采用分段锁的方式，对底层的数组分段加锁，这样只有拿到一段子数组的锁才能对其进行操作，当一段子数组被线程A访问时，另一段子数组也能够被线程B访问，提高了效率</p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片3.png" style="zoom:80%;"><p><strong>Java8之后：</strong></p><p>通过CAS+synchronized使锁更细化，也就是说不再使用分段锁，而是对每一个头结点分别加锁，这样一来效率又有了成倍的提高</p><p>而且采用了数组+链表+红黑树的底层结构，查询效率也更高</p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片4.png" style="zoom:80%;"><p><strong>put方法：</strong></p><ul><li>首先使用无锁操作CAS插入头结点，失败则循环重试</li><li>若头结点已经存在，则尝试获取头结点的同步锁synchronized，再进行操作</li></ul><blockquote><p><strong>Synchronized</strong>：属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。</p><p><strong>CAS</strong>（Compare And Swap：比较并替换）：属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p></blockquote><h1 id="4-不同数组之间的对比"><a href="#4-不同数组之间的对比" class="headerlink" title="4.不同数组之间的对比"></a>4.不同数组之间的对比</h1><h2 id="4-1HashMap-和-Hashtable-的区别"><a href="#4-1HashMap-和-Hashtable-的区别" class="headerlink" title="4.1HashMap 和 Hashtable 的区别"></a>4.1HashMap 和 Hashtable 的区别</h2><ol><li><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p></li><li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p></li><li><p><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p></li><li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p><p> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p><p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</p></li><li><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></li></ol><h2 id="4-2HashMap-和-HashSet-的区别"><a href="#4-2HashMap-和-HashSet-的区别" class="headerlink" title="4.2HashMap 和 HashSet 的区别"></a>4.2HashMap 和 HashSet 的区别</h2><p>HashSet 底层就是基于 HashMap 实现的</p><table><thead><tr><th align="center">HashMap</th><th align="center">HashSet</th></tr></thead><tbody><tr><td align="center">实现了Map接口</td><td align="center">实现Set接口</td></tr><tr><td align="center">存储键值对</td><td align="center">仅存储对象</td></tr><tr><td align="center">调用 <code>put（）</code>向map中添加元素</td><td align="center">调用 <code>add（）</code>方法向Set中添加元素</td></tr><tr><td align="center">HashMap使用键（Key）计算Hashcode</td><td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td></tr></tbody></table><h3 id="4-2-1HashSet如何检查重复"><a href="#4-2-1HashSet如何检查重复" class="headerlink" title="4.2.1HashSet如何检查重复"></a>4.2.1HashSet如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><h2 id="4-3ConcurrentHashMap-和-Hashtable-的区别"><a href="#4-3ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="4.3ConcurrentHashMap 和 Hashtable 的区别"></a>4.3ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://wangjin1996219.github.io/categories/JAVA/"/>
    
    
    <category term="Java集合" scheme="http://wangjin1996219.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://wangjin1996219.github.io/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://wangjin1996219.github.io/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-04-16T03:24:37.000Z</published>
    <updated>2021-05-18T06:37:13.155Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1.线程与进程"></a>1.线程与进程</h1><p>同操作系统</p><h1 id="2-简述线程与进程的关系"><a href="#2-简述线程与进程的关系" class="headerlink" title="2.简述线程与进程的关系"></a>2.简述线程与进程的关系</h1><h2 id="2-1JVM的角度看线程与进程"><a href="#2-1JVM的角度看线程与进程" class="headerlink" title="2.1JVM的角度看线程与进程"></a>2.1JVM的角度看线程与进程</h2><p>JVM运行时数据区如下图所示：</p><div align="center">  <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png" width="600px"></div><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区(JDK1.8 之后的元空间)</li></ul><p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反，它的创建和切换的开销都比较大，但是资源是相互之间独立的。</p><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="Java-虚拟机栈（线程私有）"><a href="#Java-虚拟机栈（线程私有）" class="headerlink" title="Java 虚拟机栈（线程私有）"></a>Java 虚拟机栈（线程私有）</h3><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><h3 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p><h3 id="运行时常量池（属于方法区）"><a href="#运行时常量池（属于方法区）" class="headerlink" title="运行时常量池（属于方法区）"></a>运行时常量池（属于方法区）</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><img src="https://camo.githubusercontent.com/0f899d9813fbf1b8fc74724089a917ff7bdd93d60e8c4f685f0e850b51969154/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067" alt="img" style="zoom:80%;"><p><strong>为什么虚拟机栈和本地方法栈以及程序计数器是线程私有的？</strong></p><ul><li>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</li><li>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</li></ul><h1 id="3-并发与并行的区别"><a href="#3-并发与并行的区别" class="headerlink" title="3.并发与并行的区别"></a>3.并发与并行的区别</h1><ul><li><strong>并发：</strong> 同一<strong>时间段</strong>，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong> <strong>单位时间</strong>内，多个任务同时执行。</li></ul><h1 id="4-为什么要使用多线程"><a href="#4-为什么要使用多线程" class="headerlink" title="4.为什么要使用多线程"></a>4.为什么要使用多线程</h1><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li><li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><h1 id="5-使用多线程可能带来什么问题"><a href="#5-使用多线程可能带来什么问题" class="headerlink" title="5.使用多线程可能带来什么问题"></a>5.使用多线程可能带来什么问题</h1><p>并发编程不一定总是能提高程序的运行效率，并且可能会带来一些问题：</p><ul><li>内存泄漏</li><li>上下文切换（开销增大）</li><li>死锁（资源分配）</li><li>受限于硬件和软件的资源闲置问题</li></ul><h1 id="6-线程的生命周期和状态"><a href="#6-线程的生命周期和状态" class="headerlink" title="6.线程的生命周期和状态"></a>6.线程的生命周期和状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><h2 id="6-1sleep-方法和-wait-方法"><a href="#6-1sleep-方法和-wait-方法" class="headerlink" title="6.1sleep() 方法和 wait() 方法"></a>6.1sleep() 方法和 wait() 方法</h2><p><strong>两者的区别：</strong></p><ul><li>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong> </li><li>wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。（比如wait方法和条件变量结合使用唤醒一个线程，实现线程间的通信）</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。</li></ul><p><strong>两者相同点：</strong></p><ul><li>两者都可以暂停线程的执行</li></ul><h2 id="6-2start-方法和run-方法"><a href="#6-2start-方法和run-方法" class="headerlink" title="6.2start() 方法和run() 方法"></a>6.2start() 方法和run() 方法</h2><p>new 一个 Thread，线程进入了新建状态</p><ul><li><strong>调用 start() 方法：</strong>会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li><li><strong>直接执行 run() 方法：</strong>会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><p>run方法其实就是线程的方法体</p><h1 id="7-上下文切换"><a href="#7-上下文切换" class="headerlink" title="7.上下文切换"></a>7.上下文切换</h1><p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><h1 id="8-线程死锁"><a href="#8-线程死锁" class="headerlink" title="8.线程死锁"></a>8.线程死锁</h1><h2 id="8-1线程死锁条件"><a href="#8-1线程死锁条件" class="headerlink" title="8.1线程死锁条件"></a>8.1线程死锁条件</h2><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>线程死锁的发生离不开下面四个条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h2 id="8-2如何避免线程死锁"><a href="#8-2如何避免线程死锁" class="headerlink" title="8.2如何避免线程死锁"></a>8.2如何避免线程死锁</h2><p>我上面说了产生死锁的四个必要条件，为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：</p><ol><li><strong>破坏互斥条件</strong> ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><h1 id="9-synchronized-关键字"><a href="#9-synchronized-关键字" class="headerlink" title="9.synchronized 关键字"></a>9.synchronized 关键字</h1><h2 id="9-1synchronized-关键字的介绍"><a href="#9-1synchronized-关键字的介绍" class="headerlink" title="9.1synchronized 关键字的介绍"></a>9.1synchronized 关键字的介绍</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h2 id="9-2synchronized关键字最主要的三种使用方式"><a href="#9-2synchronized关键字最主要的三种使用方式" class="headerlink" title="9.2synchronized关键字最主要的三种使用方式"></a>9.2synchronized关键字最主要的三种使用方式</h2><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p>下面以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用：</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要用 volatile 关键字修饰uniqueInstance？</strong></p><p>uniqueInstance = new Singleton()——这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>由于 JVM 具有指令重排的特性，所以并不能保证这三个操作的先后顺序，执行顺序有可能变成 1-&gt;3-&gt;2。也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给uniqueInstance成员，然后再去初始化这个Singleton实例。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h2 id="9-3synchronized-关键字的底层原理"><a href="#9-3synchronized-关键字的底层原理" class="headerlink" title="9.3synchronized 关键字的底层原理"></a>9.3synchronized 关键字的底层原理</h2><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>1.synchronized 同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%86.png" alt="synchronized关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>2.synchronized 修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然获取SynchronizedDemo2类的相关字节码信息：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%8E%9F%E7%90%862.png" alt="synchronized关键字原理"></p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><h2 id="9-4-JDK1-6-之后的synchronized-关键字底层做了哪些优化"><a href="#9-4-JDK1-6-之后的synchronized-关键字底层做了哪些优化" class="headerlink" title="9.4 JDK1.6 之后的synchronized 关键字底层做了哪些优化"></a>9.4 JDK1.6 之后的synchronized 关键字底层做了哪些优化</h2><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h2 id="9-5-synchronized和ReentrantLock-的区别"><a href="#9-5-synchronized和ReentrantLock-的区别" class="headerlink" title="9.5 synchronized和ReentrantLock 的区别"></a>9.5 synchronized和ReentrantLock 的区别</h2><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择ReentrantLock是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><h1 id="10-volatile关键字"><a href="#10-volatile关键字" class="headerlink" title="10.volatile关键字"></a>10.volatile关键字</h1><h2 id="10-1Java内存模型"><a href="#10-1Java内存模型" class="headerlink" title="10.1Java内存模型"></a>10.1Java内存模型</h2><p><strong>注意：</strong>JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝</p><p>（我感觉<strong>主内存</strong>可以认为是<strong>堆</strong>，<strong>本地内存</strong>可以认为是<strong>栈</strong>）</p><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="数据不一致"></p><p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p><p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7.png" alt="volatile关键字的可见性"></p><h2 id="10-2并发编程的三个重要特性"><a href="#10-2并发编程的三个重要特性" class="headerlink" title="10.2并发编程的三个重要特性"></a>10.2并发编程的三个重要特性</h2><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized </code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong>  ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。（单例模式）</li></ol><h2 id="10-3synchronized-关键字和-volatile-关键字"><a href="#10-3synchronized-关键字和-volatile-关键字" class="headerlink" title="10.3synchronized 关键字和 volatile 关键字"></a>10.3synchronized 关键字和 volatile 关键字</h2><ul><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li><li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h1 id="11-ThreadLocal"><a href="#11-ThreadLocal" class="headerlink" title="11.ThreadLocal"></a>11.ThreadLocal</h1><h2 id="11-1ThreadLocal简介"><a href="#11-1ThreadLocal简介" class="headerlink" title="11.1ThreadLocal简介"></a>11.1ThreadLocal简介</h2><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>  <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p><p>如果你<strong>创建了一个<code>ThreadLocal</code>变量</strong>，那么<strong>访问这个变量的每个线程都会有这个变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。<strong>他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p><h2 id="11-2ThreadLocal原理"><a href="#11-2ThreadLocal原理" class="headerlink" title="11.2ThreadLocal原理"></a>11.2ThreadLocal原理</h2><p>从 <code>Thread</code>类源代码入手。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set() </code>方法。</p><p><code>ThreadLocal</code>类的<code>set()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong><code>ThreadLocal</code> 内部维护的是一个类似 <code>Map</code> 的<code>ThreadLocalMap</code> 数据结构，<code>key</code> 为当前对象的 <code>Thread</code> 对象，值为 Object 对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p><h2 id="11-3ThreadLocal-内存泄露问题"><a href="#11-3ThreadLocal-内存泄露问题" class="headerlink" title="11.3ThreadLocal 内存泄露问题"></a>11.3ThreadLocal 内存泄露问题</h2><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p><h1 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12.线程池"></a>12.线程池</h1><h2 id="12-1为什么要用线程池"><a href="#12-1为什么要用线程池" class="headerlink" title="12.1为什么要用线程池"></a>12.1为什么要用线程池</h2><ul><li><strong>降低资源消耗：</strong>线程池通常会维护一些线程（数量为 <code>corePoolSize</code>），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。</li><li><strong>提高响应速度：</strong>由于线程池维护了一批 <code>alive</code> 状态的线程，当任务到达时，不需要再创建线程，而是直接由这些线程去执行任务，从而减少了任务的等待时间。</li><li><strong>提高线程的可管理性：</strong>使用线程池可以对线程进行统一的分配，调优和监控。</li></ul><h2 id="12-2线程池设计思路"><a href="#12-2线程池设计思路" class="headerlink" title="12.2线程池设计思路"></a>12.2线程池设计思路</h2><p>将线程池的实现类比于工厂的生产流程：</p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\工厂.png" style="zoom:110%;"><p>工厂各部分的映射：</p><ul><li>工厂——线程池</li><li>订单——任务（Runnable）</li><li>正式工人——核心线程</li><li>临时工——普通线程</li><li>仓库（仓库中堆积了生产原料）——任务队列</li><li>调度员——getTask()</li></ul><blockquote><p><strong>getTask()是一个方法，将任务队列中的任务调度给空闲线程</strong></p></blockquote><p>经过映射形成线程池的流程如下：</p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\线程池.png" style="zoom:110%;"><p>那么线程池的流程可以提炼成：</p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\线程池流程.png" style="zoom:90%;"><h2 id="12-3Executor-框架"><a href="#12-3Executor-框架" class="headerlink" title="12.3Executor 框架"></a>12.3Executor 框架</h2><h3 id="12-3-1Executor-框架简介"><a href="#12-3-1Executor-框架简介" class="headerlink" title="12.3.1Executor 框架简介"></a>12.3.1Executor 框架简介</h3><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过JDK提供的 Executor 框架来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外。</p><p>此外，Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架就是为了更好地控制多线程。</p><p>还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p><strong>this 逃逸：</strong>指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h3 id="12-3-2Executor-框架结构（三大部分）"><a href="#12-3-2Executor-框架结构（三大部分）" class="headerlink" title="12.3.2Executor 框架结构（三大部分）"></a>12.3.2Executor 框架结构（三大部分）</h3><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\Executor.png" style="zoom:90%;"><p><strong>1) 任务(<code>Runnable</code> /<code>Callable</code>)</strong></p><p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。**<code>Runnable</code> 接口<strong>或 **<code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p><p><strong>2) 任务的执行(<code>Executor</code>)</strong></p><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p><p><strong>3) 异步计算的结果(<code>Future</code>)</strong></p><p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p><p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p><h3 id="12-3-3-Executor-框架的使用示意图"><a href="#12-3-3-Executor-框架的使用示意图" class="headerlink" title="12.3.3 Executor 框架的使用示意图"></a>12.3.3 Executor 框架的使用示意图</h3><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\Executor框架的使用示意图.png" style="zoom:90%;"><ol><li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li><li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li><li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li><li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li></ol><h3 id="12-3-4ThreadPoolExecutor-类介绍"><a href="#12-3-4ThreadPoolExecutor-类介绍" class="headerlink" title="12.3.4ThreadPoolExecutor 类介绍"></a>12.3.4ThreadPoolExecutor 类介绍</h3><p><strong>1）ThreadPoolExecutor 类构造方法</strong></p><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                              )</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>线程池创建的核心参数：</strong></p><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数:</p><ol><li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :拒绝策略。当线程池中线程数达到<code>maximumPoolSize</code>且<code>workQueue</code>打满时，后续提交的任务将被拒绝，<code>handler</code>可以指定用什么方式拒绝任务。</li></ol><p><strong>ThreadPoolExecutor 拒绝策略定义:</strong></p><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ul><li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li><li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：直接运行这个任务的<code>run</code>方法，但并非是由线程池的线程处理，而是交由任务的调用线程处理。</li><li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li><li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 将当前处于等待队列列头的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。</li></ul><h2 id="12-4线程池的创建方式"><a href="#12-4线程池的创建方式" class="headerlink" title="12.4线程池的创建方式"></a>12.4线程池的创建方式</h2><p><strong>方式一： ThreadPoolExecutor 的构造函数创建（推荐使用）</strong></p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\创建线程池1.png" style="zoom:90%;"><p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure><p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p><p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\创建线程池2.png" style="zoom:90%;"><p>通过 Executors 工具类我们可以很轻松的创建我们下面将要说的几种线程池。但是实际上我们一般都不是直接使用 Java 提供好的线程池，另外在《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure><h2 id="12-5-Java-提供提供的几种线程池"><a href="#12-5-Java-提供提供的几种线程池" class="headerlink" title="12.5 Java 提供提供的几种线程池"></a>12.5 Java 提供提供的几种线程池</h2><ul><li><strong>FixedThreadPool：</strong> 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor 又分为：ScheduledThreadPoolExecutor（包含多个线程）和 SingleThreadScheduledExecutor （只包含一个线程）两种。</li></ul><h4 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h4><ul><li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li><li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景；</li><li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li><li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li><li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li></ul><h2 id="12-6ThreadPoolExecutor-使用示例"><a href="#12-6ThreadPoolExecutor-使用示例" class="headerlink" title="12.6ThreadPoolExecutor 使用示例"></a>12.6ThreadPoolExecutor 使用示例</h2><p><strong>Runnable+ThreadPoolExecutor</strong></p><h3 id="12-6-1示例代码"><a href="#12-6-1示例代码" class="headerlink" title="12.6.1示例代码"></a>12.6.1示例代码</h3><p><strong>首先创建一个 <code>Runnable</code> 接口的实现类：</strong><code>MyRunnable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写测试程序：</strong><code>ThreadPoolExecutorDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们上面的代码指定了：</p><ol><li><code>corePoolSize</code>: 核心线程数为 5。</li><li><code>maximumPoolSize</code> ：最大线程数 10</li><li><code>keepAliveTime</code> : 等待时间为 1L。</li><li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li><li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li><li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li></ol><p><strong>Output：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br></pre></td></tr></table></figure><p><strong>代码输出解释：</strong></p><p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p><h3 id="12-6-2线程池原理分析"><a href="#12-6-2线程池原理分析" class="headerlink" title="12.6.2线程池原理分析"></a>12.6.2线程池原理分析</h3><p>通过代码输出结果可以看出：<strong>线程首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong></p><p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong>在 上面的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现原理如下图所示：</p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\图解线程池实现原理.png" style="zoom:110%;"><p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回true说明创建和启动工作线程成功，否则的话返回的就是false。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line">   <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">   <span class="comment">//获取线程池状态</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">//获取线程池中线程的数量</span></span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="comment">// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize </span></span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">break</span> retry;</span><br><span class="line">               <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">               c = ctl.get();  </span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                   <span class="keyword">continue</span> retry;</span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">       <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">       <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">       Worker w = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">           w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">           <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">               <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">               mainLock.lock();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//获取线程池状态</span></span><br><span class="line">                   <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                  <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">                 <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                  <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                   <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       workers.add(w);</span><br><span class="line">                      <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                       <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                       <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                     <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                       workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 释放锁</span></span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">               <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                   t.start();</span><br><span class="line">                 <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                   workerStarted = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">           <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> workerStarted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="12-7几个常见的对比"><a href="#12-7几个常见的对比" class="headerlink" title="12.7几个常见的对比"></a>12.7几个常见的对比</h2><h3 id="12-7-1Runnable-vs-Callable"><a href="#12-7-1Runnable-vs-Callable" class="headerlink" title="12.7.1Runnable vs Callable"></a>12.7.1Runnable vs Callable</h3><p><strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是**<code>Callable</code> 接口<strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **<code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p><p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。</p><h3 id="12-7-2-execute-vs-submit"><a href="#12-7-2-execute-vs-submit" class="headerlink" title="12.7.2 execute() vs submit()"></a>12.7.2 execute() vs submit()</h3><ol><li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li><li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ol><p>我们以**<code>AbstractExecutorService</code>**接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看<code>execute()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-7-3-shutdown-VS-shutdownNow"><a href="#12-7-3-shutdown-VS-shutdownNow" class="headerlink" title="12.7.3 shutdown() VS shutdownNow()"></a>12.7.3 shutdown() VS shutdownNow()</h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="12-7-4-isTerminated-VS-isShutdown"><a href="#12-7-4-isTerminated-VS-isShutdown" class="headerlink" title="12.7.4 isTerminated() VS isShutdown()"></a>12.7.4 isTerminated() VS isShutdown()</h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="12-7-5示例代码"><a href="#12-7-5示例代码" class="headerlink" title="12.7.5示例代码"></a>12.7.5示例代码</h3><p><strong>Callable+ThreadPoolExecutor</strong></p><p><strong>首先创建一个 <code>Callable</code> 接口的实现类：</strong><code>MyCallable.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong><code>CallableDemo.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br></pre></td></tr></table></figure><p>可以得到任务的执行情况，包括是否成功提交，还有任务的返回结果等信息。</p><h1 id="13-生产者消费者模式"><a href="#13-生产者消费者模式" class="headerlink" title="13.生产者消费者模式"></a>13.生产者消费者模式</h1><h2 id="13-1生产者和消费者模式描述"><a href="#13-1生产者和消费者模式描述" class="headerlink" title="13.1生产者和消费者模式描述"></a>13.1生产者和消费者模式描述</h2><p>生产者和消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者从空间里取走数据。</p><h2 id="13-2存在的问题——线程安全问题"><a href="#13-2存在的问题——线程安全问题" class="headerlink" title="13.2存在的问题——线程安全问题"></a>13.2存在的问题——线程安全问题</h2><ol><li>当生产者比消费者快时，消费者会漏掉一部分数据；</li><li>当消费者比生产者快时，消费者会取走相同的数据。</li></ol><p><strong>解决方式：</strong>要考虑线程安全的问题，解决此问题有三种方式</p><ol><li>同步代码块 </li><li>同步方法 </li><li>lock锁机制， 通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块</li></ol><h2 id="13-3解决方式"><a href="#13-3解决方式" class="headerlink" title="13.3解决方式"></a>13.3解决方式</h2><h3 id="13-3-1同步方法"><a href="#13-3-1同步方法" class="headerlink" title="13.3.1同步方法"></a>13.3.1同步方法</h3><p><strong>wait()和notify()方法</strong></p><ul><li>wait()：当缓冲区已满/空时，生产者或消费者线程停止自己的执行，释放锁，使自己处于等待状态，让其它线程执行。</li><li>notify()：当生产者或消费者向缓冲区放入或取出一个产品时，向其他等待的线程发出通知，同时释放锁，使自己处于等待状态，让其它线程执行。</li></ul><blockquote><p><code>wait()</code>、<code>nofity()</code>这两个方法必须有锁对象调用，而任意对象都可以作为 synchronized 的同步锁，因此这三个方法只能在Object 类中声明 。</p></blockquote><p><strong>生产者和消费者模式中涉及到的类</strong></p><ul><li>商店类（Shop）:定义一个成员变量，表示第几个面包，提供生产面包和消费面包的操作</li><li>生产者类（Producer）：实现Runnable接口，重写run()方法，调用生产面包的操作</li><li>消费者类（Consumer）：实现Runnable接口，重写run()方法，调用消费面包的操作</li><li>测试类</li></ul><p><strong>代码实现</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://wangjin1996219.github.io/categories/JAVA/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://wangjin1996219.github.io/2021/04/15/HashMap/"/>
    <id>http://wangjin1996219.github.io/2021/04/15/HashMap/</id>
    <published>2021-04-15T09:10:10.000Z</published>
    <updated>2021-04-15T12:19:21.395Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">热题100-1. 两数之和</a></strong></p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>利用HashMap查找时间复杂度为O(1)</strong></p><ul><li>遍历数组，每遍历到一个元素，用目标值减去该元素，如果前面有对应的元素，在HashMap中应该有对应的键值，将该元素索引和HashMap中的索引返回即可</li><li>如果没有，将该元素和其索引存储到HashMap中</li><li>遍历结束没有找到，返回空数组</li></ul><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    hm.put(nums[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,hm.get(target-nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        hm.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><a href="https://www.nowcoder.com/practice/704c8388a82e42e58b7f5751ec943a11?tpId=190&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-未排序数组中累加和为给定值的最长子数组长度</strong></a></p><p>给定一个无序数组arr, 其中元素可正、可负、可0。给定一个整数k，求arr所有子数组中累加和为k的最长子数组长度</p><p>与力扣上一道二叉树的题目很像</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>前缀和：</strong>前缀和表示数组中该元素前面的元素累加和 + 该元素的和</p><p>同一数组中，如果<strong>两个数的前缀总和是相同的，那么这些元素之间的元素总和为零</strong>。进一步扩展相同的想法，<strong>如果前缀总和currSum，在元素A和元素B处相差target，则位于元素A和元素B之间的元素之和是target</strong>。</p><ul><li>维护一个最大长度的变量max</li><li>遍历数组中的元素，计算该元素的前缀和</li><li>当该元素的前缀和-目标值在HashMap中时，表示它们之间的差值满足目标值</li><li>如果该前缀和在HashMap中不存在，添加到Hashmap中；如果存在，不用添加，因为要求最长子序列，所以索引越远越好</li></ul><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max length of the subarray sum = k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxlenEqualK</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        hm.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            preSum+=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(preSum-k))&#123;</span><br><span class="line">                max=Math.max(max,i+<span class="number">1</span>-hm.get(preSum-k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hm.containsKey(preSum))&#123;</span><br><span class="line">                hm.put(preSum,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目三</p><p>解题思路</p><p>代码及注释</p><p>题目四</p><p>解题思路</p><p>代码及注释</p><p>题目五</p><p>解题思路</p><p>代码及注释</p><p>题目六</p><p>解题思路</p><p>代码及注释</p><p>题目七</p><p>解题思路</p><p>代码及注释</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数据结构篇" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis相关</title>
    <link href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-10T07:12:13.000Z</published>
    <updated>2021-05-21T14:14:23.328Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1Redis简介"><a href="#1-1Redis简介" class="headerlink" title="1.1Redis简介"></a>1.1Redis简介</h2><ul><li>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向；</li><li>redis 也经常用来做分布式锁；</li><li>redis 提供了多种数据类型来支持不同的业务场景；</li><li>redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </li></ul><h2 id="1-2为什么要用-redis"><a href="#1-2为什么要用-redis" class="headerlink" title="1.2为什么要用 redis"></a>1.2为什么要用 redis</h2><p>主要依据“<strong>高性能</strong>”和“<strong>高并发</strong>”这两点</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg"></p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg"></p><h2 id="1-3为什么用redis而不用map-guava-做缓存"><a href="#1-3为什么用redis而不用map-guava-做缓存" class="headerlink" title="1.3为什么用redis而不用map/guava 做缓存?"></a>1.3为什么用redis而不用map/guava 做缓存?</h2><ul><li><input disabled type="checkbox"> 本地缓存和分布式缓存分别适用于哪些数据？（美团）</li></ul><p>以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错。</p><p>使用 redis 之类的称为<strong>分布式缓存</strong>，在多实例（进程）的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p><h3 id="1-3-1本地缓存map-guava"><a href="#1-3-1本地缓存map-guava" class="headerlink" title="1.3.1本地缓存map/guava"></a>1.3.1本地缓存map/guava</h3><p><strong>优缺点：</strong></p><ol><li><p>访问速度快，但无法进行大数据存储</p><p> 本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。</p></li><li><p>集群的数据更新问题</p><p> 与此同时，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错，如基于 Redis 的发布订阅机制来同步更新各个部署节点。</p></li><li><p>数据随应用进程的重启而丢失</p><p> 由于本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。所以对于需要持久化的数据，需要注意及时保存，否则可能会造成数据丢失。</p></li></ol><p><strong>使用场景：</strong></p><p>本地缓存一般适合于缓存只读数据，如统计类数据。或者每个部署节点独立的数据，如长连接服务中，每个部署节点由于都是维护了不同的连接，每个连接的数据都是独立的，并且随着连接的断开而删除。如果数据在集群的不同部署节点需要共享和保持一致，则需要使用分布式缓存来统一存储，实现应用集群的所有应用进程都在该统一的分布式缓存中进行数据存取即可。</p><h3 id="13-2分布式缓存redis"><a href="#13-2分布式缓存redis" class="headerlink" title="13.2分布式缓存redis"></a>13.2分布式缓存redis</h3><p><strong>优缺点：</strong></p><ol><li><p>支持大数据量存储，不受应用进程重启影响</p><p> 分布式缓存由于是独立部署的进程，拥有自身独立的内存空间，不会受到应用进程重启的影响，在应用进程重启时，分布式缓存的数据依然存在。同时对于数据量而言，由于不需要占用应用进程的内存空间，并且一般支持以集群的方式拓展，故可以进行大数据量的数据缓存。</p></li><li><p>数据集中存储，保证数据一致性</p><p> 当应用进程采用集群方式部署时，集群的每个部署节点都通过一个统一的分布式缓存进行数据存取操作，故不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题。</p></li><li><p>数据读写分离，高性能，高可用</p><p> 分布式缓存一般支持数据副本机制，可以实现读写分离，故可以解决高并发场景中的数据读写性能问题。并且由于在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。</p></li><li><p>数据跨网络传输，性能低于本地缓存</p><p> 由于分布式缓存是独立部署的进程，并且一般都是与应用进程位于不同的机器，故需要通过网络来进行数据传输，这样相对于本地缓存的进程内部的数据读取操作，性能会较低。</p></li></ol><h1 id="2-数据类型和使用场景分析"><a href="#2-数据类型和使用场景分析" class="headerlink" title="2.数据类型和使用场景分析"></a>2.数据类型和使用场景分析</h1><h2 id="2-1String"><a href="#2-1String" class="headerlink" title="2.1String"></a>2.1String</h2><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 </p><p><strong>应用场景：</strong></p><ul><li>常规key-value缓存应用</li><li>常规计数：微博上的粉丝数等</li></ul><h2 id="2-2Hash"><a href="#2-2Hash" class="headerlink" title="2.2Hash"></a>2.2Hash</h2><p>hash 是一个 string 类型的 field 和 value 的映射表（值：包含键值对的无序散列表）</p><p><strong>应用场景：</strong></p><ul><li>hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li></ul><p>比如下面我就用 hash 类型存放了我本人的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: <span class="number">1</span>,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: <span class="number">22</span>,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3List"><a href="#2-3List" class="headerlink" title="2.3List"></a>2.3List</h2><p>list 就是链表</p><p><strong>应用场景：</strong></p><p>Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h2 id="2-4Set"><a href="#2-4Set" class="headerlink" title="2.4Set"></a>2.4Set</h2><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p><strong>应用场景：</strong></p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><h2 id="2-5Sorted-Set"><a href="#2-5Sorted-Set" class="headerlink" title="2.5Sorted Set"></a>2.5Sorted Set</h2><p>和set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>应用场景：</strong></p><p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis支持持久化支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>将数据在某个节点上的副本写入一个临时文件，持久化结束后，用该临时文件替换上次持久化的文件，达到数据恢复的目的</p><ul><li><strong>优点：</strong>使用单独的子进程来持久化，主进程不会进行任何的I/O操作，保证了redis的高效性能</li><li><strong>缺点：</strong>RDB通常间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据的丢失，所示更适用于对数据要求不是很严谨的情况</li></ul><p>项目中使用的存储机制：检测到更改的key越多，更新越频繁</p><table><thead><tr><th>更改key的数目</th><th>更新时间间隔</th></tr></thead><tbody><tr><td>更改了1个key</td><td>间隔900秒更新一次数据</td></tr><tr><td>更改了10个key</td><td>间隔300秒更新一次数据</td></tr><tr><td>10000</td><td>60秒</td></tr></tbody></table><p><strong>AOF（append-only file）持久化</strong></p><p>将执行过的指令记录下来，数据恢复时，按照记录文件中的指令顺序，再将指令执行一遍</p><ul><li><strong>优点：</strong>可以保持更高的数据完整性，如果设置appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。且日志写入写信不完整，支持检查AOF日志来进行AOF修复，AOF没有被write之前可以删除某些指令</li><li><strong>缺点：</strong>AOF文件比RDB文件大，恢复的速度比RDB慢</li></ul><h1 id="4-过期键的删除策略-Redis设置过期时间"><a href="#4-过期键的删除策略-Redis设置过期时间" class="headerlink" title="4.过期键的删除策略-Redis设置过期时间"></a>4.过期键的删除策略-Redis设置过期时间</h1><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p><p><strong>定期删除+惰性删除。</strong></p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p><h1 id="5-内存相关"><a href="#5-内存相关" class="headerlink" title="5.内存相关"></a>5.内存相关</h1><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</p><h2 id="5-1Redis的内存淘汰策略"><a href="#5-1Redis的内存淘汰策略" class="headerlink" title="5.1Redis的内存淘汰策略"></a>5.1Redis的内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p><strong>全局的键空间选择性移除</strong></p><ol><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p><strong>设置过期时间的键空间选择性移除</strong></p><ol><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li></ol><p>4.0版本后增加以下两种：</p><ol><li><strong>volatile-lfu</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6.线程模型"></a>6.线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p><strong>Redis 是单线程的，为什么还那么快？</strong></p><ol><li>操作完全基于内存，速度快；</li><li>数据结构简单，对数据的操作也简单；</li><li>采用单线程，避免了不必要的上下文切换开销；</li><li>使用非阻塞的<strong>多路IO复用模型。</strong></li></ol><p>​    I/O 多路复用模型是利用select、poll、epoll可以<strong>同时监察多个流的 I/O 事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，<strong>当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流</strong>（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 <strong>I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且<strong>Redis在内存中操作数据的速度非常快</strong>（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7.事务"></a>7.事务</h1><p>==没整完哦==</p><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。</p><p><strong>隔离性</strong></p><p>Redis 是单线程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h1 id="8-集群方案"><a href="#8-集群方案" class="headerlink" title="8.集群方案"></a>8.集群方案</h1><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> 、<code>twemproxy</code> 有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p><p>现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p><p>Redis的官方多机部署方案，Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master  node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><h2 id="8-1Redis-cluster-介绍"><a href="#8-1Redis-cluster-介绍" class="headerlink" title="8.1Redis cluster 介绍"></a>8.1Redis cluster 介绍</h2><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h2 id="8-2哨兵模式"><a href="#8-2哨兵模式" class="headerlink" title="8.2哨兵模式"></a>8.2哨兵模式</h2><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/哨兵.png" style="zoom:80%;"><p><strong>哨兵的介绍</strong></p><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，也可以理解为是一个<strong>故障转移系统</strong>，主要有以下功能：</p><ul><li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li></ul><p><strong>哨兵的核心知识</strong></p><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li><li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li></ul><h2 id="8-3节点间的内部通信机制"><a href="#8-3节点间的内部通信机制" class="headerlink" title="8.3节点间的内部通信机制"></a>8.3节点间的内部通信机制</h2><p><strong>基本通信原理</strong></p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式：</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\集中式.png" style="zoom:120%;"><p><strong>Gossip 协议：</strong>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\Gossip.png" style="zoom:120%;"><p><strong>两种通信方式对比：</strong></p><ul><li><p><strong>集中式：</strong></p><p>优点：元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</p><p>缺点：所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p></li><li><p><strong>Gossip协议：</strong></p><p>优点：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p><p>缺点：元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p></li></ul><blockquote><p><strong>数据元、元数据与数据</strong></p><p>数据元是组成实体数据的最小单元，或称原子数据，例如，客户联系方式中的手机号码，手机号为数据元，135****为数据元的值。</p><p>元数据是用来描述数据的数据，让数据更容易理解、查找、管理和使用。举个栗子“村里有个姑娘叫小芳，长得好看又善良”这首耳熟能详的歌，我们分析一下，姓名：小芳、性别：姑娘（女）、长相：好看、性格：善良，住址：村里。这里面：小芳是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。当然元数据也会被描述，例如上边我举的例子中姓名的字段长度，字段编码、定义、字段类型、默认值等是用来描述“姓名”这个数据元的。</p></blockquote><h2 id="8-4分布式寻址算法"><a href="#8-4分布式寻址算法" class="headerlink" title="8.4分布式寻址算法"></a>8.4分布式寻址算法</h2><ul><li><strong>hash 算法（大量缓存重建）</strong></li><li><strong>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</strong></li><li><strong>Redis cluster 的 hash slot 算法</strong></li></ul><h3 id="8-4-1hash-算法"><a href="#8-4-1hash-算法" class="headerlink" title="8.4.1hash 算法"></a>8.4.1hash 算法</h3><p>来了一个 key，首先计算 hash 值，然后<strong>对节点数取模</strong>。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><h3 id="8-4-2一致性-hash-算法"><a href="#8-4-2一致性-hash-算法" class="headerlink" title="8.4.2一致性 hash 算法"></a>8.4.2一致性 hash 算法</h3><blockquote><p>简书文章链接：<a href="https://www.jianshu.com/p/528ce5cd7e8f"><strong>点击这里</strong></a></p></blockquote><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。（因为计算出HashCode后，沿着顺时针走遇到的）</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\一致性hash算法.png" style="zoom:80%;"><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><blockquote><p><strong>缓存热点又称为数据倾斜问题</strong></p><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（<strong>被缓存的对象大部分缓存在某一台服务器上</strong>）问题</p></blockquote><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\数据倾斜问题.png" style="zoom:67%;"><p>数据定位算法不变，只需要增加一步：<strong>虚拟节点到实际点的映射</strong>。</p><p>所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p><h3 id="8-4-3Redis-cluster-的-hash-slot-算法"><a href="#8-4-3Redis-cluster-的-hash-slot-算法" class="headerlink" title="8.4.3Redis cluster 的 hash slot 算法"></a>8.4.3Redis cluster 的 hash slot 算法</h3><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 校验码值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有  5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的  hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 <strong>key 找的是 hash slot，不是机器</strong>。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\hash-slot.png" style="zoom:80%;"><p>9.分区</p><h1 id="10-分布式问题"><a href="#10-分布式问题" class="headerlink" title="10.分布式问题"></a>10.分布式问题</h1><h2 id="10-1分布式锁"><a href="#10-1分布式锁" class="headerlink" title="10.1分布式锁"></a>10.1分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p><strong>当且仅当 key 不存在</strong>，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>如返回1，则该客户端获得锁，把lock-key的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。<br>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\分布式锁.png" style="zoom:80%;"><p><strong>使用SETNX完成同步锁的流程及事项如下：</strong></p><ul><li><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功（如指令2、1）</p></li><li><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p></li><li><p>释放锁，使用DEL命令将锁数据删除</p></li></ul><h2 id="10-2如何解决Redis的并发竞争Key问题"><a href="#10-2如何解决Redis的并发竞争Key问题" class="headerlink" title="10.2如何解决Redis的并发竞争Key问题"></a>10.2如何解决Redis的并发竞争Key问题</h2><p><strong>介绍：</strong>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>这里的并发指的是多个redis的client同时set key引起的并发问题。</p><p><strong>解决方案：</strong></p><p><strong>方案一：分布式锁+时间戳</strong></p><p><strong>分布式锁：</strong>传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。分布式锁可以基于很多种方式实现，比如zookeeper、redis等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p><p>利用SETNX非常简单地实现分布式锁。例如：某客户端要获得一个名字youzhi的锁，客户端使用下面的命令进行获取：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock.youzhi&lt;current Unix <span class="built_in">time</span> + lock timeout + <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>如返回1，则该客户端获得锁，把lock.youzhi的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。</p><p>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p><p><strong>时间戳</strong></p><p>由于上面举的例子，要求key的操作需要顺序执行，所以需要<strong>在缓存中</strong>保存一个时间戳判断set顺序。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统 A key <span class="number">1</span> &#123;ValueA <span class="number">7</span>:<span class="number">00</span>&#125;</span><br><span class="line">系统 B key <span class="number">1</span> &#123;ValueB <span class="number">7</span>:<span class="number">05</span>&#125;</span><br></pre></td></tr></table></figure><p>假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。</p><p><strong>方案二：利用消息队列</strong></p><p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p><p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p><p><strong>附加：zookeeper分布式锁</strong></p><p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h1 id="11-缓存异常"><a href="#11-缓存异常" class="headerlink" title="11.缓存异常"></a>11.缓存异常</h1><h2 id="11-1缓存雪崩"><a href="#11-1缓存雪崩" class="headerlink" title="11.1缓存雪崩"></a>11.1缓存雪崩</h2><p><strong>什么是缓存雪崩？</strong></p><p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>有哪些解决办法？</strong></p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉（通过限流来限制直接访问数据库的请求数量，当限流组件发现剩余的请求未能通过自己，便会调用自定义的降级组件，返回一些默认的友好提示：服务器忙，请稍后重试等，不让客户端继续等待）</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" style="zoom:80%;"><h2 id="11-2缓存穿透"><a href="#11-2缓存穿透" class="headerlink" title="11.2缓存穿透"></a>11.2缓存穿透</h2><p><strong>什么是缓存穿透？</strong></p><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，造成数据库负载过大。如下图所示：</p><p><strong>正常缓存处理流程：</strong></p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png" style="zoom:60%;"><p><strong>缓存穿透情况处理流程：</strong></p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png" style="zoom:60%;"><p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;; </code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p><p><strong>有哪些解决办法？</strong></p><p><strong>1）参数校验</strong></p><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。（也就是将一些明显错误的key值，直接将错误信息返回给客户端直接报错）</p><p><strong>2）缓存无效 key</strong> </p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险（比如频繁更换key，造成大量的无效key存在于缓存中）</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png" style="zoom:60%;"><p>也就是在Redis缓存与服务端之间再加一层布隆过滤器</p><h1 id="12-常用工具"><a href="#12-常用工具" class="headerlink" title="12.常用工具"></a>12.常用工具</h1><h2 id="12-1Redis支持的客户端"><a href="#12-1Redis支持的客户端" class="headerlink" title="12.1Redis支持的客户端"></a>12.1Redis支持的客户端</h2><p>Redisson、Jedis等</p><p><strong>二者的对比</strong></p><ul><li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；（Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的）</li><li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li></ul><h1 id="13-其他问题"><a href="#13-其他问题" class="headerlink" title="13.其他问题"></a>13.其他问题</h1><h2 id="13-1redis-和-memcached-的区别"><a href="#13-1redis-和-memcached-的区别" class="headerlink" title="13.1redis 和 memcached 的区别"></a>13.1redis 和 memcached 的区别</h2><ol><li><strong>Redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程（存在线程安全问题），非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><table><thead><tr><th align="center">对比参数</th><th align="center">Redis</th><th align="center">Memcached</th></tr></thead><tbody><tr><td align="center"><strong>数据存储类型</strong></td><td align="center">1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td align="center">1. 文本型 2. 二进制类型</td></tr><tr><td align="center"><strong>持久化支持</strong></td><td align="center">1. RDB 2. AOF</td><td align="center">不支持</td></tr><tr><td align="center"><strong>集群模式</strong></td><td align="center">原生支持 cluster 模式，可以实现主从复制，读写分离</td><td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td align="center"><strong>网络IO模型</strong></td><td align="center">1. 单线程的多路 IO 复用模型</td><td align="center">1. 多线程，非阻塞IO模式</td></tr><tr><td align="center">内存管理机制</td><td align="center">在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td align="center">Memcached 的数据则会一直在内存中，将内存分片来解决内存碎片的问题</td></tr><tr><td align="center">事件库</td><td align="center">自封转简易事件库AeEvent</td><td align="center">贵族血统的LibEvent事件库</td></tr><tr><td align="center">类型</td><td align="center">1. 支持内存 2. 非关系型数据库</td><td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td align="center">查询【操作】类型</td><td align="center">1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td><td align="center">1.常用的CRUD 2. 少量的其他命令</td></tr><tr><td align="center">附加功能</td><td align="center">1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td><td align="center">1. 多线程服务支持</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">复杂数据结构，有持久化，高可用需求，value存储内容较大</td><td align="center">纯key-value，数据量非常大，并发量非常大的业务</td></tr></tbody></table><h2 id="13-2如何保证缓存与数据库双写时的数据一致性？"><a href="#13-2如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="13.2如何保证缓存与数据库双写时的数据一致性？"></a>13.2如何保证缓存与数据库双写时的数据一致性？</h2><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p><strong>读请求和写请求串行化</strong></p><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="13-2-1Cache-Aside-Pattern"><a href="#13-2-1Cache-Aside-Pattern" class="headerlink" title="13.2.1Cache Aside Pattern"></a>13.2.1Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p><ul><li><p><strong>因为对于比较复杂的缓存数据计算场景，当被更新的缓存频繁更新、且不常被访问时，更新缓存的代价比较高</strong></p><p><strong>例如：</strong>一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p></li></ul><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><h3 id="13-2-2最初级的缓存不一致问题及解决方案"><a href="#13-2-2最初级的缓存不一致问题及解决方案" class="headerlink" title="13.2.2最初级的缓存不一致问题及解决方案"></a>13.2.2最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><strong>解决思路：</strong></p><p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p><h3 id="13-2-3比较复杂的数据不一致问题分析"><a href="#13-2-3比较复杂的数据不一致问题分析" class="headerlink" title="13.2.3比较复杂的数据不一致问题分析"></a>13.2.3比较复杂的数据不一致问题分析</h3><p><strong>问题：</strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改，造成数据库和缓存中的数据不一样。</p><p><strong>出现场景：</strong>上亿流量高并发场景下，缓存会出现这个问题（大量的“更新”+“读”操作&lt;其实就是时间差&gt;）</p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p><p><strong>解决思路：</strong></p><p>更新数据的时候，根据<strong>数据的唯一标识（例如店铺ID）</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><h1 id="14-五种IO模型"><a href="#14-五种IO模型" class="headerlink" title="14.五种IO模型"></a>14.五种IO模型</h1><blockquote><p><strong>Note：</strong></p><p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p><p> 我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p></blockquote><p>一个IO操作其实分成了两个步骤：</p><ul><li>发起IO请求</li><li>实际的IO操作。</li></ul><p><strong>同步IO和异步IO的区别：</strong>在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。<br><strong>阻塞IO和非阻塞IO的区别：</strong>在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 </p><h2 id="14-1阻塞IO模型"><a href="#14-1阻塞IO模型" class="headerlink" title="14.1阻塞IO模型"></a>14.1阻塞IO模型</h2><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p>执行如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd=connect();</span><br><span class="line">write(fd);</span><br><span class="line">read(fd);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\阻塞IO.png" style="zoom:100%;"><h2 id="14-2非阻塞IO模型"><a href="#14-2非阻塞IO模型" class="headerlink" title="14.2非阻塞IO模型"></a>14.2非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\非阻塞IO.png"></p><p>这样会造成CPU的占有率特别高</p><h2 id="14-3多路复用IO模型"><a href="#14-3多路复用IO模型" class="headerlink" title="14.3多路复用IO模型"></a>14.3多路复用IO模型</h2><p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p><p>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p><p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\多路复用IO.png"></p><h2 id="14-4信号驱动IO模型"><a href="#14-4信号驱动IO模型" class="headerlink" title="14.4信号驱动IO模型"></a>14.4信号驱动IO模型</h2><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情。</p><p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\信号驱动IO.png"></p><h2 id="14-5异步IO模型"><a href="#14-5异步IO模型" class="headerlink" title="14.5异步IO模型"></a>14.5异步IO模型</h2><p>读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。</p><p>读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p><p><strong>对比信号驱动IO，异步IO的主要区别在于：</strong>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</p><p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\异步IO.png"></p><h3 id="14-5-1常用的IO复用模型"><a href="#14-5-1常用的IO复用模型" class="headerlink" title="14.5.1常用的IO复用模型"></a>14.5.1常用的IO复用模型</h3><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让<strong>单个进程可以监视多个文件描述符</strong>，一旦<strong>某个描述符就绪</strong>（一般是读就绪或写就绪），能够<strong>通知程序进行相应的读写操作</strong>。与多进程和多线程技术相比，I/O多路复用技术的最大优势是<strong>系统开销小</strong>，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p><strong>三种：select，poll，epoll</strong></p><ul><li><p><strong>select</strong>==&gt;时间复杂度O(n)</p><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询所有流</strong>，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p></li><li><p><strong>poll</strong>==&gt;时间复杂度O(n)</p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p></li><li><p><strong>epoll</strong>==&gt;时间复杂度O(1)</p><p>epoll可以理解为event poll，不同于无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p></li></ul><p><strong>三种模型分析：</strong></p><p><strong>select缺点：</strong></p><ul><li>每次调用select，都需要把fd_set集合从用户态拷贝到内核空间中；</li><li>需要在内核遍历传递进来的所有fd_set，找出能读出数据，或者写入数据的流，对他们进行操作；</li><li>内核对被监控的fd_set集合大小做了限制，为1024。</li></ul><p><strong>poll缺点：</strong></p><ul><li>poll没有最大文件描述符数量的限制，因为数据结构变成了链表</li><li>其他缺点和select一样</li></ul><p><strong>epoll：（优势）</strong></p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数</li><li>不需要每次都把fd_set集合从用户态拷贝到内核态</li></ul><p><strong>应用场景：</strong></p><p>select、poll：连接数少并且连接都十分活跃的情况</p><p>epoll：连接多，并且有大量不太活跃的连接</p><p><strong>epoll的实现原理：</strong></p><ul><li><p><strong>epoll_create()系统调用：</strong>通过此调用建立一个epoll对象，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p><p><code>红黑树：</code>树中存储着所有添加到epoll中的需要监控的事件</p><p><code>双向链表：</code>存放着将要通过epoll_wait()返回给用户的满足条件的事件（所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中）</p></li><li><p><strong>epoll_ctl()系统调用：</strong>通过此调用向epoll对象中添加、删除、修改感兴趣的事件，所以不需要每次调用epoll_wait都复制所有的事件结构</p></li><li><p><strong>epoll_wait()系统调用：</strong>通过此调用会直接返回链表中的就绪事件，效率高。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="专业知识" scheme="http://wangjin1996219.github.io/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Redis相关" scheme="http://wangjin1996219.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>

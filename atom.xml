<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wj-Blog</title>
  
  
  <link href="http://wangjin1996219.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangjin1996219.github.io/"/>
  <updated>2021-08-08T08:41:56.913Z</updated>
  <id>http://wangjin1996219.github.io/</id>
  
  <author>
    <name>老王家的小王呀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS原理分析</title>
    <link href="http://wangjin1996219.github.io/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://wangjin1996219.github.io/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-07-27T11:55:05.000Z</published>
    <updated>2021-08-08T08:41:56.913Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-J-U-C-类结构"><a href="#1-1-J-U-C-类结构" class="headerlink" title="1.1 J.U.C 类结构"></a>1.1 J.U.C 类结构</h2><p> <strong>J.U.C（java.util.concurrent）包：</strong>提供了很多高性能的并发类，大大提高了并发性能。研究具体的类原理前需要对整个框架有一个大概的认识，整个框架分为五个模块，部分高级模块会依赖其他基础模块，如图所示：</p><p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-07-27-AQS原理分析\图片04.png" alt="image-20210620113447451"></p><h2 id="1-2-AQS-原理分析"><a href="#1-2-AQS-原理分析" class="headerlink" title="1.2 AQS 原理分析"></a>1.2 AQS 原理分析</h2><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的<strong>框架</strong></p><p><strong>AQS 核心思想</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</p><p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><blockquote><p><strong>CLH(Craig,Landin,and Hagersten)队列：</strong>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>AQS 原理如图所示：</p><p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-07-27-AQS原理分析\图片03.png" alt="AQS原理图"></p><p><strong>AQS 使用一个 int 成员变量 state 来表示同步状态</strong>，当 state&gt;0 时表示已经获取锁，当 state=0 时表示释放了锁。用 volatile 修饰共享变量 state 保证线程同步，线程通过 CAS 去改变状态符，成功则获取锁成功，失败则被 AQS 封装成 Node 进入等待队列，等待被唤醒。通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p><blockquote><p><strong>AQS 是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋的方式，不停地尝试获取锁，直到被其他线程获取成功。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p><strong>AQS 提供了三种方法对状态信息修改：</strong>protected 类型的 getState，setState，compareAndSetState 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AQS-对资源的共享方式"><a href="#1-AQS-对资源的共享方式" class="headerlink" title="1. AQS 对资源的共享方式"></a>1. AQS 对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p><h3 id="2-AQS-底层模板方法模式"><a href="#2-AQS-底层模板方法模式" class="headerlink" title="2. AQS 底层模板方法模式"></a>2. AQS 底层模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 </p><p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到A线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state 会累加），这就是<strong>可重入</strong>的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 为例，任务分为N个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS(Compare and Swap) 减1。等到所有子线程都执行完后(即state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><p><strong>总结：</strong> </p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p><p>AQS 解决了实现同步器是涉及到的大量细节问题，如：获取同步状态、FIFO 同步队列等。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。</p><p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态。</p><h1 id="2-实现不可重入锁"><a href="#2-实现不可重入锁" class="headerlink" title="2.实现不可重入锁"></a>2.实现不可重入锁</h1><h2 id="1-自定义同步器"><a href="#1-自定义同步器" class="headerlink" title="1.自定义同步器"></a>1.自定义同步器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//加锁，将当前持有锁的线程设置为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前线程设为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//将状态值设为0</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//是否持有独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-自定义锁"><a href="#2-自定义锁" class="headerlink" title="2.自定义锁"></a>2.自定义锁</h2><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">22:29:28.727 c.TestAqs [t1] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t1] - unlocking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - unlocking... </span><br></pre></td></tr></table></figure><h1 id="3-ReentrantLock-原理"><a href="#3-ReentrantLock-原理" class="headerlink" title="3. ReentrantLock 原理"></a>3. ReentrantLock 原理</h1><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片01.png" alt="image-20210727202338191" style="zoom: 80%;"><p>内部也是维护了一个同步器 Sync，它有两种实现：公平锁和非公平锁</p><h2 id="1-非公平锁实现原理"><a href="#1-非公平锁实现原理" class="headerlink" title="1.非公平锁实现原理"></a>1.非公平锁实现原理</h2><h3 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h3><p>先从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS</p><p><strong>没有竞争时：</strong></p><p>通过 cas 将状态 state 置为 1，并将当前的线程设置为线程本身。</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片05.png" alt="image-20210727215938412" style="zoom:67%;"><p><strong>第一个竞争出现时：</strong></p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片06.png" alt="image-20210727220243625" style="zoom:67%;"><p>Thread-1 执行了</p><ol><li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p></li><li><p>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 </p></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列 </p><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 </p><p>Node 的创建是懒惰的 </p><p>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</p></li></ol><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片07.png" alt="image-20210727220431998" style="zoom:67%;"><p>当前线程进入 acquireQueued 逻辑 </p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 </li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 （仍然会自旋一下）</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false（前驱节点为-1，表示有责任唤醒它的后继节点）</li></ol><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片08.png" alt="image-20210727220659132" style="zoom:67%;"><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 </li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true </li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片09.png" alt="image-20210727220801956" style="zoom:67%;"><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片10.png" alt="image-20210727220831897" style="zoom:80%;"><ul><li>Thread-0 释放锁，进入 tryRelease 流程，如果成功 设置 exclusiveOwnerThread 为 null </li><li>state = 0</li></ul><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片11.png" alt="image-20210727220940026" style="zoom: 80%;"><ul><li>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 </li><li>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </li><li>回到 Thread-1 的 acquireQueued 流程</li></ul><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/Users\王进\AppData\Roaming\Typora\typora-user-images\image-20210727221037145.png" alt="image-20210727221037145" style="zoom: 80%;"><p>如果加锁成功<strong>（没有竞争）</strong>，会设置 </p><ul><li>exclusiveOwnerThread 为 Thread-1，state = 1 </li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片12.png" alt="image-20210727221208737" style="zoom:80%;"><p>如果不巧又被 Thread-4 占了先 </p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state = 1 </li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当线程在等待队列中被唤醒时，按照本来应该是队列中的头结点对应的线程，将线程设置为本身，并将 state 状态置1的，但是这时候来了一个新的获取锁的线程，抢先一步完成了这个操作，那么该线程获取执行权。</p><h2 id="2-可重入原理"><a href="#2-可重入原理" class="headerlink" title="2.可重入原理"></a>2.可重入原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可重入锁对于第一次获取时，判断 state == 0，会将 state 设置为 1 ，并将线程设置为当前线程，返回 true 表示设置成功；</p><p>当第二次获取锁时，只要判断线程还是当前线程, 表示发生了锁重入，这是只将状态++就可。</p><h2 id="3-可打断原理"><a href="#3-可打断原理" class="headerlink" title="3.可打断原理"></a>3.可打断原理</h2><p><strong>不可打断模式</strong></p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可打断模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-公平锁实现原理"><a href="#4-公平锁实现原理" class="headerlink" title="4.公平锁实现原理"></a>4.公平锁实现原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                    <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">                    (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">                    <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                    s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁的实现，它在尝试获取锁之前会，先检查 AQS 队列中是否有前驱节点, 没有才去竞争，这样就避免了在等待队列之前的线程获取到锁。</p><h2 id="5-条件变量实现原理"><a href="#5-条件变量实现原理" class="headerlink" title="5.条件变量实现原理"></a>5.条件变量实现原理</h2><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><h3 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h3><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片13.png" alt="image-20210727222806003" style="zoom:80%;"><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片14.png" alt="image-20210727222843874" style="zoom:80%;"><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片15.png" alt="image-20210727222913544" style="zoom:80%;"><p>park 阻塞 Thread-0</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片16.png" alt="image-20210727222944967" style="zoom:80%;"><h3 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h3><p>假设 Thread-1 要来唤醒 Thread-0</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片17.png" alt="image-20210727223020830" style="zoom:80%;"><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片18.png" alt="image-20210727223052269" style="zoom:80%;"><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片19.png" alt="image-20210727223124810" style="zoom:80%;"><p>Thread-1 释放锁，进入 unlock 流程，略</p><h1 id="4-其它组件"><a href="#4-其它组件" class="headerlink" title="4.其它组件"></a>4.其它组件</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p><strong>CountDownLatch的内部实现如下：</strong></p><p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\countdownlatch.png" alt="img"></p><ul><li><strong>CountDownLatch</strong>内部维护一个计数器，CountDownLatch.countDown（）每被执行一次都会使计数器值减少1。 </li><li><strong>当计数器不为0时</strong>，CountDownLatch.await（）方法的调用将会导致执行线程被暂停，这些线程就叫做该 CountDownLatch 上的等待线程。 </li><li>CountDownLatch.countDown（）相当于一个通知方法，<strong>当计数器值达到0时</strong>，唤醒所有等待线程。当然对应还有指定等待时间长度的CountDownLatch.await( long , TimeUnit)方法。 </li></ul><p><strong>Demo0：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..end..run..</span><br></pre></td></tr></table></figure><p><strong>Demo1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end..</span><br></pre></td></tr></table></figure><ul><li>由 Demo0 可知，当主线程不等待时，那 end 输出就可能在任意时刻执行，也就是主线程与其它线程是并行的；</li><li>由 Demo1可知，当主线程 await 一下，那主线程就会等其它线程执行到 countDownLatch==0 来唤醒主线程，那么输出 end 的操作就会最后执行。</li></ul><h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行，在实际工作中可以用来<strong>模拟高并发请求测试</strong>。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\CyclicBarrier.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;王进..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">before..before..before..before..before..王进..after..after..after..after..after..</span><br></pre></td></tr></table></figure><p><strong>reset 方法的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 reset 方法实现了 “屏障” 的循环使用。</p><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    String time = sim.format(satrtTime);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;时刻访问了资源&quot;</span>);</span><br><span class="line">                    System.out.println(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-6</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-8</span><br><span class="line">pool-1-thread-7</span><br><span class="line">pool-1-thread-9</span><br><span class="line">pool-1-thread-10</span><br><span class="line">线程pool-1-thread-2在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-5在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-6在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-1在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-3在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">线程pool-1-thread-4在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-7在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">线程pool-1-thread-9在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-8在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-10在2021-06-20 22:11:11时刻访问了资源</span><br><span class="line">2 </span><br></pre></td></tr></table></figure><p>多个线程可以并发执行，一共十个线程对应十个请求访问资源，但是同时最多只能有三个线程访问共享资源。也就是控制并发量。</p><h2 id="4-AQS-组件总结"><a href="#4-AQS-组件总结" class="headerlink" title="4. AQS 组件总结"></a>4. AQS 组件总结</h2><ul><li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CAS机制</title>
    <link href="http://wangjin1996219.github.io/2021/07/20/CAS%E6%9C%BA%E5%88%B6/"/>
    <id>http://wangjin1996219.github.io/2021/07/20/CAS%E6%9C%BA%E5%88%B6/</id>
    <published>2021-07-20T03:40:35.000Z</published>
    <updated>2021-08-08T08:41:09.385Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h1><p>启动两个线程，每个线程中让变量 count 循环累加 100 次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出的 count 结果一定是 200 吗？因为这段代码是非线程安全的，所以最终的自增结果很可能会小于 200。这是因为 i++ 这种操作并不是原子性的, 实际上它的操作是首先从<strong>内存</strong>中取出数据放在<strong>cpu寄存器</strong>中进行计算, 然后再将计算好的结果返回到<strong>内存</strong>中。</p><p>我们再加上 synchronized 同步锁，再来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyRunnable.class)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了同步锁之后，count 自增的操作变成了原子性操作，所以最终输出一定是 count=200，代码实现了线程安全。虽然 synchronized 确保了线程安全，但是在某些情况下，这并不是一个最优的选择。</p><p>synchronized 关键字会让没有得到锁资源的线程进入 BLOCKED 状态，而后在争夺到锁资源后恢复为 RUNNABLE 状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p><p>尽管 JAVA 1.6 为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过过度，但是在最终转变为重量级锁之后，性能仍然比较低。所以面对这种情况，我们就可以使用 java 中的“原子操作类”。</p><p>所谓原子操作类，指的是 java.util.concurrent.atomic 包下，一系列以 Atomic 开头的包装类。如 AtomicBoolean，AtomicUInteger，AtomicLong。它们分别用于 Boolean，Integer，Long 类型的原子性操作。</p><p>现在我们尝试使用 AtomicInteger 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 AtomicInteger 之后，最终的输出结果同样可以保证是 200。并且在某些情况下，代码的性能会比 synchronized 更好。</p><p>而 Atomic 操作类的底层正是用到了“CAS机制”。</p><h1 id="2-CAS-机制"><a href="#2-CAS-机制" class="headerlink" title="2. CAS 机制"></a>2. CAS 机制</h1><p>CAS 是英文单词 Compare and Swap 的缩写，翻译过来就是比较并替换。</p><p>CAS 机制中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。</p><p>更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</p><p><strong>例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.在内存地址V当中，存储着值为10的变量。</span><br><span class="line">2.此时线程1想把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11.</span><br><span class="line">3.在线程1要提交更新之前，另一个线程2抢先一步，把内存 地址V中的变量值率先更新成了11。</span><br><span class="line">4.线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。</span><br><span class="line">5.线程1重新获取内存地址V的当前值，并重新计算想要修改的值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</span><br><span class="line">6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行比较，发现A和地址V的实际值是相等的。</span><br><span class="line">7.线程1进行交换，把地址V的值替换为B，也就是12。</span><br></pre></td></tr></table></figure><p>从思想上来说，synchronized 属于悲观锁，悲观的认为程序中的并发情况严重，所以严防死守，CAS 属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。</p><p>在 java 中除了上面提到的 Atomic 系列类，以及 Lock 系列类夺得底层实现，甚至在 JAVA1.6 以上版本，synchronized 转变为重量级锁之前，也会采用 CAS 机制。</p><h1 id="3-CAS-的缺点"><a href="#3-CAS-的缺点" class="headerlink" title="3. CAS 的缺点"></a>3. CAS 的缺点</h1><ol><li><p><strong>CPU 开销过大</strong></p><p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</p></li><li><p><strong>不能保证代码块的原子性</strong></p><p>CAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 3 个变量共同进行原子性的更新，就不得不使用 synchronized 了。</p></li><li><p><strong>ABA 问题</strong></p><p>这是 CAS 机制最大的问题所在。（后面有介绍）</p></li></ol><h1 id="4-JAVA-中-CAS-的底层实现"><a href="#4-JAVA-中-CAS-的底层实现" class="headerlink" title="4. JAVA 中 CAS 的底层实现"></a>4. JAVA 中 CAS 的底层实现</h1><p>我们看一下 AtomicInteger 当中常用的自增方法 incrementAndGet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个无限循环，也就是 CAS 的自旋，循环体中做了三件事：</p><ol><li>获取当前值</li><li>当前值+1，计算出目标值</li><li>进行 CAS 操作，如果成功则跳出循环，如果失败则重复上述步骤</li></ol><p>这里需要注意的重点是 get 方法，这个方法的作用是获取变量的当前值。</p><p>如何保证获取的当前值是内存中的最新值？很简单，用 volatile 关键字来保证（保证线程间的可见性）。我们接下来看一下 compareAndSet 方法的实现：</p><p><img src="https://img-blog.csdn.net/2018031217514825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI5OTgxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>compareAndSet 方法的实现很简单，只有一行代码。这里涉及到两个重要的对象，一个是 unsafe，一个是 valueOffset。</p><p>什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。</p><p>至于 valueOffset 对象，是通过 unsafe.objectFiledOffset 方法得到，所代表的是 AtomicInteger 对象 value 成员变量在内存中的偏移量。我们可以简单的把 valueOffset 理解为 value 变量的内存地址。</p><p>我们上面说过，CAS 机制中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。</p><p>而 unsafe 的 compareAndSwapInt 方法的参数包括了这三个基本元素：valueOffset 参数代表了 V，expect 参数代表了A，update 参数代表了 B。</p><p>正是 unsafe 的 compareAndSwapInt 方法保证了 Compare 和 Swap 操作之间的原子性操作。</p><h1 id="5-ABA-问题"><a href="#5-ABA-问题" class="headerlink" title="5. ABA 问题"></a>5. ABA 问题</h1><p>我们现在来说什么是 ABA 问题。假设内存中有一个值为 A 的变量，存储在地址 V 中。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片09.png" alt="img"></p><p>此时有三个线程想使用 CAS 的方式更新这个变量的值，每个线程的执行时间有略微偏差。线程1和线程2已经获取当前值，线程3还未获取当前值。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片10.png" alt="img"></p><p>接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获取了当前值B。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片11.png" alt="img"></p><p>在之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片12.png" alt="img"></p><p>最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值A”，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片13.png" alt="img"></p><p>看起来这个例子没啥问题，但如果结合实际，就可以发现它的问题所在：</p><ol><li>我们假设一个提款机的例子。假设有一个遵循 CAS 原理的提款机，小灰有 100 元存款，要用这个提款机来提款 50 元。</li><li>由于提款机硬件出了点问题，小灰的提款操作被同时提交了两次，开启了两个线程，两个线程都是获取当前值 100 元，要更新成 50 元。</li><li>理想情况下，应该一个线程更新成功，一个线程更新失败，小灰的存款值被扣一次。</li><li>线程1首先执行成功，把余额从 100 改成 50，线程2因为某种原因阻塞。这时，小灰的妈妈刚好给小灰汇款 50 元。</li><li>线程2仍然是阻塞状态，线程3执行成功，把余额从 50 改成了 100。</li><li>线程2恢复运行，由于阻塞之前获得了“当前值”100，并且经过 compare 检测，此时存款实际值也是100，所以会成功把变量值100更新成50。</li><li>原本线程2应当提交失败，小灰的正确余额应该保持100元，结果由于ABA问题提交成功了。</li></ol><h2 id="解决方法—加版本号"><a href="#解决方法—加版本号" class="headerlink" title="解决方法—加版本号"></a>解决方法—加版本号</h2><p>真正要做到严谨的 CAS 机制，我们在 compare 阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。</p><p>我们仍然以刚才的例子来说明，假设地址V中存储着变量值A，当前版本号是01。线程1获取了当前值A和版本号01，想要更新为B，但是被阻塞了。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片14.png" alt="img"></p><p>这时候，内存地址V中变量发生了多次改变，版本号提升为03，但是变量值仍然是A。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片15.png" alt="img"></p><p>随后线程1恢复运行，进行 compare 操作。经过比较，线程1所获得的值和地址的实际值都是A，但是版本号不相等，所以这一次更新失败。</p><p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片16.png" alt="img"></p><p>在 Java 中，AtomicStampedReference 类就实现了用版本号作比较额 CAS 机制。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://wangjin1996219.github.io/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://wangjin1996219.github.io/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-07-20T01:13:14.000Z</published>
    <updated>2021-08-08T08:41:17.671Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-volatile-简介"><a href="#1-volatile-简介" class="headerlink" title="1. volatile 简介"></a>1. volatile 简介</h1><p>volatile 是 Java 提供的一种轻量级的同步机制。相比于 synchronized（synchronized通常称为重量级锁），volatile 更轻量级，因为它不会引起线程上下文的切换和调度。可以保证可见性和有序性，但是不能保证原子性。</p><h1 id="2-Java-内存模型（JMM）"><a href="#2-Java-内存模型（JMM）" class="headerlink" title="2. Java 内存模型（JMM）"></a>2. Java 内存模型（JMM）</h1><h2 id="2-1现代计算机内存模型"><a href="#2-1现代计算机内存模型" class="headerlink" title="2.1现代计算机内存模型"></a>2.1现代计算机内存模型</h2><p>其实早期计算机中 cpu 和内存的速度是差不多的，但在现代计算机中，cpu 的指令速度远超内存的存取速度，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲。</p><p>将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（CacheCoherence）。</p><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。</p><p><img src="/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-20-volatile关键字\图片01.png" alt="img"></p><h2 id="2-2-JavaMemoryModel"><a href="#2-2-JavaMemoryModel" class="headerlink" title="2.2 JavaMemoryModel"></a>2.2 JavaMemoryModel</h2><p><strong>Java 内存模型(JavaMemoryModel)：</strong>描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量，存储到内存和从内存中读取变量这样的底层细节。</p><p><strong>JMM 有以下规定：</strong></p><p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p><p>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</p><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p><p><img src="/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-20-volatile关键字\图片02.png" alt="img"></p><p>对于普通的共享变量来讲，线程 A 将其修改为某个值发生在线程 A 的本地内存中，此时还未同步到主内存中去；而线程 B 已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用 synchronized 或者 Lock 这些方式太重量级了，比较合理的方式其实就是 volatile。</p><p>需要注意的是，JMM 是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应 cpu 缓存和物理内存</p><h1 id="3-volatile-关键字的特性"><a href="#3-volatile-关键字的特性" class="headerlink" title="3. volatile 关键字的特性"></a>3. volatile 关键字的特性</h1><h2 id="3-1保证可见性"><a href="#3-1保证可见性" class="headerlink" title="3.1保证可见性"></a>3.1保证可见性</h2><ul><li>当写一个 volatile 变量时，JMM 会把该线程本地内存中的变量强制刷新到主内存中去；</li><li>这个写会操作会导致其他线程中的 volatile 变量缓存无效。</li></ul><h2 id="3-2禁止指令重排"><a href="#3-2禁止指令重排" class="headerlink" title="3.2禁止指令重排"></a>3.2禁止指令重排</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p><ol><li><p>重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p></li><li><p>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>比如：a=1;b=2;c=a+b 这三个操作，第一步（a=1) 和第二步 (b=2) 由于不存在数据依赖关系， 所以可能会发生重排序，但是 c=a+b 这个操作是不会被重排序的，因为需要保证最终的结果一定是 c=a+b=3。</p><p>重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行 status=true 再执行 a=2。而此时线程 B 会顺利到达4处，而线程 A 中 a=2 这个操作还未被执行，所以 b=a+1 的结果也有可能依然等于 2。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> status = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态切换为true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> changeStatus&#123;</span><br><span class="line">a = <span class="number">2</span>;   <span class="comment">//1</span></span><br><span class="line">status = <span class="keyword">true</span>;  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若状态为true，则为running</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(status)&#123;   <span class="comment">//3</span></span><br><span class="line"><span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">//4</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用 volatile 关键字修饰共享变量便可以禁止这种重排序。若用 volatile 修饰共享变量，在编译时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序，volatile 禁止指令重排序也有一些规则：</p><ol><li><p>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；</p></li><li><p>在进行指令优化时，不能将对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p><p>即执行到 volatile 变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。</p></li></ol><h1 id="4-volatile-与-synchronized-的区别"><a href="#4-volatile-与-synchronized-的区别" class="headerlink" title="4. volatile 与 synchronized 的区别"></a>4. volatile 与 synchronized 的区别</h1><ol><li>volatile 是一种轻量级锁，不会造成线程阻塞，synchronized 是重量级锁，所以同样场景下 volatile 关键字的性能更高，比如说多线程修改一个共享变量只是赋值操作，，因为赋值本身具有原子性，再由 volatile 保证可见性即可实现线程安全；</li><li>volatile 关键字只能保证可见性和有序性，但是不能保证原子性，synchronized 关键字都可以保证；</li><li> volatile 只能修饰变量，而 synchronized 可以修饰变量、方法和类。</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="http://wangjin1996219.github.io/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://wangjin1996219.github.io/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-07-19T11:16:32.000Z</published>
    <updated>2021-08-08T08:40:47.341Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-synchronized-介绍"><a href="#1-synchronized-介绍" class="headerlink" title="1. synchronized 介绍"></a>1. synchronized 介绍</h1><p>synchronized 是 Java 中的一个关键字，解决的是多个线程之间访问共享资源的同步性。它可以用在普通方法、静态方法和代码块上，synchronized 关键字可以保证在多线程环境下，同步方法或者同步代码块在同一时刻只允许有一个线程在执行，其余线程都在等待获取锁，也就是实现了整体并发中的局部串行。</p><h1 id="2-synchronized-的三种应用方式"><a href="#2-synchronized-的三种应用方式" class="headerlink" title="2. synchronized 的三种应用方式"></a>2. synchronized 的三种应用方式</h1><h2 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h2><p>同步代码块的格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象)&#123;</span><br><span class="line">    多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized(任意对象)：相当于给代码加锁了，任意时刻只能有一个线程访问共享的代码块，并且<strong>任意对象都可以看成是一把锁</strong>。</p><p>下面我们写一个包含同步代码块的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个任意对象，作为同步代码块的锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过synchronized关键字锁住共享资源</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">                Method1();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//让线程Thread-1执行方法2</span></span><br><span class="line">                Method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//同步代码块：创建两个对象my5、my6</span></span><br><span class="line">        MyRunnable2 my5 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        MyRunnable2 my6 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">19</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">25</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>可以看到<strong>同一时刻只有获取到锁对象 obj 的线程才能访问同步代码块</strong></p><p>如果将线程2的构造对象传入 My6，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my6);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>可以看到两个线程可以同时访问同步代码块，这是因为他俩访问的并不是同一块同步代码块，并且锁对象 obj 也并不是同一个锁对象，可以检验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(my5.obj==my6.obj);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><h2 id="2-同步实例方法"><a href="#2-同步实例方法" class="headerlink" title="2.同步实例方法"></a>2.同步实例方法</h2><p>同步方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法就是把 synchronized 关键字加到方法上，同步方法的锁对象是同一对象。</p><p>下面我们写一个包含同步方法的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步方法：创建两个对象my1、my2</span></span><br><span class="line">        MyRunnable my1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        MyRunnable my2 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">26</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">32</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>我们将线程2构造的对象替换成 my2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my2);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们开始传入的是同一个对象，所以线程串行访问共享资源，当我们传入的不是同一个对象时，每个对象都相当于一把锁，所以执行没有冲突。</p><p><strong>结论：</strong>所以同步方法的锁对象是 this 对象</p><h2 id="3-静态同步方法"><a href="#3-静态同步方法" class="headerlink" title="3.静态同步方法"></a>3.静态同步方法</h2><p>静态同步方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态同步方法就是把 synchronized 关键字加到静态方法上，静态同步方法的锁对象是类名。</p><p>下面我们写一个包含静态同步方法的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态同步方法：创建两个对象my3、my4</span></span><br><span class="line">        MyRunnable1 my3 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line">        MyRunnable1 my4 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:48:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:48:56:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>我们将线程2构造的对象替换成 my4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my4);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:49:47:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:49:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们可以看到，修改前后，线程的执行顺序是一样的，也就是说静态同步方法只有拿到这个 class 才能访问，而运行时 JVM 只有这一个类，所以同一时间只能有一个线程访问共享资源。</p><p><strong>结论：</strong>所以静态同步方法的锁对象是类名</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) ，因为 JVM 中，字符串常量池具有缓存功能！</p><h1 id="3-synchronized-底层实现"><a href="#3-synchronized-底层实现" class="headerlink" title="3. synchronized 底层实现"></a>3. synchronized 底层实现</h1><h2 id="3-1底层语义原理"><a href="#3-1底层语义原理" class="headerlink" title="3.1底层语义原理"></a>3.1底层语义原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。</p><h2 id="3-2-Java-对象头与-Monitor"><a href="#3-2-Java-对象头与-Monitor" class="headerlink" title="3.2 Java 对象头与 Monitor"></a>3.2 Java 对象头与 Monitor</h2><p>我们都知道对象是放在堆内存中的，对象大致可以分为三个部分，分别是<strong>对象头，实例变量和填充字节</strong></p><p><img src="https://img-blog.csdnimg.cn/20210212204438565.png" alt="在这里插入图片描述"></p><ul><li><strong>实例变量：</strong>存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按 4 字节对齐。</li><li><strong>填充数据：</strong>由于虚拟机要求对象起始地址必须是 8 字节的整数倍。<strong>填充数据不是必须存在的，仅仅是为了字节对齐</strong>，这点了解即可。</li></ul><p><strong>Java 头对象：</strong>它是实现 synchronized 锁对象的基础，一般而言，synchronized 使用的锁对象是存储在 Java 对象头里的，jvm 中采用 2 个字来存储对象头(如果对象是数组则会分配 3 个字，多出来的 1 个字记录的是数组长度)，其主要结构是由 Mark Word 和 Class Metadata Address 组成，其结构说明如下表：</p><table><thead><tr><th align="center">虚拟机位数</th><th align="center">头对象结构</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64bit</td><td align="center">Mark Word</td><td align="center">存储对象的 hashCode、锁信息或分代年龄或 GC 标志等信息</td></tr><tr><td align="center">32/64bit</td><td align="center">Class Metadata Address</td><td align="center">类型指针指向对象的类元数据，JVM 通过这个指针确定该对象是哪个类的实例。</td></tr></tbody></table><p>其中 Mark Word 在默认情况下存储着对象的 HashCode、分代年龄、锁标记位等以下是 32 位 JVM 的 Mark Word 默认存储结构：</p><table><thead><tr><th align="center">锁状态</th><th align="center">25bit</th><th align="center">4bit</th><th align="center">1bit是否是偏向锁</th><th align="center">2bit 锁标志位</th></tr></thead><tbody><tr><td align="center">无锁状态</td><td align="center">对象HashCode</td><td align="center">对象分代年龄</td><td align="center">0</td><td align="center">01</td></tr></tbody></table><p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到 JVM 的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如 32 位 JVM 下，除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：</p><p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片01.png" alt="img"></p><p>其中轻量级锁和偏向锁是 Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说 synchronized 的对象锁，锁标识位为 10，其中指针指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++实现的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor 中有两个队列，WaitSet 和 EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter 对象)，owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 EntryList 集合，当线程获取到对象的 monitor 后进入 Owner 区域并把 monitor 中的 owner 变量设置为当前线程同时 monitor 中的计数器 count 加 1，若线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减 1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor(锁)并复位变量的值，以便其他线程进入获取 monitor(锁)。如下图所示：</p><p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片02.png" alt="img"></p><p>由此看来，monitor 对象存在于每个 Java 对象的对象头中(存储的指针的指向)，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是 notify/notifyAll/wait 等方法存在于顶级对象 Object 中的原因</p><h2 id="3-3-synchronized-代码块底层原理"><a href="#3-3-synchronized-代码块底层原理" class="headerlink" title="3.3 synchronized 代码块底层原理"></a>3.3 synchronized 代码块底层原理</h2><p>现在我们重新定义一个 synchronized 修饰的同步代码块，在代码块中操作共享变量 i，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码库</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码并使用 javap 反编译后得到字节码如下(这里我们省略一部分没有必要的信息)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncCodeBlock.class</span><br><span class="line">  Last modified <span class="number">2017</span>-<span class="number">6</span>-<span class="number">2</span>; size <span class="number">426</span> bytes</span><br><span class="line">  MD5 checksum c80bc322c87b312de760942820b4fed5</span><br><span class="line">  Compiled from <span class="string">&quot;SyncCodeBlock.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">zejian</span>.<span class="title">concurrencys</span>.<span class="title">SyncCodeBlock</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  <span class="comment">//........省略常量池中数据</span></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> com.zejian.concurrencys.SyncCodeBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">  <span class="comment">//===========主要看看syncTask方法实现================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SyncCodeBlock.java&quot;</span></span><br></pre></td></tr></table></figure><p>我们主要关注字节码中的如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: monitorenter  <span class="comment">//进入同步方法</span></span><br><span class="line"><span class="comment">//..........省略其他  </span></span><br><span class="line"><span class="number">15</span>: monitorexit   <span class="comment">//退出同步方法</span></span><br><span class="line"><span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line"><span class="comment">//省略其他.......</span></span><br><span class="line"><span class="number">21</span>: monitorexit <span class="comment">//退出同步方法</span></span><br></pre></td></tr></table></figure><p>从字节码中可知同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置，当执行 monitorenter 指令时，当前线程将试图获取 objectref (即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即 monitorexit 指令被执行，执行线程将释放 monitor (锁)并设置计数器值为 0，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个 monitorexit 指令，它就是异常结束时被执行的释放 monitor 的指令。</p><h2 id="3-4-synchronized-方法底层原理"><a href="#3-4-synchronized-方法底层原理" class="headerlink" title="3.4 synchronized 方法底层原理"></a>3.4 synchronized 方法底层原理</h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM 可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有 monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放 monitor。在方法执行期间，执行线程持有了 monitor，其他任何线程都无法再获得同一个 monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的 monitor 将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 javap 反编译后的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncMethod.class</span><br><span class="line">  Last modified <span class="number">2017</span>-<span class="number">6</span>-<span class="number">2</span>; size <span class="number">308</span> bytes</span><br><span class="line">  MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94</span><br><span class="line">  Compiled from <span class="string">&quot;SyncMethod.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">zejian</span>.<span class="title">concurrencys</span>.<span class="title">SyncMethod</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略没必要的字节码</span></span><br><span class="line">  <span class="comment">//==================syncTask方法======================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SyncMethod.java&quot;</span></span><br></pre></td></tr></table></figure><p>从字节码中可以看出，synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是 synchronized 锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Java 6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下 Java 官方在 JVM 层面对 synchronized 锁的优化。</p><h1 id="4-JVM-对-synchronized-的优化"><a href="#4-JVM-对-synchronized-的优化" class="headerlink" title="4. JVM 对 synchronized 的优化"></a>4. JVM 对 synchronized 的优化</h1><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。然后我们来看一下锁的原理和膨胀（升级）过程。</p><p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片03.png"></p><h2 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1.偏向锁"></a>1.偏向锁</h2><p><strong>偏向锁的原理：</strong></p><p>偏向锁是 Java 6 之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p><strong>偏向锁的升级：</strong></p><p>当线程 1 访问代码块并获取锁对象时，会在 java 对象头和栈帧中记录偏向的锁的 threadID，因为偏向锁不会主动释放锁，因此以后线程 1 再次获取锁的时候，需要比较当前线程的 threadID 和 Java 对象头中的 threadID 是否一致，如果一致（还是线程 1 获取锁对象），则无需使用 CAS 来加锁、解锁；如果不一致（其他线程，如线程 2 要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程 1 的 threadID），那么需要查看 Java 对象头中记录的线程 1 是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程 1，撤销偏向锁，升级为轻量级锁，如果线程 1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p><h2 id="2-轻量级锁与自旋锁"><a href="#2-轻量级锁与自旋锁" class="headerlink" title="2.轻量级锁与自旋锁"></a>2.轻量级锁与自旋锁</h2><p><strong>为什么要有轻量级锁？</strong></p><p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要 CPU 从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</p><p><strong>轻量级锁与自旋锁原理与锁升级过程：</strong></p><p>线程 1 获取轻量级锁时会先把锁对象的对象头 MarkWord 复制一份到线程 1 的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用 CAS 把对象头中的内容替换为线程 1 存储的锁记录（DisplacedMarkWord）的地址；</p><p>如果在线程 1 复制对象头的同时（在线程1 CAS 之前），线程 2 也准备获取锁，复制了对象头到线程 2 的锁记录空间中，但是在线程2 CAS 的时候，发现线程 1 已经把对象头换了，线程 2 的 CAS 失败，那么线程 2 就尝试使用自旋锁来等待线程 1 释放锁。 自旋锁简单来说就是让线程 2 在循环中不断 CAS</p><p>但是如果自旋的时间太长也不行，因为自旋是要消耗 CPU 的，因此自旋的次数是有限制的，比如 10 次或者 100 次，如果自旋次数到了线程 1 还没有释放锁，或者线程 1 还在执行，线程 2 还在自旋等待，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止 CPU 空转。</p><h2 id="3-几种锁的对比"><a href="#3-几种锁的对比" class="headerlink" title="3.几种锁的对比"></a>3.几种锁的对比</h2><p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片04.png" alt="在这里插入图片描述"></p><h1 id="5-如何保证原子性、有序性和可见性"><a href="#5-如何保证原子性、有序性和可见性" class="headerlink" title="5.如何保证原子性、有序性和可见性"></a>5.如何保证原子性、有序性和可见性</h1><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h2><p><strong>原子性：</strong> 即一个操作或者多个操作 <strong>要么全部执行并且执行的过程不会被任何因素打断</strong>，要么就都<strong>不执行</strong>。</p><p><strong>实现方式：</strong>Java 内存模型提供了字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式的使用这两个操作，在 synchronized 块之间的操作是具备原子性的。</p><p><strong>例：</strong>线程 1 在执行 monitorenter 指令的时候，会对 Monitor 进行加锁，加锁后其他线程无法获得锁，除非线程 1 主动解锁。即使在执行过程中，由于某种原因，比如 CPU 时间片用完，线程 1 放弃了 CPU，但是它并没有进行解锁。而由于 synchronized 的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。</p><h2 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h2><p><strong>有序性：</strong> 程序执行的顺序按照代码的先后顺序执行。</p><p><strong>实现方式：</strong>在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。但是 synchronized 提供了有序性保证，这其实和 as-if-serial 语义有关。<br>as-if-serial 语义是指不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的，由于 synchronized 修饰的代码，同一时间只能被同一线程访问。那么可以认为是单线程执行的。所以可以保证其有序性。</p><blockquote><p><strong>Note：</strong>需要注意的是<code>synchronized</code>虽然能够保证有序性，但是<code>无法禁止指令重排和处理器优化的</code>。</p></blockquote><h2 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3.可见性"></a>3.可见性</h2><p><strong>可见性：</strong> 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>实现方式：</strong>被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁，但在一个变量解锁之前，必须先把此变量<code>同步回主存</code>中，这样解锁后，后续其它线程就可以访问到被修改后的值，从而保证可见性。</p><ul><li>获得锁之后，需要<strong>刷新处理器缓存</strong>，使得前面写线程所做的更新可以同步到本线程。 </li><li>释放锁需要<strong>冲刷处理器缓存</strong>，使得当前线程对共享数据的改变可以被推送到下一个线程处理器的高速缓冲中。</li></ul><h1 id="6-JVM-对-synchronized-内部锁的调度"><a href="#6-JVM-对-synchronized-内部锁的调度" class="headerlink" title="6. JVM 对 synchronized 内部锁的调度"></a>6. JVM 对 synchronized 内部锁的调度</h1><p><strong>先来看下 JVM 对锁这种资源的两种调度方式：公平调度和非公平调度。</strong></p><p><strong>1.公平调度方式</strong></p><p>按照<strong>申请的先后顺序</strong>授予资源的独占权。</p><ul><li>优点：线程申请资源所需的时间偏差较小；不会出现线程饥饿的现象；适合在资源的持有线程占用资源的时间相对长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。</li><li>缺点：吞吐率较小 </li></ul><p><strong>2.非公平调度方式</strong></p><p>在该策略中，资源的持有线程释放该资源的时候，等待队列中一个线程会被唤醒，而该线程从被唤醒到其继续执行可能需要一段时间。在该段时间内，<strong>新来的线程（活跃线程）</strong>可以先被授予该资源的独占权。</p><p>如果新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续执行前释放相应的资源，从而不影响该被唤醒的线程申请资源。</p><ul><li>优点：吞吐率较高，单位时间内可以为更多的申请者调配资源 </li><li>缺点：资源申请者申请资源所需的时间偏差可能较大，并可能出现线程饥饿的现象 </li></ul><p><strong>JVM 对 synchronized 内部锁的调度：</strong></p><p>JVM 对内部锁的调度是一种<strong>非公平的调度方式</strong>，JVM 会给每个内部锁分配一个<strong>入口集（Entry Set）</strong>，用于记录等待获得相应内部锁的线程。当锁被持有的线程释放的时候，该锁的入口集中的任意一个线程将会被唤醒，从而得到再次申请锁的机会。被唤醒的线程等待占用处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放的锁。也就是并不是先到先得的顺序。</p><h1 id="7-synchronized-和-ReentrantLock-的区别"><a href="#7-synchronized-和-ReentrantLock-的区别" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别"></a>7. synchronized 和 ReentrantLock 的区别</h1><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReentrantLock 首先是使用更加灵活了，synchronized 的锁定粒度比较大，在方法层面，而 ReentrantLock 能够锁定任意的代码区域。并且 ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><p><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p></li><li><p><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</p></li><li><p>synchronized 关键字与 wait() 和 notify()/notifyAll() 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于Condition接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll() 方法 只会唤醒注册在该 Condition 实例中的所有等待线程。</p></li><li><p><strong>附加：</strong>ReentrantLock 提供了一个 tryLock 方法，该方法尝试获取锁，成功的话返回 true ，失败的话不会导致尝试获取锁的线程暂停而是返回 false，可以避免死锁。（起预判作用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deathLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//如果获取成功则执行业务逻辑，如果获取失败，则释放lock1的锁，自旋重新尝试获得锁</span></span><br><span class="line">                            <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;Thread1：已成功获取 lock1 and lock2 ...&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock2.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1：获取锁失败，重新获取---&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//防止发生活锁</span></span><br><span class="line">                        TimeUnit.NANOSECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//如果获取成功则执行业务逻辑，如果获取失败，则释放lock2的锁，自旋重新尝试获得锁</span></span><br><span class="line">                            <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;Thread2：已成功获取 lock2 and lock1 ...&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock1.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2：获取锁失败，重新获取---&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//防止发生活锁</span></span><br><span class="line">                        TimeUnit.NANOSECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            deathLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该示例启动两个线程。线程1首先获取lock1的锁，然后再获取lock2的锁；线程2首先获取lock2的锁，然后再获取lock1的锁。这样如果这时线程1获得了lock1的锁，同时线程2获得lock2的锁，然后线程1尝试去获得lock2的锁，线程2尝试获得线程1的锁，就会造成死锁。</p><p>我们这里使用 tryLock 来获取两个锁，如果一个线程不能同时获取两把锁，那么就回退并自旋重新尝试（使用 while 循环）。</p></li></ul><p><strong>应该怎么选择这两种锁：</strong></p><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-synchronized-介绍&quot;&gt;&lt;a href=&quot;#1-synchronized-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. synchronized 介绍&quot;&gt;&lt;/a&gt;1. synchronized 介绍&lt;/h1&gt;&lt;p&gt;syn</summary>
      
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>大数据和空间限制与系统设计题目汇总</title>
    <link href="http://wangjin1996219.github.io/2021/07/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <id>http://wangjin1996219.github.io/2021/07/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</id>
    <published>2021-07-16T06:48:12.000Z</published>
    <updated>2021-08-02T05:43:16.709Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="海量数据处理例题"><a href="#海量数据处理例题" class="headerlink" title="海量数据处理例题"></a>海量数据处理例题</h1><h2 id="1-如何从大量的-URL-中找出相同的-URL？"><a href="#1-如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="1.如何从大量的 URL 中找出相同的 URL？"></a>1.如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p><h3 id="思路一（分治-HashSet）"><a href="#思路一（分治-HashSet）" class="headerlink" title="思路一（分治+HashSet）"></a>思路一（分治+HashSet）</h3><p><strong>分析：</strong></p><p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。</p><p>对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p><p><strong>思路：</strong></p><p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, …, a<sub>999</sub>，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b<sub>0</sub>, b<sub>1</sub>, b<sub>2</sub>, …, b<sub>999</sub> 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a<sub>0</sub> 对应 b<sub>0</sub>, …, a<sub>999</sub> 对应 b<sub>999</sub>， 。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。（这里要注意因为使用的是 Hash，所以不同对中一定没有相同的元素）</p><p>接着遍历 a<sub>i</sub>( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 b<sub>i</sub> 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p><h3 id="思路二（分治-前缀树）"><a href="#思路二（分治-前缀树）" class="headerlink" title="思路二（分治+前缀树）"></a>思路二（分治+前缀树）</h3><p>在比较每一对中是否有相同元素的时候，可以通过前缀树来比较，因为一般而言，URL 的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>这种数据结构来进行存储。</p><p>字典树的优势：<strong>降低存储成本的同时，提高查询效率</strong>。</p><h2 id="2-如何从大量数据中找出高频词？"><a href="#2-如何从大量数据中找出高频词？" class="headerlink" title="2.如何从大量数据中找出高频词？"></a>2.如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p><h3 id="思路一（分治-HashMap-小顶堆）"><a href="#思路一（分治-HashMap-小顶堆）" class="headerlink" title="思路一（分治+HashMap+小顶堆）"></a>思路一（分治+HashMap+小顶堆）</h3><p><strong>分析：</strong></p><p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p><p><strong>思路：</strong></p><p>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 a<sub>i</sub> 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p><p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。</p><p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p><h2 id="3-如何在大量的数据中找出不重复的整数？"><a href="#3-如何在大量的数据中找出不重复的整数？" class="headerlink" title="3.如何在大量的数据中找出不重复的整数？"></a>3.如何在大量的数据中找出不重复的整数？</h2><h3 id="方案（BitMap-布隆过滤器）"><a href="#方案（BitMap-布隆过滤器）" class="headerlink" title="方案（BitMap+布隆过滤器）"></a>方案（BitMap+布隆过滤器）</h3><p><strong>BitMap 介绍：</strong></p><p>布隆过滤器是基于 BitMap+Hash 实现的。</p><p>Bit-map 的基本思想就是用一个 bit 位来标记某个元素对应的 Value，而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，因此在存储空间方面，可以大大节省。（PS：划重点 <strong>节省存储空间</strong>）</p><p>假设有这样一个需求：在 20 亿个随机整数中找出某个数 m 是否存在其中，并假设 32 位操作系统，4G 内存</p><p>在 Java 中，int 占 4 字节，1字节=8位（1 byte = 8 bit）</p><p>如果每个数字用 int 存储，那就是 20 亿个 int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈<strong>7.45</strong>G</p><p>如果按位存储就不一样了，20 亿个数就是 20 亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈<strong>0.233</strong>G</p><p>那么，问题来了，如何表示一个数呢？</p><p>刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制</p><p>这样我们可以很容易表示 {1,2,4,6} 这几个数：</p><p><img src="/2021/07/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/GitHub\MyBlogs\source_posts\2021-07-16-大数据和空间限制与系统设计题目汇总\图片01.png" alt="img"></p><p><strong>适用场景：</strong>海量数据中的数据重复问题，像消息过滤啥的。</p><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>不安全网页的黑名单包含 100 亿个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一种网页过滤系统，可以根据网页的 URL 判断该网页是否在黑名单上，如何设计该系统。</p><p><strong>要求：</strong>允许有万分之一以下的判断失误率；使用的额外空间不能超过 30GB</p><p><strong>分析：</strong>我们可以选择用 <strong>HashMap或者数据库</strong> 来将 100 亿个 url 都保存下来，但是这样至少需要 640GB 的内存空间，并且允许一定程度的失误率，所以考虑使用 BitMap，或者说布隆过滤器。</p><p><strong>总结：</strong>如果遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，并且系统容忍一定程度的失误率以及对空间要求比较严格，那么需要用<strong>布隆过滤器（BitMap）</strong>来解答。布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。但是想做到完全正确是不可能的。布隆过滤器的优势就在于使用很少的空间就可以将准确率做到很高的程度。</p><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>32 位无符号整数的范围是 0~4294967295，现在正好有一个包含 40 亿个无符号整数的文件，所有在文件中没有出现过的数。</p><p><strong>Q1：</strong>最多使用1GB，找到所有没出现过的数。</p><p><strong>分析：</strong>如果 40 亿个数都不同，则哈希表记录数为 40 亿条，所需要空间 40亿×4B=16GB，显然不符合要求。</p><p><strong>解决办法：</strong>由于哈希表需要占用很多空间，因此可以使用 BitMap 的方式来表示数出现的情况。即申请一个长度为 4294967295 的 bit 类型的数组bitArr，bitArr 上每一个位置只可以表示0或1。由于 1B=8bit，所以 4294967295 个 bit 占用空间为 500MB。遍历完成后，<strong>再遍历一遍，发现哪个位置上的值不是1，就说明这个数不在 40 亿个数中。</strong></p><p><strong>Q2：</strong>最多使用1GB，找出所有出现了两次的数。</p><p><strong>解决办法：</strong>使用 BitMap 的方式来表示数出现的情况，即申请一个<strong>长度为 4294967295×2 的 bit 类型的数组 bitArr</strong>，由于 1B=8bit，所以所以 4294967295 ×  2 个 bit 占用空间为1GB。遍历这40亿个数，如果第一次遇到 num，就把 bitArr[num * 2+1] 和 bitArr[num * 2] 设置为 01，第二次设置为 10，第三次设置为 11，之后就不再管了。然后依次遍历 bitArr，如果发现 bitArr[num * 2+1] 和 bitArr[num * 2] 为 10，那么i就是出现了两次的数。</p><p><strong>Q3：</strong>最多使用 10MB，只用找到一个没出现过的数即可。</p><p><strong>解决办法：</strong>将 0~4294967295 区间平均分成 64 个区间，每个区间是 67108864 个数，由于只有 40 亿个数，因此至少有一个区间上的计数少于 67108864。</p><p>第一次遍历：申请长度为 64 的整形数组 countArr[0…63]，<strong>countArr[i] 表示区间i上的数有多少个</strong>。例如，遍历到 3422552090 时， 3422552090/67108864=51，因此 countArr[51]++。遍历完 40 亿个数之后，一定存在 count[i] 小于 67108864，找到第一个 i 即可。此时内存为 64×4B。</p><p>第二次遍历：假设第一步的 i=37。申请<strong>长度为 67108864 的 bit map</strong>，内存大小大约为 8MB，记为 bitArr[0…67108863]。然后再遍历一次 40 亿个数，此时只关注落在第 37 区间的数，即满足 num/67108864=37的num。然后将 bitArr[num  - 67108864*37]=1，然后遍历 bitArr，找到 bitArr[i] 不等于 1 的 i 值，然后 67108864×37+i 就是第一个没出现过的数。</p><h2 id="4-最多使用-10MB，找到-40-亿个整数的中位数。"><a href="#4-最多使用-10MB，找到-40-亿个整数的中位数。" class="headerlink" title="4.最多使用 10MB，找到 40 亿个整数的中位数。"></a>4.最多使用 10MB，找到 40 亿个整数的中位数。</h2><h3 id="思路一（分治）"><a href="#思路一（分治）" class="headerlink" title="思路一（分治）"></a>思路一（分治）</h3><p>长度为 2MB 的无符号整型数组占用的空间为 8MB，所以将区间的数量定位 4294967295/2M=2148 个。申请一个长度为 2148 的无符号整型数组 arr[0…2147]，arr[i] 表示第i区间有多少个数。然后遍历这 40 亿个数，将对应的进行 arr[num/2M]++ 操作，然后累加每个区间的出现次数，如果 0~K-1 区间上的数的个数为 19.998 亿，但是当加上第 K 个区间上的数的个数后就超过了 20 亿，因此第 20 亿个数是第K区间上第 0.002 亿个数。</p><p>然后申请一个长度为 2MB 的无符号整型数组 countArr[0…2M-1]，占用空间是 8MB。然后遍历这 40 亿个数，只对第 K 区间的数做统计，countArr[numi - K * 2M]++，然后只在第K区间上找到第 0.002 亿个数即可。</p><h3 id="思路二（双堆法）"><a href="#思路二（双堆法）" class="headerlink" title="思路二（双堆法）"></a>思路二（双堆法）</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p><p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p><h1 id="海量数据处理方法总结"><a href="#海量数据处理方法总结" class="headerlink" title="海量数据处理方法总结"></a>海量数据处理方法总结</h1><h2 id="1-Bloom-filter（布隆过滤器）"><a href="#1-Bloom-filter（布隆过滤器）" class="headerlink" title="1.Bloom filter（布隆过滤器）"></a>1.Bloom filter（布隆过滤器）</h2><p><strong>原理：</strong>上面有</p><p><strong>适用场景：</strong>可以用来实现数据字典，进行数据的判重，或者集合求交集</p><h2 id="2-哈希"><a href="#2-哈希" class="headerlink" title="2.哈希"></a>2.哈希</h2><p><strong>原理：</strong>哈希函数</p><p><strong>适用场景：</strong>快速查找，删除的基本数据结构，还可以通过 HashMap 进行频率的统计等，通常需要总数据量可以放入内存</p><h2 id="3-位数组"><a href="#3-位数组" class="headerlink" title="3.位数组"></a>3.位数组</h2><p><strong>原理：</strong>上面有</p><p><strong>适用场景：</strong>可进行数据的快速查找，判重（判断元素是否存在），删除</p><h2 id="4-分治"><a href="#4-分治" class="headerlink" title="4.分治"></a>4.分治</h2><p><strong>原理：</strong>将数据交给不同的机器去处理，数据划分，结果归约</p><p><strong>适用场景：</strong>通常是大量的数据不能放入内存中的情况，分成多个小文件，最后再整合处理</p><h1 id="系统设计问题"><a href="#系统设计问题" class="headerlink" title="系统设计问题"></a>系统设计问题</h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="面试相关" scheme="http://wangjin1996219.github.io/categories/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="场景题" scheme="http://wangjin1996219.github.io/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>死锁问题</title>
    <link href="http://wangjin1996219.github.io/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <id>http://wangjin1996219.github.io/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-15T06:51:56.000Z</published>
    <updated>2021-08-08T08:40:05.274Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1.死锁的概念"></a>1.死锁的概念</h1><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><h1 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2.死锁产生的必要条件"></a>2.死锁产生的必要条件</h1><p>线程死锁的发生离不开下面四个条件：</p><ol><li><strong>互斥条件：</strong>该资源任意一个时刻只由一个线程占用。只有互斥使用的资源才会导致死锁（如打印机设备），像内存、扬声器这种可以让多个进程共享使用的资源不可能造成死锁（因为进程不用阻塞等待）。</li><li><strong>请求与保持条件：</strong>已经得到了某个资源的进程可以再请求新的资源，但是新的资源被其它进程占用，此时进程阻塞，但是又对已获得的资源保持不放。</li><li><strong>不剥夺条件：</strong>线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后主动释放资源。</li><li><strong>循环等待条件：</strong>存在一种进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。</li></ol><blockquote><p><strong>Note：</strong>发生死锁一定有循环等待关系，但是有循环等待关系不一定发生死锁，有同类型的资源可满足其中一个进程的需求时。</p></blockquote><h1 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3.死锁的处理策略"></a>3.死锁的处理策略</h1><ol><li>预防死锁：破坏死锁产生的四个必要条件中的一个或几个；</li><li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）；</li><li>死锁的检测和接触：允许死锁的发生，不过操作系统会检测出死锁的发生，然后采取某种措施解除死锁。</li></ol><p>前两种方式不会产生死锁，但是最后一种会产生，产生之后再解决。</p><h2 id="3-1预防死锁"><a href="#3-1预防死锁" class="headerlink" title="3.1预防死锁"></a>3.1预防死锁</h2><p>核心思想：破坏死锁产生的四个必要条件</p><ol><li><p><strong>破坏互斥条件：</strong>将原来的互斥使用的资源，通过 SPOOLing 技术改造成共享资源，其实是将请求放到了输出进程中，然后请求进程可以继续向下执行的一种策略，且在并发请求的进程看来，好像资源是可以共享的。</p><p>但是并不是所有的资源都可以这样改造，所以应用比较少。</p></li><li><p><strong>不可剥夺条件：</strong></p><p>方案一：当某个进程请求新的资源得不到满足时，他必须立刻释放保持的所有资源，待以后需要时再申请，也就是某些资源还没使用完，也要主动释放，这就破坏了不可剥夺条件；</p><p>方案二：当某个进程需要的资源被其它进程所占用的时候，可以根据优先级由操作系统配合将低优先级进程的资源剥夺给高优先级的进程使用。</p></li><li><p><strong>破坏请求与保持条件：</strong>一次性申请所有的资源。比如使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。<strong>（即加大锁的粒度）</strong></p></li><li><p><strong>破坏循坏等待条件：</strong>可以采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完。这样一个进程只有已占有小编号的资源时，才有资格去申请大编号的资源，已经持有大编号资源的进程不可能逆向地回来申请小编号资源，就不会产生循环等待的问题。</p><p>但是如果系统有新增资源，就可能需要重新分配所有编号；进程实际使用资源顺序可能和编号递增顺序不一致，可能造成资源浪费；必须按照次序申请资源，造成编程复杂。</p></li></ol><h2 id="3-2避免死锁"><a href="#3-2避免死锁" class="headerlink" title="3.2避免死锁"></a>3.2避免死锁</h2><h3 id="1-安全序列与安全状态"><a href="#1-安全序列与安全状态" class="headerlink" title="1.安全序列与安全状态"></a>1.安全序列与安全状态</h3><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片01.png" alt="img"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和  A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>所谓的安全序列就是指，如果系统按照这种序列分配资源，每个进程都能顺利完成，只要能找到一个安全序列，系统就是安全状态。当然安全序列可以有多个。</p><p>但是如果分配了资源以后，系统找不出任何一个安全序列，系统就进入了不安全状态，这就意味着所有进程无法执行下去。当然不排除有些进提前释放了资源，回到安全状态，但是我们一般考虑到最坏的情况。</p><h3 id="2-安全状态与死锁的关系"><a href="#2-安全状态与死锁的关系" class="headerlink" title="2.安全状态与死锁的关系"></a>2.安全状态与死锁的关系</h3><p>如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但是发生死锁一定是不安全状态）</p><p>因此可以在系统分配资源之前预判是否会使系统进入不安全状态，以此决定是否分配请求，这也是“银行家算法”的核心思想。</p><h3 id="3-单个资源的银行家算法"><a href="#3-单个资源的银行家算法" class="headerlink" title="3.单个资源的银行家算法"></a>3.单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片02.png" alt="img"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="4-多个资源的银行家算法"><a href="#4-多个资源的银行家算法" class="headerlink" title="4.多个资源的银行家算法"></a>4.多个资源的银行家算法</h3><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片03.png" alt="img"></p><blockquote><p>将资源变成向量的形式。</p></blockquote><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A  分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1，0，2，0)，表示 4 个资源分别还剩下 1/0/2/0。</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h2 id="3-3死锁的检测与解除"><a href="#3-3死锁的检测与解除" class="headerlink" title="3.3死锁的检测与解除"></a>3.3死锁的检测与解除</h2><h3 id="1-死锁的检测"><a href="#1-死锁的检测" class="headerlink" title="1.死锁的检测"></a>1.死锁的检测</h3><p><strong>1.每种类型一个资源的死锁检测</strong></p><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片04.png" alt="img"></p><p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p><p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>2.每种类型多个资源的死锁检测</strong></p><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片05.png" alt="img"></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p><p>算法总结如下：</p><p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p><ol><li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li><li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li><li>如果没有这样一个进程，算法终止。</li></ol><h3 id="2-死锁的恢复"><a href="#2-死锁的恢复" class="headerlink" title="2.死锁的恢复"></a>2.死锁的恢复</h3><p>检测到死锁的存在，并不是说系统中所有的进程都是死锁进程。</p><ol><li><strong>资源剥夺法：</strong>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其它的死锁进程，但是也要防止被挂起的进程长时间得不到资源而饥饿；</li><li><strong>撤销进程法：</strong>强制撤销所有的死锁进程，并剥夺这些进程的资源，这种方式实现比较简单，但是代价比较大，可能有些资源已经接近完成，最后被撤销。</li><li><strong>进程回退法：</strong>让一个进程回退到之前的一种状态，可以阻止死锁的时候，可以将资源先给其它进程，这就要求系统记录还原点。</li></ol><p>如何决定对谁动手？</p><ol><li>进程优先级</li><li>已执行时间</li><li>还要多久完成</li><li>进程使用的资源数量</li><li>进程是交互式的还是批处理式的</li></ol><h1 id="4-线程的活性故障"><a href="#4-线程的活性故障" class="headerlink" title="4.线程的活性故障"></a>4.线程的活性故障</h1><p>线程的活性故障是由于资源的稀缺性或者程序自身的问题导致线程<strong>一直处于非Runnable状态</strong>，并且其处理的任务<strong>一直无法完成的现象</strong>被称为是线程活性故障。常见的线程活性故障包括<strong>死锁，锁死，活锁与线程饥饿</strong>。</p><p><strong>解析：</strong>每一个线程都有其特定的任务处理逻辑。由于资源的稀缺性或者资源本身的一些特性，导致多个线程需要共享一些排他性资源，比如说处理器，数据库连接等。当出现资源争用的时候，部分线程会进入等待状态。</p><h2 id="4-1线程锁死与死锁"><a href="#4-1线程锁死与死锁" class="headerlink" title="4.1线程锁死与死锁"></a>4.1线程锁死与死锁</h2><p><strong>1.线程锁死的外部表现，以及与死锁的区别</strong></p><p>线程锁死是指等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务 一直无法进展。</p><p>线程死锁和线程锁死的外部表现是一致的，即故障线程一直处于非运行状态使得其所执行的任务没有进展。但是锁死的产生条件和线程死锁不一样，即使产生死锁的4个必要条件都没有发生，线程锁死仍然可能已经发生。</p><p><strong>2.线程锁死发生的几种情况</strong></p><ul><li><p><strong>信号丢失锁死</strong></p><p>信号丢失锁死是因为没有对应的通知线程来将等待线程唤醒，导致等待线程一直处于等待状态。</p><p><strong>典型例子</strong>是等待线程在执行Object.wait( )/Condition.await( )前<strong>没有对保护条件进行判断，而此时保护条件实际上可能已经成立</strong>，此后可能并无其他线程更新相应保护条件涉及的共享变量使其成立并通知等待线程，这就使得等待线程一直处于等待状态，从而使其任务一直无法进展。</p></li><li><p><strong>嵌套监视器锁死</strong></p><p>嵌套监视器锁死是由于嵌套锁导致等待线程永远无法被唤醒的一种故障。</p><p>比如一个线程，只释放了内层锁Y.wait()，但是没有释放外层锁X; 但是通知线程必须先获得外层锁X，才可以通过 Y.notifyAll()来唤醒等待线程，这就导致出现了嵌套等待现象。</p></li></ul><h2 id="4-2线程活锁与死锁"><a href="#4-2线程活锁与死锁" class="headerlink" title="4.2线程活锁与死锁"></a>4.2线程活锁与死锁</h2><p><strong>1.线程活锁的概念</strong></p><p>线程活锁是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的 CPU 时间。</p><p><strong>2.线程活锁与死锁的区别</strong></p><p>活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是一直在不断改变的，活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的 CPU 时间。活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行。</p><h2 id="4-3线程饥饿与死锁"><a href="#4-3线程饥饿与死锁" class="headerlink" title="4.3线程饥饿与死锁"></a>4.3线程饥饿与死锁</h2><p><strong>1.线程饥饿的概念</strong></p><p>饥饿是指如果线程 T1 占用了资源 R，线程 T2 又请求锁 R，于是 T2 等待。T3 也请求资源 R，当 T1 释放了 R 上的封锁后，系统首先批准了 T3 的请求，T2 仍然等待。然后 T4 又请求封锁 R，当 T3 释放了 R 上的封锁之后，系统又批准了 T4 的请求……，T2 可能永远等待。</p><p>这也就是 ReentrantLock 显示锁里提供的不公平锁机制（当然了，ReentrantLock 也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p><p><strong>2.线程饥饿与死锁活锁的区别</strong></p><p>进程会处于饥饿状态是因为持续地有其它优先级更高的进程请求相同的资源。不像死锁或者活锁，饥饿能够被解开。例如，当其它高优先级的进程都终止时并且没有更高优先级的进程到达。</p><h2 id="4-4线程活性故障总结"><a href="#4-4线程活性故障总结" class="headerlink" title="4.4线程活性故障总结"></a>4.4线程活性故障总结</h2><ul><li>线程饥饿发生时，如果线程处于可运行状态，也就是其一直在申请资源，那么就会转变为活锁 </li><li>只要存在一个或多个线程因为获取不到其所需的资源而无法进展就是线程饥饿，所以线程死锁、活锁其实也算是线程饥饿 </li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://wangjin1996219.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="操作系统相关" scheme="http://wangjin1996219.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>（四）优惠券系统-系统通用组件搭建</title>
    <link href="http://wangjin1996219.github.io/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://wangjin1996219.github.io/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2021-07-13T13:41:06.000Z</published>
    <updated>2021-08-08T03:43:03.887Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-SpringCloud-四大组件"><a href="#1-SpringCloud-四大组件" class="headerlink" title="1. SpringCloud 四大组件"></a>1. SpringCloud 四大组件</h1><h2 id="1-1-Eureka"><a href="#1-1-Eureka" class="headerlink" title="1.1 Eureka"></a>1.1 Eureka</h2><h3 id="Eureka-的组成"><a href="#Eureka-的组成" class="headerlink" title="Eureka 的组成"></a>Eureka 的组成</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片01.png" style="zoom: 50%;"><p>Eureka 可以分成两大部分：Server 与 Client。</p><p>Client 的四个基本功能有：</p><ol><li><p>服务注册：客户端Client 在启动后，向配置的 服务端Server 发起注册，把自身信息提供给 Server。</p></li><li><p>心跳续约：Client 和 Server 之间维护的一个定时心跳（Eureka 发起的主动操作 （Client ping Server）），表示还在存活着。</p></li><li><p>下线：EurekaClient 关闭后，向 Server 发起通知，Server 把信息清理掉。</p></li><li><p>获取服务注册信息：Eureka Client 之间相互调用，需要知道不同的 Eureka 之间的源信息。从 Eureka Server 中获取。</p></li></ol><h3 id="Eureka-的工作原理"><a href="#Eureka-的工作原理" class="headerlink" title="Eureka 的工作原理"></a>Eureka 的工作原理</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片02.png" style="zoom:67%;"><p>上图中我们首先会启动一个或多个 Eureka server，这些 eureka server 同步保留着所有的服务信息。然后我们启动不同的 eureka client，向服务端发起服务注册和服务查询。<strong>不论我们是向那个 eureka server 进行的注册，最终都会同步给所有配置好的 eureka server。我们获取的服务信息，也同样都是一致的。</strong></p><p>要知道 Eureka 与 Zookeeper 的对比，参考《SpringCloud相关》</p><p><strong>Eureka Server 是怎么存储服务元信息的：</strong></p><p>通过一个两层的 HashMap 来存储</p><ul><li>第一层的 HashMap：Key 存放的是<strong>应用的名称</strong>，每个微服务都是一个应用，一个应用中可以包含多个实例</li><li>第二层的 HashMap：Key 存放的是<strong>实例的名称</strong>，Value 存放实例的地址，比如实例的 IP、端口号、状态信息等</li></ul><h3 id="Eureka-模块搭建"><a href="#Eureka-模块搭建" class="headerlink" title="Eureka 模块搭建"></a>Eureka 模块搭建</h3><p><strong>1.搭建父模块</strong></p><p>修改 pom.xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子模块，新建model后会自动生成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的打包类型, 即项目的发布形式, 默认为 jar. 对于聚合项目的父模块来说, 必须指定为 pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springCloud 也是基于Springboot开发，引入springboot 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringCloud版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok 工具通过在代码编译时期动态的将注解替换为具体的代码,</span></span><br><span class="line"><span class="comment">       IDEA 需要添加 lombok 插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试用例依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 标识springcloud版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置远程仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.搭建 coupon-eureka 模块</strong></p><p>修改 pom.xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块名及描述信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Cloud Eureka For Coupon<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- eureka server: 提供服务发现与服务注册 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将</span></span><br><span class="line"><span class="comment">        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.编写一个应用启动类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//标识为一个EurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//标识是一个SpringBoot应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.配置 EurekaServer：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 标识是否从 Eureka Server 获取注册信息, 默认是 true. 如果这是一个单节点的 Eureka Server</span></span><br><span class="line"><span class="comment">    # 不需要同步其他节点的数据, 设置为 false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 是否将自己注册到 Eureka Server, 默认是 true. 由于当前应用是单节点的 Eureka Server</span></span><br><span class="line"><span class="comment">    # 需要设置为 false</span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 设置 Eureka Server 所在的地址, 查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p><strong>5.启动 springboot 程序，测试 Eureka Server：</strong></p><p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片03.png"></p><h3 id="集群-Eureka-Server-模块搭建"><a href="#集群-Eureka-Server-模块搭建" class="headerlink" title="集群 Eureka Server 模块搭建"></a>集群 Eureka Server 模块搭建</h3><p>除了新建一个与上面相同的 Eureka Server 应用之外，最主要的区别就是修改配置文件：</p><p><strong>1.修改配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#节点1</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server1</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8000</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server1</span></span><br><span class="line"><span class="comment">    #是否允许一台机器部署多个实例</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      #实现相互注册，配置集群其它节点的地址</span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server2:8001/eureka/,http://server3:8002/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="comment">#节点2</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server2</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8001</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server2</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/,http://server3:8002/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="comment">#节点3</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server3</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8002</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server3</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/,http://server2:8001/eureka/</span></span><br></pre></td></tr></table></figure><p>注意：bootstrap.yml 比 application.yml 优先级要高，也就是优先根据这个配置来</p><p><strong>2.配置 hosts 文件</strong></p><p>windows 系统，打开路径 <strong>C:\Windows\System32\drivers\etc，</strong>修改配置文件添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1  server1</span><br><span class="line">127.0.0.1  server2</span><br><span class="line">127.0.0.1  server3</span><br></pre></td></tr></table></figure><p><strong>3.执行 maven 命令打包</strong></p><p>a.打开 idea 终端页面：</p><ul><li><p>方法一：在IDEA中点击view→tool window→Terminal即可开启</p></li><li><p>方法二：按住ALT+F12(如果是笔记本按不出来的话再加个Fn键)</p></li></ul><p>打开 idea terminal 窗口，切换到<code>根路径</code>：F:\2021JOB\0-javaguide面经v4\JavaGuide\7 Spring Cloud微服务实战 打造企业级优惠券系统 \imooc-coupon&gt;（就是项目的根目录）</p><p>执行指令将 Eureka Server 服务进行打包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true -U</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片04.png"></p><p>打包后在 coupon-eureka 模块下能看到相关 jar 包</p><p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片05.png"></p><p>b.选择性的使用配置文件 bootstrap.yml 部分属性运行 jar 包：</p><p>前两个窗口报错正常（因为还没启动第二、三个 server），第三个 server 不应该报错。</p><p>e.1 第一个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打包：mvn clean package -Dmaven.test.skip&#x3D;true -U</span><br><span class="line"></span><br><span class="line">切换目录：</span><br><span class="line">cd coupon-eureka\target</span><br><span class="line"></span><br><span class="line">启动服务：</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server1</span><br></pre></td></tr></table></figure><p>e.2 打开第二个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd coupon-eureka\target</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server2</span><br></pre></td></tr></table></figure><p>e.3 打开第三个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd coupon-eureka\target</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server3</span><br></pre></td></tr></table></figure><p>上边步骤完成后，eureka 集群已经起来了，浏览器分别输入：<a href="http://server1:8001，http://server2:8002，http://server3:8003">http://server1:8001，http://server2:8002，http://server3:8003</a> 访问即可</p><p>以下是访问 <a href="http://localhost:8001/">http://localhost:8001/</a> 端口的 Eureka 界面，也就是集群中 Server2 的注册中心界面：</p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片06.png" alt="img" style="zoom: 67%;"><p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片07.png" alt="img"></p><p>界面内容的解释：</p><ul><li><strong>System Status</strong>：系统状态信息，包含启动时间，当前时间，数据中心，环境</li><li><strong>Ds Replicas：</strong>父本，说明该服务器从哪里同步数据，如上图，从 server2 和 server3 同步数据</li><li><strong>Instances currently registered with Eureka：</strong>当前实例注册到 eureka 的信息（如上图，有三个 server）</li><li><strong>General Info：</strong>通用信息，关于 eureka 的一些信息采集信息</li><li><strong>instance info：</strong> 当前实例信息</li></ul><h2 id="1-2-Zuul"><a href="#1-2-Zuul" class="headerlink" title="1.2 Zuul"></a>1.2 Zuul</h2><h3 id="Zuul-的过滤器"><a href="#Zuul-的过滤器" class="headerlink" title="Zuul 的过滤器"></a>Zuul 的过滤器</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片08.png" alt="img" style="zoom: 80%;"><p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code></p><ol><li>pre filters 前置过滤器：在请求到达路由之前调用，进行身份验证，在集群中选择微服务，记录调试信息等。</li><li>routing filters 路由过滤器：将请求路由到微服务，用于构建发送给微服务请求。</li><li>post filters 后置过滤器：在请求路由到微服务以后执行，可以为响应添加标准的 HTTP header, 收集统一信息和指标，将响应从微服务发送给客户端。</li><li>error fiilters 异常处理过滤器：任何阶段执行发生了错误，都会调用。</li><li>custom filters 自定义过滤器：我们为了满足一些特定的需求，而自己定义的过滤器。例如 TokenFilter、RateLimiterFilter 等。</li></ol><p><strong>自定义过滤器实现的四个方法。四个抽象方法：</strong></p><ul><li><p>filterType：对应 Zuul 生命周期的四个阶段：pre、post、route 和 error </p></li><li><p>filterOrder：过滤器的优先级，数字越小，优先级越高</p></li><li><p>shouldFilter：方法返回 boolean 类型，true 时表示是否执行该过滤器的 run 方法，false 则表示不执行</p></li><li><p>run：过滤器的过滤逻辑</p></li></ul><h3 id="Zuul-模块搭建"><a href="#Zuul-模块搭建" class="headerlink" title="Zuul 模块搭建"></a>Zuul 模块搭建</h3><p><strong>1.修改 pom.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>coupon-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块名及描述信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>coupon-gateway<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Cloud Gateway For Coupon<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Eureka 客户端, 客户端向 Eureka Server 注册的时候会提供一系列的元数据信息, 例如: 主机, 端口, 健康检查url等</span></span><br><span class="line"><span class="comment">            Eureka Server 接受每个客户端发送的心跳信息, 如果在某个配置的超时时间内未接收到心跳信息, 实例会被从注册列表中移除</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务网关 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- apache 工具类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将</span></span><br><span class="line"><span class="comment">        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.编写网关的启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;网关应用启动入口&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * 1. <span class="doctag">@EnableZuulProxy</span> 标识当前的应用是 Zuul Server</span></span><br><span class="line"><span class="comment"> * 2. <span class="doctag">@SpringCloudApplication</span> 组合了 SpringBoot 应用 + 服务发现 + 熔断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(ZuulGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.配置网关应用</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/</span></span><br></pre></td></tr></table></figure><p><strong>4.启动网关应用，注册到 Eureka Server（单体）</strong></p><p>先启动 Eureka Server 应用，再启动 gatway 应用，打开Eureka Server 应用所在的 8000 端口我们在 Eureka Server 的界面就可以看到 gatway 应用成功注册到注册中心：</p><p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片09.png"></p><h3 id="自定义过滤器类"><a href="#自定义过滤器类" class="headerlink" title="自定义过滤器类"></a>自定义过滤器类</h3><p><strong>1.定义通用的抽象过滤器类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;通用的抽象过滤器类&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * Created by Qinyi.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZuulFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于在过滤器之间传递消息, 数据保存在每个请求的 ThreadLocal 中</span></span><br><span class="line">    <span class="comment">// 扩展了 Map,任何类型的数据都能存到 RequestContext 中</span></span><br><span class="line">    RequestContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识请求是否继续执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NEXT = <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器是否执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">boolean</span>) ctx.getOrDefault(NEXT, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的执行逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Some arbitrary artifact may be returned. Current implementation ignores it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException if an error occurs during execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">return</span> cRun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">cRun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        context.set(NEXT, <span class="keyword">false</span>);</span><br><span class="line">        context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">        context.getResponse().setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        context.setResponseStatusCode(code);</span><br><span class="line">        context.setResponseBody(String.format(<span class="string">&quot;&#123;\&quot;result\&quot;: \&quot;%s!\&quot;&#125;&quot;</span>, msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        context.set(NEXT, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义前置抽象过滤器类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自通用的抽象过滤器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPreZuulFilter</span> <span class="keyword">extends</span> <span class="title">AbstractZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.自定义后置抽象过滤器类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承自通用的抽象过滤器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPostZuulFilter</span> <span class="keyword">extends</span> <span class="title">AbstractZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="优惠券系统项目" scheme="http://wangjin1996219.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动装配原理</title>
    <link href="http://wangjin1996219.github.io/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <id>http://wangjin1996219.github.io/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</id>
    <published>2021-07-10T00:56:37.000Z</published>
    <updated>2021-08-08T08:39:41.299Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p>转载自**<a href="https://www.cnblogs.com/hellokuangshen/p/12450327.html">狂神博客</a>**。</p></blockquote><h1 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1.pom.xml"></a>1.pom.xml</h1><h2 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h2><p>它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点进去，发现还有一个父依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里才是真正管理 SpringBoot 应用里面所有依赖版本的地方，SpringBoot 的版本控制中心；</p><p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了。</strong></p><h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>springboot-boot-starter-xxx</strong>：就是 spring-boot 的 xxx 场景下的启动器</p><p><strong>spring-boot-starter-web</strong>：帮我们导入了 web 模块正常运行所依赖的组件；</p><p>SpringBoot 将所有的功能场景都抽取出来，做成一个个的 starter （启动器），只需要在项目中引入这些 starter 即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ，我们未来也可以自己自定义 starter。</p><h1 id="2-主启动类"><a href="#2-主启动类" class="headerlink" title="2.主启动类"></a>2.主启动类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以为是启动了一个方法，没想到启动了一个服务</span></span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><p>进入这个注解：可以看到上面还有很多其他注解！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是注解的构成体系：</p><p><img src="/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-07-10-SpringBoot自动装配原理\图片01.png" alt="img"></p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p><p>作用：自动扫描并加载符合条件的组件或者 bean ， 将这个 bean 定义加载到 IOC 容器中</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot 的配置类 ，标注在某个类上 ， 表示这是一个 SpringBoot 的配置类；</p><p>我们继续进去这个注解查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点进去得到下面的 @Component</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里的 @Configuration，说明这是一个配置类 ，<strong>配置类就是对应 Spring 的 xml 配置文件</strong>，也就是支持 Java 配置的方式；</p><p>里面的 @Component 这就说明，启动类本身也是 Spring 中的一个组件而已，负责启动应用！</p><p>我们回到 SpringBootApplication 注解中继续看。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p><p>以前我们需要自己配置的东西，而现在 SpringBoot 可以自动帮我们配置 。</p><p>@EnableAutoConfiguration 告诉 SpringBoot 开启自动配置功能，这样自动配置才能生效，并且可以帮我们配置不同场景下所需要的依赖。</p><p>点进注解接续查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><strong>作用：</strong>自动配置包</p><p>往下继续点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@import：</strong>Spring 底层注解 @import ， 给容器中导入一个组件</p><p><strong>Registrar.class 作用：</strong>将主启动类的所在包及包下面所有子包里面的所有组件扫描注册到 SpringIOC 容器，与 ComponentScan 区别就是扫描的组件不同 ；</p><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p><strong>作用：</strong>给容器导入组件</p><p>AutoConfigurationImportSelector.class：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点进去这个类看源码：</p><ol><li><p>这个类中有一个这样的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得候选的配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的getSpringFactoriesLoaderFactoryClass（）方法</span></span><br><span class="line">    <span class="comment">//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入 SpringFactoriesLoader 类 loadFactoryNames() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">//这里它又调用了 loadSpringFactories 方法</span></span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们继续点击查看 loadSpringFactories 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">//获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将读取到的资源遍历，封装成为一个Properties</span></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发现一个多次出现的文件：META-INF/spring.factories，全局搜索它</p><p><img src="/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-07-10-SpringBoot自动装配原理\图片02.png" alt="img"></p><p>这就是 SpringBoot 自动配置的核心所在。</p><p>可以看到这些一个个的都是 JavaConfig 配置类，而且都注入了一些 Bean，可以找一些自己认识的类，看着熟悉一下！</p><p>所以，<strong>自动配置的核心是从 META-INF/spring.factories 路径下找你所配置的 jar 包，然后把其包装成对应的 properties 文件，然后遍历 properties, 加载到 ioc 容器中。</strong></p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>SpringBoot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值</li><li>将这些值作为自动配置类导入容器，自动配置类就生效，帮我们进行自动配置工作；</li><li>整个 J2EE 的整体解决方案和自动配置都在 springboot-autoconfigure 的 jar 包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ，并配置好这些组件 ；</li><li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="框架相关" scheme="http://wangjin1996219.github.io/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="SpringBoot相关" scheme="http://wangjin1996219.github.io/tags/SpringBoot%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>（三）优惠券系统-SpringBoot开发框架</title>
    <link href="http://wangjin1996219.github.io/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/"/>
    <id>http://wangjin1996219.github.io/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</id>
    <published>2021-07-08T03:49:54.000Z</published>
    <updated>2021-07-13T13:41:19.346Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-SpringBoot-特性"><a href="#1-SpringBoot-特性" class="headerlink" title="1. SpringBoot 特性"></a>1. SpringBoot 特性</h1><p>项目主体业务使用 SpringCloud 框架开发实现，但是 SpringCloud 基于 SpringBoot 实现。为便于更顺畅学习，本章中会对 SpringBoot 开发框架进行介绍，下面先看 SpringBoot 的常见特性，如图所示：</p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source\_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片01.png" style="zoom:50%;"><h1 id="2-编写-SpringBoot-应用"><a href="#2-编写-SpringBoot-应用" class="headerlink" title="2.编写 SpringBoot 应用"></a>2.编写 SpringBoot 应用</h1><p><strong>1.创建 Maven 工程</strong></p><p>定义坐标和工程的位置</p><p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片02.png"></p><p><strong>2. pom.xml 文件的基本结构</strong></p><ol><li><p>parent 标签加入 springboot，标识 springboot 项目（引入 springboot 依赖）</p></li><li><p>添加 maven 坐标，标识 maven 项目</p></li><li><p>dependency 标签引入其它依赖</p></li><li><p>build 引入其他插件</p></li></ol><p><strong>3.修改 pom.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1  引入springboot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2  maven 坐标信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.springboot.study<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc_springboot_study<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  项目名字介绍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-study<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Study project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3  引入相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 专门用于数据绑定的依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4  引入相关插件--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>imooc-springboot-study<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4.编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBootApplication</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootStudyApplication.class,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>启动 main 方法：</strong>这样就成功启动了 SpringBoot 工程</p><p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片03.png" alt="image-20210708160931954"></p><h1 id="3-SpringBoot-应用启动入口"><a href="#3-SpringBoot-应用启动入口" class="headerlink" title="3. SpringBoot 应用启动入口"></a>3. SpringBoot 应用启动入口</h1><p><strong>SpringBoot 主要包括以下三种启动方式：</strong></p><ol><li>SpringApplication 静态方法 run</li><li>通过 API 调整应用行为</li><li>SpringApplicationBuilder 的 Fluent API ，实现链式调用</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.Banner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBootApplication</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动，通过静态run方法</span></span><br><span class="line">        SpringApplication.run(SpringBootStudyApplication.class,args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动，通过 API 调整应用行为</span></span><br><span class="line">      <span class="comment">/*  </span></span><br><span class="line"><span class="comment">      SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非web启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三种方式启动 链式调用</span></span><br><span class="line"><span class="comment">        new SpringApplicationBuilder(SpringBootStudyApplication.class)</span></span><br><span class="line"><span class="comment">                .bannerMode(Banner.Mode.OFF)</span></span><br><span class="line"><span class="comment">                .web(WebApplicationType.NONE)</span></span><br><span class="line"><span class="comment">                .run(args);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面已经演示了通过静态的 run 方法启动。下面来看剩下的两种：</p><p><strong>2.第二种方式启动，通过 API 调整应用行为</strong></p><p>启动后，控制台输出如下：</p><p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片04.png" alt="image-20210708200147745"></p><p>这里我们通过 API 设置了项目是非 web 应用，所以也没有默认开放的端口号，而且进程自动就结束了。</p><p><strong>3.第三种方式启动，SpringApplicationBuilder 的 Fluent API ，实现链式调用</strong></p><p>链式调用就是每次方法的调用返回一个 this 指针，然后通过这个指针调用方法来实现的。</p><p>启动后，控制台输出如下：</p><p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片04.png" alt="image-20210708200147745"></p><h1 id="4-SpringBoot-自动配置原理"><a href="#4-SpringBoot-自动配置原理" class="headerlink" title="4. SpringBoot 自动配置原理"></a>4. SpringBoot 自动配置原理</h1><p>已经整理</p><h1 id="5-SpringBoot-配置文件"><a href="#5-SpringBoot-配置文件" class="headerlink" title="5. SpringBoot 配置文件"></a>5. SpringBoot 配置文件</h1><h2 id="5-1-application-和-bootstrap"><a href="#5-1-application-和-bootstrap" class="headerlink" title="5.1 application 和 bootstrap"></a>5.1 application 和 bootstrap</h2><ul><li>  同一目录下的 bootstrap 优先级高于 application，优先被加载</li><li>  bootstrap 用于应用程序上下文的引导阶段，由父 ApplicationContext 加载 bootstrap 是系统级别的配置（不变的参数），</li><li>  application 是应用级别的配置</li></ul><p><strong>Demo：</strong></p><p>在 resources 文件下，创建 application.yml 配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>通过启动器启动项目：</p><p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片06.png" alt="image-20210710155222311"></p><p>可以看到 Tomcat 在 8000 端口启动，上下文路径是 /imooc</p><p>有一种场景，就是我们在线上或者测试环境中需要不同的配置，那么就需要创建不同的配置文件进行选择：</p><p>创建 application-prod.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc-prod</span></span><br></pre></td></tr></table></figure><p>创建 application-dev.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc-dev</span></span><br></pre></td></tr></table></figure><p>修改 application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#修改这里，就可以实现对不同配置文件的选择</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment">#  这里没有用了，因为不同的配置文件会有自己的上下文路径</span></span><br><span class="line"><span class="comment">#  servlet:</span></span><br><span class="line"><span class="comment">#    context-path: /imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure><h2 id="5-2不同目录配置文件加载顺序"><a href="#5-2不同目录配置文件加载顺序" class="headerlink" title="5.2不同目录配置文件加载顺序"></a>5.2不同目录配置文件加载顺序</h2><ul><li>  sfile:/config/- 优先级最高（项目根路径下的 config）</li><li>  file:./- 优先级第二（项目根路径下）</li><li>  classpath:/config/- 优先级第三（项目 resources/config 下）</li><li>  classpath/- 优先级第四（项目 resources 目录下）</li></ul><blockquote><p><strong>Note：</strong></p><p>高优先级覆盖低优先级相同配置</p><p>多个配置文件互补</p></blockquote><p><strong>Demo：</strong></p><p>刚才我们是在 resources 目录下创建的配置文件，也就是优先级最低，现在我们在项目根路径下创建 config 文件夹，然后创建 application.yml 配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"> <span class="attr">servlet:</span></span><br><span class="line">   <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br></pre></td></tr></table></figure><p>常规 resource 路径下的 application.xml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"> <span class="comment"># 注意：这里不能有profiles active: dev，否则 按application-dev配置文件的端口号</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="string">端口号</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"> <span class="attr">servlet:</span></span><br><span class="line">   <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br></pre></td></tr></table></figure><p>通过启动类启动后，就会是按照优先级更高的配置文件 8085 端口启动，然后选择线上环境的配置文件</p><h1 id="6-SpringBoot-配置注入的方式"><a href="#6-SpringBoot-配置注入的方式" class="headerlink" title="6. SpringBoot 配置注入的方式"></a>6. SpringBoot 配置注入的方式</h1><h2 id="6-1-Value-注入方式"><a href="#6-1-Value-注入方式" class="headerlink" title="6.1 @Value 注入方式"></a>6.1 @Value 注入方式</h2><p>application.yml 配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">imooc:</span></span><br><span class="line">  <span class="attr">springboot:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2.1</span><span class="string">,2.1.4</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">study</span></span><br></pre></td></tr></table></figure><p>要通过 @Value 注解将配置文件中的内容注入到 application 应用中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/conf_inject_1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;first conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, version, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-ConfigurationProperties-配置注入"><a href="#6-2-ConfigurationProperties-配置注入" class="headerlink" title="6.2 @ConfigurationProperties 配置注入"></a>6.2 @ConfigurationProperties 配置注入</h2><p>配置文件不变，我们创建一个配置类 SpringBootConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;imooc.springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将其注入到测试类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SpringBootConfig springBootConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Controller</span><span class="params">(SpringBootConfig springBootConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springBootConfig = springBootConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/conf_inject_1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;first conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, version, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第二种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/conf_inject_2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sencondConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;second conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, springBootConfig.getVersion(), springBootConfig.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-SpringBoot-定时任务"><a href="#7-SpringBoot-定时任务" class="headerlink" title="7. SpringBoot 定时任务"></a>7. SpringBoot 定时任务</h1><p><strong>定时任务需要配置：</strong></p><p>启动器开启定时任务注解 @EnableScheduling</p><p><code>启动类：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动</span></span><br><span class="line">        <span class="comment">//SpringApplication.run(SpringBootStudyApplication.class,args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动</span></span><br><span class="line">        <span class="comment">/*SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非wub启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式启动 链式调用</span></span><br><span class="line">       <span class="keyword">new</span> SpringApplicationBuilder(SpringBootStudyApplication.class)</span><br><span class="line">                <span class="comment">//.bannerMode(Banner.Mode.OFF)</span></span><br><span class="line">               <span class="comment">// .web(WebApplicationType.NONE)</span></span><br><span class="line">               .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>定时任务类：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;SpringBoot 定时任务&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * Created by wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter fmt = DateTimeFormatter.ofPattern(</span><br><span class="line">            <span class="string">&quot;HH:mm:ss&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;上一次开始执行时间点之后3000毫秒再执行&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule01 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;上一次执行完毕时间点之后3s再执行&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule02 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;第一次延迟2s之后执行, 之后按照每3s执行一次&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 2000, fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule03 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;每3s执行一次&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/3 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule04 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定时任务不同使用方式（四种）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(fixedRate &#x3D; 3000)　　上一次开始执行时间点之后3000毫秒再执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(fixedDelay &#x3D; 3000)　　上一次执行完毕时间点之后3s再执行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(initialDelay &#x3D; 2000, fixedRate &#x3D; 3000)　　第一次延迟2s之后执行, 之后按照每3s执行一次</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(cron &#x3D; &quot;*&#x2F;3 * * * * ?&quot;)　　每3s执行一次</span><br></pre></td></tr></table></figure><h1 id="8-SpringBoot-异步任务"><a href="#8-SpringBoot-异步任务" class="headerlink" title="8. SpringBoot 异步任务"></a>8. SpringBoot 异步任务</h1><p><strong>1.启动类</strong></p><p>加入 @EnableAsync 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="meta">@EnableAsync</span>  <span class="comment">//允许异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动</span></span><br><span class="line">        <span class="comment">//SpringApplication.run(SpringBootStudyApplication.class,args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动</span></span><br><span class="line">        <span class="comment">/*SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非wub启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式启动 链式调用</span></span><br><span class="line">       <span class="keyword">new</span> SpringApplicationBuilder(SpringBootStudyApplication.class)</span><br><span class="line">                <span class="comment">//.bannerMode(Banner.Mode.OFF)</span></span><br><span class="line">               <span class="comment">// .web(WebApplicationType.NONE)</span></span><br><span class="line">               .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.创建异步任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有返回的异步任务</span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@Async(&quot;getAsyncExecutor&quot;)</span> <span class="comment">//注解表明是异步任务，并且声明使用的线程池配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncNotReturn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//记一下sleep</span></span><br><span class="line">        log.info(<span class="string">&quot;无返回自定义线程名字为&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有返回的异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@Async(&quot;getAsyncExecutor&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Integer&gt; <span class="title">asyncHasReturn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;有返回自定义线程名字为&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.创建线程池配置类</strong></p><p>因为 SpringBoot 不可能通过主线程去执行异步任务，因为会阻塞，所以肯定是新开线程，但是新开的线程使用默认的线程池（比较简单）无法重复利用，所以要定义线程池的配置类，来使用自定义的线程池配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//记一下实现的接口(实现异步任务配置类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncThreadPoolConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将线程池初始化到springioc容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.线程池设置参数</span></span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(<span class="number">20</span>);<span class="comment">//核心线程20个，能同时处理20个客户端请求</span></span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(<span class="number">10</span>);<span class="comment">//缓冲队列允许10个线程等待</span></span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(<span class="number">30</span>);<span class="comment">//超出缓冲队列最多允许30个线程处理</span></span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(<span class="number">60</span>);<span class="comment">//线程存活时间60秒</span></span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(<span class="string">&quot;hcx_&quot;</span>);<span class="comment">//线程名称前缀</span></span><br><span class="line"></span><br><span class="line">        threadPoolTaskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        threadPoolTaskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.拒绝策略</span></span><br><span class="line">        threadPoolTaskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.线程池初始化</span></span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法仅能处理无返回值异步任务的异常，有返回值的异步任务异常客户端处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义异常处理类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1     打印日志</span></span><br><span class="line">            log.info(<span class="string">&quot;wdd异常打印&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&quot;</span>+throwable.getMessage(),method.getName(),JSON.toJSONString(objects));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2     正常跑出异常</span></span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3     发短信或者邮件通知运维人员</span></span><br><span class="line">            <span class="comment">//todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-SpringBoot-单元测试"><a href="#9-SpringBoot-单元测试" class="headerlink" title="9. SpringBoot 单元测试"></a>9. SpringBoot 单元测试</h1><p><strong>创建测试用例</strong></p><p>加入两个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//带有SpringBoot支持的引导程序，提供了可指定外部环境的参数</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span><span class="comment">//junit引用spring的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//至少有一个测试用例，否则报 java.lang.Exception: No runnable methods 异常</span></span><br><span class="line">    <span class="comment">//这个空方法主要是用于测试外部环境是否好用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blankFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-开机启动"><a href="#10-开机启动" class="headerlink" title="10.开机启动"></a>10.开机启动</h1><p>开机启动，也就是程序启动时，要自动完成什么功能。</p><p>两种开机启动方式：</p><p><strong>1.实现 BootApplicationRunner 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;BootApplicationRunner&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;=启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.实现 BootCommandRunner 接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCommandRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;BootCommandRunner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式明显的不同就是，传递参数的方式不同。</p><p><strong>3.通过 @Order 调整先后顺序</strong></p><p><code>BootApplicationRunner 方式：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;BootApplicationRunner&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;=启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BootCommandRunner 方式：</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCommandRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;BootCommandRunner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-SpringBoot-Jackson-的使用技巧"><a href="#11-SpringBoot-Jackson-的使用技巧" class="headerlink" title="11. SpringBoot Jackson 的使用技巧"></a>11. SpringBoot Jackson 的使用技巧</h1><p><strong>1.创建 POJO：</strong></p><p>注意看 Jackson 相关的注解作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span><span class="comment">//getset和toString方法</span></span><br><span class="line"><span class="meta">@Builder</span><span class="comment">//buil方法，参见Controller层的调用</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">//全参构造器</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;address&quot;&#125;)</span><span class="comment">//忽略一组属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMoocer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">//别名，传值后key值变为name </span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@JsonIgnore指示忽略掉该属性</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定日期属性的格式</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date registerTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.创建配置类：</strong></p><p>用于指定一些通用属性的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">buildJackson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//初始化objectMapper,公共配置类，初始化日期的格式（JacksonConfig 是作用于全局的）。</span></span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)); </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//属性为null,不参与序列化</span></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); </span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.修改 Controller，进行测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.config.SpringBootConfig;</span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.vo.IMoocer;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/userController&quot;)</span>  </span><br><span class="line"><span class="comment">//注解可以将HTTP请求映射给controller来处理，包括返回视图页面的controller和Rest服务的controller。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span>   </span><br><span class="line"><span class="comment">//@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@Controller标识的类，该类代表控制器类(控制层/表现层)。这里控制层里面的每个方法，都可以去调用@Service标识的类（业务逻辑层），@Service标识的类中的方法可以继续调用@Resposity标识的接口实现类（Dao层/持久层）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.imooc.userid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.imooc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入objectMapper对象</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入Compenent组件</span></span><br><span class="line">    <span class="keyword">private</span> SpringBootConfig springBootConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用构造方法</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testInjectOne</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testInjectOne&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigInjectOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*      System.out.println(&quot;userid=&quot;+this.userid);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;username=&quot;+this.username);*/</span></span><br><span class="line">        log.info(<span class="string">&quot;userid=&quot;</span>+<span class="keyword">this</span>.userid);</span><br><span class="line">        log.info(<span class="string">&quot;username=&quot;</span>+<span class="keyword">this</span>.username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testInjectTwo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testInjectTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigInjectTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;userid=&quot;</span>+springBootConfig.getUserid());</span><br><span class="line">        log.info(<span class="string">&quot;username=&quot;</span>+springBootConfig.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testJackson</span></span><br><span class="line"><span class="comment">     *  测试jackson序列化和反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testJackson&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMoocer <span class="title">testJackson</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//builder方法</span></span><br><span class="line">        IMoocer iMoocer = IMoocer.builder() .userName(<span class="string">&quot;小魏&quot;</span>) .age(<span class="string">&quot;18&quot;</span>) .address(<span class="string">&quot;北京&quot;</span>) .birthday(<span class="keyword">new</span> Date()) .build(); </span><br><span class="line">        <span class="comment">//序列化方式</span></span><br><span class="line">        String sJsonString = objectMapper.writeValueAsString(iMoocer);</span><br><span class="line">        log.info(<span class="string">&quot;序列化方法：&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&quot;</span>+sJsonString);</span><br><span class="line">        <span class="comment">//反序列化方式</span></span><br><span class="line">        IMoocer iMoocer1 = objectMapper.readValue(sJsonString,IMoocer.class); <span class="keyword">return</span> iMoocer1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-SpringBoot-Actuator-监控-1"><a href="#12-SpringBoot-Actuator-监控-1" class="headerlink" title="12. SpringBoot Actuator 监控(1)"></a>12. SpringBoot Actuator 监控(1)</h1><p><strong>1.开启 Actuator 监控</strong></p><p>a.引入相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>b. application.yml 配置文件开启监控功能：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#最特殊的监控端点，开通后可以通过shutdown url对程序进行关闭动作。一般不会开启</span></span><br><span class="line">  <span class="attr">endpoints:</span> </span><br><span class="line">  <span class="attr">web:</span> </span><br><span class="line">  <span class="attr">exposure:</span> </span><br><span class="line">  <span class="attr">include:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#打开所有的监控点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8081/imooc/actuator/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span> <span class="comment">#自定义的应用程序配置信息</span></span><br><span class="line"><span class="attr">app:</span> </span><br><span class="line"><span class="attr">name:</span> <span class="string">imooc_springboot_study</span> </span><br><span class="line"><span class="attr">groupid:</span> <span class="string">org.springframework.boot</span> </span><br><span class="line"><span class="attr">version:</span> <span class="number">2.1</span><span class="number">.4</span><span class="string">.RELEASE</span></span><br></pre></td></tr></table></figure><p><strong>2.原生端点三类监控</strong></p><ol><li><p><strong>应用配置类常用监控</strong>  </p><p>自己配置的应用程序 info 信息：/actuator/info  </p><p>应用中 bean 的信息：/actuator/beans  </p><p>应用中 URI 路径信息：/actuator/mappings</p></li><li><p><strong>度量指标类常用监控</strong>  </p><p>检查应用的运行状态：/actuator/health  </p><p>当前线程活动快照：/actuator/threaddump</p></li><li><p><strong>操作控制类常用监控</strong>  </p><p>关闭应用（POST）：/actuator/shutdown  </p><p>​        curl -X POST “<a href="http://localhost：8080/actuator/shutdown（POST请求）">http://localhost：8080/actuator/shutdown（POST请求）</a></p></li></ol><h1 id="13-SpringBoot-Actuator-监控-2"><a href="#13-SpringBoot-Actuator-监控-2" class="headerlink" title="13. SpringBoot Actuator 监控(2)"></a>13. SpringBoot Actuator 监控(2)</h1><p><strong>1.自定义端点类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.Endpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.ReadOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.WriteOperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Endpoint(id=&quot;datetime&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeEndPoint</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String forMat = <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取端点注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ReadOperation</span><span class="comment">//显示监控指标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">readPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小魏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;birthday&quot;</span>,<span class="keyword">new</span> SimpleDateFormat(forMat).format(<span class="keyword">new</span> Date()));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态更改监控指标</span></span><br><span class="line">    <span class="meta">@WriteOperation</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writePoint</span><span class="params">(String forMat)</span></span>&#123; <span class="keyword">this</span>.forMat = forMat; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.自定义端点配置类</strong></p><p>告诉 SpringBoot ，DateTimeEndPoint 是我们自定义的端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.endpoint.DateTimeEndPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span><span class="comment">//当该bean缺少的时候注入bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnEnabledEndpoint</span><span class="comment">//当监控端点开启的时候（application.yml打开监控端点）才会注入应用程序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTimeEndPoint <span class="title">dateTimeEndPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DateTimeEndPoint();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-SpringBoot-自定义-Starter"><a href="#14-SpringBoot-自定义-Starter" class="headerlink" title="14. SpringBoot 自定义 Starter"></a>14. SpringBoot 自定义 Starter</h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="优惠券系统项目" scheme="http://wangjin1996219.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>MessageQueue基础知识</title>
    <link href="http://wangjin1996219.github.io/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://wangjin1996219.github.io/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-07T07:44:01.000Z</published>
    <updated>2021-08-08T08:39:00.426Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-消息队列的基本概念"><a href="#1-消息队列的基本概念" class="headerlink" title="1.消息队列的基本概念"></a>1.消息队列的基本概念</h1><p><strong>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。</strong>队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片01.png" alt="Message queue"></p><h1 id="2-为什么要用消息队列"><a href="#2-为什么要用消息队列" class="headerlink" title="2.为什么要用消息队列"></a>2.为什么要用消息队列</h1><p>我觉得使用消息队列主要有三点好处：</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰/限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><p>面试中问到的话，要结合自己的项目来回答。</p><h2 id="2-1异步处理提高系统性能"><a href="#2-1异步处理提高系统性能" class="headerlink" title="2.1异步处理提高系统性能"></a>2.1异步处理提高系统性能</h2><p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片02.png" alt="通过异步处理提高系统性能"></p><p><strong>不使用消息队列时：</strong></p><p>用户的访问数据会通过服务器直接访问数据库，在高并发的场景下，会对数据库造成很大的压力，同时也会使得响应延迟加剧。</p><p><strong>使用消息队列时：</strong></p><p>在使用消息队列后，用户的请求数据会加入消息队列后直接返回，再由消息队列的消费进程从消息队列中获取数据，异步写入数据库，由于消息队列服务器处理速度远快于数据库（消息队列服务器处理请求的性能更高），因此用户的相应延迟也可以得到很好的改善。</p><p>需要注意的是，因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h2 id="2-2-削峰-限流"><a href="#2-2-削峰-限流" class="headerlink" title="2.2 削峰/限流"></a>2.2 削峰/限流</h2><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉（转嫁高并发压力到消息队列服务器）。</strong></p><p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片04.png" alt="削峰"></p><h2 id="2-3-降低系统耦合性"><a href="#2-3-降低系统耦合性" class="headerlink" title="2.3 降低系统耦合性"></a>2.3 降低系统耦合性</h2><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p><p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片05.png" alt="解耦"></p><p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合， 这显然也提高了系统的扩展性。</p><p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p><p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。</strong> </p><h1 id="3-使用消息队列的问题"><a href="#3-使用消息队列的问题" class="headerlink" title="3.使用消息队列的问题"></a>3.使用消息队列的问题</h1><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://wangjin1996219.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="MQ相关" scheme="http://wangjin1996219.github.io/tags/MQ%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Kafka基础知识</title>
    <link href="http://wangjin1996219.github.io/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://wangjin1996219.github.io/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-07T07:42:03.000Z</published>
    <updated>2021-08-08T08:08:44.682Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>Kafka 是一个基于<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>，主要应用于<strong>大数据实时处理</strong>领域。</p><h1 id="2-为什么使用消息队列"><a href="#2-为什么使用消息队列" class="headerlink" title="2.为什么使用消息队列"></a>2.为什么使用消息队列</h1><p>还需要根据自己这个项目实际说一下</p><ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰/限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol><h1 id="3-Kafka-与其它消息队列的对比"><a href="#3-Kafka-与其它消息队列的对比" class="headerlink" title="3. Kafka 与其它消息队列的对比"></a>3. Kafka 与其它消息队列的对比</h1><p>属于技术选型，结合项目说一下，为什么要选 Kafka</p><h1 id="4-消息模型"><a href="#4-消息模型" class="headerlink" title="4. 消息模型"></a>4. 消息模型</h1><h2 id="4-1点对点消息系统"><a href="#4-1点对点消息系统" class="headerlink" title="4.1点对点消息系统"></a>4.1点对点消息系统</h2><p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片01.png" alt="img"></p><p><strong>点对点消息系统的特点：</strong></p><ol><li>点对点消息系统是把消息持久化到消息队列中，不同消费者不能消费同一个消息</li><li>消费者消费掉消息队列的数据后，或者消息超时后，数据会从消息队列中删除</li><li>顺序发送消息</li></ol><p>例：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）。</p><p><strong>点对点消息系统存在的问题：</strong></p><p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p><p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p><h2 id="4-2发布订阅消息系统（Kafka）"><a href="#4-2发布订阅消息系统（Kafka）" class="headerlink" title="4.2发布订阅消息系统（Kafka）"></a>4.2发布订阅消息系统（Kafka）</h2><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p><p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片02.png" alt="img"></p><p><strong>发布订阅消息系统的特点：</strong></p><ol><li>消息持久化到 topic 中，不同的 topic 标识信息属于不同的 topic，消费者可订阅一个或多个 topic 的消息，也就是不同的消费者可以消费同一个消息</li><li>数据被消费后不会被删除</li><li>异步处理消息</li></ol><p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p><blockquote><p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p></blockquote><h1 id="5-Kafka-常见术语"><a href="#5-Kafka-常见术语" class="headerlink" title="5. Kafka 常见术语"></a>5. Kafka 常见术语</h1><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p><p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片03.png" alt="Kafka Topic Partition"></p><ul><li><strong>Producer（生产者）：</strong>生产者发送消息存储到 Partition 中，也可指定数据存储到哪个 Partition 中，通过代码设定即可。</li><li><strong>Consumer（消费者）：</strong>可从 Broker 中读取数据，消费者可消费多个 Topic 中的数据，多个消费者构成消费者组。</li><li><strong>Broker（代理）：</strong> 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li><li><strong>Topic（主题）：</strong> 数据所属类（类似于数据库中的表名的概念）。</li><li><strong>Partition（分区）：</strong> Partition 属于 Topic 的一部分（创建 kafka Topic 时，默认使用一个 partition，另外可在 kafka 命令行客户端，指定 partition 个数）。一个 Topic 可以有多个 Partition（至少有一个） ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 实现负载均衡。每个 partition，可能使用多个文件存储（冗余文件备份，超过一定限制后，会对文件切分）。</li><li><strong>Offset（偏移量）：</strong>每个 Partition 都有偏移量，每个消息都有针对 Partition 的 64 字节的偏移量，指定消息在数据中的起始位置。</li><li><strong>副本：</strong>副本是对 Partition 的备份，作用为防止数据丢失（单机版 Kafka 不能设置副本，副本分布在不同的机器上）。消费者不会从副本读取数据，它会从 Kafka Leader 中读取数据。</li></ul><h1 id="6-Kafka-多副本机制及好处"><a href="#6-Kafka-多副本机制及好处" class="headerlink" title="6. Kafka 多副本机制及好处"></a>6. Kafka 多副本机制及好处</h1><p><strong>1.多副本机制介绍</strong></p><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片05.png" alt="img"></p><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p><p><strong>2.多分区（Partition）以及多副本（Replica）机制的好处</strong></p><ol><li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><h1 id="7-Kafka-如何保证消息的消费顺序"><a href="#7-Kafka-如何保证消息的消费顺序" class="headerlink" title="7. Kafka 如何保证消息的消费顺序"></a>7. Kafka 如何保证消息的消费顺序</h1><p><strong>场景：</strong>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：更改用户会员等级、根据会员等级计算订单价格。假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p><p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="img"></p><p>每次添加消息到 Partition（分区）的时候都会采用尾加法，如上图所示。消息在被追加到 Partition（分区）的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）为我们保证 Partition（分区）中的消息有序，而不能保证 Topic（主题）中的 Partition（分区）的有序，比如上面的两条消息分别发送到同一 Topic 中不同的 Partition 中，在消费的时候就可能是无序的。</p><p>针对这种场景，我们简单提出下面两种方案：</p><p><strong>方案一：</strong>1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p><strong>方案二：</strong>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片06.png" alt="img" style="zoom:67%;"><h1 id="8-Kafka-如何保证消息不丢失"><a href="#8-Kafka-如何保证消息不丢失" class="headerlink" title="8. Kafka 如何保证消息不丢失"></a>8. Kafka 如何保证消息不丢失</h1><h2 id="8-1生产者丢失消息的情况"><a href="#8-1生产者丢失消息的情况" class="headerlink" title="8.1生产者丢失消息的情况"></a>8.1生产者丢失消息的情况</h2><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。 </p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>另外这里推荐为 Producer 的<code>retries </code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</strong></p><blockquote><p>可以通过 countDownLatch 来实现，重试的代码抽取成方法，主线程 countDownLatch.await() 阻塞，然后去执行方法，重试次数减到 0 唤醒主线程继续执行。</p></blockquote><h2 id="8-2消费者丢失消息的情况"><a href="#8-2消费者丢失消息的情况" class="headerlink" title="8.2消费者丢失消息的情况"></a>8.2消费者丢失消息的情况</h2><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片04.png" alt="kafka offset" style="zoom: 67%;"><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了，这样就会让没有消费的消息丢失。</p><p><strong>解决办法：我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h2 id="8-3-Kafka-丢失消息的情况"><a href="#8-3-Kafka-丢失消息的情况" class="headerlink" title="8.3 Kafka 丢失消息的情况"></a>8.3 Kafka 丢失消息的情况</h2><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>场景：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><p><strong>设置 request.required.acks = -1</strong></p><p>解决办法就是我们设置  <strong>request.required.acks = -1</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>request.required.acks = -1</strong> 代表则所有副本 follower 都从 leader 复制过去才会回 ack，该消息才算真正成功被发送。</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>该参数用于保证当前集群中处于正常同步状态的副本 follower 数量，当实际值小于配置值时，集群停止服务。一般情况下需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了，因为始终满足不了最小工作数了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><blockquote><p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p></blockquote><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p><p><strong>通过 ack、replication.factor、min.insync.replicas 和 unclean.leader.election.enable 的配合，保证在 Kafka 配置为 CP 系统时，要么不工作，要么得到 ack 后，消息不会丢失且消息状态一致。</strong></p><h1 id="9-Kafka-如何保证消息不重复消费"><a href="#9-Kafka-如何保证消息不重复消费" class="headerlink" title="9. Kafka 如何保证消息不重复消费"></a>9. Kafka 如何保证消息不重复消费</h1><p>上文中我们知道，kafka 有个 offset(偏移量) 的概念，就是每个消息写进去，都有一个 offset ，代表他的序号，然后 consumer 消费了数据之后，每隔一段时间，会把自己消费过的消息的 offset 提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧。</p><p><strong>场景：</strong>但是如果我们在消费完一条消息后，还没来得及更改偏移量，系统突然重启，或者进程被 kill 了，这样 offset 没有被修改，在系统重启之后，少数的消息就会被重复消费。</p><p>举个例子,假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？</p><p>一条数据或者请求重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p><p>通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。 </p><p><strong>解决思路：</strong></p><ol><li>如果你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下即可；</li><li>如果你是写 redis，那没问题了，反正每次都是 set，天然幂等性；</li><li>如果你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 redis 。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>再比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为 kafka 消费者还没来得及提交 offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据</li></ol><p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p><h1 id="10-Kafka-消费者组"><a href="#10-Kafka-消费者组" class="headerlink" title="10. Kafka 消费者组"></a>10. Kafka 消费者组</h1><p>消费者和 topic 内的 partition 关联方式：</p><p>消费者组协作消费同一个 topic 方法，<strong>kafka 能保证每个  topic 内的 partition 被消费者组内的一个消费者消费</strong>。</p><ul><li>1 个消费者组包含一个消费者，消费一个 topic 中的 4 个分区，该消费者消费全部分区</li><li>1 个消费者组包含两个消费者，消费一个 topic 中的 4 个分区，两个消费者平均随机消费两个不同的分区</li><li>1 个消费者组包含 4 个消费者，消费一个 topic 中的 4 个分区，4 个消费者平均随机消费一个不同的分区</li><li>1 个消费这组包含 5 个消费者，消费一个 topic 中的 4 个分区，4 个消费者平均随机消费一个不同的分区，第 5 个消费者处于空闲状态（注意<strong>消费者组的消费者个数应小于等于 partition 个数</strong>，避免资源浪费）</li><li>2 个消费者组消费一个 topic 中的 4 个分区，<strong>每个消费者组是独立消费，并不和其他消费者组关联</strong></li></ul><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片07.png" style="zoom: 67%;"><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片08.png" style="zoom:67%;"><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片09.png" style="zoom:67%;"><h1 id="11-Zookeeper-在-Kafka-中的作用"><a href="#11-Zookeeper-在-Kafka-中的作用" class="headerlink" title="11. Zookeeper 在 Kafka 中的作用"></a>11. Zookeeper 在 Kafka 中的作用</h1><blockquote><p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong> 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：<a href="https://www.jianshu.com/p/a036405f989c">https://www.jianshu.com/p/a036405f989c</a> 。</p></blockquote><p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zookeeper-kafka.jpg" style="zoom:50%;"><p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p><p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p><ol><li><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li><strong>Topic 注册</strong>：在 Kafka 中，同一个 <strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li><li>……</li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://wangjin1996219.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka相关" scheme="http://wangjin1996219.github.io/tags/Kafka%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>（一）优惠券系统-项目介绍</title>
    <link href="http://wangjin1996219.github.io/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <id>http://wangjin1996219.github.io/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</id>
    <published>2021-07-06T13:34:59.000Z</published>
    <updated>2021-07-06T13:37:24.255Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-课程目的"><a href="#1-课程目的" class="headerlink" title="1.课程目的"></a>1.课程目的</h1><ol><li><p><strong>单体服务的缺点：</strong></p><p>整个工程任何一个功能点问题，都可能拖垮整个业务系统，所以需要去学习微服务。</p></li><li><p><strong>微服务的优点</strong></p><p>作为微服务，就是将原本大系统中的功能点拆分为独立的小系统并独立部署，可见原本单体服务中的各种功能变成了服务。</p><p>另外，客户端不再直接与微服务进行交互，而是通过网关做路由分发，且功能之间的方法调用变成了各个微服务之间的服务调用。这样的设计架构会让开发部署过程变得简单，易维护，且微服务出现问题不会影响其他的维护，对业务系统的高可用要求提供了保障。</p></li></ol><img src="/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/GitHub\MyBlogs\source\_posts\2021-07-06-（一）优惠券系统-项目介绍\图片01.png" alt="img" style="zoom:120%;"><h1 id="2-课程内容"><a href="#2-课程内容" class="headerlink" title="2.课程内容"></a>2.课程内容</h1><p><strong>设计思想：</strong>注册中心，优惠券模版微服务，优惠券分发微服务，优惠券结算微服务</p><img src="/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/GitHub\MyBlogs\source\_posts\2021-07-06-（一）优惠券系统-项目介绍\图片02.png" alt="img" style="zoom:120%;">]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="优惠券系统项目" scheme="http://wangjin1996219.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>（二）优惠券系统-准备工作</title>
    <link href="http://wangjin1996219.github.io/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://wangjin1996219.github.io/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</id>
    <published>2021-07-06T13:33:57.000Z</published>
    <updated>2021-07-08T03:33:26.038Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h1><h2 id="1-1-pom-xml"><a href="#1-1-pom-xml" class="headerlink" title="1.1 pom.xml"></a>1.1 pom.xml</h2><h2 id="1-2坐标组成"><a href="#1-2坐标组成" class="headerlink" title="1.2坐标组成"></a>1.2坐标组成</h2><ul><li><p>groupid：这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，优 groupld 蕉等项目com.imooc.coupon 拥有所有的和优惠券相关的项目。</p></li><li><p>artifactd：这是工程的标识。它通常是工程的名称。例如，优惠券结算系统。</p><p>groupld 和 artifactId 一起定义了 artifact 在仓库中的位置。</p></li><li><p>versionid ：这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：com.imooc.coupon.setlement1.0。</p></li></ul><h2 id="1-3-maven-常用命令"><a href="#1-3-maven-常用命令" class="headerlink" title="1.3 maven 常用命令"></a>1.3 maven 常用命令</h2><p>常用命令含义/功能：</p><ul><li>mvn -v ：查看 Maven 的版本，也用来检查 Maven 是否安装成功</li><li>mvn compile：编译，将 Java 源文件编译成 class 文件</li><li>mvn test：执行 test 目录下的测试用例</li><li>mvn package：打包，将 Java 工程打成 jar 包</li><li>mvn clean：清理环境，清除 target 文件夹</li><li>mvn install ：安装，将当前项目安装到 Maven 的本地仓库中</li></ul><h2 id="1-4-idea-运行-maven-命令"><a href="#1-4-idea-运行-maven-命令" class="headerlink" title="1.4 idea 运行 maven 命令"></a>1.4 idea 运行 maven 命令</h2><p>terminal 命令窗口，可以执行 maven 命令</p><h1 id="2-Maven-相关特性"><a href="#2-Maven-相关特性" class="headerlink" title="2. Maven 相关特性"></a>2. Maven 相关特性</h1><h1 id="3-Maven-多模块项目"><a href="#3-Maven-多模块项目" class="headerlink" title="3. Maven 多模块项目"></a>3. Maven 多模块项目</h1><h1 id="4-Redis支持的数据类型"><a href="#4-Redis支持的数据类型" class="headerlink" title="4. Redis支持的数据类型"></a>4. Redis支持的数据类型</h1><h1 id="5-Redis-特性以及问题规避"><a href="#5-Redis-特性以及问题规避" class="headerlink" title="5. Redis 特性以及问题规避"></a>5. Redis 特性以及问题规避</h1><h1 id="6-Redis-的-I-O-模型"><a href="#6-Redis-的-I-O-模型" class="headerlink" title="6. Redis 的 I/O 模型"></a>6. Redis 的 I/O 模型</h1><h1 id="7-MySql-版本与配置"><a href="#7-MySql-版本与配置" class="headerlink" title="7. MySql 版本与配置"></a>7. MySql 版本与配置</h1><h1 id="8-Mysql-索引"><a href="#8-Mysql-索引" class="headerlink" title="8. Mysql 索引"></a>8. Mysql 索引</h1><h1 id="9-Spring-Data-JPA"><a href="#9-Spring-Data-JPA" class="headerlink" title="9. Spring Data JPA"></a>9. Spring Data JPA</h1><h2 id="9-1-ORM"><a href="#9-1-ORM" class="headerlink" title="9.1 ORM"></a>9.1 ORM</h2><p><strong>1.什么是 ORM</strong></p><p>ORM，即 Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的 SQL 语句打交道，只需简单的操作对象的属性和方法。</p><p><strong>2.为什么会出现ORM思想</strong></p><p>先从项目中数据流存储形式这个角度说起，简单拿MVC这种分层模式来说：Model 作为数据承载实体，在用户界面层和业务逻辑层之间数据实现面向对象OO形式传递.，当我们需要通过 Control 层分发请求把数据持久化时我们会发现. ，内存中的面向对象的OO如何持久化成关系型数据中存储一条实际数据记录呢？</p><p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两者之间是不匹配的，而 ORM 作为项目中间件形式实现数据在不同场景下数据关系映射，对象关系映射（Object Relational Mapping，简称ORM）是一种<strong>为了解决面向对象与关系数据库存在的互不匹配的现象的技术</strong>，ORM 就是这样而来的。</p><p><img src="/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/GitHub\MyBlogs\source_posts\2021-07-06-（二）优惠券系统-准备工作\图片01.png" alt="img"></p><p><strong>3.常用的 ORM 框架</strong></p><ol><li>Hibernate 全自动需要些 hql 语句</li><li>iBATIS 半自动自己写 sql 语句,可操作性强,小巧</li><li>EclipseLink 一个可扩展的支持 JPA 的 ORM 框架，供强大的缓存功能，缓存支持集群。</li><li>Apache OJB 等等</li></ol><h2 id="9-2-Spring-Data-JPA"><a href="#9-2-Spring-Data-JPA" class="headerlink" title="9.2 Spring Data JPA"></a>9.2 Spring Data JPA</h2><p><strong>1.SpringData jpa</strong></p><p>JPA(Java Persistence API) 是当年的 Sun 官方提出的 <strong>Java 持久化规范</strong>。<br>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，<strong>可使开发者用极简的代码即可实现对数据的访问和操作</strong>。</p><p><strong>2. JPA 包含的技术</strong>  </p><ul><li><p>ORM 映射元数据：支持 <strong>xml</strong> 和<strong>注解</strong>来标识源数据的形式，对象的增删改查映射到表  </p></li><li><p>查询语言（JPQL）：面向对象查询数据</p></li></ul><p><strong>3.什么是 SpringData JPA</strong></p><p>即 Java PersistenceAPI，用于对象持久化的 <strong>API</strong>，它是 <strong>ORM 规范</strong>，使得应用程序以统一的方式访问持久层。</p><p><strong>4. JPA 和 Hibernate 的关系</strong></p><ul><li><p>JPA 是 Hibernate 的一个抽象</p></li><li><p>JPA 是 ORM 规范，不是 ORM 框架</p></li><li><p>Hibernate 是 JPA 的一种实现</p></li><li><p>JPA 是 Hibernate 的一个功能子集</p></li></ul><img src="/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/GitHub\MyBlogs\source\_posts\2021-07-06-（二）优惠券系统-准备工作\图片02.png" style="zoom:150%;"><p><strong>4. JPA 优点</strong></p><ul><li><p>标准化：相同 api，代码层面修改较少便能在不同框架下使用</p></li><li><p>简单易用：创建实体，只需要 @entity 注解即可</p></li><li><p>面向对象：定义了 jpql (类似于 sql)，支持批量修改更新 join,group by,having 等，支持类之间的继承，多态等</p></li></ul><p><strong>5. JPA 包含的技术</strong></p><ul><li><p>ORM 映射元数据：支持 <strong>xml</strong> 和<strong>注解</strong>来标识源数据的形式，对象的增删改查映射到表</p></li><li><p>查询语言（JPQL）：面向对象查询数据</p></li><li><p>提供了查询 API</p></li></ul><p><strong>6. Spring Data 项目</strong></p><ul><li><p>Spring Data 是 Spring 的一个子项目，用于简化数据库访问</p></li><li><p>Spring Data JPA 是 Spring Data 的一个子项目</p></li><li><p>Spring Data JPA 致力于减少数据访问层（DAO）的开发量</p></li></ul><h1 id="10-数据库连接池"><a href="#10-数据库连接池" class="headerlink" title="10.数据库连接池"></a>10.数据库连接池</h1><h2 id="10-4-SpringBoot2-HikariCP-的配置"><a href="#10-4-SpringBoot2-HikariCP-的配置" class="headerlink" title="10.4 SpringBoot2 HikariCP 的配置"></a>10.4 SpringBoot2 HikariCP 的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.hikari.connection-timeout 客户端等待连接池连接的最大毫秒数</span><br><span class="line">spring.datasource.hikari.minimum-idle连接池中维护的最小空闲连接数</span><br><span class="line">spring.datasource.hikari.maximum-pool-size 最大池大小</span><br><span class="line">spring.datasource.hikari.idle-timeout 允许连接在连接池中空闲的最长时间（毫秒）</span><br><span class="line">spring.datasource.hikari.max-lifetime 池中连接关闭后的最长生命周期（毫秒）</span><br><span class="line">spring.datasource.hikari.auto-commit从池返回的连接的默认自动提交行为（默认为true）</span><br></pre></td></tr></table></figure><h2 id="10-1数据库连接池的功能"><a href="#10-1数据库连接池的功能" class="headerlink" title="10.1数据库连接池的功能　"></a>10.1数据库连接池的功能　</h2><p><strong>连接复用：</strong>通过建立一个数据库连接池以及一套连接使用管理策略，<strong>使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销</strong>。较为频繁的使用数据库时，数据库连接的使用成为系统的瓶颈，所以需要数据库连接池</p><h2 id="10-2数据库连接池的基本原理"><a href="#10-2数据库连接池的基本原理" class="headerlink" title="10.2数据库连接池的基本原理"></a>10.2数据库连接池的基本原理</h2><p>数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。  </p><ul><li>getConnection ：得到数据库连接</li><li>releaseConnection：释放数据库链接，并不关闭，管理回收下次使用（无框架的时候进行这 getConnection 和 releaseConnection）</li></ul><h2 id="10-3数据库连接池的优势"><a href="#10-3数据库连接池的优势" class="headerlink" title="10.3数据库连接池的优势"></a>10.3数据库连接池的优势</h2><ul><li>资源重用，连接池中的数据库连接可以复用</li><li>更快的系统响应，维护一些可用的连接，避免了数据库连接创建销毁的开销，提升了系统效应速度</li><li>优化资源分配</li><li>统一的连接管理 ，避免数据库泄露，占用超时设定，强制回收被占用的连接</li></ul><h2 id="10-4-SpringBoot2-HikariCP-的配置-1"><a href="#10-4-SpringBoot2-HikariCP-的配置-1" class="headerlink" title="10.4 SpringBoot2 HikariCP 的配置"></a>10.4 SpringBoot2 HikariCP 的配置</h2><p>SpringBoot1 的默认连接池是 Tomcat 数据库连接池，HikariCP 是 SpringBoot2 中的默认连接池，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.hikari.connection-timeout 客户端等待连接池连接的最大毫秒数</span><br><span class="line">spring.datasource.hikari.minimum-idle连接池中维护的最小空闲连接数</span><br><span class="line">spring.datasource.hikari.maximum-pool-size 最大池大小</span><br><span class="line">spring.datasource.hikari.idle-timeout 允许连接在连接池中空闲的最长时间（毫秒）</span><br><span class="line">spring.datasource.hikari.max-lifetime 池中连接关闭后的最长生命周期（毫秒）</span><br><span class="line">spring.datasource.hikari.auto-commit从池返回的连接的默认自动提交行为（默认为true）</span><br></pre></td></tr></table></figure><p><strong>SpringBoot2 如何选择连接池？</strong></p><p>优先选择 hikaricp, 不存在依赖的话，选择 tomcat 连接池，如果 tomcat 连接池也不存在，会继续选择优先级更低的 commons,db2 等连接池。</p><h1 id="11-Kafka-相关"><a href="#11-Kafka-相关" class="headerlink" title="11. Kafka 相关"></a>11. Kafka 相关</h1><h1 id="12-Kafka-的安装与使用"><a href="#12-Kafka-的安装与使用" class="headerlink" title="12. Kafka 的安装与使用"></a>12. Kafka 的安装与使用</h1>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://wangjin1996219.github.io/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="优惠券系统项目" scheme="http://wangjin1996219.github.io/tags/%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式锁</title>
    <link href="http://wangjin1996219.github.io/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://wangjin1996219.github.io/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-06-30T08:08:42.000Z</published>
    <updated>2021-08-08T08:37:39.909Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p>原本的单体单机部署的系统被演化成分布式集群系统之后，由于分布式系统的多进程、多线程分布在不同的机器上，这就使得原先的并发控制策略失效，也就是我们在集群中一个节点上加的锁不能被其它节点所识别，所以要实现分布式锁来解决该问题。</p><h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2.分布式锁"></a>2.分布式锁</h1><p>分布式锁主流的实现方案：</p><ul><li><input disabled type="checkbox"> 基于数据库实现分布式锁</li><li><input checked disabled type="checkbox"> 基于缓存（Redis等）</li><li><input disabled type="checkbox"> 基于Zookeeper</li></ul><h1 id="3-Redis-实现分布式锁"><a href="#3-Redis-实现分布式锁" class="headerlink" title="3. Redis 实现分布式锁"></a>3. Redis 实现分布式锁</h1><h2 id="3-1简单实现"><a href="#3-1简单实现" class="headerlink" title="3.1简单实现"></a>3.1简单实现</h2><p><strong>实现架构图：</strong></p><p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片01.png" alt="image-20210630161443209"></p><p>实现流程：</p><ol><li><p>多个客户端同时获取锁（setnx 命令实现）</p><ul><li>当且仅当 key 不存在，可将 key 的值设为 value，并返回 1 ，该客户端获得锁。</li><li>若给定的 key 已经存在，则 SETNX 不做任何动作。并返回 0 ，表示该锁没有被释放，获取锁失败。</li><li>客户端最后可以通过 DEL lock-key 来释放该锁。</li></ul></li><li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p></li><li><p>其他客户端等待重试</p></li></ol><p><strong>Redis 操作指令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;释放锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; del users </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setnx</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2优化之设置锁的过期时间"><a href="#3-2优化之设置锁的过期时间" class="headerlink" title="3.2优化之设置锁的过期时间"></a>3.2优化之设置锁的过期时间</h2><p>上面的实现中缺乏原子性，setnx 刚好获取到锁，业务逻辑出现异常，导致锁无法释放，所以就要设置过期时间。但是如果在 setnx 和 expire 之间出现异常，锁也无法释放，所以设置过期时间还不够，要在 set 时加锁并指定过期时间</p><p><strong>实现架构图：</strong></p><p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片02.png" alt="image-20210630162701714"></p><p><strong>Redis 操作指令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;设置过期时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; expire users 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl users </span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; ttl users </span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(integer) 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;加锁的同时设置过期时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; set users 20 nx ex 10</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>代码实现修改：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>，<span class="number">3</span>，TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h2 id="3-3优化之-UUID-防误删"><a href="#3-3优化之-UUID-防误删" class="headerlink" title="3.3优化之 UUID 防误删"></a>3.3优化之 UUID 防误删</h2><p><strong>问题：</strong>可能会释放其他服务器的锁。</p><p><strong>场景：</strong>如果业务逻辑的执行时间是 7s。执行流程如下</p><ol><li><p>index1 业务逻辑没执行完，3 秒后锁被自动释放。</p></li><li><p>index2 获取到锁，执行业务逻辑，3 秒后锁被自动释放。</p></li><li><p>index3 获取到锁，执行业务逻辑</p></li><li><p>index1 业务逻辑执行完成，开始调用 del 释放锁，这时释放的是 index3 的锁，导致 index3 的业务只执行 1s 就被别人释放。</p></li></ol><p>最终等于没锁的情况。</p><p><strong>解决：</strong>setnx 获取锁时，设置一个指定的唯一值（例如：uuid），释放前获取这个值，判断是否自己的锁，只有自己的锁才能释放。</p><p><strong>实现架构图：</strong></p><p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片03.png" alt="image-20210630163248866"></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setnx</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4判断是不是自己的锁，并释放锁，del</span></span><br><span class="line">        <span class="keyword">if</span>(uuid.equals((String)redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4优化之-LUA-脚本保证删除的原子性"><a href="#3-4优化之-LUA-脚本保证删除的原子性" class="headerlink" title="3.4优化之 LUA 脚本保证删除的原子性"></a>3.4优化之 LUA 脚本保证删除的原子性</h2><p>问题：删除操作缺乏原子性。</p><p>场景：</p><ol><li><p>index1 执行删除时，查询到的 lock 值确实和 uuid 相等                        </p></li><li><p>index1 执行删除前，lock 刚好过期时间已到，被 redis 自动释放。在 redis 中没有了 lock，没有了锁。</p></li><li><p>index2 获取了 lock，index2 线程获取到了 cpu 的资源，开始执行方法</p></li><li><p>index1 执行删除，此时会把index2的lock删除</p><p>index1 因为判断完 uuid 之后，已经在方法中了，所以不需要重新上锁。index1 有执行的权限。index1 已经比较完成了，这个时候，开始执行删除的 index2 的锁！</p></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来释放锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua脚本</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lua 脚本详解：</strong></p><p>支持原子性操作，脚本在执行的时候，不能被其它事务打断，所以我们可以将删除操作放到脚本中，来保证它的原子性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="3-5总结"><a href="#3-5总结" class="headerlink" title="3.5总结"></a>3.5总结</h2><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ol><h1 id="4-解决并发竞争-Key-问题"><a href="#4-解决并发竞争-Key-问题" class="headerlink" title="4.解决并发竞争 Key 问题"></a>4.解决并发竞争 Key 问题</h1><p><strong>介绍：</strong>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>这里的并发指的是多个 Redis 的 client 同时 set key 引起的并发问题。</p><h2 id="方案一：分布式锁-时间戳"><a href="#方案一：分布式锁-时间戳" class="headerlink" title="方案一：分布式锁+时间戳"></a>方案一：分布式锁+时间戳</h2><p><strong>分布式锁：</strong>传统的加锁的做法（如 java 的 synchronized 和 Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。分布式锁可以基于很多种方式实现，比如 Zookeeper、Redis 等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p><p>利用 SETNX 非常简单地实现分布式锁。例如：某客户端要获得一个名字 users 的锁，客户端使用下面的命令进行获取：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock.users&lt;current Unix <span class="built_in">time</span> + lock timeout + <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>把 lock.users 的键值设置为时间值表示该键已被锁定</p><p><strong>时间戳</strong></p><p>由于上面举的例子，要求key的操作需要顺序执行，所以需要<strong>在缓存中</strong>保存一个时间戳判断set顺序。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统 A key <span class="number">1</span> &#123;ValueA <span class="number">7</span>:<span class="number">00</span>&#125;</span><br><span class="line">系统 B key <span class="number">1</span> &#123;ValueB <span class="number">7</span>:<span class="number">05</span>&#125;</span><br></pre></td></tr></table></figure><p>假设系统 B 先抢到锁，将 key1 设置为{ValueB 7:05}。接下来系统 A 抢到锁，发现自己的 key1 的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。（因为操作的发出本身就是有时间信息的，所以可以与缓存中 Set 操作的时间戳做比较）</p><h2 id="方案二：利用消息队列"><a href="#方案二：利用消息队列" class="headerlink" title="方案二：利用消息队列"></a>方案二：利用消息队列</h2><p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p><p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p><h2 id="附加：zookeeper-分布式锁"><a href="#附加：zookeeper-分布式锁" class="headerlink" title="附加：zookeeper 分布式锁"></a>附加：zookeeper 分布式锁</h2><p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="数据库相关" scheme="http://wangjin1996219.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Redis相关" scheme="http://wangjin1996219.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-27T03:07:08.000Z</published>
    <updated>2021-08-08T07:50:47.145Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-数据库基础知识"><a href="#1-数据库基础知识" class="headerlink" title="1.数据库基础知识"></a>1.数据库基础知识</h1><h2 id="1-1什么是SQL？"><a href="#1-1什么是SQL？" class="headerlink" title="1.1什么是SQL？"></a>1.1什么是SQL？</h2><p>结构化查询语言（Structure Query Language）简称SQL，是一种数据库查询语言。</p><p>作用：用于存取、查询、更新和管理关系型数据库</p><h2 id="1-2关系型数据库与非关系型数据库"><a href="#1-2关系型数据库与非关系型数据库" class="headerlink" title="1.2关系型数据库与非关系型数据库"></a>1.2关系型数据库与非关系型数据库</h2><p><strong>关系型数据库：</strong>由数据库中的二维表及其之间的联系组成的一个数据库组织</p><p><strong>常见：</strong>MySQL、SQL Server、Oracle</p><p><strong>优点：</strong></p><ol><li>易于维护：都是表结构，格式统一</li><li>使用方便：SQL语言通用</li><li>支持复杂查询：可以使用SQL语句用于一个表以及多个表之间的查询</li></ol><p><strong>缺点：</strong></p><ol><li>当操作海量数据时，读写性能比较差</li><li>表结构固定，灵活度稍差</li><li>对于高并发读写需求，硬盘I/O是一个很大的瓶颈</li></ol><p><strong>非关系型数据库：</strong>非关系型数据库是一种数据结构化存储方法的集合，可以是文档或者键值对</p><p><strong>常见：</strong>Redis</p><p><strong>优点：</strong></p><ol><li>格式灵活，可以是键值对的形式、文档形式、图片形式等等，而关系型数据库只支持基本的数据类型</li><li>速度快</li><li>高扩展性</li><li>成本低</li></ol><p><strong>缺点：</strong></p><ol><li>不提供SQL支持，学习和使用成本较高</li><li>无事务处理</li><li>数据结构相对复杂</li><li>复杂查询方面欠缺</li></ol><h2 id="1-3数据库三大范式是什么"><a href="#1-3数据库三大范式是什么" class="headerlink" title="1.3数据库三大范式是什么"></a>1.3数据库三大范式是什么</h2><ul><li><p>1NF：有主键，字段是原子性的，不可分；（保证字段的原子性）</p></li><li><p>2NF：有主键，非主键列完全依赖于主键，而不能是依赖于主键的一部分；（保证一张表只能描述一件事）</p><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。</p></li><li><p>3NF：<strong>非主键字段不能相互依赖</strong>。 每列都与主键有<strong>直接关系</strong>，<strong>不存在传递的依赖。</strong></p><p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p></li></ul><p><strong>不符合第一范式的例子：</strong></p><p> <strong>表：</strong>字段1、 字段2、字段3 (字段3.1、字段3.2)……</p><table><thead><tr><th>学号</th><th>姓名</th><th>信息</th></tr></thead><tbody><tr><td>1001</td><td>张三</td><td>湖北武汉市，12345678</td></tr><tr><td>1002</td><td>李四</td><td>山东滨州市，1234567</td></tr><tr><td>1003</td><td>王五</td><td>河北沧州市，123456</td></tr></tbody></table><p>这个表中主键重复，信息字段可以再分。</p><table><thead><tr><th>学号</th><th>姓名</th><th>家庭住址</th><th>联系电话</th></tr></thead><tbody><tr><td>1001</td><td>张三</td><td>湖北武汉市</td><td>12345678</td></tr><tr><td>1002</td><td>李四</td><td>山东滨州市</td><td>1234567</td></tr><tr><td>1003</td><td>王五</td><td>河北沧州市</td><td>123456</td></tr></tbody></table><p><strong>不符合第二范式的例子：</strong></p><p><strong>表：</strong></p><table><thead><tr><th>学号</th><th>教师编号</th><th>学生姓名</th><th>教师姓名</th></tr></thead><tbody><tr><td>1001</td><td>001</td><td>张三</td><td>王老师</td></tr><tr><td>1002</td><td>002</td><td>李四</td><td>张老师</td></tr><tr><td>1003</td><td>001</td><td>王五</td><td>王老师</td></tr><tr><td>1001</td><td>002</td><td>张三</td><td>张老师</td></tr></tbody></table><p>在这张表中，学生编号+教师编号做联合主键，复合主键（学生编号+教师编号）。</p><p>但是学生依赖于学生编号，教师依赖于教师编号，所以产生了部分依赖。这样张三、王老师等都重复了，也就是产生了数据冗余。可以通过分表的方式来表示多对多的关系。</p><p><strong>学生表：</strong></p><table><thead><tr><th>学号（pk）</th><th>学生姓名</th></tr></thead><tbody><tr><td>1001</td><td>张三</td></tr><tr><td>1002</td><td>李四</td></tr><tr><td>1003</td><td>王五</td></tr></tbody></table><p><strong>教师表：</strong></p><table><thead><tr><th>教师编号（pk）</th><th>教师姓名</th></tr></thead><tbody><tr><td>001</td><td>王老师</td></tr><tr><td>002</td><td>张老师</td></tr></tbody></table><p><strong>学生教师关系表：</strong></p><table><thead><tr><th>id（pk）</th><th>学号（fk）</th><th>教师编号（fk）</th></tr></thead><tbody><tr><td>1</td><td>1001</td><td>001</td></tr><tr><td>2</td><td>1002</td><td>002</td></tr><tr><td>3</td><td>1003</td><td>001</td></tr><tr><td>4</td><td>1001</td><td>002</td></tr></tbody></table><p><strong>不符合第三范式的例子:</strong></p><p><strong>表：</strong></p><table><thead><tr><th>学号（pk）</th><th>学生姓名</th><th>班级编号</th><th>班级名称</th></tr></thead><tbody><tr><td>1001</td><td>张三</td><td>01</td><td>一年一班</td></tr><tr><td>1002</td><td>李四</td><td>02</td><td>一年二班</td></tr><tr><td>1003</td><td>王五</td><td>03</td><td>一年三班</td></tr><tr><td>1004</td><td>张三</td><td>03</td><td>一年三班</td></tr></tbody></table><p>存在依赖传递: (班级名称) → (班级编号) → (学号)，产生了数据的冗余，即重复的一年三班，存在一对多的关系，仍然通过拆分表来解决。</p><p><strong>学生表：</strong></p><table><thead><tr><th>学号（pk）</th><th>学生姓名</th><th>班级编号（fk）</th></tr></thead><tbody><tr><td>1001</td><td>张三</td><td>01</td></tr><tr><td>1002</td><td>李四</td><td>02</td></tr><tr><td>1003</td><td>王五</td><td>03</td></tr><tr><td>1004</td><td>张三</td><td>03</td></tr></tbody></table><p><strong>班级表：</strong></p><table><thead><tr><th>班级编号（pk）</th><th>班级名称</th></tr></thead><tbody><tr><td>01</td><td>一年一班</td></tr><tr><td>02</td><td>一年二班</td></tr><tr><td>03</td><td>一年三班</td></tr></tbody></table><p><strong>总结：多对多、一对多应该如何设计表</strong></p><p>多对多：三张表，关系表两个外键</p><p>一对多：两张表，多的表加外键</p><h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h1><h2 id="2-1概念"><a href="#2-1概念" class="headerlink" title="2.1概念"></a>2.1概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片01.png" alt="img" style="zoom:80%;"><h2 id="2-2四大特性（ACID）"><a href="#2-2四大特性（ACID）" class="headerlink" title="2.2四大特性（ACID）"></a>2.2四大特性（ACID）</h2><p><strong>1. 原子性（Atomicity）</strong></p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><ul><li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li></ul><p><strong>2. 一致性（Consistency）</strong></p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><blockquote><p>我们在理解数据库时，要把数据库想象成现实生活中的映射，如果数据库中的数据全都符合现实生活中的约束，那么这些数据就是一致的，或者说符合一致性的。</p></blockquote><p><strong>3. 隔离性（Isolation）</strong></p><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><p><strong>4. 持久性（Durability）</strong></p><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><ul><li>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li></ul><p><strong>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</strong></p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片02.png" alt="img" style="zoom:80%;"><h2 id="2-3-AUTOCOMMIT"><a href="#2-3-AUTOCOMMIT" class="headerlink" title="2.3 AUTOCOMMIT"></a>2.3 AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h1 id="3-并发一致性问题"><a href="#3-并发一致性问题" class="headerlink" title="3.并发一致性问题"></a>3.并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1.丢失修改"></a>1.丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><h2 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><h2 id="5-原因分析"><a href="#5-原因分析" class="headerlink" title="5.原因分析"></a>5.原因分析</h2><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是<strong>封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p><h1 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4.隔离级别"></a>4.隔离级别</h1><p>隔离级别的存在也是为了解决隔离性的问题</p><h2 id="1-读取未提交"><a href="#1-读取未提交" class="headerlink" title="1.读取未提交"></a>1.读取未提交</h2><p> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><h2 id="2-读取已提交"><a href="#2-读取已提交" class="headerlink" title="2.读取已提交"></a>2.读取已提交</h2><p>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><h2 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3.可重复读"></a>3.可重复读</h2><p>对同一字段的多次读取结果都是一致的，除非数据是被事务本身所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><h2 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4.可串行化"></a>4.可串行化</h2><p>最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><h1 id="5-锁机制"><a href="#5-锁机制" class="headerlink" title="5.锁机制"></a>5.锁机制</h1><h2 id="5-1锁的粒度"><a href="#5-1锁的粒度" class="headerlink" title="5.1锁的粒度"></a>5.1锁的粒度</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁、表级锁和页级锁。</p><p><strong>行级锁：</strong> 行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p><p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p><strong>表级锁：</strong> 表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p><p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><p><strong>页级锁：</strong> 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><h2 id="5-2锁的类型"><a href="#5-2锁的类型" class="headerlink" title="5.2锁的类型"></a>5.2锁的类型</h2><p><strong>1.读写锁</strong></p><ul><li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新，即执行 INSERT、UPDATE 或 DELETE 命令时。<strong>加锁期间其它事务不能对 A 加任何锁</strong>。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行 select 读取操作，但是不能进行更新操作。<strong>加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</strong>。</li></ul><p>锁的兼容关系如下：</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片03.png" alt="img" style="zoom:80%;"><p><strong>2.意向锁</strong></p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片04.png" alt="img" style="zoom:80%;"><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h2 id="5-3锁协议"><a href="#5-3锁协议" class="headerlink" title="5.3锁协议"></a>5.3锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片06.png" alt="img" style="zoom:50%;"><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片07.png" alt="img" style="zoom:50%;"><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片08.png" alt="img" style="zoom:50%;"><h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p><strong>两段锁协议：</strong> 是指所有的事务必须分两个阶段对数据项加锁和解锁。即<code>事务分两个阶段</code>，第一个阶段是<code>获得封锁</code>。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是<code>释放封锁</code>，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p><p>第一阶段是获得封锁的阶段，称为<code>扩展阶段</code>：其实也就是该阶段可以进入加锁操作，<code>在对任何数据进行读操作之前要申请获得S锁</code>，<code>在进行写操作之前要申请并获得X锁</code>，<code>加锁不成功，则事务进入等待状态</code>，直到加锁成功才继续执行。就是<code>加锁后就不能解锁</code>了。</p><p>第二阶段是释放封锁的阶段，称为<code>收缩阶段</code>：当事务释放一个封锁后，事务进入封锁阶段，在该阶段<code>只能进行解锁而不能再进行加锁操作</code>。</p><p><strong>加锁时机</strong></p><p>当对记录进行更新操作或者select for update(X锁)、lock in share mode(S锁)时，会对记录进行加锁。</p><p><strong>解锁时机</strong></p><p>commit或者rollback时。</p><p><strong>例：</strong></p><p>T1 事务：满足两段锁协议</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>T2 事务：不满足两段锁协议</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如 T1 事务满足两段锁协议，它是可串行化调度。但是 T2 事务不满足，还可以是可串行化调度。</p><blockquote><p><strong>可串行化调度：</strong>是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p></blockquote><h3 id="3-MySQL-隐式与显式锁定"><a href="#3-MySQL-隐式与显式锁定" class="headerlink" title="3. MySQL 隐式与显式锁定"></a>3. MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="6-InnoDB-存储引擎的锁的算法"><a href="#6-InnoDB-存储引擎的锁的算法" class="headerlink" title="6. InnoDB 存储引擎的锁的算法"></a>6. InnoDB 存储引擎的锁的算法</h1><h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p>锁直接加在索引记录上面，锁住的是key。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p>在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。Gap 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p><h2 id="3-Next-Key-Lock"><a href="#3-Next-Key-Lock" class="headerlink" title="3. Next-Key Lock"></a>3. Next-Key Lock</h2><p>Next-Key Lock 是行锁和间隙锁的组合，锁定索引记录两边的间隙，并锁定记录本身，对于行的查询都是采用该方法，主要是解决幻读的问题。</p><p><strong>间隙锁的缺点：</strong></p><p>间隙锁有一个缺点就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入键值锁定范围内的任何数据，在某些场景下可能会对并发性能造成较大的危害。</p><h1 id="7-多版本并发控制"><a href="#7-多版本并发控制" class="headerlink" title="7.多版本并发控制"></a>7.多版本并发控制</h1><h2 id="7-1什么是-MVCC"><a href="#7-1什么是-MVCC" class="headerlink" title="7.1什么是 MVCC"></a>7.1什么是 MVCC</h2><p><strong>MVCC</strong> 全称<code>Multi-Version Concurrency Control</code>，即<strong>多版本并发控制。</strong>MVCC 在 MySQL 中的实现主要是为了<strong>提高数据库并发性能</strong>，用<strong>更好的去处理读-写冲突</strong>。</p><p>它是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现<strong>读取已提交</strong>和<strong>可重复读</strong>这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2 id="7-2当前读和快照读"><a href="#7-2当前读和快照读" class="headerlink" title="7.2当前读和快照读"></a>7.2当前读和快照读</h2><p>在学习 MVCC 多版本并发控制之前，我们必须先了解一下，什么是 MySQL InnoDB 下的当前读和快照读?</p><ul><li><strong>当前读</strong><br>像 select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁) 这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li><li><strong>快照读</strong><br>像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读（一个事务读的肯定是最新版本）；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC，可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li></ul><p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p><p><strong>当前读，快照读和MVCC的关系：</strong></p><ul><li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念，仅仅是一个理想概念。</li><li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。</li></ul><h2 id="7-3-MVCC-能解决什么问题"><a href="#7-3-MVCC-能解决什么问题" class="headerlink" title="7.3 MVCC 能解决什么问题"></a>7.3 MVCC 能解决什么问题</h2><p><strong>数据库并发场景有三种，分别为：</strong></p><ul><li><code>读-读</code>：不存在任何问题，也不需要并发控制</li><li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题</li></ul><p><strong>MVCC带来的好处是？</strong><br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li><li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li></ul><p><strong>总结MVCC的作用：</strong><br>MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p><ul><li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li><li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li></ul><p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p><h2 id="7-4-MVCC-的实现原理"><a href="#7-4-MVCC-的实现原理" class="headerlink" title="7.4 MVCC 的实现原理"></a>7.4 MVCC 的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖<strong>数据库记录</strong>中的 <strong><code>3个隐式字段</code>**，</strong><code>undo日志</code>** ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念：</p><p><strong>隐式字段：</strong>  <strong>数据库表中</strong>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p><ul><li><strong>DB_TRX_ID</strong><br>最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li><li><strong>DB_ROLL_PTR</strong><br>回滚指针，用于配合undo日志，指向上一个旧版本（存储于rollback segment里）</li><li><strong>DB_ROW_ID</strong><br>隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li><li>还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li></ul><p><strong>undo日志：</strong>undo log主要分为两种</p><ul><li><strong>insert undo log</strong><br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li><li><strong>update undo log（最重要）</strong><br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li></ul><p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p><p><strong>Read View(读视图)</strong></p><p><code>Read View</code>就是事务进行<code>快照读</code>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)**</p><p>所以我们知道 <code>Read View</code>主要是<strong>用来做可见性判断</strong>的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p><p><code>Read View</code>遵循一个可见性算法，主要是将要<code>被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟<code>Read View</code>的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个<code>DB_TRX_ID</code>所在的旧记录就是当前事务能看见的最新老版本</p><p><strong>读视图中的字段，小的那个记录的是活跃的事务中的最小ID，还有一个记录系统分配的最新事务ID，也就是这个范围内的事务要么是活跃的，要么是结束的，结束的可以看因为是在该事务执行快照读之前提交的，还有有数据库隐式字段记录的事务ID在最小值之前，也就是与执行该快照读的事务没有交集，当前事务也能够读到，但是当隐式字段的ID是最新分配的就读不到了</strong></p><h2 id="7-5-MVCC-工作整体流程"><a href="#7-5-MVCC-工作整体流程" class="headerlink" title="7.5 MVCC 工作整体流程"></a>7.5 MVCC 工作整体流程</h2><ul><li><p>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.01.png" style="zoom: 67%;"></li><li><p><code>Read View</code>不仅仅会通过一个列表<code>trx_list</code>来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录<code>trx_list</code>列表中事务ID最小的ID），<code>low_limit_id</code>(记录<code>trx_list</code>列表中快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3。</p></li><li><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的<code>undo log</code>，如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和活跃事务ID列表(<code>trx_list</code>)进行比较，判断当前事务2能看到该记录的版本是哪个。</p><img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片05.png" style="zoom: 67%;"></li><li><p>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID 4去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看4是否小于<code>up_limit_id(1)</code>，所以不符合条件，继续判断 4 是否大于等于 <code>low_limit_id(5)</code>，也不符合条件，最后判断4是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p><p><strong>总结：</strong>这个事务是活跃的不能看，执行快照之后分配的事务ID不能看，只有在执行快照之前提交完成 的事务数据能看</p></li><li><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p></li></ul><h2 id="7-6-MVCC-相关问题"><a href="#7-6-MVCC-相关问题" class="headerlink" title="7.6 MVCC 相关问题"></a>7.6 MVCC 相关问题</h2><p><strong>1. RR 是如何在 RC 级的基础上解决不可重复读的？</strong></p><p><strong>当前读和快照读在RR级别下的区别：</strong></p><p><code>表1:</code></p><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center">快照读(无影响)查询金额为500</td><td align="center">快照读查询金额为500</td></tr><tr><td align="center">更新金额为400</td><td align="center"></td></tr><tr><td align="center">提交事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select <code>快照读</code>金额为500</td></tr><tr><td align="center"></td><td align="center">select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table><p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p><p><code>表2:</code></p><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">开启事务</td><td align="center">开启事务</td></tr><tr><td align="center">快照读（无影响）查询金额为500</td><td align="center"></td></tr><tr><td align="center">更新金额为400</td><td align="center"></td></tr><tr><td align="center">提交事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">select <code>快照读</code>金额为400</td></tr><tr><td align="center"></td><td align="center">select lock in share mode<code>当前读</code>金额为400</td></tr></tbody></table><p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p><ul><li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li></ul><p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p><p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p><p><strong>2. RC，RR 级别下的 InnoDB 快照读有什么不同？</strong></p><p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p><ul><li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<code>Read View</code>, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个<code>Read View</code>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个<code>Read View</code>，所以对之后更新的修改不可见；</li><li>即RR级别下，快照读生成<code>Read View</code>时，<code>Read View</code>会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<code>Read View</code>创建的事务所做的修改均是可见</li><li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因（不可重复读）</li></ul><p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="数据库相关" scheme="http://wangjin1996219.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="数据库系统原理" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区</title>
    <link href="http://wangjin1996219.github.io/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <id>http://wangjin1996219.github.io/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</id>
    <published>2021-06-21T08:37:42.000Z</published>
    <updated>2021-08-08T08:36:42.694Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-JVM-运行时数据区"><a href="#1-JVM-运行时数据区" class="headerlink" title="1. JVM 运行时数据区"></a>1. JVM 运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）,如图所示：</p><img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片01.png" alt="img" style="zoom: 50%;"><h1 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h1><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p><h1 id="3-Java-虚拟机栈"><a href="#3-Java-虚拟机栈" class="headerlink" title="3. Java 虚拟机栈"></a>3. Java 虚拟机栈</h1><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈（被指令操作的数据）、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<strong>（线程私有、生命周期同线程生命周期）</strong></p><img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片02.png" alt="img" style="zoom:80%;"><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError（OOM） 异常。</li></ul><h1 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h1><p>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p><h1 id="5-Java-堆"><a href="#5-Java-堆" class="headerlink" title="5. Java 堆"></a>5. Java 堆</h1><p>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例和数组都在这里分配内存；<strong>（线程共享）</strong></p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代（Young Generation）、老年代（Old Generation）。在细致一点的有Eden空间、From Survivor 空间、To Survior 空间等。</p><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><div align="center">  <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px"></div><p>​       上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。（年轻代：老年代=8:1）</p><h1 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h1><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译（ JIT 编译）后的代码等数据。<strong>（线程共享）</strong></p><p>方法区可以看成是一块独立于 Java 堆的内存空间。但是与 Java 堆一样都是线程共享的内存区域。</p><p>方法区在 JVM 启动的时候创建，它的内存分配与 Java 堆一样，可以是不连续的。</p><p>方法区的大小跟堆内存一样，可以选择固定或者是可扩展的。方法区的大小决定了可以保存多少个类，如果定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出错误：java.lang.OutOfMemoryError : PermGen（永久代实现） 或者 java.lang.OutOfMemoryError : Metaspace（元空间实现）。比如：加载大量的第三方 jar 包、Tomcat 部署的工程过多、动态生成大量的反射类就会出现 OOM。</p><p>关闭 JVM 就会释放这个区域的内存。</p><h2 id="6-1-Hotspot-虚拟机中方法区的演进过程"><a href="#6-1-Hotspot-虚拟机中方法区的演进过程" class="headerlink" title="6.1 Hotspot 虚拟机中方法区的演进过程"></a>6.1 Hotspot 虚拟机中方法区的演进过程</h2><p>要注意，只有在 Hotspot 虚拟机中才有永久代的概念，方法区是 Java 虚拟机的一种规范，并不要求每个实现版本的统一。</p><p><strong>Hotspot 中方法区的变化：</strong></p><ul><li><strong>jdk1.6 之前：</strong>有永久代，静态变量存放在永久代上，之所以落地在永久代，是因为存活时间比较长，不用频繁 GC。</li><li><strong>jdk1.7：</strong>有永久代，但是逐渐“去永久代”，字符串常量池、静态变量移除，保存在堆中（拿走了一部分内容）</li><li><strong>jdk1.8 及之后：</strong>无永久代的概念了，通过元空间来存放类型信息、字段、方法、运行时常量池，注意这时的元空间是使用的本地内存，也就是 JVM 之外的内存。但是字符串常量池、静态变量仍在堆中。</li></ul><p>演变过程示意图：</p><p><strong>jdk1.6:</strong></p><img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片03.png" alt="image-20210621172036767" style="zoom:60%;"><p><strong>jdk1.7:</strong></p><img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片04.png" alt="image-20210621172445798" style="zoom:60%;"><p><strong>jdk1.8:</strong></p><img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片05.png" alt="image-20210621172649516" style="zoom:60%;"><h2 id="6-2-永久代为什么要被元空间替换"><a href="#6-2-永久代为什么要被元空间替换" class="headerlink" title="6.2 永久代为什么要被元空间替换"></a>6.2 永久代为什么要被元空间替换</h2><p>从 jdk1.8 之后，永久代就消失了，取而代之的是用元空间来存储类的元信息，元空间是落地在本地内存中的，因此元空间的最大可用内存就是系统的可用内存空间。</p><p>这项改动的原因主要是因为以下两个方面：</p><ol><li><p>为永久代设置空间大小是很难确定的</p><p>在某些场景下，如果分配的内存空间较小，容易造成 FullGC 的次数变多，导致 Stop World 的次数多，系统运行停顿时间变长，另一方面是动态加载的类过多，容易产生永久代的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中需要动态加载很多类，容易发生 OOM 错误。</p><p>如果盲目分配很大的内存空间，就会造成资源浪费。</p><p>而元空间和永久代的最大区别就是：元空间不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</p></li><li><p>对永久代的调优比较困难</p><p>虽然永久代的 FullGC 的机会比较少，但是也会出现。</p><p>方法区的垃圾回收内容：常量池中废弃的常量和不再使用的类。对于废弃常量的回收比较简单，但是判断是否需要回收一个类需要特别复杂的机制，是一个比较耗时的过程。</p><p>所以使用元空间可以尽可能地少出现 FullGC ，对于 JVM 是一个很好的优化。</p></li></ol><h2 id="6-3字符串常量池"><a href="#6-3字符串常量池" class="headerlink" title="6.3字符串常量池"></a>6.3字符串常量池</h2><p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到 string pool 中（记住： string pool 中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在 HotSpot VM 里实现的 string  pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</p><h2 id="6-4-Class-文件常量池"><a href="#6-4-Class-文件常量池" class="headerlink" title="6.4 Class 文件常量池"></a>6.4 Class 文件常量池</h2><p>class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池表(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。  字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值（int count = 20 中的 20 ）等。  符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><strong>作用：</strong>一个 Java 源文件经过编译后会产生一个字节码文件。而这一个程序的执行需要很多的数据支持，像各种类型的类等，如果我们都将这些数据放到字节码文件中，这个文件会非常大，即便是一个很简单的程序。换另一种方式，可以将需要的类型用一个符号代替，将这些符号放到常量池中，就会大大减小编程后的字节码文件大小。</p><h2 id="6-5运行时常量池"><a href="#6-5运行时常量池" class="headerlink" title="6.5运行时常量池"></a>6.5运行时常量池</h2><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p><p>jvm 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而<strong>当类或者接口文件加载到虚拟机内存中后，jvm就会将class常量池中的内容存放到运行时常量池中</strong>，由此可知，<strong>运行时常量池也是每个类都有一个</strong>。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是<strong>把符号引用替换为直接引用</strong>，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><h2 id="6-6实例说明"><a href="#6-6实例说明" class="headerlink" title="6.6实例说明"></a>6.6实例说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String（<span class="string">&quot;abc&quot;</span>）；<span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure><p>这行代码形式上很简单，其实很复杂。有一个常见的 Java 笔试题就是问上面这行代码创建了几个 String 对象。</p><p>你可能认为它创建了一个对象，其实它是创建了两个 String 对象。</p><p>JVM为了提高性能，将一下两种形式的字符串放在一个称之为字符串驻留池的内存块中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">形式一：String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">形式二：<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>其实，形式一和形式二都是字符串的字面常量。所以，可以这样理解，即把字符串的字面常量都放在了字符串驻留池中。对形式一来说， str 其实就是引用的字符串驻留池中 “abc” 这个 String 对象。</p><p>如果有如下的两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>那么，上面的两行代码创建了几个 String 对象？答案是一个。根据我们刚才所述，那么第一行语句将在池中创建一个 String 对象，第二行会先在池中寻找是否有值与 “abc” 相同的 String 对象，如果有，就直接引用，没有这在池中新建 String 对象。这下，就明白了为什么上面的两行语句仅仅创建了一个 String 对象。</p><p>然后，让我们来看一看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>)；</span><br></pre></td></tr></table></figure><p>先不讨论到底创建了几个 String 对象。我们在这里，比较一下这种 new 的方式和上面的直接赋值方式两种创建 String 对象的不同，直接赋值的方式是在字符串驻留池中创建对象，但 new 这种方式是在堆中创建对象。即 new 创建的 String 对象是不会放入字符串驻留池中的。如果一定要把某个通过 new 创建的字符串对象放入驻留池，可以使用 intern() 方法。如 String strt =  str.intern()，将把 str 的值放在驻留池中（当然，是在驻留池原来没有这个值对应的 String 对象的情况下），并返回驻留池中 String 对象的引用。</p><p>现在，可以分析 String str = new String(“abc”); 创建了几个 String 对象了。很明显，传入的 “abc” 字符串字面常量在驻留池中创建了一个对象，new 操作符在堆中创建了一个对象，所以，一共创建了两个 String 对象。</p><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>); </span><br><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">String str4 = str2.intern(); </span><br><span class="line">String str5 = <span class="string">&quot;def&quot;</span>; </span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false </span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的内存分配过程：</p><p>首先，在堆中会有一个 ”abc” 实例，全局 StringTable 中存放着 ”abc” 的一个引用值</p><p>然后，在运行第二句的时候会生成<strong>两个实例：</strong>一个是<strong>字符串常量池</strong>中的 ”def” 实例对象，并且 StringTable 中存储一个 ”def” 的引用值，还有一个是<strong>堆内存</strong>中 new 出来的一个 ”def” 的实例对象，与上面那个是不同的实例</p><p>当在解析 str3 的时候查找 StringTable，里面有 ”abc” 的全局驻留字符串引用，所以 str3 的引用地址与之前的那个已存在的相同</p><p>str4 是在运行的时候调用 intern() 函数，返回 StringTable 中 ”def” 的引用值，如果没有就将 str2 的引用值添加进去，在这里，StringTable 中已经有了 ”def” 的引用值了，所以返回上面在 new str2 的时候添加到 StringTable 中的  “def” 引用值，最后 str5 在解析的时候就也是指向存在于 StringTable 中的 ”def” 的引用值</p><p>上面程序的首先经过编译之后，在该类的 class 常量池中存放一些符号引用，然后类加载之后，将 class 常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中 str1 所指向的 ”abc” 实例对象），然后将这个对象的引用存到全局 String Pool 中，也就是 StringTable 中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询 StringTable，保证 StringTable 里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p><h2 id="6-7补充说明"><a href="#6-7补充说明" class="headerlink" title="6.7补充说明"></a>6.7补充说明</h2><h3 id="1-符号引用与直接引用"><a href="#1-符号引用与直接引用" class="headerlink" title="1.符号引用与直接引用"></a>1.符号引用与直接引用</h3><p><strong>在JVM中类加载过程中，在解析阶段，Java虚拟机会把类的二级制数据中的符号引用替换为直接引用。</strong></p><ol><li><p>符号引用</p><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在 Class 文件中它以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在 Java 中，一个 java 类将会编译成一个 class 文件。<strong>在编译时， java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</strong>比如 org.simple.People 类引用了 org.simple.Language 类，在编译时 People 类并不知道 Language 类的实际内存地址，因此只能使用符号 org.simple.Language（假设是这个，当然实际中是由类似于 CONSTANT_Class_info 的常量来表示的）来表示 Language 类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p></li><li><p>直接引用</p><p>直接引用可以是</p><p>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</p><p>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</p><p>（3）一个能间接定位到目标的句柄</p><p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java虚拟机" scheme="http://wangjin1996219.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器原理</title>
    <link href="http://wangjin1996219.github.io/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://wangjin1996219.github.io/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-21T01:27:29.000Z</published>
    <updated>2021-08-08T08:37:09.798Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><p>布隆过滤器的作用就是用来过滤非法 key ，避免缓存穿透，布隆过滤器用的是位数组，很节省空间，性能也相当好。</p><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：<strong>如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在</strong>。这就是布隆过滤器的基本思想。</p><p><img src="/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-06-21-布隆过滤器原理\图片02.png" alt="这里写图片描述"></p><p><img src="/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-06-21-布隆过滤器原理\图片03.png" alt="这里写图片描述"></p><p><strong>Demo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你的布隆过滤器容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">28</span>;</span><br><span class="line">    <span class="comment">//bit数组，用来存放key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BitSet bitSet = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</span><br><span class="line">    <span class="comment">//后面hash函数会用到，用来生成不同的hash值，可随意设置，别问我为什么这么多8，图个吉利</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">58</span>, <span class="number">68</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add方法，计算出key的hash值，并将对应下标置为true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Arrays.stream(ints).forEach(i -&gt; bitSet.set(hash(key, i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断key是否存在，true不一定说明key存在，但是false一定说明不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">         <span class="comment">//短路与，只要有一个bit位为false，则返回false</span></span><br><span class="line">             result = result &amp;&amp; bitSet.get(hash(key, i));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash函数，借鉴了hashmap的扰动算法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : (i * (DEFAULT_SIZE - <span class="number">1</span>) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>testDemo</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyNewBloomFilter myNewBloomFilter = <span class="keyword">new</span> MyNewBloomFilter();</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;郭德纲&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;蔡徐鸡&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="number">666</span>);</span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友 &quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友1&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;郭德纲&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;蔡徐老母鸡&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="number">666</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="number">888</span>));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对比hash算法计算出来的下标，注意，我们是对比一组，而不是只看一次，一次hash结果对应一个下标</p><p>把同一个key进行多次hash运算，将hash出来的下标放入数组，数组默认全为0，放入元素后该下标就为1，后面判断是否存在元素的时候也是进行同样次数的hash运算，看下结果对应的所有下标是否全为1，若全为1，则代表该key可能存在，若存在不为1的，则说明该key一定不存在；</p><p>默认位数组：[0，0，0，0，0，0]<br>比方说有个已知key的下标是0，2，5</p><p>对应位数组：[1，0，1，0，0，1]<br>判断某个未知key存不存在的时候，假设我们计算出来的下标是0，2，4</p><p>对应位数组：[1，0，1，0，1，0]<br>此时位数组内5对应下标值为0，而已知key位数组的5对应下标位1，说明这两个一定不是同一个key</p><p>相反，如果某个key计算出来的下标为[1，0，1，0，0，1]，只能说这个key可能存在，因为这个key可能是其它key计算出来的</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://wangjin1996219.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据结构" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Netty任务队列</title>
    <link href="http://wangjin1996219.github.io/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    <id>http://wangjin1996219.github.io/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</id>
    <published>2021-06-15T13:31:27.000Z</published>
    <updated>2021-08-08T08:09:49.016Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-Netty中的-TaskQueue-有-3-种典型使用场景"><a href="#1-Netty中的-TaskQueue-有-3-种典型使用场景" class="headerlink" title="1.Netty中的 TaskQueue 有 3 种典型使用场景"></a>1.Netty中的 TaskQueue 有 3 种典型使用场景</h1><ol><li><p>用户程序自定义的普通任务</p></li><li><p>用户自定义定时任务</p></li><li><p>非当前 Reactor 线程调用 Channel 的各种方法</p><p>例如在<strong>推送系统</strong>的业务线程里面，根据<strong>用户的标识</strong>，找到对应的 <strong>Channel</strong> <strong>引用</strong>，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被<strong>异步消费</strong></p></li></ol><h1 id="2-自定义的普通任务"><a href="#2-自定义的普通任务" class="headerlink" title="2.自定义的普通任务"></a>2.自定义的普通任务</h1><p>Netty 如果不做特定的操作当有<strong>耗时高的业务</strong>，handler 会阻塞，如下所示：</p><p><strong>Demo：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.自定义的handler需要继承netty规定的handlerAdapter</span></span><br><span class="line"><span class="comment">*重写一些方法，自定义的handler才能称为一个handler</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">    <span class="comment">//ChannelHandlerContext是上下文对象，含有管道pipeline,通道channel</span></span><br><span class="line">    <span class="comment">//Object msg客户端发送的数据，默认Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//当有耗时高的业务时</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , 阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sever go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//write加Flush方法，将数据写入缓存并刷新</span></span><br><span class="line">        <span class="comment">//对发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列01.png" alt="在这里插入图片描述"></p><p>因为 Handler 中有高耗时的方法，所以服务器端在执行到该方法时，就会阻塞，客户端也会阻塞之后才收到消息。</p><h2 id="使用任务队列"><a href="#使用任务队列" class="headerlink" title="使用任务队列"></a>使用任务队列</h2><p><strong>修改一下服务端的 Handler：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.自定义的handler需要继承netty规定的handlerAdapter</span></span><br><span class="line"><span class="comment">*重写一些方法，自定义的handler才能称为一个handler</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">    <span class="comment">//ChannelHandlerContext是上下文对象，含有管道pipeline,通道channel</span></span><br><span class="line">    <span class="comment">//Object msg客户端发送的数据，默认Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当有耗时高的业务时- 通过异步解决</span></span><br><span class="line">        <span class="comment">//提交该channel对应的NIOEventLoop的taskQueue上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.用户自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , 阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sever go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//write加Flush方法，将数据写入缓存并刷新</span></span><br><span class="line">        <span class="comment">//对发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列02.png" alt="在这里插入图片描述"></p><p>TaskQueue 实现了异步处理，先执行 channelReadComplete，再执行阻塞事件，所以我们看到服务器很快就能启动，然后客户端间隔十秒收到消息，实现了异步获取服务。</p><p><strong>Note：</strong></p><ul><li>任务队列也可以放下多个任务</li><li>任务在 taskQueue 运行是顺序的，并且是一次运行单个任务（串行执行）</li></ul><h1 id="3-自定义的定时任务"><a href="#3-自定义的定时任务" class="headerlink" title="3.自定义的定时任务"></a>3.自定义的定时任务</h1><p>用户自定义定时任务与普通任务区别并不大，有一点不同：将<strong>任务提交到 scheduleTaskQueue</strong></p><p><strong>修改一下服务端的 Handler：</strong>在 channelRead 方法中添加下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.用户自定义定时任务-》任务提交到scheduleTaskQueue</span></span><br><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , scheduleTaskQueue阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列03.png" alt="在这里插入图片描述"></p><p>这里我们又加入了一个阻塞 20 秒的任务，证明任务队列中的任务是串行执行的。</p><h1 id="4-非当前-Reactor-线程调用-Channel-的方法"><a href="#4-非当前-Reactor-线程调用-Channel-的方法" class="headerlink" title="4.非当前 Reactor 线程调用 Channel 的方法"></a>4.非当前 Reactor 线程调用 Channel 的方法</h1><p><strong>实现方式：</strong></p><p>可以使用一个集合管理所有的 SocketChannel，当我们想要推送消息时，将业务加入到该 Channel 对应的 NioEventLoop 的 TaskQueue 或者 ScheduleTaskQueue。</p><p>其实操作与上面两种类似<br>服务器使用集合保存管理所有的 SocketChannel，ctx.channel() 获得想要的通道， ctx.channel().eventLoop().schedule()或者.execute(）操作调用 Write 方法向该用户推送消息</p><p>其实我们前面已经往客户端推送消息了，这里只是对推送的通道做一定的限制（也就是要根据标识找到用户对应的 Channel ）。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="框架相关" scheme="http://wangjin1996219.github.io/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Netty相关" scheme="http://wangjin1996219.github.io/tags/Netty%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Netty线程模型</title>
    <link href="http://wangjin1996219.github.io/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://wangjin1996219.github.io/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-06-15T07:54:18.000Z</published>
    <updated>2021-08-08T08:10:04.970Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-线程模型的基本介绍"><a href="#1-线程模型的基本介绍" class="headerlink" title="1.线程模型的基本介绍"></a>1.线程模型的基本介绍</h1><p><strong>目前存在的线程模型有：</strong></p><ul><li>传统阻塞 I/O 服务模型</li><li>Reactor 模式</li></ul><p><strong>然后根据 Reactor 的数量和处理资源线程池的数量不同，有三种典型的表现：</strong></p><ol><li>单 Reactor 单线程</li><li>单 Reactor 多线程</li><li>主从 Reactor 多线程 </li></ol><h1 id="2-传统的阻塞-I-O-服务模型"><a href="#2-传统的阻塞-I-O-服务模型" class="headerlink" title="2.传统的阻塞 I/O 服务模型"></a>2.传统的阻塞 I/O 服务模型</h1><p><strong>工作原理图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\传统阻塞模型.png" alt="image-20210615163611563"></p><p><strong>模型特点：</strong></p><ol><li>采用阻塞 IO 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ol><p><strong>问题分析：</strong></p><ol><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</li></ol><h1 id="3-Reactor-模型"><a href="#3-Reactor-模型" class="headerlink" title="3. Reactor 模型"></a>3. Reactor 模型</h1><p><strong>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</strong></p><ol><li>基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</li></ol><p><strong>工作原理图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Reactor模式.png" alt="image-20210615164010482"></p><p><strong>工作流程：</strong></p><ol><li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher 模式</li><li>Reactor 模式使用 I/O 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键</li></ol><p><strong>Reactor 模式中核心组成：</strong></p><p><strong>Reactor：</strong>Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。</p><p><strong>Handlers：</strong>处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</p><h2 id="3-1单-Reactor-单线程"><a href="#3-1单-Reactor-单线程" class="headerlink" title="3.1单 Reactor 单线程"></a>3.1单 Reactor 单线程</h2><p><strong>工作原理示意图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\单线程模型.png" alt="image-20210615165549406"></p><p><strong>工作流程：</strong></p><ol><li>Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li><li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后续业务处理</li><li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li><li>Handler 会完成 Read→业务处理→Send 的完整业务流程</li></ol><p><strong>优缺点分析：</strong></p><ul><li><strong>优点：</strong>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li><strong>缺点：</strong><ol><li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li></ol></li></ul><p><strong>使用场景：</strong></p><p>客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况</p><h2 id="3-2单-Reactor-多线程"><a href="#3-2单-Reactor-多线程" class="headerlink" title="3.2单 Reactor 多线程"></a>3.2单 Reactor 多线程</h2><p><strong>工作原理示意图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\多线程模型.png" alt="image-20210615170532648"></p><p><strong>工作流程：</strong></p><ol><li>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</li><li>如果建立连接请求, 则右 Acceptor 通过 accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 reactor 分发调用连接对应的 handler 来处理</li><li>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务</li><li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler</li><li>handler 收到响应后，通过 send 将结果返回给 client</li></ol><p><strong>优缺点分析：</strong></p><ul><li><strong>优点：</strong>可以充分的利用多核 cpu 的处理能力</li><li><strong>缺点：</strong>多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈</li></ul><h2 id="3-3主从-Reactor-多线程"><a href="#3-3主从-Reactor-多线程" class="headerlink" title="3.3主从 Reactor 多线程"></a>3.3主从 Reactor 多线程</h2><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行</p><p><strong>工作原理示意图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\主从多线程模型.png" alt="image-20210615171159338"></p><p><strong>工作流程：</strong></p><ol><li>Reactor 主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过 Acceptor(接收器) 处理连接事件</li><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor </li><li>Subreactor 将连接加入到连接队列进行监听，并创建 handler 进行各种事件处理</li><li>当有新事件发生时， Subreactor 就会调用对应的 handler 处理</li><li>handler 通过 read 读取数据，分发给后面的 worker 线程处理</li><li>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过 send 将结果返回给 client</li><li>Reactor 主线程可以对应多个 Reactor 子线程, 即 <strong>MainRecator 可以关联多个 SubReactor</strong></li></ol><p><strong>优缺点分析：</strong></p><ul><li><strong>优点：</strong><ol><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li></ol></li><li><strong>缺点：</strong>编程复杂度较高</li></ul><p><strong>应用场景：</strong></p><p>这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p><h2 id="3-4-Reactor-模型小结"><a href="#3-4-Reactor-模型小结" class="headerlink" title="3.4 Reactor 模型小结"></a>3.4 Reactor 模型小结</h2><p><strong>3</strong> <strong>种模式用生活案例来理解</strong></p><ol><li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li><li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 Reactor 多线程，多个前台接待员，多个服务生</li></ol><p><strong>Reactor</strong> <strong>模式具有如下的优点：</strong></p><ol><li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li><li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li><li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h1 id="4-Netty模型"><a href="#4-Netty模型" class="headerlink" title="4. Netty模型"></a>4. Netty模型</h1><h2 id="4-1基础版"><a href="#4-1基础版" class="headerlink" title="4.1基础版"></a>4.1基础版</h2><p>Netty 主要基于<strong>主从</strong> <strong>Reactors</strong> <strong>多线程模型</strong>（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Netty模型01.png" alt="image-20210615203144413"></p><p>每个线程就是 NioEventLoop ，包含一个 Selector、以及任务队列等。</p><h2 id="4-2高级版"><a href="#4-2高级版" class="headerlink" title="4.2高级版"></a>4.2高级版</h2><p><strong>Netty 的服务端工作原理图：</strong></p><p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Netty模型02.png" alt="image-20210615203430618"></p><p><strong>工作流程：</strong></p><ul><li>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接,，WorkerGroup 专门负责网络的读写</li><li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</li><li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</li><li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯</li><li>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop</li><li>每个 Boss NioEventLoop 循环执行的步骤有3步<ol><li>轮询 accept 事件</li><li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker NIOEventLoop 上的 selector</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ol></li><li>每个 Worker NIOEventLoop 循环执行的步骤<ol><li>轮询 read, write 事件</li><li>处理 I/O 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</li><li>处理任务队列的任务 ， 即 runAllTasks</li></ol></li><li>每个 Worker NIOEventLoop  处理业务时，会使用 pipeline (管道), pipeline 中包含了 channel , 即通过 pipeline 可以获取到对应通道, 管道中维护了很多的处理器</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="框架相关" scheme="http://wangjin1996219.github.io/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Netty相关" scheme="http://wangjin1996219.github.io/tags/Netty%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java同步方法的锁对象</title>
    <link href="http://wangjin1996219.github.io/2021/06/05/Java%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://wangjin1996219.github.io/2021/06/05/Java%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-06-05T14:10:35.000Z</published>
    <updated>2021-08-08T08:35:51.796Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h1><p>同步代码块的格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象)&#123;</span><br><span class="line">    多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized(任意对象)：相当于给代码加锁了，任意时刻只能有一个线程访问共享的代码块，并且<strong>任意对象都可以看成是一把锁</strong>。</p><p>下面我们写一个包含同步代码块的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个任意对象，作为同步代码块的锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过synchronized关键字锁住共享资源</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">                Method1();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//让线程Thread-1执行方法2</span></span><br><span class="line">                Method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//同步代码块：创建两个对象my5、my6</span></span><br><span class="line">        MyRunnable2 my5 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        MyRunnable2 my6 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">19</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">25</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>可以看到<strong>同一时刻只有获取到锁对象 obj 的线程才能访问同步代码块</strong></p><p>如果将线程2的构造对象传入 My6，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my6);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>可以看到两个线程可以同时访问同步代码块，这是因为他俩访问的并不是同一块同步代码块，并且锁对象 obj 也并不是同一个锁对象，可以检验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(my5.obj==my6.obj);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><h1 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h1><p>同步方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法就是把 synchronized 关键字加到方法上，同步方法的锁对象是同一对象。</p><p>下面我们写一个包含同步方法的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步方法：创建两个对象my1、my2</span></span><br><span class="line">        MyRunnable my1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        MyRunnable my2 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">26</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">32</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>我们将线程2构造的对象替换成 my2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my2);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们开始传入的是同一个对象，所以线程串行访问共享资源，当我们传入的不是同一个对象时，每个对象都相当于一把锁，所以执行没有冲突。</p><p><strong>结论：</strong>所以同步方法的锁对象是 this 对象</p><h1 id="3-静态同步方法"><a href="#3-静态同步方法" class="headerlink" title="3.静态同步方法"></a>3.静态同步方法</h1><p>静态同步方法的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态同步方法就是把 synchronized 关键字加到静态方法上，静态同步方法的锁对象是类名。</p><p>下面我们写一个包含静态同步方法的共享资源 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态同步方法：创建两个对象my3、my4</span></span><br><span class="line">        MyRunnable1 my3 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line">        MyRunnable1 my4 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:48:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:48:56:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p>我们将线程2构造的对象替换成 my4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my4);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:49:47:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:49:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure><p><strong>分析：</strong>我们可以看到，修改前后，线程的执行顺序是一样的，也就是说静态同步方法只有拿到这个 class 才能访问，而运行时 JVM 只有这一个类，所以同一时间只能有一个线程访问共享资源。</p><p><strong>结论：</strong>所以静态同步方法的锁对象是类名</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) ，因为 JVM 中，字符串常量池具有缓存功能！</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java多线程" scheme="http://wangjin1996219.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wj-Blog</title>
  
  
  <link href="http://wangjin1996219.github.io/atom.xml" rel="self"/>
  
  <link href="http://wangjin1996219.github.io/"/>
  <updated>2021-04-15T12:19:21.395Z</updated>
  <id>http://wangjin1996219.github.io/</id>
  
  <author>
    <name>老王家的小王呀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap</title>
    <link href="http://wangjin1996219.github.io/2021/04/15/HashMap/"/>
    <id>http://wangjin1996219.github.io/2021/04/15/HashMap/</id>
    <published>2021-04-15T09:10:10.000Z</published>
    <updated>2021-04-15T12:19:21.395Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/two-sum/">热题100-1. 两数之和</a></strong></p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>利用HashMap查找时间复杂度为O(1)</strong></p><ul><li>遍历数组，每遍历到一个元素，用目标值减去该元素，如果前面有对应的元素，在HashMap中应该有对应的键值，将该元素索引和HashMap中的索引返回即可</li><li>如果没有，将该元素和其索引存储到HashMap中</li><li>遍历结束没有找到，返回空数组</li></ul><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    hm.put(nums[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,hm.get(target-nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        hm.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><a href="https://www.nowcoder.com/practice/704c8388a82e42e58b7f5751ec943a11?tpId=190&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-未排序数组中累加和为给定值的最长子数组长度</strong></a></p><p>给定一个无序数组arr, 其中元素可正、可负、可0。给定一个整数k，求arr所有子数组中累加和为k的最长子数组长度</p><p>与力扣上一道二叉树的题目很像</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>前缀和：</strong>前缀和表示数组中该元素前面的元素累加和 + 该元素的和</p><p>同一数组中，如果<strong>两个数的前缀总和是相同的，那么这些元素之间的元素总和为零</strong>。进一步扩展相同的想法，<strong>如果前缀总和currSum，在元素A和元素B处相差target，则位于元素A和元素B之间的元素之和是target</strong>。</p><ul><li>维护一个最大长度的变量max</li><li>遍历数组中的元素，计算该元素的前缀和</li><li>当该元素的前缀和-目标值在HashMap中时，表示它们之间的差值满足目标值</li><li>如果该前缀和在HashMap中不存在，添加到Hashmap中；如果存在，不用添加，因为要求最长子序列，所以索引越远越好</li></ul><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max length of the subarray sum = k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxlenEqualK</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        hm.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            preSum+=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(preSum-k))&#123;</span><br><span class="line">                max=Math.max(max,i+<span class="number">1</span>-hm.get(preSum-k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hm.containsKey(preSum))&#123;</span><br><span class="line">                hm.put(preSum,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目三</p><p>解题思路</p><p>代码及注释</p><p>题目四</p><p>解题思路</p><p>代码及注释</p><p>题目五</p><p>解题思路</p><p>代码及注释</p><p>题目六</p><p>解题思路</p><p>代码及注释</p><p>题目七</p><p>解题思路</p><p>代码及注释</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数据结构篇" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>Redis相关</title>
    <link href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-10T07:12:13.000Z</published>
    <updated>2021-04-16T03:18:09.675Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1Redis简介"><a href="#1-1Redis简介" class="headerlink" title="1.1Redis简介"></a>1.1Redis简介</h2><ul><li>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向；</li><li>redis 也经常用来做分布式锁；</li><li>redis 提供了多种数据类型来支持不同的业务场景；</li><li>redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </li></ul><h2 id="1-2为什么要用-redis"><a href="#1-2为什么要用-redis" class="headerlink" title="1.2为什么要用 redis"></a>1.2为什么要用 redis</h2><p>主要依据“<strong>高性能</strong>”和“<strong>高并发</strong>”这两点</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg"></p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg"></p><h2 id="1-3为什么用redis而不用map-guava-做缓存"><a href="#1-3为什么用redis而不用map-guava-做缓存" class="headerlink" title="1.3为什么用redis而不用map/guava 做缓存?"></a>1.3为什么用redis而不用map/guava 做缓存?</h2><p>以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错。</p><p>使用 redis 之类的称为<strong>分布式缓存</strong>，在多实例（进程）的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p><h1 id="2-数据类型和使用场景分析"><a href="#2-数据类型和使用场景分析" class="headerlink" title="2.数据类型和使用场景分析"></a>2.数据类型和使用场景分析</h1><h2 id="2-1String"><a href="#2-1String" class="headerlink" title="2.1String"></a>2.1String</h2><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 </p><p><strong>应用场景：</strong></p><ul><li>常规key-value缓存应用</li><li>常规计数：微博数，粉丝数等</li></ul><h2 id="2-2Hash"><a href="#2-2Hash" class="headerlink" title="2.2Hash"></a>2.2Hash</h2><p>hash 是一个 string 类型的 field 和 value 的映射表（值：包含键值对的无序散列表）</p><p><strong>应用场景：</strong></p><ul><li>hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li></ul><p>比如下面我就用 hash 类型存放了我本人的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: <span class="number">1</span>,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: <span class="number">22</span>,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3List"><a href="#2-3List" class="headerlink" title="2.3List"></a>2.3List</h2><p>list 就是链表</p><p><strong>应用场景：</strong></p><p>Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h2 id="2-4Set"><a href="#2-4Set" class="headerlink" title="2.4Set"></a>2.4Set</h2><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p><strong>应用场景：</strong></p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p><h2 id="2-5Sorted-Set"><a href="#2-5Sorted-Set" class="headerlink" title="2.5Sorted Set"></a>2.5Sorted Set</h2><p>和set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>应用场景：</strong></p><p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis支持持久化支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>将数据在某个节点上的副本写入一个临时文件，持久化结束后，用该临时文件替换上次持久化的文件，达到数据恢复的目的</p><p><strong>优点：</strong>使用单独的子进程来持久化，主进程不会进行任何的I/O操作，保证了redis的高效性能</p><p><strong>缺点：</strong>RDB通常间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据的丢失，所示更适用于对数据要求不是很严谨的情况</p><p>项目中使用的存储机制：检测到更改的key越多，更新越频繁</p><table><thead><tr><th>更改key的数目</th><th>更新时间间隔</th></tr></thead><tbody><tr><td>更改了1个key</td><td>间隔900秒更新一次数据</td></tr><tr><td>更改了10个key</td><td>间隔300秒更新一次数据</td></tr><tr><td>10000</td><td>60秒</td></tr></tbody></table><p><strong>AOF（append-only file）持久化</strong></p><p>将执行过的指令记录下来，数据恢复时，按照记录文件中的指令顺序，再将指令执行一遍</p><p>优点：可以保持更高的数据完整性，如果设置appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。且日志写入写信不完整，支持检查AOF日志来进行AOF修复，AOF没有被write之前可以删除某些指令</p><p>缺点：AOF文件比RDB文件大，恢复的速度比RDB慢</p><h1 id="4-过期键的删除策略-Redis设置过期时间"><a href="#4-过期键的删除策略-Redis设置过期时间" class="headerlink" title="4.过期键的删除策略-Redis设置过期时间"></a>4.过期键的删除策略-Redis设置过期时间</h1><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p><p><strong>定期删除+惰性删除。</strong></p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p><h1 id="5-内存相关"><a href="#5-内存相关" class="headerlink" title="5.内存相关"></a>5.内存相关</h1><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</p><h2 id="5-1Redis的内存淘汰策略"><a href="#5-1Redis的内存淘汰策略" class="headerlink" title="5.1Redis的内存淘汰策略"></a>5.1Redis的内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p><strong>全局的键空间选择性移除</strong></p><ol><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p><strong>设置过期时间的键空间选择性移除</strong></p><ol><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li></ol><p>4.0版本后增加以下两种：</p><ol><li><strong>volatile-lfu</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6.线程模型"></a>6.线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p><strong>Redis 是单线程的，为什么还那么快？</strong></p><ol><li>操作完全基于内存，速度快；</li><li>数据结构简单，对数据的操作也简单；</li><li>采用单线程，避免了不必要的上下文切换开销；</li><li>使用非阻塞的<strong>多路IO复用模型。</strong></li></ol><p>​    I/O 多路复用模型是利用select、poll、epoll可以<strong>同时监察多个流的 I/O 事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，<strong>当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流</strong>（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 <strong>I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且<strong>Redis在内存中操作数据的速度非常快</strong>（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7.事务"></a>7.事务</h1><p>==没整完哦==</p><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。</p><p><strong>隔离性</strong></p><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h1 id="8-集群方案"><a href="#8-集群方案" class="headerlink" title="8.集群方案"></a>8.集群方案</h1><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> 、<code>twemproxy</code> 有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p><p>现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p><p>Redis的官方多机部署方案，Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master  node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><h2 id="8-1Redis-cluster-介绍"><a href="#8-1Redis-cluster-介绍" class="headerlink" title="8.1Redis cluster 介绍"></a>8.1Redis cluster 介绍</h2><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p><p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h2 id="8-2节点间的内部通信机制"><a href="#8-2节点间的内部通信机制" class="headerlink" title="8.2节点间的内部通信机制"></a>8.2节点间的内部通信机制</h2><p><strong>基本通信原理</strong></p><p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p><p><strong>集中式：</strong>是将集群元数据（节点信息、故障等等）几种存储在某个节点上。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\集中式.png" style="zoom:120%;"><p><strong>Gossip 协议：</strong>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\Gossip.png" style="zoom:120%;"><p><strong>两种通信方式对比：</strong></p><ul><li><p><strong>集中式：</strong></p><p>优点：元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</p><p>缺点：所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p></li><li><p><strong>Gossip协议：</strong></p><p>优点：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p><p>缺点：元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p></li></ul><blockquote><p><strong>数据元、元数据与数据</strong></p><p>数据元是组成实体数据的最小单元，或称原子数据，例如，客户联系方式中的手机号码，手机号为数据元，135****为数据元的值。</p><p>元数据是用来描述数据的数据，让数据更容易理解、查找、管理和使用。举个栗子“村里有个姑娘叫小芳，长得好看又善良”这首耳熟能详的歌，我们分析一下，姓名：小芳、性别：姑娘（女）、长相：好看、性格：善良，住址：村里。这里面：小芳是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。当然元数据也会被描述，例如上边我举的例子中姓名的字段长度，字段编码、定义、字段类型、默认值等是用来描述“姓名”这个数据元的。</p></blockquote><h2 id="8-3分布式寻址算法"><a href="#8-3分布式寻址算法" class="headerlink" title="8.3分布式寻址算法"></a>8.3分布式寻址算法</h2><ul><li><strong>hash 算法（大量缓存重建）</strong></li><li><strong>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</strong></li><li><strong>Redis cluster 的 hash slot 算法</strong></li></ul><h3 id="8-3-1hash-算法"><a href="#8-3-1hash-算法" class="headerlink" title="8.3.1hash 算法"></a>8.3.1hash 算法</h3><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p><h3 id="8-3-2一致性-hash-算法"><a href="#8-3-2一致性-hash-算法" class="headerlink" title="8.3.2一致性 hash 算法"></a>8.3.2一致性 hash 算法</h3><blockquote><p>简书文章链接：<a href="https://www.jianshu.com/p/528ce5cd7e8f"><strong>点击这里</strong></a></p></blockquote><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p><p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p><p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。（因为计算出HashCode后，沿着顺时针走遇到的）</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\一致性hash算法.png" style="zoom:80%;"><p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p><blockquote><p><strong>缓存热点又称为数据倾斜问题</strong></p><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（<strong>被缓存的对象大部分缓存在某一台服务器上</strong>）问题</p></blockquote><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\数据倾斜问题.png" style="zoom:67%;"><p>数据定位算法不变，只需要增加一步：<strong>虚拟节点到实际点的映射</strong>。</p><p>所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p><h3 id="8-3-3Redis-cluster-的-hash-slot-算法"><a href="#8-3-3Redis-cluster-的-hash-slot-算法" class="headerlink" title="8.3.3Redis cluster 的 hash slot 算法"></a>8.3.3Redis cluster 的 hash slot 算法</h3><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 校验码值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p><p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有  5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的  hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p><p>任何一台机器宕机，另外两个节点，不影响的。因为 <strong>key 找的是 hash slot，不是机器</strong>。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\hash-slot.png" style="zoom:80%;"><p>9.分区</p><h1 id="10-分布式问题"><a href="#10-分布式问题" class="headerlink" title="10.分布式问题"></a>10.分布式问题</h1><h2 id="10-1分布式锁"><a href="#10-1分布式锁" class="headerlink" title="10.1分布式锁"></a>10.1分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p><p><strong>当且仅当 key 不存在</strong>，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p><p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>如返回1，则该客户端获得锁，把lock-key的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。<br>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\分布式锁.png" style="zoom:80%;"><p><strong>使用SETNX完成同步锁的流程及事项如下：</strong></p><ul><li><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功（如指令2、1）</p></li><li><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p></li><li><p>释放锁，使用DEL命令将锁数据删除</p></li></ul><h2 id="10-2如何解决Redis的并发竞争Key问题"><a href="#10-2如何解决Redis的并发竞争Key问题" class="headerlink" title="10.2如何解决Redis的并发竞争Key问题"></a>10.2如何解决Redis的并发竞争Key问题</h2><p><strong>介绍：</strong>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>这里的并发指的是多个redis的client同时set key引起的并发问题。</p><p><strong>解决方案：</strong></p><p><strong>方案一：分布式锁+时间戳</strong></p><p><strong>分布式锁：</strong>传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。分布式锁可以基于很多种方式实现，比如zookeeper、redis等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p><p>利用SETNX非常简单地实现分布式锁。例如：某客户端要获得一个名字youzhi的锁，客户端使用下面的命令进行获取：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock.youzhi&lt;current Unix <span class="built_in">time</span> + lock timeout + <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>如返回1，则该客户端获得锁，把lock.youzhi的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。</p><p>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p><p><strong>时间戳</strong></p><p>由于上面举的例子，要求key的操作需要顺序执行，所以需要在缓存中保存一个时间戳判断set顺序。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统A key <span class="number">1</span> &#123;ValueA <span class="number">7</span>:<span class="number">00</span>&#125;</span><br><span class="line">系统B key <span class="number">1</span> &#123;ValueB <span class="number">7</span>:<span class="number">05</span>&#125;</span><br></pre></td></tr></table></figure><p>假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。</p><p><strong>方案二：利用消息队列</strong></p><p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p><p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p><p><strong>附加：zookeeper分布式锁</strong></p><p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><h1 id="11-缓存异常"><a href="#11-缓存异常" class="headerlink" title="11.缓存异常"></a>11.缓存异常</h1><h2 id="11-1缓存雪崩"><a href="#11-1缓存雪崩" class="headerlink" title="11.1缓存雪崩"></a>11.1缓存雪崩</h2><p><strong>什么是缓存雪崩？</strong></p><p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p><strong>有哪些解决办法？</strong></p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉（通过限流来限制直接访问数据库的请求数量，当限流组件发现剩余的请求未能通过自己，便会调用自定义的降级组件，返回一些默认的友好提示：服务器忙，请稍后重试等，不让客户端继续等待）</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" style="zoom:80%;"><h2 id="11-2缓存穿透"><a href="#11-2缓存穿透" class="headerlink" title="11.2缓存穿透"></a>11.2缓存穿透</h2><p><strong>什么是缓存穿透？</strong></p><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，造成数据库负载过大。如下图所示：</p><p><strong>正常缓存处理流程：</strong></p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png" style="zoom:60%;"><p><strong>缓存穿透情况处理流程：</strong></p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png" style="zoom:60%;"><p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;; </code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p><p><strong>有哪些解决办法？</strong></p><p><strong>1）参数校验</strong></p><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>2）缓存无效 key</strong> </p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险（比如频繁更换key，造成大量的无效key存在于缓存中）</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png" style="zoom:60%;"><h1 id="12-常用工具"><a href="#12-常用工具" class="headerlink" title="12.常用工具"></a>12.常用工具</h1><h2 id="12-1Redis支持的客户端"><a href="#12-1Redis支持的客户端" class="headerlink" title="12.1Redis支持的客户端"></a>12.1Redis支持的客户端</h2><p>Redisson、Jedis等</p><p><strong>二者的对比</strong></p><ul><li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；（Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的）</li><li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li></ul><h1 id="13-其他问题"><a href="#13-其他问题" class="headerlink" title="13.其他问题"></a>13.其他问题</h1><h2 id="13-1redis-和-memcached-的区别"><a href="#13-1redis-和-memcached-的区别" class="headerlink" title="13.1redis 和 memcached 的区别"></a>13.1redis 和 memcached 的区别</h2><ol><li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><table><thead><tr><th align="center">对比参数</th><th align="center">Redis</th><th align="center">Memcached</th></tr></thead><tbody><tr><td align="center"><strong>数据存储类型</strong></td><td align="center">1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td><td align="center">1. 文本型 2. 二进制类型</td></tr><tr><td align="center"><strong>持久化支持</strong></td><td align="center">1. RDB 2. AOF</td><td align="center">不支持</td></tr><tr><td align="center"><strong>集群模式</strong></td><td align="center">原生支持 cluster 模式，可以实现主从复制，读写分离</td><td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td></tr><tr><td align="center"><strong>网络IO模型</strong></td><td align="center">1. 单线程的多路 IO 复用模型</td><td align="center">1. 多线程，非阻塞IO模式</td></tr><tr><td align="center">内存管理机制</td><td align="center">在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td><td align="center">Memcached 的数据则会一直在内存中，将内存分片来解决内存碎片的问题</td></tr><tr><td align="center">事件库</td><td align="center">自封转简易事件库AeEvent</td><td align="center">贵族血统的LibEvent事件库</td></tr><tr><td align="center">类型</td><td align="center">1. 支持内存 2. 非关系型数据库</td><td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td></tr><tr><td align="center">查询【操作】类型</td><td align="center">1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td><td align="center">1.常用的CRUD 2. 少量的其他命令</td></tr><tr><td align="center">附加功能</td><td align="center">1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td><td align="center">1. 多线程服务支持</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">复杂数据结构，有持久化，高可用需求，value存储内容较大</td><td align="center">纯key-value，数据量非常大，并发量非常大的业务</td></tr></tbody></table><h2 id="13-2如何保证缓存与数据库双写时的数据一致性？"><a href="#13-2如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="13.2如何保证缓存与数据库双写时的数据一致性？"></a>13.2如何保证缓存与数据库双写时的数据一致性？</h2><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p><strong>读请求和写请求串行化</strong></p><p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p><p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p><h3 id="13-2-1Cache-Aside-Pattern"><a href="#13-2-1Cache-Aside-Pattern" class="headerlink" title="13.2.1Cache Aside Pattern"></a>13.2.1Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p><ul><li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li><li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li></ul><p><strong>为什么是删除缓存，而不是更新缓存？</strong></p><ul><li><p><strong>因为对于比较复杂的缓存数据计算场景，当被更新的缓存频繁更新、且不常被访问时，更新缓存的代价比较高</strong></p><p><strong>例如：</strong>一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p></li></ul><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><h3 id="13-2-2最初级的缓存不一致问题及解决方案"><a href="#13-2-2最初级的缓存不一致问题及解决方案" class="headerlink" title="13.2.2最初级的缓存不一致问题及解决方案"></a>13.2.2最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><strong>解决思路：</strong></p><p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p><h3 id="13-2-3比较复杂的数据不一致问题分析"><a href="#13-2-3比较复杂的数据不一致问题分析" class="headerlink" title="13.2.3比较复杂的数据不一致问题分析"></a>13.2.3比较复杂的数据不一致问题分析</h3><p><strong>问题：</strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改，造成数据库和缓存中的数据不一样。</p><p><strong>出现场景：</strong>上亿流量高并发场景下，缓存会出现这个问题</p><p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p><p><strong>解决思路：</strong></p><p>更新数据的时候，根据<strong>数据的唯一标识（例如店铺ID）</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p><p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p><p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p><p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p><h1 id="14-五种IO模型"><a href="#14-五种IO模型" class="headerlink" title="14.五种IO模型"></a>14.五种IO模型</h1><blockquote><p><strong>Note：</strong></p><p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p><p> 我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p></blockquote><h2 id="14-1阻塞IO"><a href="#14-1阻塞IO" class="headerlink" title="14.1阻塞IO"></a>14.1阻塞IO</h2><p><strong>读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。内核准备数据，并将数据从内核拷贝到用户内存，内核返回结果，用户进程再解除阻塞状态，重新运行起来。</strong></p><p>执行如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd=connect();</span><br><span class="line">write(fd);</span><br><span class="line">read(fd);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</p><h2 id="14-2非阻塞IO"><a href="#14-2非阻塞IO" class="headerlink" title="14.2非阻塞IO"></a>14.2非阻塞IO</h2><p>用户进程调用recvfrom之后，如果内核数据没有准备好，并不会阻塞用户进程，而是立即返回数据未准备好的信号，用户进程以后不断调用recvfrom来<strong>轮询</strong>内核是否准备好数据。</p><h2 id="14-3信号驱动IO"><a href="#14-3信号驱动IO" class="headerlink" title="14.3信号驱动IO"></a>14.3信号驱动IO</h2><p>用户进程调用recvfrom之后，不等待数据就绪立即返回，等内核准备好数据之后，发送信号给用户进程。</p><h2 id="14-4异步IO"><a href="#14-4异步IO" class="headerlink" title="14.4异步IO"></a>14.4异步IO</h2><p>读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。</p><p>读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p><p>对比信号驱动IO，异步IO的主要区别在于：**信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)**。</p><h2 id="14-5IO多路复用IO"><a href="#14-5IO多路复用IO" class="headerlink" title="14.5IO多路复用IO"></a>14.5IO多路复用IO</h2><p>可以处理多个连接。这里的select相当于一个代理，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个套接字，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。</p><p>由于select可以监听多个socket，我们可以用它来处理多个连接。所以称为复用。</p><h3 id="14-5-1常用的IO复用模型"><a href="#14-5-1常用的IO复用模型" class="headerlink" title="14.5.1常用的IO复用模型"></a>14.5.1常用的IO复用模型</h3><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让<strong>单个进程可以监视多个文件描述符</strong>，一旦<strong>某个描述符就绪</strong>（一般是读就绪或写就绪），能够<strong>通知程序进行相应的读写操作</strong>。与多进程和多线程技术相比，I/O多路复用技术的最大优势是<strong>系统开销小</strong>，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><p><strong>三种：select，poll，epoll</strong></p><ul><li><p><strong>select</strong>==&gt;时间复杂度O(n)</p><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询所有流</strong>，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p></li><li><p><strong>poll</strong>==&gt;时间复杂度O(n)</p><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p></li><li><p><strong>epoll</strong>==&gt;时间复杂度O(1)</p><p>epoll可以理解为event poll，不同于无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p></li></ul><p><strong>三种模型分析：</strong></p><p><strong>select缺点：</strong></p><ul><li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态；</li><li>需要在内核遍历传递进来的所有fd_set，找出能读出数据，或者写入数据的流，对他们进行操作；</li><li>内核对被监控的fd_set集合大小做了限制，为1024。</li></ul><p><strong>poll缺点：</strong></p><ul><li>poll没有最大文件描述符数量的限制，因为数据结构变成了链表</li><li>其他缺点和select一样</li></ul><p><strong>epoll：（优势）</strong></p><ul><li>没有最大并发连接的限制，能打开的FD的上限远大于1024</li><li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数</li><li>不需要每次都把fd_set集合从用户态拷贝到内核态</li></ul><p><strong>应用场景：</strong></p><p>select、poll：连接数少并且连接都十分活跃的情况</p><p>epoll：连接多，并且有大量不太活跃的连接</p><p><strong>epoll的实现原理：</strong></p><ul><li><p><strong>epoll_create()系统调用：</strong>通过此调用建立一个epoll对象，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p><p><code>红黑树：</code>树中存储着所有添加到epoll中的需要监控的事件</p><p><code>双链表：</code>存放着将要通过epoll_wait()返回给用户的满足条件的事件（所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中）</p></li><li><p><strong>epoll_ctl()系统调用：</strong>通过此调用向epoll对象中添加、删除、修改感兴趣的事件，所以不需要每次调用epoll_wait都复制所有的事件结构</p></li><li><p><strong>epoll_wait()系统调用：</strong>通过此调用会直接返回链表中的就绪事件，效率高。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="专业知识" scheme="http://wangjin1996219.github.io/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Redis相关" scheme="http://wangjin1996219.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>校园商铺项目1.0总结</title>
    <link href="http://wangjin1996219.github.io/2021/04/10/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE1-0%E6%80%BB%E7%BB%93/"/>
    <id>http://wangjin1996219.github.io/2021/04/10/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE1-0%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-09T16:58:18.000Z</published>
    <updated>2021-04-14T09:17:32.358Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="开发准备（完成）"><a href="#开发准备（完成）" class="headerlink" title="开发准备（完成）"></a>开发准备（完成）</h1><p>开发环境的准备</p><p>开发工具的配置</p><p>创建一个Maven项目</p><h1 id="项目设计和框架搭建（完成）"><a href="#项目设计和框架搭建（完成）" class="headerlink" title="项目设计和框架搭建（完成）"></a>项目设计和框架搭建（完成）</h1><p>对系统的功能模块进行了大致划分</p><p>设计并创建实体类的表结构</p><p>配置Maven</p><p>自底向上方法完成SSM的各项配置</p><p>实现一个查询区域的功能</p><h1 id="Logback配置与使用（完成）"><a href="#Logback配置与使用（完成）" class="headerlink" title="Logback配置与使用（完成）"></a>Logback配置与使用（完成）</h1><p>主要是日志的配置和初步验证配置的可行性</p><h1 id="店铺注册功能模块（完成）"><a href="#店铺注册功能模块（完成）" class="headerlink" title="店铺注册功能模块（完成）"></a>店铺注册功能模块（完成）</h1><p><strong>店铺注册的流程：</strong>用户进入店铺注册的界面，根据js代码中的逻辑，会通过一个url路由到后端的Controller层的方法，该方法用于获取店铺的区域列表和店铺类别，将结果封装成json对象返回到前端，将该信息填入到对应的控件中，用户选择列表信息，并填入其它需要填入的信息，以及验证码信息，将前端的信息封装成json返回后端，验证码信息会由一个工具类CodeUtil对比用户输入的和图片的能否对应上，然后对店铺信息和店铺的图片信息进行转换处理，对图片信息进行处理时，要用到ImageUtil和PathUtil工具类，最后将返回结果封装成json返回给前端。</p><p><strong>验证码的实现：</strong></p><ol><li>在pom.xml加入kaptcha的jar包</li><li>在web.xml中创建验证码的servlet</li><li>在html中加入kaptcha控件</li><li>在js文件里读取控件内容，将验证码内容读取保存到json中，通过ajax传到后台</li><li>后端的CodeUtil工具类用于比较图片中实际的验证码与输入的验证码是否一致（图片中的验证码是从请求会话中得到的）</li></ol><h1 id="主从库同步与读写分离（完成）"><a href="#主从库同步与读写分离（完成）" class="headerlink" title="主从库同步与读写分离（完成）"></a>主从库同步与读写分离（完成）</h1><ol><li>修改主服务器配置文件和从服务器配置文件，实现主从同步；</li><li>在Spring中DataSource有一个抽象类AbstractRoutingDataSource，他能够根据不同的路由找到不同的数据源，类中的determineCurrentLookupKey方法就是决定目标数据源的；</li><li>因此创建DynamicDataSource类让它继承抽象类AbstractRoutingDataSource，重写determineCurrentLookupKey方法，调用DynamicDataSourceHolder类中的getDbType()方法，实现不同数据源的选择；</li><li>创建DynamicDataSourceHolder类决定返回的数据源是master还是slave（用到了ThreadLocal保证线程安全）；</li><li>创建DynamicDataSourceInterceptor类初始化DynamicDataSourceHolder类，拦截所有的数据库操作请求，通过分析sql语句来判断是读还是写操作，读操作就给DynamicDataSourceHolder设置slave源，写操作就给其设置master源，通过DynamicDataSourceHolder类中的setDbType方法；</li><li>完成路由后，在Mybatis-config.xml中配置拦截器。我们需要依靠拦截器对传递进来的SQL信息来选择数据源，例如传进来的是insert,update,delete语句，就使用主库的数据源，如果是select就选择从库的数据源；</li><li>在SpringDao.xml文件中分别配置主从库数据源；</li><li>在jdbc.properties配置文件中，配置主从库数据源的地址；</li></ol><p><strong>流程：</strong>当我们插入一条数据时，Mybatis会根据SQL语句将DynamicDataSourceHolder初始化，将该线程的数据源设定为主库，Spring通过SpringDao.xml的配置，通过dataSource中的targetDataSource选择数据源，而这个对象就是dynamicDataSource中的targetDataSources该对象的key是master或slave分别对应两个数据库连接池，通过determineCurrentLookupKey方法选择了数据源之后，取出键值key，对应的哪个连接池就是哪个连接池。</p><h1 id="店铺编辑功能和列表功能（完成）"><a href="#店铺编辑功能和列表功能（完成）" class="headerlink" title="店铺编辑功能和列表功能（完成）"></a>店铺编辑功能和列表功能（完成）</h1><p>实现了两个模块功能：</p><ol><li><p>店铺编辑功能（类似于店铺注册功能）</p></li><li><p>店铺列表功能</p><p>分页实现：加了一个工具类，将页号转换成行号，也就是将前台的第几页+页面大小转换成从第几行取一个页面大小的数据量</p></li></ol><h1 id="商品类别模块"><a href="#商品类别模块" class="headerlink" title="商品类别模块"></a>商品类别模块</h1><h1 id="商品模块"><a href="#商品模块" class="headerlink" title="商品模块"></a>商品模块</h1><h1 id="前端展示系统"><a href="#前端展示系统" class="headerlink" title="前端展示系统"></a>前端展示系统</h1><h1 id="阿里云部署及远程微信开发调试（完成）"><a href="#阿里云部署及远程微信开发调试（完成）" class="headerlink" title="阿里云部署及远程微信开发调试（完成）"></a>阿里云部署及远程微信开发调试（完成）</h1><ul><li><p>购买阿里云服务器</p></li><li><p>在服务器上搭建项目运行环境</p></li><li><p>将项目部署到远端服务器</p></li><li><p>解析域名，将服务器的IP地址改成自定义域名</p></li><li><p><strong>微信登录功能：</strong>微信测试号</p><p>1、填写接口配置信息：接口的Url和Token（一经提交，微信便发送GET请求到服务器中）</p><p>GET请求携带的参数：signature、timestamp、nonce、echostr，其中signature是微信的加密签名，结合了开发者填写的token参数和timestamp、nonce参数</p><p>2、开发者需要通过检验signature确认请求是否来源于微信服务器，并原样返回echostr参数内容，表示接入成功</p><p>3、编写两个类：WechatController和SignUtil用于应答连通微信公众号</p><p>​      加密校验流程：</p><p>​      1）将token、timestamp、nonce三个参数进行字典序排序</p><p>​      2）将三个字符串拼接成一个字符串进行sha1加密</p><p>​      3）获取加密后的字符串后与signature对比，表示来源于微信服务器</p><p>​      4）将echostr参数原样返回</p><p>4、接下来需要编写自己的程序以获取关注此公众号的用户信息</p><p>​      1） <strong>WechatLoginController</strong> 用来获取已关注此微信号的用户信息，获取用户的openId后，判断当用户不存在创建微信账号并创建用户的信息</p><p>​     以下是工具类：</p><p>​     2）【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息</p><p>​     3）【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息</p><p>​     4）【WechatUtil】主要用来提交https请求给微信获取用户信息</p><p>​     5）【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器</p><p>5、验证登录成功之后，将用户转发到相应的界面，如店铺列表、前端展示系统等</p><p>这样，当用户关注我们的公众号时，通过微信浏览器访问我们的服务器，就会自动创建账号，下次该用户再次访问时，通过判断用户的openId，就会实现微信的自动登录。</p></li></ul><h1 id="项目升级（完成）"><a href="#项目升级（完成）" class="headerlink" title="项目升级（完成）"></a>项目升级（完成）</h1><p><strong>对项目中的关键信息进行DES加密：</strong></p><ol><li>创建加密和解密的工具类：DESUtil；</li><li>将JDBC.properties文件中的数据库连接的账号、密码信息都改为加密后的密文；</li><li>创建类，用于解密关键字段；</li><li>更改spring-dao.xml中的配置，将含有加密字段的文件路径放入解密类的bean中。</li></ol><p><strong>引入Redis缓存：</strong></p><ol><li><p>引入Jedis的jar包：Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的；</p></li><li><p>创建redis.properties：定义连接redis的账户密码等字段</p></li><li><p>创建spring-redis.xml对redis进行配置：</p><p>创建Redis连接池对象：通过接口JedisPollWriper初始化连接池对象</p><p>创建Redis工具类JedisUtil，封装好Redis的连接以进行相关的操作</p><p>​     <strong>JedisUtil工具类：</strong>封装好Redis的连接以进行相关的操作，工具类中包含以下几个内部类：</p><p>​          1、Keys：主要封装了对redis中的键值对中的键操作的方法，比如：清空所有的Key，删除keys对应的记录等，方法的实现主  要还是通过jedis对象中的方法对redis中的内容进行操作</p><p>​          2、Strings：主要封装了一些根据string操作对象的值查询value，添加记录等的方法</p><p>创建Redis数据类型如string、map、list等的bean用于注入</p></li><li><p>在对Redis配置完成之后，需要对需要存入Redis缓存中的数据对应的查询、插入、修改的代码逻辑进行更改</p></li></ol><p><strong>本地账号的登录：</strong></p><ol><li>获取是否需要进行验证码校验的标识符（三次错误就会需要输入验证码）</li><li>从request中获取输入的帐号、密码</li><li>传入帐号和密码去获取平台帐号信息</li><li>同时在session里设置用户信息</li></ol><p><strong>添加拦截器，以实现登录验证及权限验证：</strong></p><p>店家管理系统中的一些敏感信息不能随意被修改，主要是验证用户是否已经登录了系统、有无对数据操作的权限</p><p><strong>具体实现：</strong></p><p>利用Spring的 AOP功能对相关功能进行织入验证方法，这样不用对每个方法都写一段权限验证的代码</p><ul><li>在spring-web.xml中配置拦截器：</li><li><strong>配置两个拦截器：</strong></li><li><strong>校验是否已登录了店家管理系统的拦截器</strong> <ul><li>定义拦截的路由：shopadmin下所有的方法（主要是对于店铺和商铺操作的方法）</li><li>拦截器具体实现类的bean以及全路径名</li></ul></li><li><strong>校验是否对该店铺有操作权限的拦截器（某一个店铺）</strong><ul><li>要对shopadmin下的部分方法进行排除，也就是不拦截，比如：获取店铺列表、注册相关（因为拦截器的具体实现是要获得用户可操作的店铺列表，和需要校验的session中的店铺进行比对的）</li></ul></li></ul><p>这样定义了拦截方法的路由之后，就会在方法执行前，执行自定义的拦截器对用户的登录情况和权限情况进行校验</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="校园商铺项目" scheme="http://wangjin1996219.github.io/categories/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="校园商铺1.0" scheme="http://wangjin1996219.github.io/tags/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1-0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://wangjin1996219.github.io/2021/04/02/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://wangjin1996219.github.io/2021/04/02/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-02T09:16:32.000Z</published>
    <updated>2021-04-02T11:48:43.161Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="ArrayList与LinkedList的原理及区别"><a href="#ArrayList与LinkedList的原理及区别" class="headerlink" title="ArrayList与LinkedList的原理及区别"></a>ArrayList与LinkedList的原理及区别</h1><p><strong>ArrayList：</strong></p><ul><li><strong>原理：</strong>基于数组来实现</li><li><strong>优点：</strong>查找效率更高，内存占用更小</li></ul><p><strong>LinkedList：</strong></p><ul><li><strong>原理：</strong>基于双向链表实现，LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li><strong>优点：</strong>对于插入和删除操作，LinkedList优于ArrayList</li></ul><h1 id="HashMap、HashTable与ConccurentHashMap"><a href="#HashMap、HashTable与ConccurentHashMap" class="headerlink" title="HashMap、HashTable与ConccurentHashMap"></a>HashMap、HashTable与ConccurentHashMap</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap的原理"><a href="#HashMap的原理" class="headerlink" title="HashMap的原理"></a>HashMap的原理</h3><p><strong>Java8之前：</strong>数组+链表（数组的查询速度快，链表的增删效率高，因此HashMap结合了两者的优势）</p><p>Hash值相同的键值对，就以链表的形式存储</p><img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\图片1.png" style="zoom:80%;"><ul><li>理想情况下，每个键位通过散列运算对应不同的值，这样查询的效率就是O(1)</li><li>当不同的键位通过散列运算总是得到相同的值，这时候就会在一个头结点后面拼接为一个很长的链表，性能就会由原来的O(1)降低为O(2)</li></ul><p>于是，<strong>Java8之后</strong>，就加入了红黑树数据结构，如下图所示：</p><img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\图片2.png" style="zoom:80%;"><p>引入一个常量TREEIFY_THRESHOLD，当链表达到一定的长度之后，就会将链表转换成红黑树，这样最坏情况就从O(n)提高到了O(logn)</p><p><strong>put方法：</strong></p><p>对Key求Hash值，如果没有碰撞直接放入数组中</p><p>如果碰撞了，就以链表的方式链接到后面</p><p>如果节点已经存在，就以新值替换旧值</p><p><strong>get方法：</strong></p><p>先对Key求Hash值找到数组的位置，再通过equals方法，在链表中找到对应的value</p><h3 id="HashMap的扩容及问题"><a href="#HashMap的扩容及问题" class="headerlink" title="HashMap的扩容及问题"></a>HashMap的扩容及问题</h3><p>向HashMap中不断加入元素，当HashMap中的数组里无法容纳时，就需要对其进行扩容</p><p><strong>方法：</strong>使用更大的数组来替换小数组</p><p><strong>问题：</strong></p><ul><li>多线程环境下，当几个线程中的HashMap都需要扩容时，调整大小就会存在竞争，容易造成死锁</li><li>由于需要在数组之间移动键值对，比较耗时</li></ul><h3 id="HashMap实现线程安全"><a href="#HashMap实现线程安全" class="headerlink" title="HashMap实现线程安全"></a>HashMap实现线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronizedMap方法中对public方法进行了加锁，相当于把原来的HashMap对象封装在safeHashMap对象中，再通过synchronizedMap中的公共方法对HashMap对象操作时，就是线程安全的了</span></span><br><span class="line">Map hashMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">Map safeHashMap=Collections.synchronizedMap(hashMap);</span><br></pre></td></tr></table></figure><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><h3 id="HashTable线程安全的实现"><a href="#HashTable线程安全的实现" class="headerlink" title="HashTable线程安全的实现"></a>HashTable线程安全的实现</h3><p>涉及到修改HashTable的方法，使用synchronized修饰，即多个线程在调用HashTable的同步方法时是串行的方式运行，性能较差</p><p>与HashMap实现的线程安全不同的是锁定的对象不一致</p><h2 id="ConccurentHashMap"><a href="#ConccurentHashMap" class="headerlink" title="ConccurentHashMap"></a>ConccurentHashMap</h2><p>由于在多线程环境下，HashMap、HashTable都是串行执行的，因此效率比较低，ConccurentHashMap便应运而生了</p><p><strong>Java8之前：</strong></p><p>采用分段锁的方式，对底层的数组分段加锁，这样只有拿到一段子数组的锁才能对其进行操作，当一段子数组被线程A访问时，另一段子数组也能够被线程B访问，提高了效率</p><img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\图片3.png" style="zoom:80%;"><p><strong>Java8之后：</strong></p><p>通过CAS+synchronized使锁更细化，也就是说不再使用分段锁，而是对每一个头结点分别加锁，这样一来效率又有了成倍的提高</p><p>而且采用了数组+链表+红黑树的底层结构，查询效率也更高</p><img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\图片4.png" style="zoom:80%;"><p><strong>put方法：</strong></p><ul><li>首先使用无锁操作CAS插入头结点，失败则循环重试</li><li>若头结点已经存在，则尝试获取头结点的同步锁synchronized，再进行操作</li></ul><blockquote><p><strong>Synchronized</strong>：属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。</p><p><strong>CAS</strong>（Compare And Swap：比较并替换）：属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="JAVA" scheme="http://wangjin1996219.github.io/categories/JAVA/"/>
    
    
    <category term="Java基础" scheme="http://wangjin1996219.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JVM相关</title>
    <link href="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/"/>
    <id>http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-01T14:40:45.000Z</published>
    <updated>2021-04-14T09:35:47.353Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><blockquote><p><strong>该博客出处：</strong><a href="https://thinkwon.blog.csdn.net/article/details/104390752">点击链接</a></p></blockquote><h1 id="1-JAVA内存区域"><a href="#1-JAVA内存区域" class="headerlink" title="1.JAVA内存区域"></a>1.JAVA内存区域</h1><h2 id="1-1JVM的主要组成部分及作用"><a href="#1-1JVM的主要组成部分及作用" class="headerlink" title="1.1JVM的主要组成部分及作用"></a>1.1JVM的主要组成部分及作用</h2><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p><strong>两个子系统：</strong></p><ul><li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li><li>Execution engine（执行引擎）：执行classes中的指令。</li></ul><p><strong>两个组件：</strong></p><ul><li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li><li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li></ul><p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码文件，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p><h2 id="1-2类的加载过程"><a href="#1-2类的加载过程" class="headerlink" title="1.2类的加载过程"></a>1.2类的加载过程</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p><h2 id="1-3JVM-运行时数据区"><a href="#1-3JVM-运行时数据区" class="headerlink" title="1.3JVM 运行时数据区"></a>1.3JVM 运行时数据区</h2><img src="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）</strong>：</p><ul><li><p><strong>程序计数器（Program Counter Register）：</strong>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p></li><li><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<strong>（线程私有、生命周期同线程生命周期）</strong></p></li><li><p><strong>本地方法栈（Native Method Stack）：</strong>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p></li><li><p><strong>Java 堆（Java Heap）：</strong>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<strong>（线程共享）</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><div align="center">  <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px"></div></li></ul><p>  上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。</p><ul><li><strong>方法区（Methed Area）：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<strong>（线程共享）</strong></li></ul><h2 id="1-4深拷贝与浅拷贝"><a href="#1-4深拷贝与浅拷贝" class="headerlink" title="1.4深拷贝与浅拷贝"></a>1.4深拷贝与浅拷贝</h2><blockquote><p><strong>注：</strong>深拷贝和浅拷贝都是对象拷贝</p></blockquote><ul><li><p><strong>浅拷贝：</strong>对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p><p>简而言之，<code>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</code></p></li><li><p><strong>深拷贝：</strong>当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p>简而言之，<code>深拷贝把要复制的对象所引用的对象都复制了一遍。</code></p></li></ul><h2 id="1-5堆栈的区别"><a href="#1-5堆栈的区别" class="headerlink" title="1.5堆栈的区别"></a>1.5堆栈的区别</h2><ul><li><p><strong>物理地址</strong></p><p>堆的物理地址分配对对象是不连续的。因此性能慢些。</p><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p></li><li><p><strong>内存分配</strong></p><p>堆因为是不连续的，所以分配的内存是在<strong>运行期</strong>确认的，因此大小不固定。一般堆大小远远大于栈。</p><p>栈是连续的，所以分配的内存大小要在<strong>编译期</strong>就确认，大小是固定的。</p></li><li><p><strong>存放的内容</strong></p><p>堆存放的是对象的实例和数组。因此该区更关注的是<strong>数据的存储</strong></p><p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是<strong>程序方法的执行</strong>。</p></li><li><p>程序的可见度</p><p>堆对于整个应用程序都是共享、可见的。</p><p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p></li></ul><h2 id="1-6队列和栈是什么？有什么区别？"><a href="#1-6队列和栈是什么？有什么区别？" class="headerlink" title="1.6队列和栈是什么？有什么区别？"></a>1.6队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。</p><ul><li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li><li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li><li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li></ul><h1 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h1><h2 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h2><table><thead><tr><th>Header</th><th>解释</th></tr></thead><tbody><tr><td>使用new关键字</td><td>调用了构造函数</td></tr><tr><td>使用Class的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用Constructor类的newInstance方法</td><td>调用了构造函数</td></tr><tr><td>使用clone方法</td><td>没有调用构造函数</td></tr><tr><td>使用反序列化</td><td>没有调用构造函数</td></tr></tbody></table><p><strong>对象创建的主要流程：</strong></p><p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定</strong>。</p><p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><p><strong>扩展：为对象分配内存的方式</strong></p><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配<strong>根据Java堆是否规整</strong>，有两种方式：</p><ul><li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li><li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li></ul><h2 id="2-2对象的访问定位"><a href="#2-2对象的访问定位" class="headerlink" title="2.2对象的访问定位"></a>2.2对象的访问定位</h2><p><code>Java</code>程序需要通过 <code>JVM</code> 栈上的引用访问堆中的具体对象。对象的访问方式取决于 <code>JVM</code> 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p><blockquote><p><strong>指针：</strong> 指向对象，代表一个对象在内存中的起始地址。</p><p><strong>句柄：</strong> 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p></blockquote><h3 id="2-2-1句柄访问"><a href="#2-2-1句柄访问" class="headerlink" title="2.2.1句柄访问"></a>2.2.1句柄访问</h3><p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p><img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p><h3 id="2-2-2直接指针"><a href="#2-2-2直接指针" class="headerlink" title="2.2.2直接指针"></a>2.2.2直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么<code>Java</code>堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p><img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p><h2 id="2-3堆内存中对象的分配的基本策略"><a href="#2-3堆内存中对象的分配的基本策略" class="headerlink" title="2.3堆内存中对象的分配的基本策略"></a>2.3堆内存中对象的分配的基本策略</h2><p><strong>堆空间的基本结构：</strong></p><div align="center">  <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px"></div><p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>另外，大对象和长期存活的对象会直接进入老年代。</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg" alt="堆内存常见分配策略"></p><h1 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3.垃圾收集器"></a>3.垃圾收集器</h1><h2 id="3-1Java垃圾回收机制"><a href="#3-1Java垃圾回收机制" class="headerlink" title="3.1Java垃圾回收机制"></a>3.1Java垃圾回收机制</h2><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在<strong>虚拟机空闲</strong>或者<strong>当前堆内存不足</strong>时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><h2 id="3-2GC及作用"><a href="#3-2GC及作用" class="headerlink" title="3.2GC及作用"></a>3.2GC及作用</h2><p><strong>GC</strong> 是垃圾收集的意思</p><p><strong>作用一：</strong>Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，避免了编程人员忘记或者错误的内存回收导致程序或系统的不稳定甚至崩溃。</p><p><strong>作用二：</strong>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p><blockquote><p><strong>Note：</strong></p><p>Java 语言没有提供释放已分配内存的显示操作方法</p><p><strong>内存泄漏：</strong>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p><p>即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p></blockquote><h2 id="3-3垃圾回收器的基本原理"><a href="#3-3垃圾回收器的基本原理" class="headerlink" title="3.3垃圾回收器的基本原理"></a>3.3垃圾回收器的基本原理</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p><p>程序员也可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><blockquote><p><strong>Note：</strong>释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”。GC将负责回收所有”不可达”对象的内存空间。</p><p>比如 ：</p><p>class1 aa = new class();  </p><p>aa=null; </p><p>那在堆上分配的内存上的数据 就无法访问到了，就是不可达对象。</p></blockquote><h2 id="3-4Minor-Gc和Full-GC-有什么不同"><a href="#3-4Minor-Gc和Full-GC-有什么不同" class="headerlink" title="3.4Minor Gc和Full GC 有什么不同"></a>3.4Minor Gc和Full GC 有什么不同</h2><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><h2 id="3-5判断对象是否可以被回收"><a href="#3-5判断对象是否可以被回收" class="headerlink" title="3.5判断对象是否可以被回收"></a>3.5判断对象是否可以被回收</h2><p>等同于判定哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断：</p><ul><li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><p><strong>可达性分析算法：</strong>基本思路就是通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。</p><img src="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:90%;"><h2 id="3-6对象什么时候可以被垃圾回收"><a href="#3-6对象什么时候可以被垃圾回收" class="headerlink" title="3.6对象什么时候可以被垃圾回收"></a>3.6对象什么时候可以被垃圾回收</h2><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</p><blockquote><p><strong>年轻代 ：</strong>年轻代用来存放新近创建的对象</p><p><strong>老年代：</strong>存活率更高的一些对象</p></blockquote><h2 id="3-7强引用-软引用-弱引用-虚引用"><a href="#3-7强引用-软引用-弱引用-虚引用" class="headerlink" title="3.7强引用,软引用,弱引用,虚引用"></a>3.7强引用,软引用,弱引用,虚引用</h2><ul><li><p><strong>强引用(StrongReference)</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p></li><li><p><strong>软引用(SoftReference)</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p></li><li><p><strong>弱引用(WeakReference)</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></li><li><p><strong>虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p></li></ul><blockquote><p><strong>Note：</strong>ReferenceQueue主要是用于监听Reference所指向的对象是否已经被垃圾回收。</p></blockquote><h2 id="3-6JVM-中的垃圾回收算法"><a href="#3-6JVM-中的垃圾回收算法" class="headerlink" title="3.6JVM 中的垃圾回收算法"></a>3.6JVM 中的垃圾回收算法</h2><h3 id="3-6-1标记-清除算法"><a href="#3-6-1标记-清除算法" class="headerlink" title="3.6.1标记-清除算法"></a>3.6.1标记-清除算法</h3><p>标记无用对象，然后进行清除回收。</p><p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p><ul><li>标记阶段：标记出可以回收的对象。</li><li>清除阶段：回收被标记的对象所占用的空间。</li></ul><p>优点：实现简单，不需要对象进行移动。</p><p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。<br><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p><h3 id="3-6-2复制算法"><a href="#3-6-2复制算法" class="headerlink" title="3.6.2复制算法"></a>3.6.2复制算法</h3><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。</p><ul><li>它把内存空间划为两个相等的区域，每次只使用其中一个区域</li><li>垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中</li><li>最后将当前使用的区域的可回收的对象进行回收</li></ul><p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p><p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。<br><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p><h3 id="3-6-3标记-整理算法"><a href="#3-6-3标记-整理算法" class="headerlink" title="3.6.3标记-整理算法"></a>3.6.3标记-整理算法</h3><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为<strong>老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低</strong>。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是：</p><ul><li>在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起</li><li>然后对端边界以外的内存进行回收</li><li>回收后，已用和未用的内存都各自一边</li></ul><p>优点：解决了标记-清理算法存在的内存碎片问题。</p><p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。<br><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p><h3 id="3-6-4分代收集算法"><a href="#3-6-4分代收集算法" class="headerlink" title="3.6.4分代收集算法"></a>3.6.4分代收集算法</h3><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：</p><img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><h2 id="3-7JVM-垃圾回收器"><a href="#3-7JVM-垃圾回收器" class="headerlink" title="3.7JVM 垃圾回收器"></a>3.7JVM 垃圾回收器</h2><h3 id="3-7-1两种垃圾回收器"><a href="#3-7-1两种垃圾回收器" class="headerlink" title="3.7.1两种垃圾回收器"></a>3.7.1两种垃圾回收器</h3><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：</strong> 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p><p><strong>G1(Garbage First)收集器 (标记-整理算法)：</strong> Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)。</p><h3 id="3-7-2CMS垃圾回收器"><a href="#3-7-2CMS垃圾回收器" class="headerlink" title="3.7.2CMS垃圾回收器"></a>3.7.2CMS垃圾回收器</h3><p><strong>CMS收集器：</strong>基于“标记-清除”算法实现</p><p><strong>运作过程如下：</strong></p><ul><li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</p></li><li><p><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/81ccc1600b6a2fdab98115abeea41877.jpg" alt="CMS垃圾收集器"></p></li></ul><p><strong>优点：</strong></p><p>由于在整个过程和中最耗时的并发标记和并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的，所以<strong>停顿时间比较短</strong></p><p><strong>缺点：</strong></p><ul><li><p><strong>CMS收集器会降低吞吐量</strong></p><p>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，</p></li><li><p><strong>CMS处理器无法处理浮动垃圾</strong> </p><p>CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾” ， </p></li><li><p><strong>CMS收集器会产生空间碎片</strong></p><p>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发 full gc。</p></li></ul><h3 id="3-7-3G1垃圾回收器"><a href="#3-7-3G1垃圾回收器" class="headerlink" title="3.7.3G1垃圾回收器"></a>3.7.3G1垃圾回收器</h3><p><strong>G1回收器：</strong>整体来看基于“标记-整理”算法，局部来看基于复制算法</p><p><strong>运作过程如下：</strong></p><ul><li><p><strong>初始标记</strong></p><p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短。</p><blockquote><p><strong>TAMS来区分哪些对象是GC开始之后新分配的：</strong>每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。</p></blockquote></li><li><p><strong>并发标记</strong></p><p>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。</p></li><li><p><strong>最终标记；</strong></p><p>最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。</p><blockquote><p><strong>已记忆集合：</strong>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</p></blockquote></li><li><p><strong>筛选回收</strong></p><p>最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p></li></ul><p><strong>优点：</strong></p><ul><li><p><strong>缩短stop-The-World停顿时间</strong></p><p>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间</p></li><li><p><strong>分代收集</strong></p><p>采用不同的方式（标记-整理、复制等）去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果</p></li><li><p><strong>减少空间碎片</strong></p><p>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的</p></li><li><p><strong>可预测的停顿</strong></p><p>这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能<strong>建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段内，</p></li></ul><p><strong>缺点：</strong></p><ul><li>对内存和CPU要求高一些</li></ul><h1 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4.虚拟机类加载机制"></a>4.虚拟机类加载机制</h1><h2 id="4-1类装载的执行过程"><a href="#4-1类装载的执行过程" class="headerlink" title="4.1类装载的执行过程"></a>4.1类装载的执行过程</h2><p><strong>类装载分为以下 5 个步骤：</strong></p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h2 id="4-2双亲委派模型"><a href="#4-2双亲委派模型" class="headerlink" title="4.2双亲委派模型"></a>4.2双亲委派模型</h2><p>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><img src="https://img-blog.csdnimg.cn/20200104165551656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><p><strong>双亲委派模型的优势：</strong></p><ul><li><p><strong>避免重复加载</strong></p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p></li><li><p><strong>避免核心类篡改</strong></p><p>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p></li></ul><p><strong>打破双亲委派模型的方法：</strong></p><p>继承ClassLoader类，重写loadClass和findClass方法</p><p>默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。为了破坏双亲委派机制必须重写loadClass方法，先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。</p><blockquote><p><strong>findClass方法：</strong>用户自定义类加载逻辑</p><p><strong>loadClass方法：</strong>双亲委派的具体逻辑实现，在该方法中，如果父类加载失败，则会调用自己的findClass（）方法来完成加载</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="专业知识" scheme="http://wangjin1996219.github.io/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JVM相关" scheme="http://wangjin1996219.github.io/tags/JVM%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>广度优先遍历</title>
    <link href="http://wangjin1996219.github.io/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
    <id>http://wangjin1996219.github.io/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</id>
    <published>2021-04-01T03:06:09.000Z</published>
    <updated>2021-04-12T03:33:26.506Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p><strong>广度优先遍历（BFS）：</strong>如果说深度优先遍历类似于树的前序遍历，那么广度优先遍历就类似于层序遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>后序补</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">热题100-102. 二叉树的层序遍历</a></strong></p><p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>创建双端队列</li><li>如果根节点不为null，将根节点加入到队列中</li><li>为了实现分层打印，在while循环中，每次得到队列的长度也就是该层的节点数，通过for循环将本层的节点打印，每次打印将该节点的左右子树加入到队列中，但是由于长度限制，新加入的节点在本次不会被打印</li></ul><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        dq.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node=dq.pollFirst();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer-32 - III. 从上到下打印二叉树 III</a></strong></p><p>之字形打印二叉树</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>当二叉树的根节点1打印之后，将它的左子节点和右子节点先后保存到一个容器中，当打印二层的节点时，先打印节点3再打印节点2，看起来节点在该容器中是先进后出的，因此可以考虑这个容器用栈来实现。</li><li>因为是Z形遍历，所以子节点放入容器的顺序是不同的，对于奇数层，打印顺序是left→right，因为是先进后出所以存储顺序是right→left，偶数层同理。</li><li>两个栈可以合并成一个队列，大大节省空间，把队列想象成两个栈底对底拼接在一起，左端存取元素用addFirst（）和pollFirst（），右端存取元素用addLast（）和pollLast（）。</li><li>奇偶层用res的元素个数来判断。</li></ul><h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) dq.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollFirst();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollLast();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83?tpId=190&tqId=35580&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-二叉树根节点到叶子节点的所有路径和</a></strong></p><p>给定一个仅包含数字 0−9\ 0-9 0−9 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>递归流程：</strong></p><ul><li>当节点为null时，返回</li><li>用路径的和加上该节点的值</li><li>当该节点的左右节点都为null时，将该路径和添加到sum中，返回</li><li>递归左子树</li><li>递归右子树</li></ul><h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> temp,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp+root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sum+=temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(temp*<span class="number">10</span>,root.left);</span><br><span class="line">        dfs(temp*<span class="number">10</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="基础算法篇" scheme="http://wangjin1996219.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>设计</title>
    <link href="http://wangjin1996219.github.io/2021/03/28/%E8%AE%BE%E8%AE%A1/"/>
    <id>http://wangjin1996219.github.io/2021/03/28/%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-28T02:20:50.000Z</published>
    <updated>2021-04-03T08:59:49.354Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/lru-cache/">热题100-146. LRU 缓存机制</a></strong></p><p>实现页面置换算法中的最近最久未被使用算法（LRU）中的set和get方法</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>set和get方法的实现需要：</li><li>双端链表：存储插入的每一个节点，节点包括四个成员变量：key、value、preNode、nextNode（分别指向前后节点）；</li><li>HashMap：键值为节点的key值，值为节点；</li><li>两个哑结点：方便头部插入和尾部删除；</li><li>addTohead：将节点插入到双端链表的头部，set方法使用；</li><li>removeNode：移除一个节点；</li><li>removeToHead：当get方法查询一个节点时，先使用removeNode将该节点在双端链表中删除，再使用addToHead方法插入到头部；</li><li>removeTail：移除尾部节点；</li></ul><blockquote><p><strong>注意：</strong>当插入节点时，必须同时保存到HashMap中，当删除节点时，将该节点在HashMap中删除</p></blockquote><h2 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedList pre;</span><br><span class="line">        DLinkedList next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        node.next.pre=node;</span><br><span class="line">        head.next=node;</span><br><span class="line">        node.pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DLinkedList <span class="title">removeToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedList node=tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        hm.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node =<span class="keyword">new</span> DLinkedList(key,value);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            hm.put(key,node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node=hm.get(key);</span><br><span class="line">            <span class="keyword">return</span> removeToHead(node).value; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,DLinkedList&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,DLinkedList&gt;();</span><br><span class="line">    DLinkedList head=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    DLinkedList tail=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LRU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=k;</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span>[] nums:operators)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                 put(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                 res.add(get(nums[<span class="number">1</span>]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">            ans[i]=(<span class="keyword">int</span>)res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="其它" scheme="http://wangjin1996219.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2021-03-25T08:48:35.000Z</published>
    <updated>2021-04-15T12:19:48.434Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>通过两个指针来实现题目要求，大大降低了空间复杂度</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle/">热题100-141. 环形链表</a></strong></p><p>给定一个链表，判断链表中是否有环。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>设置两个指针slow和fast</p><p>slow每次移动一个节点，fast每次移动两个节点</p><p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p></li><li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p></li><li><p>当循环中满足fast==slow时，返回true结束循环，否则链表遍历结束返回false</p></li></ul><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;<span class="comment">//遍历到一个节点时，首先这个节点不能为null，如果该节点不进行判断，就会出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">热题100-142. 环形链表 II</a></strong></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>寻找第一次相遇的点：</strong></p><ul><li><p>设置两个指针slow和fast</p><p>slow每次移动一个节点，fast每次移动两个节点</p><p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p></li><li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p></li><li><p>当循环中满足fast==slow时，结束循环，判断slow和fast是否相等，不相等返回null，反之，继续执行下面的语句</p></li></ul><p><strong>第二次相遇的点就是环的入口：</strong></p><p>分析：设第一次相遇时，指针slow走过s步，fast走的步数比它多n倍的b步，所以fast走过的步数是s+nb；又因为fast一次走两步，所以s+nb=2s,所以s=nb;也就是相遇的这个点是b的倍数，环的入口满足a+xb,所以另一个指针指向头部，另一个指针不动，两个指针一次移动一个节点，第二次相遇时，走过的步数满足a+xb，就是环的入口节点。</p><h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast=head.next;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast=head;</span><br><span class="line">    slow=slow.next;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>使用HashMap存储数组/字符串中的元素及其对应的下标；</li><li>设置左右两个指针，右指针遍历数组，每到一个元素的位置，先在HashMap中查看该元素是否存在，如果元素存在于HashMap中，更新left指针的值，另(left，right]区间内没有重复的元素；</li><li>将该元素及其下标存储到HashMap中；</li><li>更新最长无重复子串的长度；</li><li>返回结果。</li></ul><h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="comment">//HashMap新的键值对会覆盖原有的键值相同的键值对</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>;fast&lt;s.length();fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(ss[fast]))&#123;</span><br><span class="line">           slow=Math.max(hm.get(ss[fast]),slow);<span class="comment">//保证区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">           <span class="comment">//例：s=&quot;abcabcbb&quot;</span></span><br><span class="line">           <span class="comment">//当right指向第三个b时</span></span><br><span class="line">           <span class="comment">//假如left指向第二个c:此时显示有重复值，但是是在left之前，所以left不用变；</span></span><br><span class="line">           <span class="comment">//假如left指向第二个a:此时显示有重复值，是在left右边,所以更新left让其指向第二个b。</span></span><br><span class="line">           <span class="comment">//始终确保区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,fast-slow);</span><br><span class="line">        hm.put(ss[fast],fast);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">热题100-19. 删除链表的倒数第 N 个结点</a></strong></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>设置快慢指针；</li><li>让快指针先走n步的距离，当慢指针开始走时，应该距离快指针有n步的距离；</li><li>快慢指针同时移动，当快指针移动到链表尾部时，慢指针正好在倒数第n个节点；</li><li>为了方便删除，使用一个哑结点，让慢指针从该节点开始移动，当快指针移动到尾部时，慢指针移动到倒数第n个节点的前一个节点，直接删除倒数第n个节点。</li></ul><h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote><p><strong><a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=190&tqId=35226&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-反转字符串</a></strong></p><p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针一个从前往后，一个从后往前，直接交换就可以</p><h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=strs.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=strs[left];</span><br><span class="line">            strs[left]=strs[right];</span><br><span class="line">            strs[right]=ch;</span><br><span class="line">            right--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/3sum/">热题100-15. 三数之和</a></strong></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p></blockquote><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>将数组排序，排序后的数组顺序为从小到大；</p></li><li><p>最外层通过for循环，遍历数组中的每一个元素，固定这个元素，再用双指针遍历右边部分的元素，看是否有三个元素和为0；</p></li><li><p>for循环内部：</p><p>1、每遍历到一个元素，判断是否大于0，因为该元素为最小元素，如果它大于0，以后的都大于零，直接结束for循环</p><p>2、每遍历到一个元素，判断它是否跟上一个元素相等，为了防止答案重复，如果元素相同向下顺延</p><p>3、当该元素不满足上面的两条，固定该元素，设置双指针指向余下部分的首尾元素</p><p>4、当left&lt;right时，执行for循环，通过sum与0的大小关系来移动双指针，同时记录满足条件的集合</p></li></ul><h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//牛客上需要自己导包，Java一般导这个就够用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;num.length;k++)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(nums[k]+&quot;+&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(num[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;num.length&amp;&amp;num[k]==num[k-<span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum=num[k]+num[i]+num[j];</span><br><span class="line">         <span class="comment">//System.out.println(sum);</span></span><br><span class="line">          <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">              temp.add(num[k]);</span><br><span class="line">              temp.add(num[i]);</span><br><span class="line">              temp.add(num[j]);</span><br><span class="line">              res.add(temp);</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">              &#125;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/container-with-most-water/">热题100-11. 盛最多水的容器</a></strong></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p></blockquote><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>设置双指针，分别指向数组的首尾元素；</p></li><li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p><p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p><p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p></li></ul><h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max=Math.min(height[left],height[right])*(right-left);</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/trapping-rain-water/">热题100-42. 接雨水</a></strong></p><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p></blockquote><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>设置双指针，分别指向数组的首尾元素；</p></li><li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p><p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p><p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p></li></ul><h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_max&lt;right_max)&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,left_max-arr[left]);</span><br><span class="line">                left_max=Math.max(left_max,arr[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,right_max-arr[right]);</span><br><span class="line">                right_max=Math.max(right_max,arr[right]);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">热题100-234. 回文链表</a></strong></p><p>请判断一个链表是否为回文链表。</p></blockquote><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>找到链表的中间节点midNode：</p><p>创建快慢指针</p><p>慢指针一次走一步</p><p>快指针一次走两步</p></li><li><p>从中间节点的后面反转链表</p></li><li><p>这样就得到了两段链表，分别遍历判断即可</p></li><li><p>最后将链表还原</p></li></ul><h3 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode firstHead=head;</span><br><span class="line">        ListNode midNode=findMidNode(head);</span><br><span class="line">        ListNode secondHead=reverse(midNode.next);</span><br><span class="line">        ListNode temp=secondHead;</span><br><span class="line">        <span class="keyword">while</span>(firstHead!=<span class="keyword">null</span>&amp;&amp;secondHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstHead.val!=secondHead.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHead=firstHead.next;</span><br><span class="line">            secondHead=secondHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        midNode.next=reverse(temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=<span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=fast.next;</span><br><span class="line">            fast.next=slow;</span><br><span class="line">            slow=fast;</span><br><span class="line">            fast=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer-04. 二维数组中的查找</a></strong></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p><p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一次比较都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><blockquote><p>解法可以参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/">点击查看</a></p></blockquote><h3 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//flag作为标志位</span></span><br><span class="line">       <span class="keyword">if</span>((matrix.length)==<span class="number">0</span>||(matrix[<span class="number">0</span>].length)==<span class="number">0</span>) <span class="keyword">return</span> flag;</span><br><span class="line">       <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//（r,c）作为右上角的起始坐标</span></span><br><span class="line">       <span class="keyword">while</span>(r&lt;=(matrix.length-<span class="number">1</span>)&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix[r][c]==target)&#123;<span class="comment">//如果右上角的坐标等于目标值，返回true，结束循环</span></span><br><span class="line">               flag=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c]&gt;target)&#123;<span class="comment">//当右上角的值大于目标值，左移一步，剔除右边的列，小于时，下移一步，剔除顶部一行</span></span><br><span class="line">               c--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="其它" scheme="http://wangjin1996219.github.io/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2021-03-25T08:47:41.000Z</published>
    <updated>2021-03-25T08:47:41.241Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2021-03-25T08:46:52.000Z</published>
    <updated>2021-03-25T08:46:52.930Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2021-03-25T08:46:12.000Z</published>
    <updated>2021-04-13T09:06:15.271Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个单调栈来实现获取滑动窗口内的最大值只需要 <strong><em>O(1)</em></strong> 的时间复杂度</p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://wangjin1996219.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-03-25T08:45:06.000Z</published>
    <updated>2021-04-14T12:14:30.827Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p><strong>动态规划：</strong>是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现(Memorization Search)</p><p>动态规划中的最优子结构：大规模问题中包含重复的子问题，并且大规模问题的最优解可以由小规模问题的最优解得到。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>满足两个条件：</strong></p><ol><li>满足以下条件之一<ul><li>求最大/最小值（Maximum/Minimum ）</li><li>求是否可行（Yes/No ）</li><li>求可行个数（Count(*) ）</li></ul></li><li>满足不能排序或者交换（Can not sort / swap ）</li></ol><h2 id="四点要素"><a href="#四点要素" class="headerlink" title="四点要素"></a>四点要素</h2><ol><li><strong>状态 State</strong><ul><li>灵感，创造力，存储小规模问题的结果</li></ul></li><li><strong>方程 Function</strong><ul><li><strong>状态之间的联系</strong>，怎么通过小的状态，来算大的状态</li></ul></li><li>初始化 Intialization<ul><li>最极限的小状态是什么, 起点</li></ul></li><li>答案 Answer<ul><li>最大的那个状态是什么，终点</li></ul></li></ol><h2 id="常见四种类型"><a href="#常见四种类型" class="headerlink" title="常见四种类型"></a>常见四种类型</h2><ol><li>矩阵类型（Matrix DP ）(10%)</li><li>序列类型（Sequence ）(40%)</li><li>子序列/子串（Two Sequences DP） (40%)</li><li>零钱、背包问题（Backpack） (10%)</li></ol><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="类型一：矩阵"><a href="#类型一：矩阵" class="headerlink" title="类型一：矩阵"></a>类型一：矩阵</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer-47. 礼物的最大价值</a></strong></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p></blockquote><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>状态定义：</strong> 设动态规划矩阵 dp ，dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)时能拿到礼物的最大累计价值。</p></li><li><p><strong>转移方程：</strong>设 f(i,j)为从棋盘左上角走至单元格 (i,j)的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j−1) 和 f(i−1,j) 中的较大值加上当前单元格礼物价值 grid(i,j)。<br>$$<br>f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)<br>$$</p></li><li><p><strong>初始状态：</strong> dp[0] [0]=grid[0] [0]，即到达单元格 (0,0)时能拿到礼物的最大累计价值为 grid[0] [0] ；</p></li><li><p><strong>返回值：</strong> dp[m−1] [n−1]，m,n分别为矩阵的行高和列宽，即返回 dp矩阵右下角元素。</p></li></ul><h4 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.max(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/maximal-square/">热题100-221. 最大正方形</a></strong></p><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p></blockquote><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSide=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          maxSide=Math.max(maxSide,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/unique-paths/">热题100-62. 不同路径</a></strong></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p></blockquote><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] grid=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;m;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;n;c++)&#123;</span><br><span class="line">            grid[r][c]=grid[r-<span class="number">1</span>][c]+grid[r][c-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/minimum-path-sum/">热题100-64. 最小路径和</a></strong></p><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p></blockquote><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.min(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型二：序列"><a href="#类型二：序列" class="headerlink" title="类型二：序列"></a>类型二：序列</h2><p>常见处理方式是给 0 位置占位，这样处理问题时一视同仁，初始化则在原来基础上 length+1，返回结果 f[n]</p><ul><li>状态可以为前 i 个</li><li>初始化 length+1</li><li>取值 index=i-1</li><li>返回值：f[n]或者 f[m][n]</li></ul><h3 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/climbing-stairs/">热题100-70. 爬楼梯</a></strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p>状态定义：创建dp数组（长度为n+1），dp[i]表示跳上i阶台阶时的跳法</p></li><li><p>转移方程：跳上第i阶台阶有两种方式，一个是从i-2阶跳两个台阶，一个是从i-1阶跳一个台阶，这样就有了状态转移方程</p></li><li><p>$$<br>f(i)=f(i−1)+f(i−2)<br>$$</p></li><li><p>初始化：因为要从前两个状态得到第i个状态，所以给0,1赋值</p></li><li><p>返回值：返回dp[n]</p></li></ul><h4 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer-10- I. 斐波那契数列</a></strong></p><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 </p></blockquote><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意这里的首相为0，不是1</p><h4 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/maximum-subarray/">热题100-53. 最大子序和</a></strong></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>状态定义：创建dp数组，设dp[i]为以i元素结尾的子数组的最大累加和子数组</li><li>转移方程：dp[i]状态可以由dp[i-1]状态转移过来，选取dp[i-1]+arr[i]和arr[i]的较大值，也就是当前面最大值为负数时，直接选取这个元素本身作为最大值</li><li>初始化：dp[i]=0</li><li>返回值：返回dp[n]</li></ul><blockquote><p><strong>Note：</strong>因为第i个状态只与前一个状态有关，可以只用一个变量preSume来代替dp数组，大大降低空间复杂度</p></blockquote><h4 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        preSum=Math.max(nums[i],preSum+nums[i]);<span class="comment">//当preSum为负数时，另preSum=nums[i]，也就是index=i结尾的子串最大值为它本身</span></span><br><span class="line">        maxValue=Math.max(preSum,maxValue);<span class="comment">//用maxValue来记录第i个数结尾的连续子数组的最大和的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目四-1"><a href="#题目四-1" class="headerlink" title="题目四"></a>题目四</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">热题100-152. 乘积最大子数组</a></strong></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p></blockquote><h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>状态定义：</strong>假如我们把dp[i]作为第i个元素结尾的子数组的最大乘积，那么这个状态怎么得到呢，只由i-1状态的最大值是得不到的，该题的关键是：<strong>当nums[i]为负数时，前面的最大值乘完变最小值，最小值乘完变最大值</strong>，所以还要创建一个dp数组，来保存每个元素结尾的子数组的最小乘积。</p></li><li><p><strong>转移方程：</strong></p><p><strong>当nums[i]&gt;=0时：</strong></p><ul><li><p>dpMax[i]=Math.max(dpMax[i-1]*nums[i],nums[i]);</p></li><li><p>dpMin[i]=Math.min(dpMin[i-1]*nums[i],nums[i]);</p></li></ul><p><strong>当nums[i]&lt;0时：</strong></p><ul><li>dpMax[i]=Math.max(dpMin[i-1]*nums[i],nums[i]);</li><li>dpMin[i]=Math.min(dpMax[i-1]*nums[i],nums[i]);</li></ul></li><li><p><strong>初始化：</strong>dpMax[0]=dpMin[0]=nums[0]</p></li><li><p><strong>返回值：</strong>返回最大值</p></li></ul><blockquote><p><strong>Note：</strong>因为第i个状态只与前一状态的最大最小值有关，所以可以用preMax和preMin两个变量代替</p></blockquote><h4 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tempMax=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> tempMin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=tempMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=tempMax;</span><br><span class="line">            tempMax=tempMin;</span><br><span class="line">            tempMin=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        tempMax=Math.max(tempMax*nums[i],nums[i]);</span><br><span class="line">        tempMin=Math.min(tempMin*nums[i],nums[i]);</span><br><span class="line"></span><br><span class="line">        max=Math.max(tempMax,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/word-break/">热题100-139. 单词拆分</a></strong></p><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p></blockquote><h4 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h4><p>状态定义：dp[i]表示以i结尾的子串，能否被分割</p><p>状态转移：dp[i]可以由前面的结果得到，需要遍历i元素前的子串，将子串分为两部分，如果有一部分已经得到&amp;另一部分在字典中能查到，则dp[i]=true</p><p>初始化：将dp[0]=true，表示整个子串都能在字典中查到</p><p>返回值：返回dp[s.length()]</p><h4 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; Dict=<span class="keyword">new</span> HashSet&lt;String&gt;(wordDict);</span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;Dict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目六（打家劫舍）"><a href="#题目六（打家劫舍）" class="headerlink" title="题目六（打家劫舍）"></a>题目六（打家劫舍）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/house-robber/">热题100-198. 打家劫舍</a></strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p></blockquote><h4 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>滚动数组法：</strong></p><ul><li><p><strong>状态定义：</strong>每个房间都有偷/不偷两种选择，用dp0和dp1分别表示不偷i个房间和偷i个房间能获得的最大价值</p></li><li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p><p>选择偷第i个房间时：dp1=dp[0]+nums[i];</p><p>选择不偷第i个房间：dp0=Math.max(dp0，dp1);</p><p>这里可以用temp暂存前一天的一个状态</p></li><li><p><strong>初始化：</strong>dp0=0，dp1=nums[0]</p></li><li><p><strong>返回值：</strong>返回dp0和dp1的较大值</p></li></ul><h4 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp0=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp1=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=dp0;</span><br><span class="line">        dp0=Math.max(dp0,dp1);</span><br><span class="line">        dp1=Math.max(temp+nums[i],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp0,dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目七（打家劫舍）"><a href="#题目七（打家劫舍）" class="headerlink" title="题目七（打家劫舍）"></a>题目七（打家劫舍）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></strong></p><p>二叉树中不能偷取直接相连的节点</p></blockquote><h4 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>状态定义：</strong>每个节点都有偷/不偷两种选择，用temp[0]和temp[1]分别表示不偷和偷该节点能获得的最大价值</p></li><li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p><p>当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</p><p>当选择偷root节点时，只能是它的值加上左右孩子都不偷时的值</p><p>递归中将这两个状态装入数组返回</p></li><li><p><strong>初始化：</strong>相当于递归终止时返回的数组，也就是都是0</p></li><li><p><strong>返回值：</strong>返回res[0],res[1]的较大值</p></li></ul><h4 id="代码及注解-10"><a href="#代码及注解-10" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//这个方法举个例子更好理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res=robInternal(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robInternal(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] left=robInternal(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right=robInternal(root.right);</span><br><span class="line">    temp[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);<span class="comment">//当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</span></span><br><span class="line">    temp[<span class="number">1</span>]=root.val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目八（股票）"><a href="#题目八（股票）" class="headerlink" title="题目八（股票）"></a>题目八（股票）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">热题100-121. 买卖股票的最佳时机</a></strong></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p></blockquote><h4 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h4><p>较简单，略</p><h4 id="代码及注解-11"><a href="#代码及注解-11" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowprice=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        profit=Math.max(profit,prices[i]-lowprice);</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;lowprice)&#123;</span><br><span class="line">            lowprice=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目九（股票）"><a href="#题目九（股票）" class="headerlink" title="题目九（股票）"></a>题目九（股票）</h3><blockquote><p><a href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=190&tqId=36950&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-股票交易的最大收益</strong></a></p><p>假定你知道某只股票每一天价格的变动。 </p><p>你最多可以同时持有一只股票。但你最多只能进行<strong>两次</strong>交易（一次买进和一次卖出记为一次交易。买进和卖出均无手续费）。 </p><p> 请设计一个函数，计算你所能获得的最大收益。</p></blockquote><h4 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>状态定义：</strong></p><p>一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过</p><p>所以定义状态转移数组dp[天数] [当前是否持股] [卖出的次数]</p></li><li><p><strong>转移方程：</strong></p><p>第i天的状态由第i-1天的状态得到</p><p>具体一天结束时的5种状态：</p><p>未持股，未卖出过股票：说明从未进行过买卖，利润为0<br>dp[i] [0] [0]=0<br>未持股，卖出过1次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [1]=max(dp[i-1] [1] [0]+prices[i],dp[i-1] [0] [1])<br>未持股，卖出过2次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [2]=max(dp[i-1] [1] [1]+prices[i],dp[i-1] [0] [2])<br>持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [0]=max(dp[i-1] [0] [0]-prices[i],dp[i-1] [1] [0])<br>持股，卖出过1次股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [1]=max(dp[i-1] [0] [1]-prices[i],dp[i-1] [1] [1])</p></li><li><p><strong>初始化：</strong></p><p> dp[0] [0] [0] = 0;//第一天休息</p><p>dp[0] [0] [1] = dp[0] [1] [1] = MIN_VALUE;//不可能</p><p>dp[0] [0] [2] = MIN_VALUE;//不可能</p><p>dp[0] [1] [0] = -prices[0];//买股票</p></li><li><p><strong>返回值：</strong>返回最后一天，不持股的两种状态</p></li></ul><h4 id="代码及注解-12"><a href="#代码及注解-12" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> MIN_VALUE = Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目十（股票）"><a href="#题目十（股票）" class="headerlink" title="题目十（股票）"></a>题目十（股票）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">热题100-309. 最佳买卖股票时机含冷冻期</a></strong></p><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul></blockquote><h4 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>状态定义：</strong></p><p><strong>一天结束时</strong>，可能有持股、不持股两种状态，并且不持股分为处于冷冻期、不处于冷冻期两种状态</p><p>定义状态转移数组dp[i] [0] 、dp[i] [1] 、dp[i] [2] </p></li><li><p><strong>转移方程：</strong></p><p>具体一天的三种状态：</p><p>持股的状态，要么前一天持股，要么前一天不持股在i天买入</p><p>dp[i] [0] =Math.max(dp[i-1] [0]，dp[i-1] [2]-prices[i])</p><p>不持股&amp;处于冷冻期的状态，前一天必须持股而且在第i天卖出</p><p>dp[i] [1]=dp[i-1] [0]+prices[i]</p><p>不持股&amp;不处于冷冻期，前一天就不持股，对应两种状态</p><p>dp[i] [2]=Math.max(dp[i-1] [1],dp[i-1] [2])</p></li><li><p><strong>初始化：</strong></p><p>第一天：</p><p>dp[0] [0]=-prices[0];买入</p><p>dp[0] [1]=0;不存在的状态</p><p>dp[0] [2]=0;什么也不干</p></li><li><p><strong>返回值：</strong>返回不持股状态的两种较大值</p></li></ul><blockquote><p><strong>Note：</strong>这里第i天的状态只与前一天的三种状态有关，所以可以用三个变量代替dp数组</p></blockquote><h4 id="代码及注解-13"><a href="#代码及注解-13" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;prices.length;x++)&#123;</span><br><span class="line">           <span class="keyword">int</span> ii=Math.max(i,k);</span><br><span class="line">           <span class="keyword">int</span> jj=Math.max(j,i-prices[x]);</span><br><span class="line">           <span class="keyword">int</span> kk=j+prices[x];</span><br><span class="line">           i=ii;</span><br><span class="line">           j=jj;</span><br><span class="line">           k=kk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(i,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目十一（回文串）"><a href="#题目十一（回文串）" class="headerlink" title="题目十一（回文串）"></a>题目十一（回文串）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/palindromic-substrings/">热题100-647. 回文子串</a></strong></p><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p></blockquote><h4 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li>两层循环，考察所有子串，判断是否是回文串。</li><li>时间复杂度 O(n^3)：串的长度为n，每个点的比较次数：0+1+2+……+n=（n+1）*n/2，所以是n^3</li><li>空间复杂度：O(n^2)：用到二维数组</li></ul><p><strong>思路：</strong></p><ul><li>大问题是一个子串是否是回文串，然后统计有几个回文子串，那规模小一点的子问题呢？</li><li>一个子串是回文串，刨去相同的首尾字符，剩下的子串也必须是回文串。</li><li>剩下的子串是否为回文串，就是规模小一点的子问题，它影响大问题的结果。</li></ul><p>用二维 Boolean 数组记录中間子问题的解，从base case出发，递推出每个子问题的解。</p><p><strong>s[i:j] 是回文的情况：</strong></p><p><strong>首先i和j元素必须相同的前提下，满足下面任意一条</strong></p><ul><li>当只有单个字符时</li><li>由两个字符组成</li><li>超过两个字符的情况，<strong>剩余的子串是一个回文串</strong>（这个要用到前面子问题的解）</li></ul><h4 id="代码及注解-14"><a href="#代码及注解-14" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">      <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录回文串的个数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                  <span class="keyword">if</span>(flag[j][i]=i==j||i-j==<span class="number">1</span>||flag[j+<span class="number">1</span>][i-<span class="number">1</span>])&#123;</span><br><span class="line">                      count++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目十二（回文串）"><a href="#题目十二（回文串）" class="headerlink" title="题目十二（回文串）"></a>题目十二（回文串）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">热题100-5. 最长回文子串</a></strong></p><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote><h4 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h4><p>同上</p><h4 id="代码及注解-15"><a href="#代码及注解-15" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||flag[j+<span class="number">1</span>][i-<span class="number">1</span>]||i-j==<span class="number">1</span>)&#123;</span><br><span class="line">                    flag[j][i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&gt;=maxLength)&#123;</span><br><span class="line">                        maxLength=i-j+<span class="number">1</span>;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,start+maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h3><blockquote><p><a href="https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-最长递增子序列</strong></a></p><p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）</p><p><strong>这个题要用贪心+二分法，否则在牛客上不能通过</strong></p></blockquote><h4 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>动态规划：</strong></p><ul><li>通过一个maxlens数组，记录每个元素结尾的最长递增子序列的长度，通过一个maxlen来记录最大的长度</li><li>对于maxlens[i]，要在区间[0，i]遍历maxlens数组，找到arr[i]&gt;arr[j]时的元素，不断地更新maxlens[i]</li><li>这种方式的时间复杂度为n^2，会出现超时的情况</li></ul><p><strong>贪心+二分：</strong></p><ul><li>仍然用maxlens数组，记录每个元素结尾的最长递增子序列的长度，maxlen来记录最大的长度</li><li>不同的是还要维护一个tails数组，tail[i]表示长度为 i 的最长上升子序列的末尾元素的最小值，比如：数组 [2, 3, 1, 4, 6]中tails最终为[1,4,6]，依次表示长度为1的最长上升子序列末尾的最小元素为1，长度为2的为4，长度为3的为6，这时如果后面再加个10那最长上升子序列的长度为4时，最小的结尾元素为10，如果再多个3，那么长度为2的最长上升子序列的结尾元素就要从4换成3。</li><li>这样一来，我们就可以通过二分法在tails数组中查找该元素结尾的最长上升子序列的最大长度</li><li>这种方式的时间复杂度变成n*logn</li></ul><p><strong>最后：（按字典序输出）</strong></p><p>假设我们原始数组是arr1，得到的maxLen为<code>[1,2,3,1,3]</code>，最终输出结果为res（字典序最小的最长递增子序列），res的最后一个元素在arr1中位置无庸置疑是<code>maxLen[i]==3</code>对应的下标，那么到底是<code>arr1[2]</code>还是<code>arr1[4]</code>呢？如果是<code>arr1[2]</code>，那么<code>arr1[2]&lt;arr1[4]</code>，则<code>maxLen[4]==4</code>，与已知条件相悖。因此我们应该取<code>arr1[4]</code>放在res的最后一个位置。</p><p>因为元素对应同样长度时，后面的元素小于等于前面的元素，否则后面的长度就会大于前面的长度了</p><h4 id="代码及注解-16"><a href="#代码及注解-16" class="headerlink" title="代码及注解"></a>代码及注解</h4><p><strong>动态规划代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            maxlens[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                    maxlens[i]=Math.max(maxlens[i],maxlens[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=Math.max(maxlen,maxlens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>贪心+二分代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] tails=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        tails[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        maxlens[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;tails[maxlen-<span class="number">1</span>])&#123;</span><br><span class="line">                tails[maxlen++]=arr[i];</span><br><span class="line">                maxlens[i]=maxlen;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> right=maxlen-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tails[mid]&lt;=arr[i])&#123;</span><br><span class="line">                        left=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right=mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tails[left]=arr[i];</span><br><span class="line">                maxlens[i]=++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目十四（股票）"><a href="#题目十四（股票）" class="headerlink" title="题目十四（股票）"></a>题目十四（股票）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣主站-122. 买卖股票的最佳时机 II</a></strong></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p></blockquote><h4 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(prices.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp0;</span><br><span class="line">            dp0=Math.max(dp1+prices[i],dp0);</span><br><span class="line">            dp1=Math.max(temp-prices[i],dp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型四：零钱、背包问题"><a href="#类型四：零钱、背包问题" class="headerlink" title="类型四：零钱、背包问题"></a>类型四：零钱、背包问题</h2><h3 id="题目一（零钱）"><a href="#题目一（零钱）" class="headerlink" title="题目一（零钱）"></a>题目一（零钱）</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/coin-change/">热题100-322. 零钱兑换</a></strong></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote><h4 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><strong>状态定义：</strong>dp[i]表示当为i元钱时，需要的硬币最少数目</li><li><strong>转移方程：</strong>dp[i]状态要遍历已经得到的dp数组，选择那个硬币最少数目作为dp[i]</li><li><strong>初始化：</strong>dp[0]=0，然后每次的dp[i]设为i+1，用于判断该元素是否找到了最少硬币数目的组合</li><li><strong>返回值：</strong>根据dp[i]是否有解，确定返回解还是无解</li></ul><blockquote><p><strong>Note：</strong>dp[i-coins[j]] 决策coins[j]是否参与</p></blockquote><h4 id="代码及注解-17"><a href="#代码及注解-17" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        dp[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;=<span class="number">0</span>&amp;&amp;dp[i-coins[j]]&lt;=i-coins[j])&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]&gt;amount? -<span class="number">1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h3><blockquote><p><strong><a href="https://leetcode-cn.com/problems/perfect-squares/">热题100-279. 完全平方数</a></strong></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p></blockquote><h4 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h4><p>同零钱问题</p><h4 id="代码及注解-18"><a href="#代码及注解-18" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从下到上地求得每个数的完全平方数的最少个数</span></span><br><span class="line"><span class="comment">    当遍历到i时，从i中减去j的平方(j是递增的)，看当前的dp[i]和从i中减去j的平方后的数+1（因为从i中减去一个平方数j得到dp数组中索引位置index=i-j*j处，因此为dp[i-j*j]+1）哪个小选哪个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j*j&gt;=<span class="number">0</span>;j++)&#123;<span class="comment">//结束条件是大于等于0，等于0也是可以的，比如4-2*2=0,说明正好正好为0，只用一个平方数就可以得到，而当大于0时，这种只用一个平方数的情况就给排除了</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="基础算法篇" scheme="http://wangjin1996219.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</id>
    <published>2021-03-25T08:44:42.000Z</published>
    <updated>2021-04-08T06:41:40.724Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="二分搜索介绍"><a href="#二分搜索介绍" class="headerlink" title="二分搜索介绍"></a>二分搜索介绍</h2><p>二分查找是一种在每次比较之后<strong>将查找空间一分为二</strong>的算法。二分查找维护查找空间的左、右和中间指示符，并比较查找目标，如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查找以空的一半结束，则无法满足条件，并且无法找到目标。</p><p><strong>四个要素：</strong></p><ol><li>初始化：start=0、end=len-1</li><li>循环退出条件：start + 1 &lt; end</li><li>比较中点和目标值：A[mid] ==、 &lt;、&gt; target</li><li>判断最后两个元素是否符合：A[start]、A[end] ? target</li></ol><h2 id="识别二分搜索"><a href="#识别二分搜索" class="headerlink" title="识别二分搜索"></a>识别二分搜索</h2><ul><li>每次需要查找集合中的索引或元素时，都应该考虑二分查找。</li><li>集合有序（如果集合是无序的，我们可以总是在应用二分查找之前先对其进行排序）。</li></ul><h2 id="实现二分搜索的方法"><a href="#实现二分搜索的方法" class="headerlink" title="实现二分搜索的方法"></a>实现二分搜索的方法</h2><p><strong>详情点击</strong>：<a href="https://leetcode-cn.com/leetbook/read/binary-search/xewjg7/"><strong>二分搜索模板</strong></a></p><p><strong>方法一：</strong></p><ul><li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li><li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="comment">// 应该是right略小于target，left略大于target</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><ul><li>搜索条件需要访问元素的直接左右邻居。</li><li>使用元素的邻居来确定它是向右还是向左。</li><li>保证查找空间在每个步骤中至少有 3 个元素。</li><li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>大部分场景方法二都能解决问题，而且还能找第一次/最后一次出现的位置</li><li>如果是最简单的二分搜索，不需要找第一个、最后一个位置、或者是没有重复元素，可以使用方法一</li></ul><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">热题100-33. 搜索旋转排序数组</a></strong></p><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用方法二，需要与其相邻的元素比较来确定向左还是向右，最后要对结果进行处理来决定最后的返回值</p><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环的条件</span></span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(nums[left]&lt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&gt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><a href="https://www.nowcoder.com/practice/09fbfb16140b40499951f55113f2166c?tpId=190&tqId=35187&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-求平方根</strong></a></p><p>实现函数 int sqrt(int x).   </p><p>计算并返回x的平方根（向下取整） </p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p><h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=x;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;x/mid)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;x/right)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer-11. 旋转数组的最小数字</a></strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p><h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;=array[left])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[left]&gt;array[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> array[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer-53 - I. 在排序数组中查找数字 I</a></strong></p><p>统计一个数字在排序数组中出现的次数。</p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p><h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            l=left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            l=right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=l;</span><br><span class="line">        right=n-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> right-l+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left-l+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">热题100-34. 在排序数组中查找元素的第一个和最后一个位置</a></strong></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p><h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=n-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            res[<span class="number">1</span>]=right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            res[<span class="number">1</span>]=left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer-53 - II. 0～n-1中缺失的数字</a></strong></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></blockquote><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一</p><h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;mid)&#123;</span><br><span class="line">        high=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;low=mid+<span class="number">1</span>;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="基础算法篇" scheme="http://wangjin1996219.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-03-25T08:44:20.000Z</published>
    <updated>2021-04-13T12:38:10.457Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的数据结构，常用于BFS广度优点遍历</p><p>创建语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双端队列：</span></span><br><span class="line">Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的特点是先进后出，常用于二叉树的迭代遍历或者DFS深度优先遍历</p><p>创建语句：<strong>常用双端队列来实现栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双端队列：</span></span><br><span class="line">Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><strong>双端队列实现队列和栈的常用方法：</strong></p><img src="/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/GitHub\MyBlogs\source\_posts\2021-03-25-栈和队列\队列.png" style="zoom:60%;"><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer-59 - I. 滑动窗口的最大值</a></strong></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个单调栈来实现获取滑动窗口内的最大值只需要 <strong><em>O(1)</em></strong> 的时间复杂度</p><p>通过for循环遍历数组中的元素</p><ul><li><p><strong>删除首位元素：</strong>通过当前的下标 i 来判断队列中的首位元素是否超出了滑动窗口区间，是就删除首位</p></li><li><p><strong>删除尾部元素：</strong>如果新增值大于队列尾部值，删除队列中比新增值小的值，如果新增值大于队列中所有值，删除所有，然后把新增值放到队列首位，保证队列一直是从大到小；如果小于队尾元素，直接插入</p><p>（因为经过第一步每次已经将超出窗口区间的元素删除了，如果新加入的元素大于区间内的元素，那么这些小的元素不可能是当前区间的最小值了；如果小于队尾元素，该元素虽然不是当前区间的最小值，但是前面的元素移出窗口区间时，它有可能成为后面某一窗口的最大值）</p></li><li><p><strong>尾部插入新值：</strong>这个虽然是尾部插入，但是有的已经插入到队首了</p></li><li><p><strong>将最大值插入到结果集合：</strong>依然是通过当前的下标 i 来判断当前是否形成了窗口区间，如果已经形成，就会取出队首元素，也就是当前窗口的最大值插入到结果集合中</p></li></ul><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;<span class="comment">//得到给定数组的长度</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  <span class="keyword">return</span> nums;<span class="comment">//如果给定数组长度为0，返回一个空数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];<span class="comment">//通过计算得到返回数组的长度为n-k+1</span></span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//创建deque双端队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//for循环遍历每一个给定数组的元素</span></span><br><span class="line">        <span class="keyword">if</span>(!dq.isEmpty()&amp;&amp;dq.getFirst()&lt;(i-k+<span class="number">1</span>))&#123;<span class="comment">//当滑动窗口的长度达到k时，每次应该先执行删除队头的操作，当dq不为空，且dq中队头元素的下标超出dq长度范围时，执行删除操作</span></span><br><span class="line">            dq.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!dq.isEmpty()&amp;&amp;nums[i]&gt;=nums[dq.getLast()])&#123;<span class="comment">//执行完删除队头操作之后，执行删除队尾操作，比较添加元素和deque队尾元素的值，当该元素大于deque队列中的值时，也就是它前面的元素不可能是当前和以后的滑动窗口范围内最大值，这时删除所有比它小的元素，当该元素小于队尾元素值时，直接加入，因为它虽然不是当前滑动窗口的最大值，但是有可能是后面的滑动窗口的最大值</span></span><br><span class="line">        dq.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    dq.addLast(i);<span class="comment">//执行添加操作，因为每次都要执行添加操作，所以不用加条件判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k-<span class="number">1</span>)&#123;<span class="comment">//当滑动窗口的值达到k的长度时，将队头的值（也就是最大值）添加到数组</span></span><br><span class="line">        res[i-k+<span class="number">1</span>]=nums[dq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="栈和队列" scheme="http://wangjin1996219.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://wangjin1996219.github.io/2021/03/25/%E9%93%BE%E8%A1%A8/"/>
    <id>http://wangjin1996219.github.io/2021/03/25/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-03-25T08:44:01.000Z</published>
    <updated>2021-04-15T12:52:36.001Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="链表相关的核心点"><a href="#链表相关的核心点" class="headerlink" title="链表相关的核心点"></a>链表相关的核心点</h1><ul><li>null/nil 异常处理</li><li>dummy node 哑巴节点</li><li>快慢指针</li><li>插入一个节点到排序链表</li><li>从一个链表中移除一个节点</li><li>翻转链表</li><li>合并两个链表</li><li>找到链表的中间节点</li></ul><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/"><strong>热题100-21.合并两个有序链表</strong></a></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>设置一个哑结点res，方便返回结果</li><li>循环比较两个链表中的节点，循环条件是两个链表指向的节点不为null，head指向数值较小的节点</li><li>循环结束的条件实际是有一个链表遍历结束，再让head.next指向没有遍历完的链表即可</li></ul><h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;<span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/">热题100-206. 反转链表</a></strong></p><p>输入一个链表，将它反转后返回头结点。</p></blockquote><h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">    ListNode curNode=head;</span><br><span class="line">    ListNode nextNode=head;</span><br><span class="line">    <span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextNode=curNode.next;</span><br><span class="line">         curNode.next=preNode;</span><br><span class="line">         preNode=curNode;</span><br><span class="line">         curNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote><p><a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=190&tqId=36037&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表的奇偶重排</strong></a></p><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。</p><p>注意是节点的编号而非节点的数值。</p></blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>设置两个哑结点</p></li><li><p>遍历链表：</p><p>奇数节点赋给奇数链表</p><p>偶数节点赋给偶数链表</p></li><li><p>如果链表没有遍历完，肯定是奇数个节点的情况，只剩一个节点赋给奇数链表</p></li><li><p>最后，将奇数链表和偶数链表结合</p></li></ul><h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp1=head1;</span><br><span class="line">        ListNode head2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp2=head2;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp1.next=head;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">            temp2.next=head.next;</span><br><span class="line">            temp2=temp2.next;</span><br><span class="line">            head=temp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp1.next=head;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp2.next=<span class="keyword">null</span>;</span><br><span class="line">        temp1.next=head2.next;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer-52. 两个链表的第一个公共节点</a></strong></p><p>输入两个链表，找出它们的第一个公共节点。</p></blockquote><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>头节点 <code>headA</code>  （节点数量a）到 <code>node</code> 前，共有 a−c个节点；</li><li>头节点 <code>headB</code>  （节点数量b）到 <code>node</code> 前，共有 b−c个节点；</li></ul><p>构建两个节点指针 A , B 分别指向两链表头节点 headA , headB ，做如下操作：</p><ul><li>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：</li></ul><p>$$<br>  a+(b−c)<br>$$</p><ul><li>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：</li></ul><p>$$<br>  b+(a−c)<br>$$</p><p> 如下式所示，此时指针 A , B 重合，并有两种情况：</p><p>$$<br>a+(b−c)=b+(a−c)<br>$$</p><ol><li>若两链表有公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li><li>若两链表无公共尾部 (即 c=0) ：指针 A , B 同时指向 null。</li></ol><p>因此返回 A 即可。</p><h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode A = headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="keyword">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="keyword">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote><p><a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=190&tqId=35219&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-两个链表生成相加链表</strong></a></p><p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p><p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p><p>类似题目：<a href="https://leetcode-cn.com/problems/add-two-numbers/"><strong>热题100-2. 两数相加</strong></a></p></blockquote><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>力扣上的题目是<strong>逆序</strong>存储，可以从最低位相加，而这里是<strong>正序</strong>存储的，要对链表进行处理</p><ul><li>先将两个链表反转，可以从头结点开始遍历链表并对节点相加</li><li>循环中要设置进位</li><li>循环结束，要判断进位是否为1，如果是要将这个节点拼接到结果链表上</li><li>最后将结果链表反转，返回</li></ul><h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode rhead1=reverseList(head1);</span><br><span class="line">        ListNode rhead2=reverseList(head2);</span><br><span class="line">        <span class="keyword">int</span> carray=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=pre;</span><br><span class="line">        <span class="keyword">while</span>(rhead1!=<span class="keyword">null</span>||rhead2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k1=rhead1==<span class="keyword">null</span>? <span class="number">0</span>:rhead1.val;</span><br><span class="line">            <span class="keyword">int</span> k2=rhead2==<span class="keyword">null</span>? <span class="number">0</span>:rhead2.val;</span><br><span class="line">            <span class="keyword">int</span> sum=k1+k2+carray;</span><br><span class="line">            carray=sum/<span class="number">10</span>;</span><br><span class="line">            sum=sum%<span class="number">10</span>;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            <span class="keyword">if</span>(rhead1!=<span class="keyword">null</span>) rhead1=rhead1.next;</span><br><span class="line">            <span class="keyword">if</span>(rhead2!=<span class="keyword">null</span>) rhead2=rhead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carray!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseList(pre.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer-22. 链表中倒数第k个节点</a></strong></p><p> 输入一个链表，输出该链表中倒数第k个结点。 </p><p> 如果该链表长度小于k，请返回空。 </p></blockquote><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针</p><h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>||k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        node.next=pHead;</span><br><span class="line">        ListNode slow=node;</span><br><span class="line">        ListNode fast=node;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;i&lt;k)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote><p><strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">热题100-19. 删除链表的倒数第 N 个结点</a></strong></p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p></blockquote><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>删除与返回第n个节点，<strong>fast指针的起始位置是不同的</strong></p><h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote><p><a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=190&tqId=35186&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-删除有序链表中重复的元素</strong></a></p><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次</p></blockquote><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>设置一个前驱节点，当当前节点与前驱节点的值相同时，跳过</li><li>当值不同时，pre.next=head，跳过重复节点，然后该节点作为后面节点的前驱节点，继续循环</li><li>循环结束时，前驱节点应该位于链表的最后一个节点，如果不是，说明链表尾部有重复元素没有跳过，如 {1,2,3,4,4,4,4,4}</li></ul><h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val==pre.val)&#123;</span><br><span class="line">                head=head.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote><p><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=190&tqId=35192&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表中的节点每k个一组反转</strong></a></p><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表</p><p>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样</p><p>你不能更改节点中的值，只能更改节点本身。</p><p>要求空间复杂度  O(1)</p></blockquote><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>节点 pre：每次指向操作链表的上段链表的结尾</p><p>节点 end：指向每段操作链表的尾部</p><p>节点 start：指向每段操作链表的头部</p><p><strong>reverseKGroup 方法：</strong>以 k 个为一段，<strong>分段处理</strong>链表</p><ul><li>首先，通过for循环查看剩余长度是否够 k 个，如果不够直接结束循环。外层的循环还要加一个if语句，让它跳出外层循环</li><li>当够 k 个，以这k个节点为一段，让 end 指向链表尾部，用一个 nextNode 指向 end.next ,并<strong>让end指向 null</strong> 为了反转该段链表</li><li>调用reverse方法，对 start 开头的链表反转</li><li>通过 pre 让上段链表与反转后的该段相接</li><li>因为<strong>反转后 start 指向了链表尾</strong>，让pre指向start，与下段链表相接</li><li>另start指向下段的头部</li><li>head也指向下段的头部，下次循环从头部开始遍历</li></ul><p><strong>reverseList 方法：</strong>反转链表</p><h3 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        ListNode end=dummy;<span class="comment">//每次指向一节链表的尾部节点</span></span><br><span class="line">        </span><br><span class="line">        ListNode start=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre.next=start;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head=head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end=head;</span><br><span class="line">            ListNode nextNode=end.next;</span><br><span class="line">            end.next=<span class="keyword">null</span>;</span><br><span class="line">            pre.next=reverseList(start);</span><br><span class="line">            pre=start;</span><br><span class="line">            start=nextNode;</span><br><span class="line">            head=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote><p><a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=190&tqId=35184&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表内指定区间反转</strong></a></p><p>将一个链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。</p></blockquote><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路跟上一题很像，只要处理好反转后的链表的链接细节就行</p><h3 id="代码及注释-6"><a href="#代码及注释-6" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode slow=dummy;</span><br><span class="line">        ListNode fast=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail=fast.next;</span><br><span class="line">        fast.next=<span class="keyword">null</span>;</span><br><span class="line">        ListNode reTail=slow.next;</span><br><span class="line">        slow.next=reverseList(reTail);</span><br><span class="line">        reTail.next=tail;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote><p><a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=190&tqId=35342&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-删除有序链表中重复出现的元素</strong></a></p><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。</p></blockquote><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>与上面的一题不同，本题最后只保留原来链表中只出现一次的节点</p><p>循环遍历链表，对于每个节点有两种可能：</p><ul><li>后面有重复的元素，要跳过所有重复元素，所以while循环之后还要跳一步才能跳过所有元素，并且让pre（上个元素）的后继指向该节点，防止尾部都是重复元素时，直接来到null，但是pre还是指向后面重复元素的第一个节点</li><li>后面没有重复元素，pre（上个元素）的后继指向该节点，并让pre指向该节点，该节点后移一个节点</li></ul><h3 id="代码及注释-7"><a href="#代码及注释-7" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val==cur.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>&amp;&amp;cur.val==cur.next.val)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">                pre.next=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目九</p><p>解题思路</p><p>代码及注释</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="LeetCode题解" scheme="http://wangjin1996219.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="数据结构篇" scheme="http://wangjin1996219.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>校园商铺1.0-项目升级</title>
    <link href="http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7/"/>
    <id>http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7/</id>
    <published>2021-03-24T14:57:46.000Z</published>
    <updated>2021-04-10T14:43:37.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-1-对关键配置信息进行DES加密"><a href="#11-1-对关键配置信息进行DES加密" class="headerlink" title="11.1 对关键配置信息进行DES加密"></a>11.1 对关键配置信息进行DES加密</h1><p>创建加密和解密的工具类：DESUtil</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Key key;</span><br><span class="line"><span class="comment">// 设置密钥key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String KEY_STR = <span class="string">&quot;myKey&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String CHARSETNAME = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String ALGORITHM = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 生成DES算法对象</span></span><br><span class="line">KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);</span><br><span class="line"><span class="comment">// 运用SHA1安全策略</span></span><br><span class="line">SecureRandom secureRandom = SecureRandom.getInstance(<span class="string">&quot;SHA1PRNG&quot;</span>);</span><br><span class="line"><span class="comment">// 设置上密钥种子</span></span><br><span class="line">secureRandom.setSeed(KEY_STR.getBytes());</span><br><span class="line"><span class="comment">// 初始化基于SHA1的算法对象</span></span><br><span class="line">generator.init(secureRandom);</span><br><span class="line"><span class="comment">// 生成密钥对象</span></span><br><span class="line">key = generator.generateKey();</span><br><span class="line">generator = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取加密后的信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getEncryptString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 基于BASE64编码，接收byte[]并转换成String</span></span><br><span class="line">BASE64Encoder base64encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 按UTF8编码</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(CHARSETNAME);</span><br><span class="line"><span class="comment">// 获取加密对象</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(ALGORITHM);</span><br><span class="line"><span class="comment">// 初始化密码信息</span></span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">byte</span>[] doFinal = cipher.doFinal(bytes);</span><br><span class="line"><span class="comment">// byte[]to encode好的String并返回</span></span><br><span class="line"><span class="keyword">return</span> base64encoder.encode(doFinal);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取解密之后的信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDecryptString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 基于BASE64编码，接收byte[]并转换成String</span></span><br><span class="line">BASE64Decoder base64decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将字符串decode成byte[]</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = base64decoder.decodeBuffer(str);</span><br><span class="line"><span class="comment">// 获取解密对象</span></span><br><span class="line">Cipher cipher = Cipher.getInstance(ALGORITHM);</span><br><span class="line"><span class="comment">// 初始化解密信息</span></span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">byte</span>[] doFinal = cipher.doFinal(bytes);</span><br><span class="line"><span class="comment">// 返回解密之后的信息</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(doFinal, CHARSETNAME);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 将JDBC.properties文件中的数据库连接的账号、密码信息都改为加密后的密文</p><p>创建类，用于解密关键字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptPropertyPlaceholderConfigurer</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 需要解密的字段数组</span></span><br><span class="line"><span class="keyword">private</span> String[] encryptPropNames = &#123; <span class="string">&quot;jdbc.username&quot;</span>, <span class="string">&quot;jdbc.password&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对关键的属性进行转换（上面的字段）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">convertProperty</span><span class="params">(String propertyName, String propertyValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEncryptProp(propertyName)) &#123;</span><br><span class="line"><span class="comment">// 对已加密的字段进行解密工作</span></span><br><span class="line">String decryptValue = DESUtil.getDecryptString(propertyValue);</span><br><span class="line"><span class="keyword">return</span> decryptValue;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> propertyValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断该属性是否已加密</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> propertyName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEncryptProp</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 若等于需要加密的field，则进行加密</span></span><br><span class="line"><span class="keyword">for</span> (String encryptpropertyName : encryptPropNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (encryptpropertyName.equals(propertyName))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改spring-dao.xml中的配置，将含有加密字段的文件路径放入工具类的bean中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里能不能理解为bean中的属性locations的值依次为jdbc.properties中的每一个字段呢</span></span><br><span class="line">&lt;bean</span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.imooc.o2o.util.EncryptPropertyPlaceholderConfigurer&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;locations&quot;</span>&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;fileEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;         </span><br></pre></td></tr></table></figure><h1 id="11-2引入Redis缓存技术配置"><a href="#11-2引入Redis缓存技术配置" class="headerlink" title="11.2引入Redis缓存技术配置"></a>11.2引入Redis缓存技术配置</h1><h2 id="11-2-1引入Jedis的jar包"><a href="#11-2-1引入Jedis的jar包" class="headerlink" title="11.2.1引入Jedis的jar包"></a>11.2.1引入Jedis的jar包</h2><p>Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的</p><h2 id="11-2-2创建redis-properties"><a href="#11-2-2创建redis-properties" class="headerlink" title="11.2.2创建redis.properties"></a>11.2.2创建redis.properties</h2><p>redis.properties中定义了连接redis的账户密码等字段</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis.hostname</span>=<span class="string">47.93.5.212</span></span><br><span class="line"><span class="meta">redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">redis.pool.maxActive</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">redis.pool.maxIdle</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">redis.pool.maxWait</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">redis.pool.testOnBorrow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="11-2-3创建spring-redis-xml对redis进行配置"><a href="#11-2-3创建spring-redis-xml对redis进行配置" class="headerlink" title="11.2.3创建spring-redis.xml对redis进行配置"></a>11.2.3创建spring-redis.xml对redis进行配置</h2><p>redis连接池的配置</p><p>创建Redis连接池对象：通过接口JedisPollWriper初始化连接池对象</p><p>创建Redis工具类JedisUtil，封装好Redis的连接以进行相关的操作</p><p>后面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis连接池的设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制一个pool可分配多少个jedis实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxActive&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 连接池中最多可空闲maxIdle个连接 ，这里取值为20，表示即使没有数据库连接时依然可以保持20空闲的连接，而不被清除，随时处于待命状态。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxIdle&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxWait&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在获取连接的时候检查有效性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.testOnBorrow&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建Redis连接池，并做相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisWritePool&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisPoolWriper&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">depends-on</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.hostname&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建Redis工具类，封装好Redis的连接以进行相关的操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jedisPool&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;jedisWritePool&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis的key操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisKeys&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Keys&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis的Strings操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisStrings&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Strings&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis的Lists操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisLists&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Lists&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis的Sets操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisSets&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Sets&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis的HashMap操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisHash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Hash&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-2-4JedisUtil工具类"><a href="#11-2-4JedisUtil工具类" class="headerlink" title="11.2.4JedisUtil工具类"></a>11.2.4JedisUtil工具类</h2><p><strong>JedisUtil工具类：</strong>封装好Redis的连接以进行相关的操作</p><p>工具类中包含以下几个内部类：</p><p>1、Keys：主要封装了对redis中的键值对中的键操作的方法，比如：清空所有的Key，删除keys对应的记录等，方法的实现主要还是通过jedis对象中的方法对redis中的内容进行操作</p><p>2、Strings：主要封装了一些根据string操作对象的值查询value，添加记录等的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存生存时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expire = <span class="number">60000</span>;</span><br><span class="line"><span class="comment">/** 操作Key的方法 */</span></span><br><span class="line"><span class="keyword">public</span> Keys KEYS;</span><br><span class="line"><span class="comment">/** 对存储结构为String类型的操作 */</span></span><br><span class="line"><span class="keyword">public</span> Strings STRINGS;</span><br><span class="line"><span class="comment">/** 对存储结构为List类型的操作 */</span></span><br><span class="line"><span class="keyword">public</span> Lists LISTS;</span><br><span class="line"><span class="comment">/** 对存储结构为Set类型的操作 */</span></span><br><span class="line"><span class="keyword">public</span> Sets SETS;</span><br><span class="line"><span class="comment">/** 对存储结构为HashMap类型的操作 */</span></span><br><span class="line"><span class="keyword">public</span> Hash HASH;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Redis连接池对象 */</span></span><br><span class="line"><span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取redis连接池</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jedisPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置redis连接池</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJedisPool</span><span class="params">(JedisPoolWriper jedisPoolWriper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jedisPool = jedisPoolWriper.getJedisPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从jedis连接池中获取获取jedis对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">jedis.expire(key, seconds);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置默认过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">expire(key, expire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************Keys*******************************************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空所有key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">flushAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String stata = jedis.flushAll();</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> stata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更改key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rename</span><span class="params">(String oldkey, String newkey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rename(SafeEncoder.encode(oldkey), SafeEncoder.encode(newkey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更改key,仅当新key不存在时才执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">renamenx</span><span class="params">(String oldkey, String newkey)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> status = jedis.renamenx(oldkey, newkey);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更改key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rename</span><span class="params">(<span class="keyword">byte</span>[] oldkey, <span class="keyword">byte</span>[] newkey)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String status = jedis.rename(oldkey, newkey);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置key的过期时间，以秒为单位</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 时间     ,已秒为单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expired</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.expire(key, seconds);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置key的过期时间,它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00，格里高利历）的偏移量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 时间     ,已秒为单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAt</span><span class="params">(String key, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.expireAt(key, timestamp);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询key的过期时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以秒为单位的时间表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">ttl</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = sjedis.ttl(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消对key过期时间的设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">persist</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.persist(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除keys对应的记录,可以是多个key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">del</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.del(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除keys对应的记录,可以是多个key</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">del</span><span class="params">(<span class="keyword">byte</span>[]... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.del(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">boolean</span> exis = sjedis.exists(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> exis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对List,Set,SortSet进行排序,如果集合数据较大应避免使用这个方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;String&gt; 集合的全部记录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;String&gt; list = sjedis.sort(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对List,Set,SortSet进行排序或limit</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String        key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> SortingParams parame 定义排序类型或limit的起止位置.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;String&gt; 全部或部分记录</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(String key, SortingParams parame)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;String&gt; list = sjedis.sort(key, parame);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定key存储的类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String string|list|set|zset|hash</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">String type = sjedis.type(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找所有匹配给定的模式的键</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key的表达式,*表示多个，？表示一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">keys</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = jedis.keys(pattern);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************Strings*******************************************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strings</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">String value = sjedis.get(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] get(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">byte</span>[] value = sjedis.get(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> set(SafeEncoder.encode(key), SafeEncoder.encode(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> set(SafeEncoder.encode(key), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String status = jedis.set(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加有过期时间的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    seconds 过期时间，以秒为单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 操作状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setEx</span><span class="params">(String key, <span class="keyword">int</span> seconds, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String str = jedis.setex(key, seconds, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加有过期时间的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    seconds 过期时间，以秒为单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 操作状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">setEx</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> seconds, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String str = jedis.setex(key, seconds, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一条记录，仅当给定的key不存在时才插入</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long 状态码，1插入成功且key不存在，0未插入，key存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setnx</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> str = jedis.setnx(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从指定位置开始插入数据，插入的数据会覆盖指定位置以后的数据&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 例:String str1=&quot;123456789&quot;;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 对str1操作后setRange(key,4,0000)，str1=&quot;123400009&quot;;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   offset</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long value的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRange</span><span class="params">(String key, <span class="keyword">long</span> offset, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = jedis.setrange(key, offset, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定的key中追加value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long 追加后value的长度</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">append</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = jedis.append(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将key对应的value减去指定的值，只有value可以转为数字时该方法才可用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   number 要减去的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long 减指定值后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decrBy</span><span class="params">(String key, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = jedis.decrBy(key, number);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;可以作为获取唯一id的方法&lt;/b&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 将key对应的value加上指定的值，只有value可以转为数字时该方法才可用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   number 要减去的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long 相加后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incrBy</span><span class="params">(String key, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = jedis.incrBy(key, number);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对指定key对应的value进行截取</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   startOffset 开始位置(包含)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   endOffset 结束位置(包含)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 截取的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getrange</span><span class="params">(String key, <span class="keyword">long</span> startOffset, <span class="keyword">long</span> endOffset)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">String value = sjedis.getrange(key, startOffset, endOffset);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取并设置指定key对应的value&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 如果key存在返回之前的value,否则返回null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 原始value或null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSet</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String str = jedis.getSet(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量获取记录,如果指定的key不存在返回List的对应位置将是null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;String&gt; 值得集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">List&lt;String&gt; str = jedis.mget(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量存储记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String keysvalues 例:keysvalues=&quot;key1&quot;,&quot;value1&quot;,&quot;key2&quot;,&quot;value2&quot;;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">mset</span><span class="params">(String... keysvalues)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String str = jedis.mset(keysvalues);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取key对应的值的长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> value值得长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">strlen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = jedis.strlen(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************Sets*******************************************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向Set添加一条记录，如果member已存在返回0,否则返回1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String member</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 操作码,0或1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sadd</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.sadd(key, member);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sadd</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] member)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.sadd(key, member);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取给定key中元素个数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scard</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = sjedis.scard(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回从第一组和所有的给定集合之间的差异的成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 差异的成员集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sdiff</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = jedis.sdiff(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个命令等于sdiff,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey 新结果集的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys 比较的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新集合中的记录数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sdiffstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.sdiffstore(newkey, keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回给定集合交集的成员,如果其中一个集合为不存在或为空，则返回空Set</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 交集成员的集合</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sinter</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = jedis.sinter(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个命令等于sinter,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey 新结果集的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys 比较的集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新集合中的记录数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sinterstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.sinterstore(newkey, keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确定一个给定的值是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String member 要判断的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在返回1，不存在返回0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sismember</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">boolean</span> s = sjedis.sismember(key, member);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回集合中的所有成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成员集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">smembers</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = sjedis.smembers(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; smembers(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">Set&lt;<span class="keyword">byte</span>[]&gt; set = sjedis.smembers(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将成员从源集合移出放入目标集合 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 如果源集合不存在或不包哈指定成员，不进行任何操作，返回0&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 否则该成员从源集合上删除，并添加到目标集合，如果目标集合中成员已存在，则只在源集合进行删除</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String srckey 源集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String dstkey 目标集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String member 源集合中的成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码，1成功，0失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">smove</span><span class="params">(String srckey, String dstkey, String member)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.smove(srckey, dstkey, member);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从集合中删除成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">spop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String s = jedis.spop(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从集合中删除指定成员</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String member 要删除的成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码，成功返回1，成员不存在返回0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">srem</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.srem(key, member);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并多个集合并返回合并后的结果，合并后的结果集合并不保存&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 合并后的结果集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> sunionstore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sunion</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = jedis.sunion(keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并多个集合并将合并后的结果集保存在指定的新集合中，如果新集合已经存在则覆盖</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String newkey 新集合的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... keys 要合并的集合</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sunionstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.sunionstore(newkey, keys);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************Hash*******************************************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从hash中删除指定的存储</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码，1成功，0失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hdel</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.hdel(key, fieid);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hdel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.del(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试hash中指定的存储是否存在</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 1存在，0不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hexists</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">boolean</span> s = sjedis.hexists(key, fieid);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回hash中指定存储位置的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存储对应的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hget</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">String s = sjedis.hget(key, fieid);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] hget(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] fieid) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">byte</span>[] s = sjedis.hget(key, fieid);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以Map的形式返回hash中的存储和值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Map&lt;Strinig,String&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">hgetAll</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">Map&lt;String, String&gt; map = sjedis.hgetAll(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个对应关系</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码 1成功，0失败，fieid已存在将更新，也返回0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hset</span><span class="params">(String key, String fieid, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.hset(key, fieid, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hset</span><span class="params">(String key, String fieid, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.hset(key.getBytes(), fieid.getBytes(), value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加对应关系，只有在fieid不存在时才执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码 1成功，0失败fieid已存</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hsetnx</span><span class="params">(String key, String fieid, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.hsetnx(key, fieid, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取hash中value的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">hvals</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;String&gt; list = sjedis.hvals(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定的存储位置加上指定的数字，存储位置的值必须可转为数字类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String fieid 存储位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String long value 要增加的值,可以是负数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 增加指定数字后，存储位置的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hincrby</span><span class="params">(String key, String fieid, <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> s = jedis.hincrBy(key, fieid, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定hash中的所有存储名字,类似Map中的keySet方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Set&lt;String&gt; 存储名称的集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">hkeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">Set&lt;String&gt; set = sjedis.hkeys(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取hash中存储的个数，类似Map中size方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> long 存储的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hlen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> len = sjedis.hlen(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据多个key，获取对应的value，返回List,如果指定的key不存在,List对应位置为null</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String ... fieids 存储位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;String&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">hmget</span><span class="params">(String key, String... fieids)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;String&gt; list = sjedis.hmget(key, fieids);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">byte</span>[]&gt; hmget(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[]... fieids) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;<span class="keyword">byte</span>[]&gt; list = sjedis.hmget(key, fieids);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加对应关系，如果对应关系已存在，则覆盖</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Strin key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Map   &lt;String,String&gt; 对应关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态，成功返回OK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hmset</span><span class="params">(String key, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String s = jedis.hmset(key, map);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加对应关系，如果对应关系已存在，则覆盖</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Strin key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Map   &lt;String,String&gt; 对应关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态，成功返回OK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hmset</span><span class="params">(<span class="keyword">byte</span>[] key, Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; map)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String s = jedis.hmset(key, map);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************Lists*******************************************//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lists</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">llen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> llen(SafeEncoder.encode(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List长度</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">llen</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = sjedis.llen(key);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖操作,将覆盖List中指定位置的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lset</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> index, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String status = jedis.lset(key, index, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 覆盖操作,将覆盖List中指定位置的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lset</span><span class="params">(String key, <span class="keyword">int</span> index, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lset(SafeEncoder.encode(key), index, SafeEncoder.encode(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在value的相对位置插入记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> LIST_POSITION 前面插入或后面插入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String        pivot 相对位置的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String        value 插入的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">linsert</span><span class="params">(String key, LIST_POSITION where, String pivot, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> linsert(SafeEncoder.encode(key), where, SafeEncoder.encode(pivot), SafeEncoder.encode(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在指定位置插入记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String        key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> LIST_POSITION 前面插入或后面插入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[]        pivot 相对位置的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[]        value 插入的内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">linsert</span><span class="params">(<span class="keyword">byte</span>[] key, LIST_POSITION where, <span class="keyword">byte</span>[] pivot, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.linsert(key, where, pivot, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取List中指定位置的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lindex</span><span class="params">(String key, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SafeEncoder.encode(lindex(SafeEncoder.encode(key), index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取List中指定位置的值</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] lindex(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line"><span class="keyword">byte</span>[] value = sjedis.lindex(key, index);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将List中的第一条记录移出List</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SafeEncoder.encode(lpop(SafeEncoder.encode(key)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将List中的第一条记录移出List</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] lpop(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">byte</span>[] value = jedis.lpop(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将List中最后第一条记录移出List</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String value = jedis.rpop(key);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向List尾部追加记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lpush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lpush(SafeEncoder.encode(key), SafeEncoder.encode(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向List头部追加记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">rpush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.rpush(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向List头部追加记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">rpush</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.rpush(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向List中追加记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lpush</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.lpush(key, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定范围的记录，可以做为分页使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> long   end</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">lrange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;String&gt; list = sjedis.lrange(key, start, end);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取指定范围的记录，可以做为分页使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    end 如果为负数，则尾部开始计算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">byte</span>[]&gt; lrange(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line"><span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">Jedis sjedis = getJedis();</span><br><span class="line">List&lt;<span class="keyword">byte</span>[]&gt; list = sjedis.lrange(key, start, end);</span><br><span class="line">sjedis.close();</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除List中c条记录，被删除的记录值为value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] value 要匹配的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除后的List中的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lrem</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> c, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line"><span class="keyword">long</span> count = jedis.lrem(key, c, value);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除List中c条记录，被删除的记录值为value</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String value 要匹配的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除后的List中的记录数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lrem</span><span class="params">(String key, <span class="keyword">int</span> c, String value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lrem(SafeEncoder.encode(key), c, SafeEncoder.encode(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算是删除吧，只保留start与end之间的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    start 记录的开始位置(0表示第一条记录)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ltrim</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">Jedis jedis = getJedis();</span><br><span class="line">String str = jedis.ltrim(key, start, end);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 算是删除吧，只保留start与end之间的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    start 记录的开始位置(0表示第一条记录)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int    end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行状态码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ltrim</span><span class="params">(String key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ltrim(SafeEncoder.encode(key), start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-3引入Redis缓存技术编码实现"><a href="#11-3引入Redis缓存技术编码实现" class="headerlink" title="11.3引入Redis缓存技术编码实现"></a>11.3引入Redis缓存技术编码实现</h1><p><strong>在对Redis配置完成之后，需要对需要存入Redis缓存中的数据对应的查询、插入、修改的代码逻辑进行更改</strong></p><p>这里我们要将不经常变更的数据：<strong>区域信息、店铺类别、头条信息</strong>等存入Redis缓存中</p><p>这里以<strong>AreaServiceImpl</strong>中<strong>getAreaList</strong>方法的逻辑举例：</p><ul><li>注入JedisUtil.Keys对象：用于对Redis中的键进行操作</li><li>注入JedisUtil.Strings对象：用于对Strings类型的对象进行操作（主要是使用其中的方法）</li><li>创建redis的key= AREALISTKEY</li><li>查询key是否存在，当不存在时，从数据库中取出数据，并且通过jedisStrings.set(key, jsonString)将数据存入到Redis中</li><li>当数据存在时，直接从Redis取出数据，因为取出的数据是Strings类型，还要将其转换为Area对象的数组</li></ul><p>对于其它方法，比如修改店铺的Area时，要将Redis对应的键删除或者修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaServiceImpl</span> <span class="keyword">implements</span> <span class="title">AreaService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AreaDao areaDao;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JedisUtil.Keys jedisKeys;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JedisUtil.Strings jedisStrings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AreaServiceImpl.class);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Area&gt; <span class="title">getAreaList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 定义redis的key</span></span><br><span class="line">String key = AREALISTKEY;</span><br><span class="line"><span class="comment">// 定义接收对象</span></span><br><span class="line">List&lt;Area&gt; areaList = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 定义jackson数据转换操作类</span></span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">// 判断key是否存在</span></span><br><span class="line"><span class="keyword">if</span> (!jedisKeys.exists(key)) &#123;</span><br><span class="line"><span class="comment">// 若不存在，则从数据库里面取出相应数据</span></span><br><span class="line">areaList = areaDao.queryArea();</span><br><span class="line"><span class="comment">// 将相关的实体类集合转换成string,存入redis里面对应的key中</span></span><br><span class="line">String jsonString;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">jsonString = mapper.writeValueAsString(areaList);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.error(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">jedisStrings.set(key, jsonString);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 若存在，则直接从redis里面取出相应数据</span></span><br><span class="line">String jsonString = jedisStrings.get(key);</span><br><span class="line"><span class="comment">// 指定要将string转换成的集合类型</span></span><br><span class="line">JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, Area.class);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将相关key对应的value里的的string转换成对象的实体类集合</span></span><br><span class="line">areaList = mapper.readValue(jsonString, javaType);</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.error(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.error(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">logger.error(e.getMessage());</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> areaList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AreaExecution <span class="title">addArea</span><span class="params">(Area area)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 空值判断，主要是判断areaName不为空</span></span><br><span class="line"><span class="keyword">if</span> (area.getAreaName() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(area.getAreaName())) &#123;</span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">area.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">area.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> effectedNum = areaDao.insertArea(area);</span><br><span class="line"><span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">deleteRedis4Area();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.SUCCESS, area);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.INNER_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(<span class="string">&quot;添加区域信息失败:&quot;</span> + e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.EMPTY);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AreaExecution <span class="title">modifyArea</span><span class="params">(Area area)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 空值判断，主要是areaId不为空</span></span><br><span class="line"><span class="keyword">if</span> (area.getAreaId() != <span class="keyword">null</span> &amp;&amp; area.getAreaId() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">area.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 更新区域信息</span></span><br><span class="line"><span class="keyword">int</span> effectedNum = areaDao.updateArea(area);</span><br><span class="line"><span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">deleteRedis4Area();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.SUCCESS, area);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.INNER_ERROR);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(<span class="string">&quot;更新区域信息失败:&quot;</span> + e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.EMPTY);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除跟实体类相关的redis key-value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteRedis4Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String key = AREALISTKEY;</span><br><span class="line"><span class="comment">// 若redis存在对应的key,则将key清除</span></span><br><span class="line"><span class="keyword">if</span> (jedisKeys.exists(key)) &#123;</span><br><span class="line">jedisKeys.del(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-4添加平台帐号体系"><a href="#11-4添加平台帐号体系" class="headerlink" title="11.4添加平台帐号体系"></a>11.4添加平台帐号体系</h1><h2 id="11-4-1添加平台帐号体系Dao层"><a href="#11-4-1添加平台帐号体系Dao层" class="headerlink" title="11.4.1添加平台帐号体系Dao层"></a>11.4.1添加平台帐号体系Dao层</h2><p>创建LocalAuthDao</p><p><strong>方法：</strong></p><ul><li>通过账号密码查询用户的信息：登录使用</li><li>通过userId查询用户的信息</li><li>添加本地账号</li><li>通过userId，修改账号密码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocalAuthDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过帐号和密码查询对应信息，登录用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuth <span class="title">queryLocalByUserNameAndPwd</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过用户Id查询对应localauth</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuth <span class="title">queryLocalByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="keyword">long</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加平台帐号</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertLocalAuth</span><span class="params">(LocalAuth localAuth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过userId,username,password更改密码</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateLocalAuth</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Param(&quot;password&quot;)</span> String password, <span class="meta">@Param(&quot;newPassword&quot;)</span> String newPassword,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@Param(&quot;lastEditTime&quot;)</span> Date lastEditTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在Mapper中实现LocalAuthDao中的信息：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.imooc.o2o.dao.LocalAuthDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;localAuthResultMap&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;com.imooc.o2o.entity.LocalAuth&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;local_auth_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;localAuthId&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;personInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.PersonInfo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;profile_img&quot;</span> <span class="attr">property</span>=<span class="string">&quot;profileImg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userType&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enable_status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enableStatus&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryLocalByUserNameAndPwd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">resultMap</span>=<span class="string">&quot;localAuthResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">SELECT</span><br><span class="line">l.local_auth_id,</span><br><span class="line">l.username,</span><br><span class="line">l.password,</span><br><span class="line">l.create_time,</span><br><span class="line">l.last_edit_time,</span><br><span class="line">p.user_id,</span><br><span class="line">p.name,</span><br><span class="line">p.gender,</span><br><span class="line">p.email,</span><br><span class="line">p.profile_img,</span><br><span class="line">p.user_type,</span><br><span class="line">p.create_time,</span><br><span class="line">p.last_edit_time,</span><br><span class="line">p.enable_status</span><br><span class="line">FROM</span><br><span class="line">tb_local_auth l</span><br><span class="line">LEFT</span><br><span class="line">JOIN</span><br><span class="line">tb_person_info</span><br><span class="line">p ON l.user_id</span><br><span class="line">=</span><br><span class="line">p.user_id</span><br><span class="line">WHERE</span><br><span class="line">l.username =</span><br><span class="line">#&#123;username&#125;</span><br><span class="line">AND</span><br><span class="line">l.password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryLocalByUserId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;localAuthResultMap&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">SELECT</span><br><span class="line">l.local_auth_id,</span><br><span class="line">l.username,</span><br><span class="line">l.password,</span><br><span class="line">l.create_time,</span><br><span class="line">l.last_edit_time,</span><br><span class="line">p.user_id,</span><br><span class="line">p.name,</span><br><span class="line">p.gender,</span><br><span class="line">p.email,</span><br><span class="line">p.profile_img,</span><br><span class="line">p.user_type,</span><br><span class="line">p.create_time,</span><br><span class="line">p.last_edit_time,</span><br><span class="line">p.enable_status</span><br><span class="line">FROM</span><br><span class="line">tb_local_auth l</span><br><span class="line">LEFT</span><br><span class="line">JOIN</span><br><span class="line">tb_person_info</span><br><span class="line">p ON l.user_id</span><br><span class="line">=</span><br><span class="line">p.user_id</span><br><span class="line">WHERE</span><br><span class="line">l.user_id =</span><br><span class="line">#&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertLocalAuth&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">parameterType</span>=<span class="string">&quot;com.imooc.o2o.entity.LocalAuth&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">&quot;localAuthId&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;local_auth_id&quot;</span>&gt;</span></span><br><span class="line">INSERT</span><br><span class="line">INTO</span><br><span class="line">tb_local_auth(username,password,user_id,create_time,last_edit_time)</span><br><span class="line">VALUES</span><br><span class="line">(#&#123;username&#125;,#&#123;password&#125;,#&#123;personInfo.userId&#125;,#&#123;createTime&#125;,#&#123;lastEditTime&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateLocalAuth&quot;</span>&gt;</span></span><br><span class="line">update tb_local_auth</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;newPassword != null&quot;</span>&gt;</span>password=#&#123;newPassword&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastEditTime != null&quot;</span>&gt;</span>last_edit_time=#&#123;lastEditTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">where user_id=#&#123;userId&#125;</span><br><span class="line">AND username=#&#123;username&#125;</span><br><span class="line">AND</span><br><span class="line">password=#&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="11-4-2添加平台帐号体系Service层"><a href="#11-4-2添加平台帐号体系Service层" class="headerlink" title="11.4.2添加平台帐号体系Service层"></a>11.4.2添加平台帐号体系Service层</h2><p><strong>创建LocalAuthService接口：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocalAuthService</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过帐号和密码获取平台帐号信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuth <span class="title">getLocalAuthByUsernameAndPwd</span><span class="params">(String userName, String password)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过userId获取平台帐号信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuth <span class="title">getLocalAuthByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定微信，生成平台专属的帐号</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuthExecution <span class="title">bindLocalAuth</span><span class="params">(LocalAuth localAuth)</span> <span class="keyword">throws</span> LocalAuthOperationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改平台帐号的登录密码</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localAuthId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newPassword</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastEditTime</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">LocalAuthExecution <span class="title">modifyLocalAuth</span><span class="params">(Long userId, String username, String password, String newPassword)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> LocalAuthOperationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建LocalAuthServiceImpl实现LocalAuthService接口：</strong></p><p><strong>bindLocalAuth方法：</strong></p><ul><li>对传入的用户信息判断，如果该用户绑定过平台账号直接退出，来保证平台账号的唯一性</li><li>如果没有绑定过，创建一个平台账号与该用户绑定</li><li>其中对平台账号的密码要进行加密，也就是创建完成之后，数据库中的密码为密文</li></ul><p><strong>getLocalAuthByUsernameAndPwd方法：</strong></p><ul><li>当用户登录平台时，要对密码进行加密，去与数据库中的进行比对来实现登录</li></ul><p><strong>modifyLocalAuth方法：</strong></p><ul><li>对传入的用户信息、账号、密码进行空值判断；</li><li>对旧密码进行验证</li><li>对新密码进行加密</li><li>成功修改用户的密码</li></ul><p><strong>getLocalAuthByUserId方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title">LocalAuthService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LocalAuthDao localAuthDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalAuth <span class="title">getLocalAuthByUsernameAndPwd</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> localAuthDao.queryLocalByUserNameAndPwd(username, MD5.getMd5(password));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalAuth <span class="title">getLocalAuthByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> localAuthDao.queryLocalByUserId(userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalAuthExecution <span class="title">bindLocalAuth</span><span class="params">(LocalAuth localAuth)</span> <span class="keyword">throws</span> LocalAuthOperationException </span>&#123;</span><br><span class="line"><span class="comment">// 空值判断，传入的localAuth 帐号密码，用户信息特别是userId不能为空，否则直接返回错误</span></span><br><span class="line"><span class="keyword">if</span> (localAuth == <span class="keyword">null</span> || localAuth.getPassword() == <span class="keyword">null</span> || localAuth.getUsername() == <span class="keyword">null</span></span><br><span class="line">|| localAuth.getPersonInfo() == <span class="keyword">null</span> || localAuth.getPersonInfo().getUserId() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.NULL_AUTH_INFO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询此用户是否已绑定过平台帐号</span></span><br><span class="line">LocalAuth tempAuth = localAuthDao.queryLocalByUserId(localAuth.getPersonInfo().getUserId());</span><br><span class="line"><span class="keyword">if</span> (tempAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果绑定过则直接退出，以保证平台帐号的唯一性</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.ONLY_ONE_ACCOUNT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果之前没有绑定过平台帐号，则创建一个平台帐号与该用户绑定</span></span><br><span class="line">localAuth.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">localAuth.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 对密码进行MD5加密</span></span><br><span class="line">localAuth.setPassword(MD5.getMd5(localAuth.getPassword()));</span><br><span class="line"><span class="keyword">int</span> effectedNum = localAuthDao.insertLocalAuth(localAuth);</span><br><span class="line"><span class="comment">// 判断创建是否成功</span></span><br><span class="line"><span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;帐号绑定失败&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.SUCCESS, localAuth);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;insertLocalAuth error: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalAuthExecution <span class="title">modifyLocalAuth</span><span class="params">(Long userId, String userName, String password, String newPassword)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> LocalAuthOperationException </span>&#123;</span><br><span class="line"><span class="comment">// 非空判断，判断传入的用户Id,帐号,新旧密码是否为空，新旧密码是否相同，若不满足条件则返回错误信息</span></span><br><span class="line"><span class="keyword">if</span> (userId != <span class="keyword">null</span> &amp;&amp; userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; newPassword != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; !password.equals(newPassword)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 更新密码，并对新密码进行MD5加密</span></span><br><span class="line"><span class="keyword">int</span> effectedNum = localAuthDao.updateLocalAuth(userId, userName, MD5.getMd5(password),</span><br><span class="line">MD5.getMd5(newPassword), <span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 判断更新是否成功</span></span><br><span class="line"><span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;更新密码失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.SUCCESS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;更新密码失败:&quot;</span> + e.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.NULL_AUTH_INFO);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-4-3添加平台帐号体系Controller层"><a href="#11-4-3添加平台帐号体系Controller层" class="headerlink" title="11.4.3添加平台帐号体系Controller层"></a>11.4.3添加平台帐号体系Controller层</h2><p>主要实现了：</p><p><strong>微信登录后，绑定平台本地账号：</strong></p><ul><li>验证码校验</li><li>从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</li><li>要求帐号密码以及当前的用户session非空</li><li>创建LocalAuth对象并赋值</li><li>绑定帐号</li></ul><p><strong>修改平台本地账号密码：</strong></p><ul><li>验证码校验</li><li>从request中获取账号、密码、新密码以及从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</li><li>要求帐号密码以及当前的用户session非空，且新旧密码不相同</li><li>查看原先帐号，看看与输入的帐号是否一致，不一致则认为是非法操作</li><li>修改平台帐号的用户密码</li></ul><p><strong>本地账号登录：</strong></p><ul><li>获取是否需要进行验证码校验的标识符（三次错误就会需要输入验证码）</li><li>从request中获取输入的帐号、密码</li><li>传入帐号和密码去获取平台帐号信息</li><li>同时在session里设置用户信息</li></ul><p><strong>注销</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;local&quot;, method = &#123; RequestMethod.GET, RequestMethod.POST &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalAuthController</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LocalAuthService localAuthService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/bindlocalauth&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户信息与平台帐号绑定</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">bindLocalAuth</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 验证码校验</span></span><br><span class="line"><span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取输入的帐号</span></span><br><span class="line">String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="comment">// 获取输入的密码</span></span><br><span class="line">String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">// 从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</span></span><br><span class="line">PersonInfo user = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">// 非空判断，要求帐号密码以及当前的用户session非空</span></span><br><span class="line"><span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 创建LocalAuth对象并赋值</span></span><br><span class="line">LocalAuth localAuth = <span class="keyword">new</span> LocalAuth();</span><br><span class="line">localAuth.setUsername(userName);</span><br><span class="line">localAuth.setPassword(password);</span><br><span class="line">localAuth.setPersonInfo(user);</span><br><span class="line"><span class="comment">// 绑定帐号</span></span><br><span class="line">LocalAuthExecution le = localAuthService.bindLocalAuth(localAuth);</span><br><span class="line"><span class="keyword">if</span> (le.getState() == LocalAuthStateEnum.SUCCESS.getState()) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, le.getStateInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名和密码均不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/changelocalpwd&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改密码</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">changeLocalPwd</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 验证码校验</span></span><br><span class="line"><span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取帐号</span></span><br><span class="line">String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="comment">// 获取原密码</span></span><br><span class="line">String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">// 获取新密码</span></span><br><span class="line">String newPassword = HttpServletRequestUtil.getString(request, <span class="string">&quot;newPassword&quot;</span>);</span><br><span class="line"><span class="comment">// 从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</span></span><br><span class="line">PersonInfo user = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">// 非空判断，要求帐号新旧密码以及当前的用户session非空，且新旧密码不相同</span></span><br><span class="line"><span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; newPassword != <span class="keyword">null</span> &amp;&amp; user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; !password.equals(newPassword)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 查看原先帐号，看看与输入的帐号是否一致，不一致则认为是非法操作</span></span><br><span class="line">LocalAuth localAuth = localAuthService.getLocalAuthByUserId(user.getUserId());</span><br><span class="line"><span class="keyword">if</span> (localAuth == <span class="keyword">null</span> || !localAuth.getUsername().equals(userName)) &#123;</span><br><span class="line"><span class="comment">// 不一致则直接退出</span></span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入的帐号非本次登录的帐号&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改平台帐号的用户密码</span></span><br><span class="line">LocalAuthExecution le = localAuthService.modifyLocalAuth(user.getUserId(), userName, password,</span><br><span class="line">newPassword);</span><br><span class="line"><span class="keyword">if</span> (le.getState() == LocalAuthStateEnum.SUCCESS.getState()) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, le.getStateInfo());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (LocalAuthOperationException e) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.toString());</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/logincheck&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">logincheck</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 获取是否需要进行验证码校验的标识符</span></span><br><span class="line"><span class="keyword">boolean</span> needVerify = HttpServletRequestUtil.getBoolean(request, <span class="string">&quot;needVerify&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (needVerify &amp;&amp; !CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取输入的帐号</span></span><br><span class="line">String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="comment">// 获取输入的密码</span></span><br><span class="line">String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line"><span class="comment">// 非空校验</span></span><br><span class="line"><span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 传入帐号和密码去获取平台帐号信息</span></span><br><span class="line">LocalAuth localAuth = localAuthService.getLocalAuthByUsernameAndPwd(userName, password);</span><br><span class="line"><span class="keyword">if</span> (localAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 若能取到帐号信息则登录成功</span></span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 同时在session里设置用户信息</span></span><br><span class="line">request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, localAuth.getPersonInfo());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名和密码均不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/logout&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当用户点击登出按钮的时候注销session</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">logout</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"><span class="comment">// 将用户session置为空</span></span><br><span class="line">request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> modelMap;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-5添加拦截器"><a href="#11-5添加拦截器" class="headerlink" title="11.5添加拦截器"></a>11.5添加拦截器</h1><p>店家管理系统中的一些敏感信息不能随意被修改，主要是验证用户是否已经登录了系统、有无对数据操作的权限</p><p>利用Spring的 AOP功能对相关功能进行织入验证方法，这样不用对每个方法都写一段权限验证的代码</p><h2 id="11-5-1在spring-web-xml中配置拦截器"><a href="#11-5-1在spring-web-xml中配置拦截器" class="headerlink" title="11.5.1在spring-web.xml中配置拦截器"></a>11.5.1在spring-web.xml中配置拦截器</h2><p><strong>两个拦截器：</strong></p><p><strong>校验是否已登录了店家管理系统的拦截器</strong> </p><ul><li>定义拦截的路由：shopadmin下所有的方法（主要是对于店铺和商铺操作的方法）</li><li>拦截器具体实现类的bean以及全路径名</li></ul><p><strong>校验是否对该店铺有操作权限的拦截器（某一个店铺）</strong></p><ul><li>要对shopadmin下的部分方法进行排除，也就是不拦截，比如：获取店铺列表、注册相关（因为拦截器的具体实现是要获得用户可操作的店铺列表，和需要校验的session中的店铺进行比对的）</li></ul><p>不拦截的方法都是session中还没有店铺或者要将某个店铺加入到session中的方法：比如getshopmanagementinfo，点击店铺列表中的某一个店铺来获取店铺信息时才将该店铺添加进session中，所以不拦截</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验是否已登录了店家管理系统的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopInterceptor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 校验是否对该店铺有操作权限的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- shoplist page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shoplist&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshoplist&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- shopregister page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopinitinfo&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/registershop&quot;</span> /&gt;</span></span><br><span class="line">        mvc:exclude-mapping</span><br><span class="line">                             path=&quot;/shopadmin/shopoperation&quot; /&gt;</span><br><span class="line">       <span class="comment">&lt;!-- shopmanage page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopmanagement&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopmanagementinfo&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopPermissionInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopPermissionInterceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>ShopLoginInterceptor拦截器的具体实现：</strong></p><ul><li>从session中取出用户信息来</li><li>若用户信息不为空则将session里的用户信息转换成PersonInfo实体类对象</li><li>做空值判断，确保userId不为空并且该帐号的可用状态为1，并且用户类型为店家</li><li>若通过验证则返回true,拦截器返回true之后，用户接下来的操作得以正常执行</li><li>若不满足登录验证，则直接跳转到帐号登录页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 店家管理系统登录验证拦截器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopLoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要做事前拦截，即用户操作发生前，改写preHandle里的逻辑，进行拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 从session中取出用户信息来</span></span><br><span class="line">Object userObj = request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (userObj != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 若用户信息不为空则将session里的用户信息转换成PersonInfo实体类对象</span></span><br><span class="line">PersonInfo user = (PersonInfo) userObj;</span><br><span class="line"><span class="comment">// 做空值判断，确保userId不为空并且该帐号的可用状态为1，并且用户类型为店家</span></span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span> &amp;&amp; user.getUserId() &gt; <span class="number">0</span> &amp;&amp; user.getEnableStatus() == <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 若通过验证则返回true,拦截器返回true之后，用户接下来的操作得以正常执行</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若不满足登录验证，则直接跳转到帐号登录页面</span></span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;script&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;window.open (&#x27;&quot;</span> + request.getContextPath() + <span class="string">&quot;/local/login?usertype=2&#x27;,&#x27;_self&#x27;)&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ShopPermissionInterceptor拦截器的具体实现：</strong></p><ul><li>从session中获取当前选择的店铺</li><li>从session中获取当前用户可操作的店铺列表</li><li>遍历可操作的店铺列表</li><li>如果当前店铺在可操作的列表里则返回true，进行接下来的用户操作</li><li>若不满足拦截器的验证则返回false,终止用户操作的执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopPermissionInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要做事前拦截，即用户操作发生前，改写preHandle里的逻辑，进行用户操作权限的拦截</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 从session中获取当前选择的店铺</span></span><br><span class="line">Shop currentShop = (Shop) request.getSession().getAttribute(<span class="string">&quot;currentShop&quot;</span>);</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">// 从session中获取当前用户可操作的店铺列表</span></span><br><span class="line">List&lt;Shop&gt; shopList = (List&lt;Shop&gt;) request.getSession().getAttribute(<span class="string">&quot;shopList&quot;</span>);</span><br><span class="line"><span class="comment">// 非空判断</span></span><br><span class="line"><span class="keyword">if</span> (currentShop != <span class="keyword">null</span> &amp;&amp; shopList != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 遍历可操作的店铺列表</span></span><br><span class="line"><span class="keyword">for</span> (Shop shop : shopList) &#123;</span><br><span class="line"><span class="comment">// 如果当前店铺在可操作的列表里则返回true，进行接下来的用户操作</span></span><br><span class="line"><span class="keyword">if</span> (shop.getShopId() == currentShop.getShopId()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若不满足拦截器的验证则返回false,终止用户操作的执行</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;11-1-对关键配置信息进行DES加密&quot;&gt;&lt;a href=&quot;#11-1-对关键配置信息进行DES加密&quot; class=&quot;headerlink&quot; title=&quot;11.1 对关键配置信息进行DES加密&quot;&gt;&lt;/a&gt;11.1 对关键配置信息进行DES加密&lt;/h1&gt;&lt;p&gt;创建</summary>
      
    
    
    
    <category term="校园商铺项目" scheme="http://wangjin1996219.github.io/categories/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="校园商铺1.0" scheme="http://wangjin1996219.github.io/tags/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1-0/"/>
    
  </entry>
  
  <entry>
    <title>校园商铺1.0-阿里云远程部署及远程微信开发调试</title>
    <link href="http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/"/>
    <id>http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</id>
    <published>2021-03-24T14:57:08.000Z</published>
    <updated>2021-04-09T22:36:24.679Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="1-1阿里云初始化与执行环境安装"><a href="#1-1阿里云初始化与执行环境安装" class="headerlink" title="1.1阿里云初始化与执行环境安装"></a>1.1阿里云初始化与执行环境安装</h1><h2 id="1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）"><a href="#1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）" class="headerlink" title="1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）"></a>1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）</h2><ol><li>申请阿里云服务器</li><li>搭建出程序的执行环境</li><li>在服务器上发布并运行自己的web project</li><li>域名解析</li><li>微信测试号的申请与连接以获取微信用户信息</li></ol><h3 id="1-1-1-1申请阿里云服务器"><a href="#1-1-1-1申请阿里云服务器" class="headerlink" title="1.1.1.1申请阿里云服务器"></a><strong>1.1.1.1申请阿里云服务器</strong></h3><p> （1）PC访问阿里云<a href="https://www.aliyun.com/%EF%BC%8C%E7%94%B3%E8%AF%B7%E9%98%BF%E9%87%8C%E4%BA%91%E5%B8%90%E5%8F%B7%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%82%A8%E7%9A%84%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E7%99%BB%E5%BD%95%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E5%B7%B2%E7%BB%8F%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E6%9B%B4%E6%96%B9%E4%BE%BF%EF%BC%89%E5%B9%B6%E7%99%BB%E5%BD%95">https://www.aliyun.com/，申请阿里云帐号（可以用您的支付宝帐号登录，因为支付宝帐号已经进行了实名认证，使用起来更方便）并登录</a><br> （2）找到云服务器ECS购买页面（页面展现随时会变，当前为全部导航-&gt;产品-&gt;弹性计算-&gt;云服务器ECS-&gt;选择自己需要的型号(我选择的是入门级)），购买云服务器，这里主要有三种方式：9块9的学生服务器（大家如果不是学生的话可以用还在读大学的小伙伴的学生证来薅羊毛，购买）、包年包月的服务器（不管你怎么使用，按年按月收费）还有按量付费的服务器（按小时计费，不用可以随时注销掉）<br><img src="http://img1.sycdn.imooc.com/59da2e00000182cc24921486.png" alt="图片描述"><br> 操作系统记得选择centos,这里我用的是最新的7.3版本<br><img src="http://img1.sycdn.imooc.com/59da2e4e0001282423901122.png" alt="图片描述"><br> 上半部分的安全设置里面需要填写上root的登录密码，以后咱们需要用这个root帐号来远程登录服务器去做部署，下半部分主要显示的是您选择的阿里云清单<br><img src="http://img1.sycdn.imooc.com/59da2e7d0001b61723841066.png" alt="图片描述"><br> 开通成功后，服务器会启动并运行，同时会自动分配一个公网IP，咱们外网就可以通过这个公网IP访问服务器，同时也可以将域名解析到这个服务器中。<br><img src="http://img1.sycdn.imooc.com/59da2ea10001283b25420984.png" alt="图片描述"><br> 这里翔仔的公网IP为47.104.1.235</p><h3 id="1-1-1-2搭建程序的执行环境"><a href="#1-1-1-2搭建程序的执行环境" class="headerlink" title="1.1.1.2搭建程序的执行环境"></a><strong>1.1.1.2搭建程序的执行环境</strong></h3><p> 搭建程序的执行环境，咱们先列一下常用的执行环境清单：<br> （1）    JDK(这里选择的是JDK1.8)<br> 下载地址为<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br> 选择的是jdk-8u144-linux-x64.rpm<br> （2）    Tomcat 8<br> 下载地址为<br><a href="http://tomcat.apache.org/download-80.cgi#8.0.46">http://tomcat.apache.org/download-80.cgi#8.0.46</a><br> 选择的是apache-tomcat-8.0.46.tar.gz<br> （3）    Mysql(这里选择的是Mysql5.7)repo源，后通过centos自带的yum安装<br> 下载的地址为<br><a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a><br> 这里选择mysql57-community-release-el7-11.noarch.rpm<br> （4）    Redis(可选，最好预先安装上，这里选择的版本为4.0.2)<br> 下载地址为<br><a href="https://redis.io/download">https://redis.io/download</a><br> 这里选择redis-4.0.2.tar.gz<br> 将上面的软件都下载到本地，并上传到服务器(如果您的系统为MAC或LINUX，直接使用SCP命令行上传，具体指令可以查询网上，如果您的系统为WIN，推荐使用filezilla可视化上传工具上传)，或者您也可以直接登录服务器，wget+ftp地址直接下载这些软件；同时需要大家注意的是，我们在服务器上部署了数据库之后，需要往数据库里面去补充数据，我们的线上数据访问的是线上的数据库而非本地的数据库。图片包也需要上传到服务器并通过配置server.xml确保能读取到这些图片（前提是docBase配置上的路径已经在服务器上创建）<br><img src="http://img1.sycdn.imooc.com/59da2edf0001118319361120.png" alt="图片描述"><br> 可以在阿里云控制台进入终端<br><img src="http://img1.sycdn.imooc.com/59da2f3c0001925208650121.png" alt="图片描述"><br> 在服务器的终端，正确的情况下就能看到这些软件了。<br><img src="http://img1.sycdn.imooc.com/59da2f5600011a9419040246.png" alt="图片描述"><br> 接下来开始安装这些软件：</p><p><strong>安装JDK</strong><br> Java程序需要运行在JRE里边，因此咱们需要安装JDK，在软件路径里执行<br> //添加可执行权限<br> chmod +x jdk-8u144-linux-x64.rpm<br> //安装RPM软件包<br> rpm -ivh jdk-8u144-linux-x64.rpm<br> //查看<a href="https://coding.imooc.com/?c=java">java</a>的版本信息，若出现版本信息则成功<br> <a href="https://coding.imooc.com/?c=java">java</a> –version<br><img src="http://img1.sycdn.imooc.com/59da2f6c0001f46a19061000.png" alt="图片描述"></p><p><strong>安装Mysql</strong><br> 安装用来配置mysql的yum源的rpm包<br> rpm -Uvh mysql57-community-release-el7-11.noarch.rpm<br> 安装Mysql<br> yum install mysql-community-server<br><img src="http://img1.sycdn.imooc.com/59da2fdf0001c0d408650502.png" alt="图片描述"><br> 开启mysql服务<br> service mysqld start<br><img src="http://img1.sycdn.imooc.com/59da2ffa0001edd619340382.png" alt="图片描述"><br> mysql安装成功后创建的超级用户’root’@‘localhost’的密码会被存储在/var/log/mysqld.log，可以使用如下命令查看密码<br> grep ‘temporary password’ /var/log/mysqld.log<br><img src="http://img1.sycdn.imooc.com/59da301d0001785925080182.png" alt="图片描述"><br> 使用mysql生成的’root’@‘localhost’用户和密码登录数据库，并修改 其密码，具体命令<br> mysql -uroot -p<br> ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘Xiangze230!’;<br><img src="http://img1.sycdn.imooc.com/59da30390001bba520861422.png" alt="图片描述"><br> 开启远程连接<br> 通过阿里云控制台开放3306端口<br> 在阿里云控制台咱们的实例页面下面选择安全组-&gt;配置规则<br><img src="http://img1.sycdn.imooc.com/59da30620001aaff25221452.png" alt="图片描述"><br> 进入到规则配置页面之后，咱们可以看到目前只有22端口和3389端口支持远程访问，咱们还需要额外开通80端口（微信公众号用），3306端口(mysql)以及6379端口(redis)<br><img src="http://img1.sycdn.imooc.com/59da30760001f73125541440.png" alt="图片描述"><br> 配置一个支持远程登录的帐号，这里配置一个work帐号<br> mysql -u root -p<br> use mysql;<br> grant SELECT,UPDATE,INSERT,DELETE on <em>.</em> to ‘work’@’%’ identified by ‘Xiangze230!’;//创建work帐号并授权，同时设置密码<br> flush privileges;//生效配置<br> 之后便能在我们本地通过调用mysql指令远程登录阿里云服务器上的mysql server中，<br> mysql -uwork -P3306 -h47.104.1.235 –p //本机远程登录mysql指令<br><img src="http://img1.sycdn.imooc.com/59da309400012e1f19880836.png" alt="图片描述"></p><p>安装redis<br> redis安装真的特别简单，首先先解压redis安装包<br> tar -zxvf redis-4.0.2.tar.gz<br> 设置redis以支持远程登录<br> vi redis-4.0.2/redis.conf<br> 将bind 127.0.0.1这句话用井号注释掉，这样就能支持远程连接了<br><img src="http://img1.sycdn.imooc.com/59da30d50001a68521601362.png" alt="图片描述"><br> <strong>此外，还需要给redis.conf添加配置以支持redis作为守护进程一直跑在后台</strong><br> 需要加入『daemonize yes』<br><img src="http://img1.sycdn.imooc.com/59da313000013ead08650187.png" alt="图片描述"><br> 安装redis<br> 去到解压后的目录里<br> cd redis-4.0.2<br> make  //安装redis<br> 启动redis服务<br> src/redis-server redis.conf<br><img src="http://img1.sycdn.imooc.com/59da314a0001d36125400270.png" alt="图片描述"><br> redis连接测试<br> 通过redis-cli连接到redis服务器<br> src/redis-cli<br> 当输入ping 得到pong的回应之后，证明redis配置已经完成<br><img src="http://img1.sycdn.imooc.com/59da316b0001170217480234.png" alt="图片描述"><br> 4．安装tomcat 8<br> tomcat 8的安装更为简单<br> 解压tomcat压缩包<br> tar -zxvf apache-tomcat-8.0.46.tar.gz<br> 启动tomcat<br> ./apache-tomcat-8.0.46/bin/startup.sh<br><img src="http://img1.sycdn.imooc.com/59da31850001020825280504.png" alt="图片描述"></p><h3 id="1-1-1-3在服务器上发布并运行自己的web-project"><a href="#1-1-1-3在服务器上发布并运行自己的web-project" class="headerlink" title="1.1.1.3在服务器上发布并运行自己的web project"></a><strong>1.1.1.3在服务器上发布并运行自己的web project</strong></h3><p> 修改tomcat默认启动端口，从8080修改为80端口，便于微信登录<br> vi apache-tomcat-8.0.46/conf/server.xml<br><img src="http://img1.sycdn.imooc.com/59da31960001a44d21681462.png" alt="图片描述"><br> 重启tomcat<br> ./apache-tomcat-8.0.46/bin/shutdown.sh<br> ./apache-tomcat-8.0.46/bin/startup.sh<br> 修改自己本地的网站的配置<br> 这里由于大家自己的<a href="https://coding.imooc.com/?c=java">java</a>网站项目的配置都不相同，只能说大概的，即把项目里的mysql配置(如果有的话)，redis配置(如果有的话)修改为阿里云服务器对应的配置(即ip，端口，密码等配置修改成服务器里安装好的这些软件的对应的配置)<br><img src="http://img1.sycdn.imooc.com/59da31b100014ae324660598.png" alt="图片描述"><br> 打出自己项目的war包<br><img src="http://img1.sycdn.imooc.com/59da31c30001ed4024681500.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31ce0001be2c08650907.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31db0001cb4808650907.png" alt="图片描述"><br> 将export出来的war包上传到服务器tomcat的webapps目录下<br> scp o2o.war <a href="mailto:root@47.104.1.235">root@47.104.1.235</a>:/root/apache-tomcat-8.0.46/webapps<br><img src="http://img1.sycdn.imooc.com/59da32070001e2d708640065.png" alt="图片描述"><br> 上传成功后，没过几秒tomcat便会在webapps目录下自动从项目war包中解析出项目工程目录来<br><img src="http://img1.sycdn.imooc.com/59da32220001dc1008650056.png" alt="图片描述"><br> 之后通过ip+请求路径的形式便能访问到自己的项目(因为已经设置成80端口，这是http默认访问的端口，所以不需要在URL里添加端口信息了)<br><img src="http://img1.sycdn.imooc.com/59da324a000107b108650519.png" alt="图片描述"></p><h3 id="1-1-1-4域名解析"><a href="#1-1-1-4域名解析" class="headerlink" title="1.1.1.4域名解析"></a><strong>1.1.1.4域名解析</strong></h3><p> 如果通过ip连接微信号，则总会弹出烦人的警告窗口，因此咱们可以先购买一个域名并对域名进行认证(具体的备案步骤不同服务商有不同要求，大家可以按照他们的要求来，主要分有个人认证和企业认证两种，当然大家如果不嫌烦，可以直接用ip即跳过域名解析这一步)，建议大家看看周围的朋友有谁已经有经过验证的域名了，这样可以直接借他的域名创建一个二级域名来用，方便省事，翔仔购买的是阿里云控制台里面的万网域名，购买并认证成功后，会有如下截图，选择购买好的域名并点击解析创建出二级域名<br><img src="http://img1.sycdn.imooc.com/59da326600014ec708650260.png" alt="图片描述"><br> 进入到解析的页面，选择添加解析，并在A记录里面设置好O2O，IP里面设置咱们的阿里云服务器公网IP。这样就能创建出o2o.yitiaojieinfo.com这样的域名指向该公网IP<br><img src="http://img1.sycdn.imooc.com/59da32830001b76108650508.png" alt="图片描述"><br> 隔一段时间，大概5-10分钟这样子，通过域名访问咱们的站点，就能发现访问是okay的<br><img src="http://img1.sycdn.imooc.com/59da329d0001476708650543.png" alt="图片描述"></p><h1 id="1-1-2阿里云部署Java网站和微信开发调试心得技巧-下"><a href="#1-1-2阿里云部署Java网站和微信开发调试心得技巧-下" class="headerlink" title="1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)"></a>1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)</h1><h2 id="1-1-2-5微信测试号的申请与连接以获取微信用户信息"><a href="#1-1-2-5微信测试号的申请与连接以获取微信用户信息" class="headerlink" title="1.1.2.5微信测试号的申请与连接以获取微信用户信息"></a><strong>1.1.2.5微信测试号的申请与连接以获取微信用户信息</strong></h2><p> 在咱们自己的程序里面编写servlet以响应微信号<br> 在接下来的步骤中，我们将在测试号里面设置接口配置信息的URL，一经设置，微信公众号便会发请求到我们设置好的URL去，我们必须编写程序应答才能顺利连通微信公众号，因此咱们需要编写相应的响应程序<br> 需要编写两个类<br> 【SignUtil】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.util.weixin;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信请求校验工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SignUtil &#123;</span><br><span class="line">    &#x2F;&#x2F; 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token &#x3D; &quot;myo2o&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 验证签名</span><br><span class="line">     * </span><br><span class="line">     * @param signature</span><br><span class="line">     * @param timestamp</span><br><span class="line">     * @param nonce</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp, String nonce) &#123;</span><br><span class="line">        String[] arr &#x3D; new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        &#x2F;&#x2F; 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        StringBuilder content &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md &#x3D; null;</span><br><span class="line">        String tmpStr &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            md &#x3D; MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            &#x2F;&#x2F; 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest &#x3D; md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr &#x3D; byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        content &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr !&#x3D; null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param byteArray</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest +&#x3D; byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param mByte</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;</span><br><span class="line">        char[] tempArr &#x3D; new char[2];</span><br><span class="line">        tempArr[0] &#x3D; Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] &#x3D; Digit[mByte &amp; 0X0F];</span><br><span class="line"></span><br><span class="line">        String s &#x3D; new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【WechatController】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.util.wechat.SignUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">&#x2F;&#x2F;一会在设置的URL里面就设置上这个路由</span><br><span class="line">@RequestMapping(&quot;wechat&quot;)</span><br><span class="line">public class WechatController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">        String signature &#x3D; request.getParameter(&quot;signature&quot;);</span><br><span class="line">        &#x2F;&#x2F; 时间戳</span><br><span class="line">        String timestamp &#x3D; request.getParameter(&quot;timestamp&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机数</span><br><span class="line">        String nonce &#x3D; request.getParameter(&quot;nonce&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机字符串</span><br><span class="line">        String echostr &#x3D; request.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">        PrintWriter out &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            out &#x3D; response.getWriter();</span><br><span class="line">            if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">                log.debug(&quot;weixin get success....&quot;);</span><br><span class="line">                out.print(echostr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (out !&#x3D; null)</span><br><span class="line">                out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新部署一版最新的程序</p><p>访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录<br><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a><br><img src="https://img1.sycdn.imooc.com/59da332500011d0308650391.png" alt="图片描述"><br> 进入到测试号页面后，分别看到如下信息<br> 【测试号信息】<br> appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等<br> appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里<br><img src="https://img1.sycdn.imooc.com/59da33380001aa6608650121.png" alt="图片描述"><br> 【接口配置信息】<br> URL: 是开发者用来接收微信消息和事件的接口URL<br> Token:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）<br><img src="https://img1.sycdn.imooc.com/59da334f000153d408650159.png" alt="图片描述"><br> 【JS接口安全域名】<br> 域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL，这里直接填写o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da336d0001ccc608650117.png" alt="图片描述"><br> 【测试号二维码】<br> 里面包含了测试号二维码以及已经关注了的用户信息<br><img src="https://img1.sycdn.imooc.com/59da33840001e2f508650283.png" alt="图片描述"><br> 【体验接口权限表】<br> 这里主要介绍【网页服务】里面的【网页帐号】<br> 网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。这里直接设置为o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da33e400010e7d08650549.png" alt="图片描述"><br><img src="https://img1.sycdn.imooc.com/59da340100017e1308650619.png" alt="图片描述"><br> 有不清楚的地方可以直接参考微信官方文档<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</a><br> 接下来需要编写自己的程序以获取关注此公众号的用户信息<br> 需要编写5个类 WechatLoginController.<a href="https://coding.imooc.com/?c=java">java</a>，UserAccessToken.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUser.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUtil.<a href="https://coding.imooc.com/?c=java">java</a>以及MyX509TrustManager.<a href="https://coding.imooc.com/?c=java">java</a><br> 【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line">import com.imooc.o2o.util.wechat.WeiXinUserUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;wechatlogin&quot;)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问</span><br><span class="line"> * https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;您的appId&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;o2o.yitiaojieinfo.com&#x2F;o2o&#x2F;wechatlogin&#x2F;logincheck&amp;role_type&#x3D;1&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;1#wechat_redirect</span><br><span class="line"> * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatLoginController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatLoginController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;logincheck&quot;, method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public String doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin login get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息</span><br><span class="line">        String code &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">        &#x2F;&#x2F; 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用</span><br><span class="line">        &#x2F;&#x2F; String roleType &#x3D; request.getParameter(&quot;state&quot;);</span><br><span class="line">        log.debug(&quot;weixin login code:&quot; + code);</span><br><span class="line">        WechatUser user &#x3D; null;</span><br><span class="line">        String openId &#x3D; null;</span><br><span class="line">        if (null !&#x3D; code) &#123;</span><br><span class="line">            UserAccessToken token;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过code获取access_token</span><br><span class="line">                token &#x3D; WeiXinUserUtil.getUserAccessToken(code);</span><br><span class="line">                log.debug(&quot;weixin login token:&quot; + token.toString());</span><br><span class="line">                &#x2F;&#x2F; 通过token获取accessToken</span><br><span class="line">                String accessToken &#x3D; token.getAccessToken();</span><br><span class="line">                &#x2F;&#x2F; 通过token获取openId</span><br><span class="line">                openId &#x3D; token.getOpenId();</span><br><span class="line">                &#x2F;&#x2F; 通过access_token和openId获取用户昵称等信息</span><br><span class="line">                user &#x3D; WeiXinUserUtil.getUserInfo(accessToken, openId);</span><br><span class="line">                log.debug(&quot;weixin login user:&quot; + user.toString());</span><br><span class="line">                request.getSession().setAttribute(&quot;openId&quot;, openId);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(&quot;error in getUserAccessToken or getUserInfo or findByOpenId: &quot; + e.toString());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F; 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了，</span><br><span class="line">        &#x2F;&#x2F; 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取到微信验证的信息后返回到指定的路由（需要自己设定）</span><br><span class="line">            return &quot;frontend&#x2F;index&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户授权token</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UserAccessToken &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到的凭证</span><br><span class="line">    @JsonProperty(&quot;access_token&quot;)</span><br><span class="line">    private String accessToken;</span><br><span class="line">    &#x2F;&#x2F; 凭证有效时间，单位：秒</span><br><span class="line">    @JsonProperty(&quot;expires_in&quot;)</span><br><span class="line">    private String expiresIn;</span><br><span class="line">    &#x2F;&#x2F; 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处</span><br><span class="line">    @JsonProperty(&quot;refresh_token&quot;)</span><br><span class="line">    private String refreshToken;</span><br><span class="line">    &#x2F;&#x2F; 该用户在此公众号下的身份标识，对于此微信号具有唯一性</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 表示权限范围，这里可省略</span><br><span class="line">    @JsonProperty(&quot;scope&quot;)</span><br><span class="line">    private String scope;</span><br><span class="line"></span><br><span class="line">    public String getAccessToken() &#123;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccessToken(String accessToken) &#123;</span><br><span class="line">        this.accessToken &#x3D; accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getExpiresIn() &#123;</span><br><span class="line">        return expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpiresIn(String expiresIn) &#123;</span><br><span class="line">        this.expiresIn &#x3D; expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRefreshToken() &#123;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRefreshToken(String refreshToken) &#123;</span><br><span class="line">        this.refreshToken &#x3D; refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getScope() &#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScope(String scope) &#123;</span><br><span class="line">        this.scope &#x3D; scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;accessToken:&quot; + this.getAccessToken() + &quot;,openId:&quot; + this.getOpenId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信用户实体类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUser implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -4684067645282292327L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; openId,标识该公众号下面的该用户的唯一Id</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 用户昵称</span><br><span class="line">    @JsonProperty(&quot;nickname&quot;)</span><br><span class="line">    private String nickName;</span><br><span class="line">    &#x2F;&#x2F; 性别</span><br><span class="line">    @JsonProperty(&quot;sex&quot;)</span><br><span class="line">    private int sex;</span><br><span class="line">    &#x2F;&#x2F; 省份</span><br><span class="line">    @JsonProperty(&quot;province&quot;)</span><br><span class="line">    private String province;</span><br><span class="line">    &#x2F;&#x2F; 城市</span><br><span class="line">    @JsonProperty(&quot;city&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">    &#x2F;&#x2F; 区</span><br><span class="line">    @JsonProperty(&quot;country&quot;)</span><br><span class="line">    private String country;</span><br><span class="line">    &#x2F;&#x2F; 头像图片地址</span><br><span class="line">    @JsonProperty(&quot;headimgurl&quot;)</span><br><span class="line">    private String headimgurl;</span><br><span class="line">    &#x2F;&#x2F; 语言</span><br><span class="line">    @JsonProperty(&quot;language&quot;)</span><br><span class="line">    private String language;</span><br><span class="line">    &#x2F;&#x2F; 用户权限，这里没什么作用</span><br><span class="line">    @JsonProperty(&quot;privilege&quot;)</span><br><span class="line">    private String[] privilege;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNickName() &#123;</span><br><span class="line">        return nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNickName(String nickName) &#123;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(int sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProvince() &#123;</span><br><span class="line">        return province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProvince(String province) &#123;</span><br><span class="line">        this.province &#x3D; province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCity() &#123;</span><br><span class="line">        return city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCity(String city) &#123;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCountry() &#123;</span><br><span class="line">        return country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCountry(String country) &#123;</span><br><span class="line">        this.country &#x3D; country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHeadimgurl() &#123;</span><br><span class="line">        return headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeadimgurl(String headimgurl) &#123;</span><br><span class="line">        this.headimgurl &#x3D; headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLanguage() &#123;</span><br><span class="line">        return language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLanguage(String language) &#123;</span><br><span class="line">        this.language &#x3D; language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getPrivilege() &#123;</span><br><span class="line">        return privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrivilege(String[] privilege) &#123;</span><br><span class="line">        this.privilege &#x3D; privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;openId:&quot; + this.getOpenId() + &quot;,nikename:&quot; + this.getNickName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【WechatUtil】主要用来提交https请求给微信获取用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ConnectException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.HttpsURLConnection;</span><br><span class="line">import javax.net.ssl.SSLContext;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import javax.net.ssl.TrustManager;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信工具类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatUtil.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取UserAccessToken实体类</span><br><span class="line">     * </span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static UserAccessToken getUserAccessToken(String code) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appId</span><br><span class="line">        String appId &#x3D; &quot;您的appId&quot;;</span><br><span class="line">        log.debug(&quot;appId:&quot; + appId);</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appsecret</span><br><span class="line">        String appsecret &#x3D; &quot;您的appsecret&quot;;</span><br><span class="line">        log.debug(&quot;secret:&quot; + appsecret);</span><br><span class="line">        &#x2F;&#x2F; 根据传入的code,拼接出访问微信定义好的接口的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;&quot; + appId + &quot;&amp;secret&#x3D;&quot; + appsecret</span><br><span class="line">                + &quot;&amp;code&#x3D;&quot; + code + &quot;&amp;grant_type&#x3D;authorization_code&quot;;</span><br><span class="line">        &#x2F;&#x2F; 向相应URL发送请求获取token json字符串</span><br><span class="line">        String tokenStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;userAccessToken:&quot; + tokenStr);</span><br><span class="line">        UserAccessToken token &#x3D; new UserAccessToken();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            token &#x3D; objectMapper.readValue(tokenStr, UserAccessToken.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (token &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取WechatUser实体类</span><br><span class="line">     * </span><br><span class="line">     * @param accessToken</span><br><span class="line">     * @param openId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static WechatUser getUserInfo(String accessToken, String openId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;&quot; + accessToken + &quot;&amp;openid&#x3D;&quot; + openId</span><br><span class="line">                + &quot;&amp;lang&#x3D;zh_CN&quot;;</span><br><span class="line">        &#x2F;&#x2F; 访问该URL获取用户信息json 字符串</span><br><span class="line">        String userStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;user info :&quot; + userStr);</span><br><span class="line">        WechatUser user &#x3D; new WechatUser();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            user &#x3D; objectMapper.readValue(userStr, WechatUser.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发起https请求并获取结果</span><br><span class="line">     * </span><br><span class="line">     * @param requestUrl</span><br><span class="line">     *            请求地址</span><br><span class="line">     * @param requestMethod</span><br><span class="line">     *            请求方式（GET、POST）</span><br><span class="line">     * @param outputStr</span><br><span class="line">     *            提交的数据</span><br><span class="line">     * @return json字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建SSLContext对象，并使用我们指定的信任管理器初始化</span><br><span class="line">            TrustManager[] tm &#x3D; &#123; new MyX509TrustManager() &#125;;</span><br><span class="line">            SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</span><br><span class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</span><br><span class="line">            &#x2F;&#x2F; 从上述SSLContext对象中得到SSLSocketFactory对象</span><br><span class="line">            SSLSocketFactory ssf &#x3D; sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">            URL url &#x3D; new URL(requestUrl);</span><br><span class="line">            HttpsURLConnection httpUrlConn &#x3D; (HttpsURLConnection) url.openConnection();</span><br><span class="line">            httpUrlConn.setSSLSocketFactory(ssf);</span><br><span class="line"></span><br><span class="line">            httpUrlConn.setDoOutput(true);</span><br><span class="line">            httpUrlConn.setDoInput(true);</span><br><span class="line">            httpUrlConn.setUseCaches(false);</span><br><span class="line">            &#x2F;&#x2F; 设置请求方式（GET&#x2F;POST）</span><br><span class="line">            httpUrlConn.setRequestMethod(requestMethod);</span><br><span class="line"></span><br><span class="line">            if (&quot;GET&quot;.equalsIgnoreCase(requestMethod))</span><br><span class="line">                httpUrlConn.connect();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当有数据需要提交时</span><br><span class="line">            if (null !&#x3D; outputStr) &#123;</span><br><span class="line">                OutputStream outputStream &#x3D; httpUrlConn.getOutputStream();</span><br><span class="line">                &#x2F;&#x2F; 注意编码格式，防止中文乱码</span><br><span class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将返回的输入流转换成字符串</span><br><span class="line">            InputStream inputStream &#x3D; httpUrlConn.getInputStream();</span><br><span class="line">            InputStreamReader inputStreamReader &#x3D; new InputStreamReader(inputStream, &quot;utf-8&quot;);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">            String str &#x3D; null;</span><br><span class="line">            while ((str &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                buffer.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            &#x2F;&#x2F; 释放资源</span><br><span class="line">            inputStream.close();</span><br><span class="line">            inputStream &#x3D; null;</span><br><span class="line">            httpUrlConn.disconnect();</span><br><span class="line">            log.debug(&quot;https buffer:&quot; + buffer.toString());</span><br><span class="line">        &#125; catch (ConnectException ce) &#123;</span><br><span class="line">            log.error(&quot;Weixin server connection timed out.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;https request error:&#123;&#125;&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.security.cert.CertificateException;</span><br><span class="line">import java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.X509TrustManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 证书信任管理器（用于https请求）</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyX509TrustManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新打包一个新的war包并发布到服务器tomcat webapps目录下<br> 发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=%E6%82%A8%E7%9A%84appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect</a><br><img src="https://img1.sycdn.imooc.com/59da34c500012aa908650494.png" alt="图片描述"><br> 之后查看日志信息，便能发现确实能够获取到用户的信息了<br><img src="https://img1.sycdn.imooc.com/59da34de0001a64308650182.png" alt="图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="校园商铺项目" scheme="http://wangjin1996219.github.io/categories/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="校园商铺1.0" scheme="http://wangjin1996219.github.io/tags/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1-0/"/>
    
  </entry>
  
  <entry>
    <title>校园商铺1.0-前端展示系统</title>
    <link href="http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-03-24T14:56:35.000Z</published>
    <updated>2021-03-24T14:56:35.153Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>校园商铺1.0-商品模块</title>
    <link href="http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/"/>
    <id>http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-24T14:55:59.000Z</published>
    <updated>2021-03-24T14:55:59.660Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>校园商铺1.0-商品类别模块</title>
    <link href="http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E7%B1%BB%E5%88%AB%E6%A8%A1%E5%9D%97/"/>
    <id>http://wangjin1996219.github.io/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E7%B1%BB%E5%88%AB%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-24T14:55:35.000Z</published>
    <updated>2021-03-24T14:55:35.729Z</updated>
    
    
    
    
    
  </entry>
  
</feed>

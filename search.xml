<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>归并排序</title>
    <url>/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p><strong>归并排序：</strong>就是将含有<strong>n</strong>个记录的序列不断从<strong>中间划分</strong>成长度为<strong>2</strong>或<strong>1</strong>的序列，然后<strong>两两归并</strong>。不断归并，直到得到一个长度为<strong>n</strong>的有序序列为止，这种排序方法也称为<strong>2路归并排序</strong>。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片.png">

<p>下面模拟一遍<strong>递归</strong>方法实现的归并排序：</p>
<p>设输入的序列为：[50,10,90,30,70,40,80,60,20]</p>
<p>调用Msort函数，传入待排序数组SR，和结果数组TR1，左下标l=0，右下标r=8；</p>
<p><strong>Msort函数：</strong>利用m将数组SR分成两部分，左半部分[50,10,90,30,70]，右半部分[40,80,60,20];</p>
<p>​                       左边部分接着划分为[50,10,90]和[30,70]</p>
<p>​                       [50,10,90]继续划分为[50,10]和[90]</p>
<p>​                       [50,10]划分为[50]和[10]</p>
<p>​                        右边部分略</p>
<p><strong>Merge函数：</strong>先是单个元素的两两归并，接着对越来越长的数组归并</p>
<p>​                       左边部分[50]和[10]组成TR2=[50,10]排序后存到TR1=[10,50]</p>
<p>​                        [10,50]和[90]组成的数组TR2=[10,50,90]排序后存到TR1=[10,50,90]</p>
<p>​                        [10,50,90]和[30,70]组成的数组TR2=[10,50,90,30,70]以m=2为分隔点，[10,50,90]作为左边部分，[30,70]作为右边部分，                    从元素10和元素30开始比较小的元素存入数组TR1，直到左边或右边部分结束，再将剩下的元素存入TR1</p>
<p>​                        右边部分略</p>
<blockquote>
<p><strong>迭代方式实现（从底至顶直接合并）</strong></p>
</blockquote>
<p>归并排序的思路就是将待排序集合一分为二，直到待排序集合只剩下 1 个元素为止 。 然后不断合并2个排好序的数组段。</p>
<p><strong>迭代：</strong>通过迭代的方式我们可以省去一分为二的过程，用合并算法直接将它们排序，构成n/2组长度为2的排序序的数组段，然后再将它们排序成长度为4的排好序的子数组段。如此继续，直到整个数组排好序。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:80%;">

<ul>
<li>从归并段的长度为1开始，一次使用归并段的长度变为原来的2倍；</li>
<li>在每趟归并的过程中，要注意处理归并段的长度为奇数和最后一个归并段和之前不等的情况，需要进行处理</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>递归方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] TR1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        Msort(SR, TR1, <span class="number">0</span>, SR.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : TR1) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组SR：待排序的数组</span></span><br><span class="line"><span class="comment">    TR1：每次将SR数组中下标l,r范围内的数字排好序放入TR1中</span></span><br><span class="line"><span class="comment">    l,r分别表示SR数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Msort</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m;<span class="comment">//分隔待排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] TR2 = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];<span class="comment">//暂存待排数组左右两部分排序好的数组</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            TR1[l] = SR[r];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;<span class="comment">//将待排范围的数组从中间分开</span></span><br><span class="line">            Msort(SR, TR2, l, m);<span class="comment">//右半部分递归调用函数Msort</span></span><br><span class="line">            Msort(SR, TR2, m + <span class="number">1</span>, r);<span class="comment">//左半部分递归调用函数Msort</span></span><br><span class="line">            Merge(TR2, TR1, l, m, r);<span class="comment">//对TR2中的两部分数组归并排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 20 30 40 50 60 70 80 90 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>迭代方式实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">1000</span>, <span class="number">1100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; SR.length) &#123;</span><br><span class="line">            MergePass(SR, res, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">            MergePass(res, SR, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//从第一个元素开始合并大小为s的相邻2段子数组</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">2</span> * s - <span class="number">1</span> &lt;= n) &#123;<span class="comment">//i+2*s 要小于等于数组长度，也就是说未合并的元素个数要大于2*s</span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);</span><br><span class="line">            i = i + <span class="number">2</span> * s;</span><br><span class="line">        &#125;<span class="comment">//此循环执行的次数为： n+1/(2*s) 次</span></span><br><span class="line">        <span class="keyword">if</span> (i + s - <span class="number">1</span> &lt; n) &#123;<span class="comment">//未合并的元素个数大于 1*s </span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, n);<span class="comment">//合并最后两个序列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//未合并的元素个数小于 1*s，直接复制到y就行了</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                TR[j] = SR[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：同上</strong></p>
<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-list">148.排序链表</a></strong></p>
<p>这道题的对两个子序列归并的部分与数组是不同的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        ListNode resNode=<span class="keyword">new</span> ListNode();</span><br><span class="line">        resNode.next=head;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;length)&#123;</span><br><span class="line">            MergePass(resNode,k,length);</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergePass</span><span class="params">(ListNode resNode,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = resNode, curr = resNode.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = mergeTwoLists(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><h2 id="·-堆的概念"><a href="#·-堆的概念" class="headerlink" title="· 堆的概念"></a>· 堆的概念</h2><p><strong>堆：</strong>通常可以看成是一个完全二叉树的<strong>数组</strong>。（堆排序实际上是堆中元素的交换，因此可以用数组实现，并且数组的查询和修改效率比较高，能够提高性能）</p>
<p><strong>堆的两种形式：</strong></p>
<ul>
<li>大顶堆：根节点<strong>大于</strong>左右孩子的节点</li>
<li>小顶堆：根节点<strong>小于</strong>左右孩子的节点</li>
</ul>
<h2 id="·-构造堆"><a href="#·-构造堆" class="headerlink" title="· 构造堆"></a>· 构造堆</h2><p><strong>1、二叉树堆结构中元素与数组堆结构中元素的对应关系：</strong>（大小顶堆一样的）</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片.png" style="zoom:150%;">

<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:150%;">

<p>那么对于某一个节点index，它的左右孩子在数组中的下标分别为：</p>
<ul>
<li>Left=index*2+1</li>
<li>Right=index*2+2</li>
</ul>
<p>叶子结点和非叶子节点的区别：</p>
<ul>
<li>非叶子节点的下标&lt;节点个数/2-1</li>
<li>叶子节点的下标&gt;节点个数/2-1</li>
</ul>
<p><strong>2、大顶堆的维护（核心）</strong></p>
<p><strong>自下而上</strong>地维护一个大顶堆，使其满足大顶堆的性质：非叶子节点的左右孩子都小于它的根节点</p>
<p>维护分为初始化时大顶堆的维护和初始化后大顶堆的维护：</p>
<ul>
<li>刚开始将待排序数组中的前k个元素复制到堆结构中的数组中，并调用HeapAdjust（）方法，<strong>从非叶子节点开始，自下而上地维护</strong>；</li>
<li>而对于新插入的剩下的n-k个元素，只有当元素小于大顶堆的根节点时，才会移除根节点，并将该元素加入大顶堆。因此除了0号元素可能不满足大顶堆的性质外，它的下层的非叶子节点都满足性质，所以<strong>维护的实质是：</strong>维护index=0的情况。</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] input = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        result = HeapSort(input, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">            System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用数组来模拟k个节点的堆结构</span></span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, a, <span class="number">0</span>, k);<span class="comment">//初始化堆中的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//k就是我们要维护的堆结构的节点下标</span></span><br><span class="line">            HeapAdjust(i, a, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;<span class="comment">//遍历剩余的n-k个元素</span></span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; a[<span class="number">0</span>]) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = input[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, a, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将大顶堆中的元素进行升序操作</span></span><br><span class="line"><span class="comment">//        for (int i = a.length - 1; i &gt; 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//            //分为两个过程：1.交换 2.通过减小节点的个数来固定最大的元素</span></span><br><span class="line"><span class="comment">//            int temp = a[i];</span></span><br><span class="line"><span class="comment">//            a[i] = a[0];</span></span><br><span class="line"><span class="comment">//            a[0] = temp;</span></span><br><span class="line"><span class="comment">//            HeapAdjust(0, a, i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数功能就是维护每一个节点的大顶堆性质</span></span><br><span class="line"><span class="comment">    index 节点的下标</span></span><br><span class="line"><span class="comment">    a 堆结构</span></span><br><span class="line"><span class="comment">    length 堆结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];<span class="comment">//temp保存当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt; a[x]) &#123;<span class="comment">//取出当前节点的左右孩子的最大值</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;<span class="comment">//更新index的值，index代表的是temp的值最终在堆中的位置，index和x的关系其实就是根节点和子节点的关系</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//由于我们是从下往上维护的，当index=0的节点满足性质后，就没有更新的必要了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;<span class="comment">//index代表的是temp的值最终在堆中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码运行的结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40 30 20 10 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><p>堆排序用于解决<strong>TOPK</strong>类问题</p>
<blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p>
<p>这里还对代码进行了优化，不用建立新数组，用给定数组直接作为堆结构数组</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, nums, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, nums, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &lt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &lt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof"><strong>剑指offer-40.最小的K个数</strong></a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, arr, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, arr, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,res,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="·-通过优先队列实现堆排序"><a href="#·-通过优先队列实现堆排序" class="headerlink" title="· 通过优先队列实现堆排序"></a>· 通过优先队列实现堆排序</h1><h2 id="·-补充内容"><a href="#·-补充内容" class="headerlink" title="· 补充内容"></a>· 补充内容</h2><p><strong>1、匿名内部类：</strong>前提是存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p>
<blockquote>
<p><strong>格式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名()&#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Inter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、PriorityQueue（优先队列）</strong></p>
<p>优先级队列的元素按照自然排序进行排序，或者根据构造队列时提供的<strong>Comparator（比较器）</strong>进行排序，具体取决于所使用的构造方法。优先级队列不允许使用null元素，依靠自然排序的优先级队列还不允许插入不可比较的对象（这样容易导致ClassCastException）。</p>
<p><strong>队列的头</strong>相当于堆的<strong>根节点</strong></p>
<blockquote>
<p><strong>构造方法：</strong></p>
<p><strong>a.无Comparator参数：</strong>默认自然排序，实现小顶堆；</p>
<p><strong>b.传入Comparator：</strong>重写里面的compare方法，实现大顶堆。<strong>（常用）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据自然排序对元素排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据指定的比较器对元素排序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong>（第二个构造方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o2-o1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回0：o1等于o2，是同一元素</span></span><br><span class="line"><span class="comment">返回正数：认为o2大于o1，让o2排在更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">返回负数：认为o2小于o1，让o2排在远离队列头部的位置</span></span><br><span class="line"><span class="comment">这样就构成了大顶堆，相反当返回的是o1-o2时，比如返回正数，仍然认为o2大于o1，让小数o2排在了更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目-1"><a href="#·-相关题目-1" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></strong></p>
</blockquote>
<h2 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h2><p>借助 <strong>哈希表</strong> 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</p>
<p>通过比较器指定排序规则，即频率越高的元素越靠近队列的头部，排序过程如下图所示：</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片2.png" style="zoom: 120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; requence=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(requence.containsKey(num))&#123;</span><br><span class="line">            requence.put(num,requence.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            requence.put(num,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1,Integer num2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> requence.get(num1)-requence.get(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:requence.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//当队列中元素个数小于k时，向队列中添加元素，先将队列中元素增加到k个</span></span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(requence.get(num)&gt;requence.get(pq.peek()))&#123;<span class="comment">//当队列中头部元素大于HashMap中频率时，先将头部弹出，再向队列中添加出现频率更高的元素</span></span><br><span class="line">            pq.poll();</span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        res[i]=pq.poll();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><blockquote>
<p><strong>参考文章：</strong><a href="https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack">https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack</a></p>
<p>字节大佬的文章写得特别棒，很实用！</p>
</blockquote>
<p><strong>回溯法（backtrack）</strong>常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于<code>全排列</code>，穷尽所有可能。时间复杂度一般 O(N!)，回溯算法就是纯暴力穷举，复杂度一般都很高。</p>
<p><strong>核心思想：</strong>就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(选择列表，路径)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">       result.add(路径);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(选择 in 选择列表)&#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtrack(选择列表,路径);</span><br><span class="line">        撤销选择;<span class="comment">//递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>题型一：</strong>给定一个可包含重复元素的序列，返回所有不重复的全排列。</p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/"><strong>剑指 Offer 38. 字符串的排列</strong></a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>过滤条件中一定是没有访问过，例如：[a,b,c,c,d]这种情况，当第一个c被标记为true，调用递归函数时，再遍历到第四个c时，当去判断时，如果判断条件没有加上没有被访问过时，第四个c就会被跳过，而且是一直被跳过，会导致路径无法满足长度，没有结果输出，其实这个条件过滤的是两个c在同一选择列表的情况，当两个c一个被固定时，就不在同一选择列表内，也就不用再过滤。</p>
</blockquote>
<blockquote>
<p><strong>题型二：</strong>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p><strong><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></strong></p>
</blockquote>
<p><strong>递归过程如下图所示：</strong></p>
<img src="/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/图片.png" style="zoom:120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backTrack(nums,<span class="number">0</span>,temp,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nums 给定的集合</span></span><br><span class="line">    <span class="comment">// pos 下次添加到集合中的元素位置索引</span></span><br><span class="line">    <span class="comment">// temp 临时结果集合(每次需要复制保存)</span></span><br><span class="line">    <span class="comment">// res 最终结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos,List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把临时结果复制出来保存到最终结果</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="comment">// 选择、处理结果、再撤销选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTrack(nums,i+<span class="number">1</span>,temp,res);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p>快速排序算法的本质同冒泡排序一样，同属于交换排序类。也就是通过不断地比较和移动交换来实现排序，只不过对于快速排序来说增大了记录的比较和移动的距离，将较大的关键字记录从前面直接移动到后面，将较小的从后面直接移动到前面，减少了总的比较次数和移动交换次数。</p>
<p><strong>快排的基本思想是：</strong>选定一个分隔点，通过一趟排序将待排记录<code>按照数组中元素与分隔点的逻辑关系分割成独立的两部分</code>，然后按照同样的方式，对两侧的子数组再排序，直到实现整个序列有序的目的。</p>
<p>例如：对于如图所示的数组进行排序的过程如下</p>
<img src="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/图片.png" style="zoom: 67%;">

<h1 id="·-代码实现"><a href="#·-代码实现" class="headerlink" title="· 代码实现"></a>· 代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiuckSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        QSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[l];</span><br><span class="line">        nums[l] = temp;</span><br><span class="line">        QSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">        QSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span> </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-colors">75.颜色分类</a></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=l)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=r;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]&lt;nums[l]) i++;</span><br><span class="line">            temp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]=temp;</span><br><span class="line">        nums[i]=nums[l];</span><br><span class="line">        quickSort(nums,l,i);</span><br><span class="line">        quickSort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历</title>
    <url>/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p>从图中的某个顶点K出发，按照一定的原则（比如：总是先选择右边第一个点）先去访问它的邻接点，初始状态下K的邻接点未被访问过，按照这个原则找到它的一个未被访问过的邻接点，然后将该邻接点标记为“true”，表示该点已经被访问过。直到有一个顶点N，按照该原则下，它的邻接点已经被访问，则退回到N点，再去访问它右边第二个点，以此类推，直到所有的顶点都被访问到，遍历结束。</p>
<p>这里我们以邻接矩阵的方式来讲解DFS的算法执行流程：</p>
<p>​                              <img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/邻接矩阵.jpg" style="zoom: 80%;"></p>
<h1 id="·-代码实现"><a href="#·-代码实现" class="headerlink" title="· 代码实现"></a>· 代码实现</h1><blockquote>
<p><strong>Note：</strong>该代码不包含图的建立部分。其中，numVertexes为图中的节点数目，vexs[]数组为顶点表 ,arc[] []为边表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.numVertexes];<span class="comment">//创建visited[]数组，作为节点的访问标志</span></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="keyword">false</span>;<span class="comment">//初始化visited[]数组为false，表示初始状态下节点未被访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//从V0开始循环遍历树中的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//若节点Vi不为false，说明该节点未被访问过，调用DFS()方法。这里可以视为对边表的行遍历</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    visited[i]=<span class="keyword">true</span>;<span class="comment">//另visited数组中的第i个节点的标志位true，表示该节点已经被访问</span></span><br><span class="line">    System.out.println(G.vexs[i]);<span class="comment">//可以对该顶点进行输出等操作</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//i表示边表矩阵的第i行，当满足G.[i][j]!==1（表示节点j是i的邻接点）且                                                   //visited[j]==false未被访问，则对节点j再进行DFS递归</span></span><br><span class="line">        <span class="keyword">if</span>(G.[i][j]!==<span class="number">1</span>&amp;&amp;visited[j]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当图是<strong>连通图</strong>时，DFSTraverse（）方法中的循环执行一次就可以；</p>
<p>当图是<strong>非连通图</strong>时，需要对它的连通分量分别进行DFS遍历，当图中尚有顶点还有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直到图中所有的节点都被访问到为止。</p>
]]></content>
      <categories>
        <category>数据结构及算法</category>
      </categories>
      <tags>
        <tag>大话数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Dao层、Service层和Controller层的初步理解</title>
    <url>/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="DAO层（Data-Access-Object）"><a href="#DAO层（Data-Access-Object）" class="headerlink" title="DAO层（Data Access Object）"></a>DAO层（Data Access Object）</h1><p><strong>Dao层：</strong>全称为数据访问层，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说某个Dao层一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作，建议Dao只做原子操作，也就是增删改查操作。</p>
<p><strong>如图，先创建一个获取店铺区域列表的接口：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片1.png" style="zoom:80%;">

<p><strong>然后通过MyBatis框架实现这个接口：</strong></p>
<p><strong>NOTE:</strong></p>
<ul>
<li>namespace 是接口的完全限定名</li>
<li>id是接口中的方法名</li>
<li>resultType是方法的返回值类型</li>
</ul>
<p>后面是SQL语句</p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片2.png" style="zoom:80%;">

<h1 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h1><p><strong>Service层：</strong>又称为服务层，被称为服务，如果粗略一点理解的话就是对一个或多个Dao进行的再次封装，封装成一个服务，所以这里不再是一个原子操作了，需要对事务控制。</p>
<p><strong>如图，先创建一个店铺区域服务的接口：</strong></p>
<p>在这个接口中可以定义很多方法，比如：增加区域、修改区域等。这里暂时只有一个获取区域列表的方法，因为Dao层中的AreaDao中只有一个获取区域列表的方法</p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片3.png" style="zoom:80%;">

<p><strong>然后，再创建实体类来实现这个接口：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片4.png" style="zoom:80%;">

<p>在这个实体类中实现了AreaService接口，通过areaDao对象调用它的queryArea方法，返回了区域列表。</p>
<p><strong>Spring对于Service层的配置：</strong></p>
<p><img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片5.png" style="zoom:80%;"><img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/2021-03-04-Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3%5C%E5%9B%BE%E7%89%875.png"></p>
<h1 id="Controler层"><a href="#Controler层" class="headerlink" title="Controler层"></a>Controler层</h1><p><strong>Controller层：</strong>负责请求转发，接受web页面传来的参数，交给相应的Service处理，接到Service返回的值，再传送给web页面。</p>
<p><strong>比如输入：<a href="http://localhost:8080/o2o/shopadmin/shopoperation">http://localhost:8080/o2o/shopadmin/shopoperation</a></strong></p>
<p>它就会访问shopoperation.html文件，并将其内容展示到浏览器中。</p>
<p>根据shopoperation.js文件的逻辑执行其中的方法，根据不同的路由（Url）调用后端Controller层的方法，Controller层再根据前端传入的信息调用不同的服务，然后把Service的返回值再返回到前端。</p>
<p><strong>部分JS代码如图所示：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片6.png" style="zoom:110%;">

<p><strong>部分Controller代码如图所示：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片7.png" style="zoom:80%;">

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>Dao层面向数据库中的表：在进行后端开发时，先要在数据库中创建出所用到的表，然后对应表去设计Dao层</p>
<p>Service层面向服务：在数据库中有了所需要的表之后，根据具体的需求或者业务逻辑，将Dao层封装成Service层，对外提供服务使用</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>MVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>win10系统激活方法</title>
    <url>/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示："><a href="#1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示：" class="headerlink" title="1、按下win+X，选择Windows PowerShell (管理员)，如下图所示："></a>1、按下win+X，选择Windows PowerShell (管理员)，如下图所示：</h1><img src="/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/图片1.png" style="zoom:90%;">

<h1 id="2、在命令提示符中依次输入："><a href="#2、在命令提示符中依次输入：" class="headerlink" title="2、在命令提示符中依次输入："></a>2、在命令提示符中依次输入：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slmgr &#x2F;ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr &#x2F;skms kms.03k.org</span><br><span class="line">slmgr &#x2F;ato</span><br></pre></td></tr></table></figure>

<h1 id="3、依次会弹出："><a href="#3、依次会弹出：" class="headerlink" title="3、依次会弹出："></a>3、依次会弹出：</h1><p>“成功地安装了产品密钥……”</p>
<p>“密钥管理服务计算机名成功的设置为 zh.us.to”</p>
<p>“正在激活……，成功地激活了产品”</p>
]]></content>
      <categories>
        <category>电脑使用中的问题</category>
      </categories>
      <tags>
        <tag>系统问题</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用</title>
    <url>/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、设置断点-amp-断点处运行快捷键"><a href="#1、设置断点-amp-断点处运行快捷键" class="headerlink" title="1、设置断点&amp;断点处运行快捷键"></a>1、设置断点&amp;断点处运行快捷键</h1><p><strong>设置断点</strong></p>
<p>在该行最前面边框双击或快捷键：Ctrl+Shift+B </p>
<p><strong>以Debug 方式运行Java程序</strong></p>
<p> Debug 运行启动 （在进行前后端联调时，Tomcat要在debug模式下运行）</p>
<p><strong>调试快捷键</strong></p>
<p> 运行到断点后： </p>
<p> F5：Step into/进入该行的函数内部 ；</p>
<p> F6：Step over/一行一行执行 ，它是不进入每一行的函数内部的；</p>
<p> F7：Step return/退出当前的函数；</p>
<p> F8：直接执行程序直到遇到下一个断点时暂停。</p>
<p>如果快捷键不能使用，可以通过窗口中的按钮运行程序，如图：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/设置断点及调试.png" style="zoom:90%;">

<h1 id="2、修改包的显示结构和显示方法"><a href="#2、修改包的显示结构和显示方法" class="headerlink" title="2、修改包的显示结构和显示方法"></a>2、修改包的显示结构和显示方法</h1><h2 id="Eclipse-中包结构展开有两种方式："><a href="#Eclipse-中包结构展开有两种方式：" class="headerlink" title="Eclipse 中包结构展开有两种方式："></a>Eclipse 中包结构展开有两种方式：</h2><p><strong>一：平坦方式（flat）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/平坦方式.png" style="zoom:110%;">

<p><strong>二、分层方式（hierarchical）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/分层方式.png" style="zoom:90%;">



<h2 id="快速展开包"><a href="#快速展开包" class="headerlink" title="快速展开包"></a>快速展开包</h2><p><strong>在右边选中类时，快速的将类对应的包结构展开（Link with editor）</strong></p>
<p>设置只需点击包机构面板中的双箭头即可。</p>
<p>双箭头按下，表示包自动展开，不按下，表示包不自动展开。</p>
<p>如图红色框内按钮：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/在右边选中类时，快速的将类对应的包结构展开.png" style="zoom:80%;">]]></content>
      <categories>
        <category>校园o2o项目1.0</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器调试快捷键</title>
    <url>/2021/02/28/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h1><blockquote>
<p><strong>转自：<a href="https://www.cnblogs.com/lishanyang/p/7767135.html">https://www.cnblogs.com/lishanyang/p/7767135.html</a></strong></p>
</blockquote>
<p>快捷键有这么以下几大类.且看我一一道来<del>~</del>注:All pane是全局快捷键</p>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console()"></a>Console()</h2><ul>
<li>Ctrl + L : 清除控制台消息</li>
<li>Tab : 自动完成通用常缀</li>
<li>→: 接受建议</li>
<li>Ctrl +  U: 清除console的提示!!(实操查看源代码!!)</li>
<li>↓ / ↑ :选中下一行/上一行</li>
<li>Enter: 执行代码或者命令</li>
</ul>
<h2 id="Debugger-调试面板"><a href="#Debugger-调试面板" class="headerlink" title="Debugger(调试面板)"></a>Debugger(调试面板)</h2><ul>
<li>F8 or Ctrl + : 暂停/继续</li>
<li>F10 or  Ctrl + ‘: 单步执行</li>
<li>F11 or Ctrl +;: 单步进入</li>
<li>Shift + F11 or Ctrl + Shift+;: 单步退出</li>
<li>Ctrl +./Ctrl+, : 上一帧/下一帧(译为框架怪怪的)</li>
<li>Ctrl +Shift+E: 被选中代码在控制台中打印出console信息**(非常实用)**</li>
<li>Ctrl + Shift + A: 添加到debugger的watch里面,可以关注你选中内容的变化</li>
<li>Ctrl + B: 打断点/取消断点**(很实用)**</li>
</ul>
<p>Chrome调试面板上的对应按钮如图所示：</p>
<img src="/2021/02/28/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/调试面板.png" style="zoom:80%;">

<h2 id="Text-Editor-文本编辑器"><a href="#Text-Editor-文本编辑器" class="headerlink" title="Text Editor(文本编辑器)"></a>Text Editor(文本编辑器)</h2><ul>
<li>Ctrl + Shift+P : 跳转到某个成员(不知鸟用)</li>
<li>Ctrl + Space: 自动完成</li>
<li>Ctrl + G : 跳转到某行</li>
<li>Ctrl + Shift + E</li>
<li>Alt + -: 跳转到之前的编辑位置</li>
<li>Alt + +: 跳转到下一个编辑的位置</li>
<li>Ctrl + /: 快捷键注释</li>
<li>Alt + ↑: 调整CSS度量单位,每次<strong>增加</strong>一个单元</li>
<li>Alt + ↓: 调整CSS度量单位,每次<strong>减少</strong>一个单元</li>
<li>Alt + PageUp: 调整CSS度量单位,每次<strong>增加</strong>10个单元</li>
<li>Alt + PageDown: 调整CSS度量单位,每次<strong>减少</strong>10个单元</li>
<li>Ctrl + D: 选择选中内容的下一个匹配内容</li>
<li>Ctrl + U: 软撤销</li>
<li>Ctrl + M: 进入匹配的括号</li>
<li>Alt + W: 关闭编辑便签</li>
<li>Alt + O: 切换相同名字的或者不同后缀的文件</li>
</ul>
<h2 id="All-Panels-所有面板"><a href="#All-Panels-所有面板" class="headerlink" title="All Panels(所有面板)"></a>All Panels(所有面板)</h2><ul>
<li>Ctrl + [ / Ctrl + ]:切换面板(向左向右)</li>
<li>Ctrl + Shift + [ / Ctrl + Shift+] : 返回之前之后的面板状态</li>
<li>Ctrl + Tilde[~]:显示Console</li>
<li>Esc: 小菜单弹出隐藏</li>
<li>Ctrl + Shift + M: 进入仿真设备模式(移动平板屏幕)</li>
<li>Ctrl + Shift + D: 切换调试面板在底部还是侧边栏展示</li>
<li>Ctrl + F: 搜索内容</li>
<li>Ctrl + Shift + F: 在所有代码中搜索(跨域),<strong>很实用</strong></li>
<li>Ctrl + Shift + C: 选择页面节点并且查看代码,<strong>最常用!!</strong></li>
<li>Ctrl + P: 快速切换源码文件,<strong>很常用!</strong></li>
</ul>
<h2 id="Style-Pane-风格面板"><a href="#Style-Pane-风格面板" class="headerlink" title="Style Pane(风格面板)"></a>Style Pane(风格面板)</h2><ul>
<li>Tab / Shift + Tab: 下一个/上一个属性</li>
<li>↑: 增加CSS度量单位-&gt;1单元</li>
<li>↓:减少CSS度量单位-&gt;1单元</li>
<li>PageUporShift + ↑:增加CSS度量单位-&gt;10单元</li>
<li>PageDownorShift + ↓:减少CSS度量单位-&gt;10单元</li>
<li>Shift + PageUp:增加CSS度量单位-&gt;100单元</li>
<li>Shift + PageDown:减少CSS度量单位-&gt;100单元</li>
<li>Alt + ↑:增加CSS度量单位-&gt;0.1单元</li>
<li>Alt + ↓:减少CSS度量单位-&gt;0.1单元</li>
</ul>
<h2 id="Timeline-Panel-时间轴面板"><a href="#Timeline-Panel-时间轴面板" class="headerlink" title="Timeline Panel(时间轴面板)"></a>Timeline Panel(时间轴面板)</h2><ul>
<li>Ctrl + E:开始</li>
<li>Ctrl + S:保存时间轴数据</li>
<li>Ctrl + O:加载时间轴数据</li>
</ul>
]]></content>
      <categories>
        <category>校园o2o项目1.0</category>
      </categories>
      <tags>
        <tag>前端调试</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>根据根节点的访问顺序可以将二叉树的遍历分为：</p>
<p><strong>前序遍历：</strong>根节点→左子树→右子树</p>
<p><strong>中序遍历：</strong>左子树→根节点→右子树</p>
<p><strong>后序遍历：</strong>左子树→右子树→根节点</p>
<p>注意：左子树一般都是先于右子树的</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-常见的位运算操作"><a href="#·-常见的位运算操作" class="headerlink" title="· 常见的位运算操作"></a>· 常见的位运算操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a=a^0</p>
<p>0=a^a</p>
<p>由上面两个推导出：a=a^b^b（与同一个数异或运算两次还是这个数本身）</p>
<h2 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h2><p>a=a^b</p>
<p>b=a^b</p>
<p>a=a^b</p>
<h2 id="移除最后一个1"><a href="#移除最后一个1" class="headerlink" title="移除最后一个1"></a>移除最后一个1</h2><p>a=n&amp;(n-1)</p>
<h2 id="获取最后一个1"><a href="#获取最后一个1" class="headerlink" title="获取最后一个1"></a>获取最后一个1</h2><p>diff=(n&amp;(n-1))^n</p>
<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/hamming-distance/">热题100-461. 汉明距离</a></strong></p>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和y，计算它们之间的汉明距离。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>异或操作当两个操作数的二进制位置不同时为1，对两个数进行异或操作就得到了两个数二进制不同位置的数目，再对结果统计1的个数就得到了两个数的汉明距离。</p>
<p>在统计结果中1的个数时，用到了<strong>移除最后一个1</strong>的操作，不断移除最后一个1，移除几次结果中就有多少个1。</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片.png" style="zoom:110%;">

<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=x^y;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(res!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        res=res&amp;(res-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></strong></p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</blockquote>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=(n-<span class="number">1</span>)&amp;n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></strong></p>
<p>一个整型数组 nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以把所有数字分成两组，使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<p>记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式 xkxk−1⋯x2x1x0，其中 xi∈{0,1}，我们考虑一下 xi=0和 xi=1的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，ai和 bi的关系——xi=1 表示 ai 和 bi 不等，xi=0 表示 ai 和 bi 相等。假如我们任选一个不为 0 的 xi，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件。</p>
<p>在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足 xi=1。但是为了方便，这里的代码选取的是「不为 0 的最低位」</p>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        ret^=i;<span class="comment">//对数组中的所有数做异或运算，则得到的结果等价于对两个只出现一次的数字做异或运算，因为两个数字不同，因此做异或运算中一定是有一位为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((k&amp;ret)==<span class="number">0</span>)&#123;</span><br><span class="line">        k&lt;&lt;=<span class="number">1</span>;<span class="comment">//得到最终结果中最低位的1的位置，并依据k分组，当一个数该位是1，做与运算时不等于0，当不是1，做与运算时等于0，因为与运算需要都是1才是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j&amp;k)==<span class="number">0</span>)&#123;<span class="comment">//将所有数字按第n位是否为1分成两组，那么相同的数字肯定分到一组，并且两个不同的数字因为第n位不同而被分到两个组里，对两个组中的数字分别进行异或运算，相同的数字做异或运算相互抵消为0，所以最后得到的a和b就是两个只出现一次的数字</span></span><br><span class="line">            a^=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b^=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[]  result=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"><strong>剑指 Offer 56 - II. 数组中数字出现的次数 II</strong></a></p>
<p>在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路 1"></a>解题思路 1</h3><p>如果一个数字出现了三次，那么它的二进制数中每一位也是出现了三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。</p>
<p>于是创建一个长度为32的数组来保存所有数字的二进制表示的每一位的和，如果某一位的和能被3整除，那么只出现一次的数字的二进制表示中对应的位为0，否则就是1。</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解 1"></a>代码及注解 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution56_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//本算法同样适用于数组nums中存在负数的情况（因为使用的是左移，不用考虑符号问题）</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];<span class="comment">//java int类型有32位，其中首位为符号位</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitMask=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//这个循环是为了统计增强for循环得到的每一个数字num中每一位上是否为1，所以bitMask需要每得到一个num就初始化一次；而且数组中的存储顺序是：索引小→大对应高位→低位</span></span><br><span class="line">                <span class="keyword">if</span>((num&amp;bitMask)!=<span class="number">0</span>) bitSum[i]++;<span class="comment">//这里判断条件不是==1（通过与运算得到的不一定是1，通过idea验证）</span></span><br><span class="line">                bitMask=bitMask&lt;&lt;<span class="number">1</span>;<span class="comment">//左移没有无符号、带符号的区别，都是在右侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从数组索引由小到大遍历得到每位上3的余数，通过res左移让高位向左，这里也避免了res右移可能引发的符号问题</span></span><br><span class="line">            res=res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            res+=bitSum[i]%<span class="number">3</span>;<span class="comment">//这两步顺序不能变，否则最后一步会多左移一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2（状态机）"><a href="#解题思路-2（状态机）" class="headerlink" title="解题思路 2（状态机）"></a>解题思路 2（状态机）</h3><p>解题思路：各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位1的个数，存在 3 种状态，即对 3 余数为 0,1,2。（不是0,1两种状态，当没加完有可能出现5,8等余数为2的情况），因此可以用两位二进制数表示这三种状态：00→01→10。</p>
<p>通过状态机可以得到对于三种状态输入的n为0或1时对应的真值表：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">one</th>
<th align="center">新one</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>通过真值表可以得到one的逻辑表达式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片1.png" style="zoom:80%;">

<p>逻辑表达式的化简公式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片2.png" style="zoom: 67%;">

<p>同理也能得到two的逻辑表达式，注意two是要通过新的one值获得，构造真值表时要用新的one值：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">新one</th>
<th align="center">新two</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解 2"></a>代码及注解 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;<span class="comment">//位运算，每次通过增强for循环得到的num，按位与ones和twos的每一位做运算，得到ones中每一位的值</span></span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;<span class="comment">// 遍历完所有数字后，各二进制位都处于状态 00 和状态 01（取决于 “只出现一次的数字” 的各二进制位是 1 还是 0 ），而此两状态是由 one来记录的（此两状态下 twos 恒为 0 ），因此返回 ones 即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/counting-bits/">热题100-338. 比特位计数</a></strong></p>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有一个整数：<br>$$<br>x=(1001011101)<em>2 = (605)</em>{10}<br>$$<br>我们已经计算了从 0 到 x−1 的全部结果。</p>
<p>我们知道，x 与 我们计算过的一个数只有一位之差:<br>$$<br>x=(0001011101)<em>2 = (93)</em>{10}<br>$$<br>它们<strong>只在最高有效位上不同</strong>，也就是我们可以通过在已经求得1的位数的一个数上+1来求得x。</p>
<p>得到状态转移函数：<br>$$<br>P(x+b)=P(x)+1,b=2^m&gt;x<br>$$<br>因为b每次肯定是大于x的</p>
<p>2的0次方为0001</p>
<p>2的1次方为0010</p>
<p>2的2次方为0100</p>
<p>2的3次方为1000</p>
<p>也就是每次在0到x这个范围内的数的最高位依次+1得到x到x+b这个范围内的数，而且1的位数只差刚加上的这个1，这样通过状态转移函数就能够得到x到x+b这个范围内的数的1的位数。</p>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [0, b) 已经求得，并存在结果数组res中</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt;= num) &#123;</span><br><span class="line">            <span class="comment">// 由 [0, b)得到 [b, 2b) 或者 [b, num) </span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; b &amp;&amp; i + b &lt;= num)&#123;</span><br><span class="line">                ans[i + b] = ans[i] + <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span>;   <span class="comment">// 将i复位</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>; <span class="comment">// b = 2b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>任何数和自身做异或运算等于0</li>
<li>任何数和0做异或运算等于该数本身</li>
<li>任何数的异或运算满足交换律</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        res=res^i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/majority-element/"><strong>热题100-169. 多数元素(同剑指 Offer 39)</strong></a></p>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>摩尔投票法：</strong>核心就是对拼消耗。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<p><strong>算法流程：</strong></p>
<p><strong>res作为假定众数</strong>，另一个是<strong>投票数voteNum</strong>，首先假设第一个数就是众数，另res=nums[0],然后向后遍历数组，每当相同时voteNum++，不相同时voteNum–；然后每当voteNum为0时，选择下一个数作为众数x，再去循环执行以上操作。因为此处的众数在数组中出现的次数超过了一半，所以最终voteNum的值一定大于0，并且最后一次把次数设为1时对应的数字就是要找的数字。</p>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> voteNum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(voteNum==<span class="number">0</span>)&#123;</span><br><span class="line">            res=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==res)&#123;</span><br><span class="line">            voteNum++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]!=res)&#123;</span><br><span class="line">            voteNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-56/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p>题目来自于LeetCode：<a href="https://leetcode-cn.com/problems/merge-intervals">https://leetcode-cn.com/problems/merge-intervals</a></p>
</blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>两个区间的关系有三种：区间有交集、区间重叠、区间无交集。如图所示：</p>
<img src="/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-56/图片.png" style="zoom: 50%;">

<p>我们可以先对区间的左端点进行排序，如果区间可以合并的话那么排序之后它们应该是连续的，先将第一个区间加入到结果数组res，按排序后的顺序考虑后面的区间。</p>
<p><strong>可以跟前一个区间合并的条件为：</strong></p>
<p>区间符合图中1、2情况，<strong>即前一个区间的右端点大于等于该区间的左端点</strong>，此时我们要更新结果数组中区间的右端点值为该区间和结果数组中区间右端点的较大值，然后接着顺序比较后面的区间。</p>
<p><strong>不能合并的条件为：</strong></p>
<p>如果<strong>当前区间的左端点在结果数组中最后一个区间的右端点之后</strong>，那么它们不会重合，我们可以直接将这个区间加入结果数组的末尾。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] interval1, <span class="keyword">int</span>[] interval2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历区间</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">            <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反之将当前区间合并至结果数组的最后区间</span></span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-21/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p>
</blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的实质就是<strong>归并排序中的归并两个子序列</strong></p>
<p>首先，我们设定一个哨兵节点 res ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 head指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p>
<img src="/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-21/图片.png" style="zoom:150%;">

<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;<span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-148/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a></p>
</blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p><strong>进阶：</strong>请在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题使用的排序算法为归并排序算法，由于递归实现归并排序的空间复杂度较高，所以我选择非递归方式来实现归并排序算法，避免了递归调用函数使用的栈空间，提高了效率。</p>
<p>详细思路请看主页的归并排序算法。</p>
<p><strong>具体做法如下：</strong>（来自LeetCode官方题解：<a href="https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/%EF%BC%89">https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/）</a></p>
<ul>
<li><p>用 k 表示每次需要排序的子链表的长度，初始时 k=1。（也就是<strong>归并排序中的步长</strong>）</p>
</li>
<li><p>每次将链表拆分成若干个长度为 k 的子链表（最后一个子链表的长度可以小于 k），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 k×2的有序子链表（最后一个子链表的长度可以小于 k×2）。合并两个子链表仍然使用「21. 合并两个有序链表」的做法。</p>
</li>
<li><p>将 k 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于链表长度，整个链表排序完毕。</p>
</li>
</ul>
<p>如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。</p>
<p>初始时 k=1，每个长度为 1的子链表都是有序的。</p>
<p>如果每个长度为 k 的子链表已经有序，合并两个长度为 subLength\textit{subLength}subLength 的有序子链表，得到长度为 k×2 的子链表，一定也是有序的。</p>
<p>当最后一个子链表的长度小于 k 时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。</p>
<p>因此可以保证最后得到的链表是有序的。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>着重看MergePass方法中的内容</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        ListNode resNode=<span class="keyword">new</span> ListNode();</span><br><span class="line">        resNode.next=head;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;length)&#123;</span><br><span class="line">            MergePass(resNode,k,length);</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergePass</span><span class="params">(ListNode resNode,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = resNode, curr = resNode.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = mergeTwoLists(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解码</title>
    <url>/2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-394/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/decode-string">https://leetcode-cn.com/problems/decode-string</a></p>
</blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>这道题我看到总结的比较好的一句话：数字放在数字栈，字符串放在字符串栈，右括号弹出一个数字栈中的数字，字符串栈弹到0为止。</p>
</blockquote>
<p>在遍历一个编码字符串时我们遇到的字符有以下几种情况：（数字栈：nums         字符串栈：ss）</p>
<p>数字——括号内字符串的重复次数</p>
<p>普通字母——拼接到res中</p>
<p>左括号’[‘——当我们遇到左括号时：</p>
<ul>
<li>先将存储数字的变量num加入数字栈nums中</li>
<li>说明括号内的字符串要重复num次，然后与括号外面的字符串拼接，因此我们先将左括号左边的res转换成字符串压入字符串栈ss中</li>
<li>另res和数字num重新计数（因为括号中还可能套括号，比如a3[a2[c]]，就是先将最外层的res=a存到字符串栈ss中，数字num=3存到数字栈nums中，将res和num置零后，再将第一层括号的res=a存到字符串栈ss中，数字num=2存到数字栈nums中）</li>
</ul>
<p>右括号’]’——当我们遇到右括号时：（说明最内层字符串记录结束，存于res中）</p>
<ul>
<li>从数字栈nums中弹出栈顶的数字，这个数就是这一层括号前面记录重复次数的数字，将res中的字符串重复curnum次，存到StringBuilder类型的temp中</li>
<li>再弹出一个ss栈顶的字符串，这个字符串就是括号之前的字符串，将它与temp拼接起来，再用res保存，用于遇到下一个右括号时，这个res就是该括号内要重复的字符串（比如a3[a2[c]]，当遇到第一个右括号时，将数字栈中的2弹出，将res=c循环拼接3次，也就是拼成temp=cc，再将字符串栈ss中的a弹出，与temp拼接成res=acc，之后遇到第二个右括号，temp=accaccacc，再与a拼接成res=aaccaccacc）</li>
</ul>
<p>最后编码字符串遍历结束，返回res</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      LinkedList&lt;Integer&gt; nums=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      LinkedList&lt;String&gt; ss=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">          <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">              num=num*<span class="number">10</span>+Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">             nums.add(num);</span><br><span class="line">             ss.add(res.toString());</span><br><span class="line">             res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">             num=<span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">             StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">             <span class="keyword">int</span> curNum = nums.removeLast();</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curNum; i++) &#123;</span><br><span class="line">                 temp.append(res);</span><br><span class="line">             &#125;</span><br><span class="line">             res = <span class="keyword">new</span> StringBuilder(ss.removeLast() + temp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              res.append(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-739/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a></p>
</blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<blockquote>
<p><strong>提示：</strong>气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</blockquote>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>这个题我们需要借助<strong>递减栈</strong></p>
<p>当给定数组为： [73, 74, 75, 71, 69, 72, 76, 73]时，我们来模拟函数的运行过程</p>
<p>遍历数组（入栈操作时我们加入栈的是<strong>元素的下标</strong>，这样我们后面能够根据弹出的元素下标填入等待的天数）</p>
<p>元素73对应的下标压入栈中，</p>
<p>元素74，这时栈不为空，要用74跟栈顶的元素来比较，当它大于栈顶的元素时，要将栈顶的元素弹出，并且将此时的元素下标x减去弹出元素的index就是该位置的温度再等几天能够观测到更高温，这里弹出73，将2-1=1加入res数组中下标0的位置，</p>
<p>元素75，同元素74，</p>
<p>元素71，小于栈顶元素75，直接压入栈中，</p>
<p>元素69，同元素71，</p>
<p>元素72，大于69，弹出69，并将5-4=1填入res数组下标4对应的位置，大于71，将71弹出，将5-3=2填入res数组下标3对应位置，小于75，循环结束，将72压入栈中，</p>
<p>然后以此类推……</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">           <span class="keyword">int</span> index=stack.pop();</span><br><span class="line">           res[index]=i-index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2021/02/04/%E5%89%91%E6%8C%87offer-16/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p>
</blockquote>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>本题的重点在于理解<strong>“快速幂法”</strong>为什么能把时间复杂度降低到<strong>log2n</strong></p>
</blockquote>
<p>求 x^n最简单的方法是通过循环将 n 个 x 乘起来，依次求x^1, x^2, …, x^{n-1}，直到求出x^n时间复杂度为 O(n) 。例如我们输入的幂次exponent为32，我们要求base的32次方就要在程序中对base乘31次。但是如果我们通过base的2次方求base的4次方接着求base的8次方，16次方，32次方，这样就能将循环次数降为对数级。我们可以通过以下公式来求得a的n次方：</p>
<p>我们设循环中的变量为i，初始值为n</p>
<p><strong>当i=n时：</strong><br>$$<br>{a^i} =<br>        \begin{cases}<br>        {a^{i/2}}·{a^{i/2}}    &amp; \text{如果 $i$ 为偶数}\<br>        {a^{i/2}}·{a^{i/2}}·a  &amp; \text{如果 $i$ 为奇数}<br>        \end{cases}<br>$$<br><strong>当i=n/2时：</strong>仍然按照上面的公式判断i的奇偶，求得a的i次方……</p>
<p>通过一个for循环，每次将幂次除以2，最终可以以O(log2n)的时间复杂度求得a的n次方，因为2^x=n,x=log2n,也就是循环x=log2n次。</p>
<blockquote>
<p>理解了快速幂法之后，下面是解题的流程：</p>
</blockquote>
<ul>
<li>当底数为0时没有意义，直接返回</li>
<li>当指数为负数时，将底数变为1/x，负数变为正数（转换成了常规的指数为正数的情况）</li>
<li>当指数为正数时，按照上面的公式求解</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b=n;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b=-b;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码中有两处注意点：</strong></p>
</blockquote>
<ol>
<li>用long类型的b去暂存n的值，因为int类型的负数范围比正数大1，这样做为了防止另n=-n时溢出</li>
<li>用指数的二进制形式来判断奇偶，并用移位来代替幂次每循环一次除以2，能够提高运算效率</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换成整数</title>
    <url>/2021/02/04/%E5%89%91%E6%8C%87offer-67/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p>
</blockquote>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<blockquote>
<p><strong>注意：</strong>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>当我们遍历给定的字符串时，当前的字符串有下面几种可能：</p>
<ul>
<li><p><strong>空格</strong>——跳过</p>
</li>
<li><p><strong>其它字符</strong>——循环遍历结束</p>
</li>
<li><p><strong>正负号</strong>——存储到flag变量中，后面再拼接到结果中</p>
</li>
<li><p><strong>数字字符：</strong></p>
<p>对数字字符要进行转换和拼接工作</p>
<p><strong>转换：</strong>将数字字符减去字符’0’，得到数字的值</p>
<p><strong>拼接：</strong>前一位得到的数字应该在高位，所以拼接公式为*<em>res=res</em>10+c**</p>
</li>
</ul>
<p>在对数字进行拼接工作时，要<strong>预判</strong>得到的结果是不是发生了越界，之所以要进行预判是因为得到的结果可能很大，不能确定用什么样类型的变量来接收这个结果。Java中int类型的数值范围为 [−231,  231 − 1]，也就是<strong>2147483647</strong>，要在进行本轮的拼接时，判断结果是否会发生越界，也就是上一轮的结果要小于<strong>214748364</strong>或者等于<strong>214748364</strong>且本轮的数值<strong>c</strong>小于等于7，这样按照公式*<em>res=res</em>10+c**拼接时才不会发生越界，当出现越界时直接返回题目要求的结果。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bndry = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;<span class="comment">//定位第一个非空格字符</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span>(str.charAt(first)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//去除多余的空格</span></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span>(first==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>) flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>||str.charAt(first)==<span class="string">&#x27;+&#x27;</span>) first++;<span class="comment">//如果第一个非空格字符为正负号时，保存到flag，且first++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;str.length();i++)&#123;<span class="comment">//拼接数字字符</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">&#x27;0&#x27;</span>||str.charAt(i)&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//遇到非数字字符，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;bndry||(res==bndry&amp;&amp;str.charAt(i)&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;<span class="comment">//预判结果是否越界</span></span><br><span class="line">            <span class="keyword">return</span> flag==<span class="number">1</span>? Integer.MAX_VALUE : Integer.MIN_VALUE;&#125;</span><br><span class="line">        res=res*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不越界的情况下，拼接数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-94/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>
</blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p><strong>中序遍历：</strong>先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</p>
<p><strong>核心就是：</strong>根节点必须在左节点弹出之后，再弹出</p>
<p><strong>方法一：</strong>递归遍历</p>
<p><strong>方法二：</strong>辅助栈法（非递归遍历）</p>
<p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后<strong>先遍历左子树</strong>，接着访问 A（A出栈），最后遍历右子树。这样保证根节点在左子树后面被访问，右子树在根节点后面被访问。</p>
<p>在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>方法一：</strong>递归遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法二：</strong>辅助栈法（非递归遍历）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;<span class="comment">//1.root!=null 2.root==null但辅助栈中有元素，对应左子树访问完</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;<span class="comment">//每到一个节点，先去遍历左子树，只要它的左子树存在，就将该节点压入栈，直到有一个节点的左                                   //子树不存在为止，也就是它就是最左边的节点</span></span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();<span class="comment">//1.root!=null表示到了最左边的节点，弹出栈访问</span></span><br><span class="line">                             <span class="comment">//2.root==null但辅助栈中有元素，对应左子树访问完,也就是上一轮的root.right==null，此时的栈                              //顶元素就对应的该左子树的根节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;<span class="comment">//访问该节点的右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-20/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>
</blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>分析题目可知，指针的指向实际上有两种情况：</p>
<ul>
<li>指向的字符为左括号</li>
<li>指向的字符为右括号</li>
</ul>
<p>要将所有的括号配对，也就是我们遇到左括号时，并不知道有没有右括号与之对应，因此先将左括号存储到一个栈中，并且遇到右括号时要将容器中对应的左括号出栈，最后栈中没有元素时，说明配对成功，返回true。</p>
<p><strong>改进：</strong>可以遇到左括号时将相应的右括号入栈，这样可以在遇到右括号时，只需要判断是否相等即可</p>
<p>在程序中，只要遇到不满足条件的情况，提前结束循环，返回false。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="comment">//该情况对应于栈为空，但是来了一个右括号的情况，或者不相等的情况，                                                     //直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a></p>
</blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java中的栈推荐用Deque双端队列来实现，效率比Stack 要高，其相关函数有：</p>
</blockquote>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E6%96%B9%E6%B3%95.png"></p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的难点在于将min函数从O（n）降为O（1），要得到栈A中的最小值首先想到的是用一个成员变量min来保存这个最小值，但是当栈中的该值弹出时，就没有办法得到次小值，因此仅用一个成员变量是不够的。</p>
<p>所以想到使用辅助栈B，将最小元素（置于栈顶）和次小元素都存储起来，使其非严格降序，每次栈A中弹出元素都要跟B栈中的栈顶元素值比较，若相等则使用pop（）函数弹出，否则不执行弹出。查看最小元素时使用peek（）函数。<a href="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png">如图所示：</a></p>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E5%9B%BE%E7%89%87.png"></p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A;</span><br><span class="line">    Deque&lt;Integer&gt; B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    B=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty() || B.peek() &gt;= x)<span class="comment">//B.empty（）对应最开始或者后面B栈中没有元素时，新压入的元素就是最小值要压入B中，当B中有元素时，新压入A栈的元素要与B中的元素比较，如果小于等于就压入B，这里等于号=很重要，因为当A栈中两个2相连压入时，就要在B中也有两个2对应，否则A中一个2弹出，也会将B中2弹出，这样会造成查询到的最小值不等于2。</span></span><br><span class="line">            B.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))&#123;<span class="comment">//判断A中弹出的值与B中栈顶的值（最小值）是否相等，若相等也将B中栈顶元素弹出。</span></span><br><span class="line">                                     <span class="comment">//因为栈中存储的是int的包装类Integer，因此只能用equals()方法，不能用“==”</span></span><br><span class="line">        B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>假期的阶段性总结</title>
    <url>/2021/01/31/%E5%81%87%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>研二的假期比往常来的稍早那么一些，回家的第二十一天，这段时间的学习效率是大打折扣，算是刚刚连抄带蒙地“刷完了”《剑指offer》里面的困难题暂时不准备刷，一部分因为懒，一部分因为菜。我属于是那种将就起来就会放飞自我的人哈哈，还是要梳理一下自己的进度，正视问题刺激一下自己才行。</p>
<h1 id="·-刷题方面"><a href="#·-刷题方面" class="headerlink" title="· 刷题方面"></a>· 刷题方面</h1><p>《剑指offer》刷完，共69道题，后面刷的一部分题勉强写了点题解：</p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-29/#more">顺时针打印矩阵</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-49/#more">丑数</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-38/#more">字符串的排列</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-66/#more">构建乘积数组</a></p>
<p><a href="https://eudemonia.tech/2021/01/27/%E5%89%91%E6%8C%87offer-45/#more">把数组排成最小的数</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-13/#more">机器人的运动范围</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-04/#more">二维数组中的查找</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">扑克牌中的顺子</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">矩阵中的路径</a></p>
<p><a href="https://eudemonia.tech/2021/01/19/%E5%89%91%E6%8C%87offer-34/#more">二叉树中和为某一值的路径</a></p>
<p>前面的题解以word文档的形式保存了，那时候还没有这个博客，后面打算二刷剑指的时候补齐。</p>
<p>下面开始刷LeetCode热题100，还是每天两道，坚持写题解，头年再刷二十道左右。</p>
<h1 id="·-校园商城项目"><a href="#·-校园商城项目" class="headerlink" title="· 校园商城项目"></a>· 校园商城项目</h1><p>慕课看到了第四章的商铺注册也就是前端的页面设计部分，还在项目1.0版本，用的是SSM框架，后面大体结构搭建起来了，但是很多细节自己并不清楚，打算再看看后面做的过程中对项目的理解情况，不行真得从头再刷一遍，有篇文章值得看一看，对项目整理架构的理解有帮助，<a href="https://www.jb51.net/article/127829.htm">点这里查看</a>。</p>
<p>每天晚上的时间都用来搞这个，进度要赶一赶了，年前争取项目1.0这块做的差不多了得。</p>
<h1 id="·-计算机网络"><a href="#·-计算机网络" class="headerlink" title="· 计算机网络"></a>· 计算机网络</h1><p>按照大佬的学习路线看王道考研视频，看完了传输层的部分，打算看完了这块之后开始结合面经学习。大佬说这个考研视频讲的偏重于前面的部分，实际面经中考点在后面的部分。</p>
<p>最多两天看完，打算用这部分时间写写论文，之后再背面经。</p>
<h1 id="·-GitHub个人博客"><a href="#·-GitHub个人博客" class="headerlink" title="· GitHub个人博客"></a>· GitHub个人博客</h1><p>大概一周的时间，自己学着做了一个个人博客，想写点东西，当个自己的学习笔记，或者是生活日记什么的。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-49/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
</blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>解题思路参考于：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></p>
<p>下面那个评论中的小伙伴解释的特别好！</p>
</blockquote>
<p>根据丑数的定义，我们可以得到<strong>丑数的递推性质</strong>：新的丑数可以由现有的丑数序列（排好序）乘以2、3、5得到。</p>
<p>在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, …, n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，</p>
<p>比如如果按照这样的顺序排列下去肯定有问题[1<em>2, 1</em>3, 1<em>5, 2</em>2, 2<em>3, 2</em>5, 3<em>2, 3</em>3, 3<em>5, … , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3</em> 3, n2 *  5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面，  后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。</p>
<p>关键在于怎么让得到的丑数序列是有序的，我们知道当序列中已经有n个丑数的情况下，后面的丑数是由现有序列中的丑数乘以2、3、5得来的，我们要先取得到的丑数中的最小值作为第n+1个丑数，这个丑数有可能是：</p>
<ul>
<li>前面序列中第M1个丑数乘以2</li>
<li>前面序列中第M2个丑数乘以3</li>
<li>前面序列中第M3个丑数乘以5</li>
</ul>
<p>也就是说，我们要取这三种途径中值最小的那个数，这个值就是新得到的丑数中的最小值。为保证每个数都能与2,3,5相乘，我们可以通过设置3个索引a, b, c，分别记录当前位置的丑数有没有与2,3,5相乘，每次循环通过以a,b,c为索引乘以相应的2,3,5得到新的丑数，取这三种途径的最小值。</p>
<p>我们模拟丑数序列的产生过程，<strong>重点是a,b,c分别指示该位置的丑数是不是已经与2,3,5相乘：</strong></p>
<img src="/2021/01/28/%E5%89%91%E6%8C%87offer-49/图片.png" style="zoom:80%;">

<p>对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道），  第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2，  第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。</p>
<p>求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5，  通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第  b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b  个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;</p>
<p>但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5，  说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数,  只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if,  这样才不会把应该加一的计数器漏掉</p>
<p>经过n次循环，就能得到第n 个丑数了。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">// 使用dp数组来存储丑数序列</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// dp[0]已知为1</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;    <span class="comment">// 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数</span></span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2)&#123;</span><br><span class="line">                a++; <span class="comment">// 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3)&#123;</span><br><span class="line">                b++; <span class="comment">// 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5)&#123;</span><br><span class="line">                c++; <span class="comment">// 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-38/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
</blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>我们把一个字符串看成是由<strong>两部分</strong>组成：</p>
<ul>
<li>第一部分是它的第一个字符；</li>
<li>第二部分是后面的所有字符；</li>
</ul>
<p>这里也体现的是<a href="https://eudemonia.tech/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#more">回溯法</a>的思想：</p>
<ol>
<li>首先所有的字符都有可能出现在第一个位置，则循环另所有的元素都轮流作为第一个元素，</li>
<li>然后固定完第一个元素后，剩下的n-1个元素都有可能出现在第二个位置，此时的选择列表为剩下的n-1个元素，</li>
<li>固定完第二个元素之后，剩下的n-2个元素再作为选择列表去枚举第三个位置，以此类推，直到临时路径的长度等于给定数组长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-66/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof</a></p>
</blockquote>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>方法一：暴力解法，每次用连乘n-1个数字的方法得到B[i]。但是这种方法的时间复杂度为O(n^2)。</p>
<p>方法二：通过分析乘积数组的特点，即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]，定义C[i]=A[0]×A[1]×…×A[i-1]，D[i]=A[i+1]×…×A[n-1]，也就是B[i]可以分成两部分C[i]和D[i]的乘积，如图所示：</p>
<p><img src="/2021/01/28/%E5%89%91%E6%8C%87offer-66/2021-01-28-%E5%89%91%E6%8C%87offer-66%5C%E5%9B%BE%E7%89%87.jpg"></p>
<p>而C[i]和D[i]可以分别通过两次循环得到，这种做法的时间复杂度为O(n)。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2021/01/27/%E5%89%91%E6%8C%87offer-45/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p>
</blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>将数组排成最小的数，我们最直观的想法是小数在前，大数在后，但是这样的排序组成的数组不一定是最小的数字，例如：10,9，这两个数字组成的最小数字应该是109而不是910。因此需要定义一种排序规则，使组成的数字最小。</p>
<p>若我们另两个数字为a，b，两个数字的组合有三种情况：</p>
<ol>
<li>当ab&gt;ba时，我们定义b应该在前；</li>
<li>当ba&gt;ab时，我们定义a应该在前；</li>
<li>当ab=ba时，两数相同，谁在前都可以。</li>
</ol>
<p>那么程序中的排序部分应该写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line"><span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>本题除了排序规则之外，还应该在准备工作中将int类型转换为String类型，防止ab组合时溢出，所以这还是一个隐形的大数问题。</p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        fastSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        String tmp = strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        fastSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        fastSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-13/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
</blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题属于二维矩阵的搜索问题，考虑使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历（DFS）</a>的方法。也就是暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。本题中一个优化是不用对一个格子的四个方向都递归，只需要对右、下两个方向递归即可，所有的能够进入的格子都能通过它的左边或上边的格子达到。</p>
<img src="/2021/01/25/%E5%89%91%E6%8C%87offer-13/图片.png" style="zoom:80%;">

<p>我们可以通过上图来模拟DFS的执行流程：</p>
<blockquote>
<p><strong>Note：</strong>引入一个二维矩阵flag[] []来作为每个网格是否访问的标志</p>
</blockquote>
<p>机器人从（0,0）点出发，将flag[0] [0]记为true表示已经被访问过，向右递归，先判断（0,1）<code>1、网格是否越界 2、是否能进入 3、是否已经被访问过</code>，然后再从（0,1）点向右递归（这就是常说的向一个方向递归），依次类推，当到（0,2）时，经过判断不能进入（0,3）号格子，然后退回到（0,2）号格子，再向下递归，依次类推（这就是所说的该方向到底后，回溯到上一个节点沿另一个方向搜索）。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">this</span>.m=m;</span><br><span class="line">    <span class="keyword">this</span>.n=n;</span><br><span class="line">    <span class="keyword">this</span>.k=k;</span><br><span class="line">    <span class="keyword">return</span> total(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||c&gt;=n||(r / <span class="number">10</span> + r % <span class="number">10</span> + c / <span class="number">10</span> + c % <span class="number">10</span> )&gt; k||flag[r][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        flag[r][c]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+total(r,c+<span class="number">1</span>)+total(r+<span class="number">1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-29/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode：</strong><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
</blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><img src="/2021/01/25/%E5%89%91%E6%8C%87offer-29/图片.png" style="zoom:50%;">

<p>以<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">上图</a>的矩阵为例，模拟一遍循环打印的过程：</p>
<p><strong>外圈：</strong></p>
<ul>
<li>从左上角的1开始，遍历顶部的一行，到右上角的元素3结束；</li>
<li>再从3下的元素6开始，遍历最右边的一列，到右下角的元素9结束；</li>
<li>再从9左边的元素8开始，遍历底部的一行，到左下角的元素7结束；</li>
<li>最后从7上边的元素4开始，遍历左边的一列，到起始元素的下边一个元素结束；  </li>
</ul>
<p><strong>内圈：</strong>元素多的话，与外圈的循环相同</p>
<p><strong>因此我们可以用多个重复的循环来解决这个问题：</strong>记左上角的元素坐标为（lr,lc）=（0,0），右下角的元素坐标为（rr,rc）=（sums.length-1,sums[0].length-1），那么每层中每次循环的起始坐标都可以用这四个元素来表示。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> lr=<span class="number">0</span>;<span class="comment">//第一层循环的左上角元素为（0,0）</span></span><br><span class="line">    <span class="keyword">int</span> lc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rr=matrix.length-<span class="number">1</span>;<span class="comment">//第一层循环的右下角元素为（matrix.length-1，matrix[0].length-1）</span></span><br><span class="line">    <span class="keyword">int</span> rc=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[(rr+<span class="number">1</span>)*(rc+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//我们以第一层循环为例讲解代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lc;j&lt;=rc;j++)&#123;<span class="comment">//第一个循环改变的是列，行不变。另j等于顶层最左边坐标的列值lc，结束值是顶层最右边坐标的列值                                 //rc</span></span><br><span class="line">            res[k++]=matrix[lr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lr&gt;rr) <span class="keyword">break</span>;<span class="comment">//先另左边的行号+1，表示该行剔除，然后用加完后的值去跟右下角的行号比较，当大于该值，表示这两个在同                           //一行也就是只有一行，循环结束，下同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lr;i&lt;=rr;i++)&#123;</span><br><span class="line">            res[k++]=matrix[i][rc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rc&lt;lc) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=rc;j&gt;=lc;j--)&#123;</span><br><span class="line">            res[k++]=matrix[rr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rr&lt;lr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rr;i&gt;=lr;i--)&#123;</span><br><span class="line">            res[k++]=matrix[i][lc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lc&gt;rc) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>++a&gt;b表示先对a的值+1再和b的值比较，a++相反。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-04/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
</blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一次比较都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<blockquote>
<p>解法可以参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/</a></p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//flag作为标志位</span></span><br><span class="line">       <span class="keyword">if</span>((matrix.length)==<span class="number">0</span>||(matrix[<span class="number">0</span>].length)==<span class="number">0</span>) <span class="keyword">return</span> flag;</span><br><span class="line">       <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//（r,c）作为右上角的起始坐标</span></span><br><span class="line">       <span class="keyword">while</span>(r&lt;=(matrix.length-<span class="number">1</span>)&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix[r][c]==target)&#123;<span class="comment">//如果右上角的坐标等于目标值，返回true，结束循环</span></span><br><span class="line">               flag=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c]&gt;target)&#123;<span class="comment">//当右上角的值大于目标值，左移一步，剔除右边的列，小于时，下移一步，剔除顶部一行</span></span><br><span class="line">               c--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌中的顺子</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-61/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p>
</blockquote>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>对于该题我们要分析怎样去判断给定的数组中的五个数字是不是连续的，那么首先应该对该数组进行排序，我们注意到本题中给定的条件中包括一条：<code>大小王为0，并且可以充当任意数字</code>。当不包含大小王时，判断五个数字是不是连续的非常简单，如果是连续的数字，每个数字相差1，也就是最大值和最小值的差为4，可以理解为4个间隔大小。因此本题可以转换为存在的大小王的个数能不能使最大值和最小值的间隔满足要求。根据大小王的个数可以分为以下情况：</p>
<p>1、不存在0：最大值和最小值的间隔为4；</p>
<p>2、存在一个0：剩下四个位置，可以是2,3,4,5这种情况（间隔为3），也可以是2,3,5,6（间隔为4），0作为4补齐，当2,3,6,7（间隔为5）此时只有一个0的情况不能再补齐，不满足条件；</p>
<p>3、存在两个0：剩下三个位置，可以是3,4,5这种情况（间隔为2），或者是3,5,6这种情况，0作位2,4或4,7 补齐，也可以是3,6,7（间隔为4），0作为4,5补齐，当3,7,8（间隔为5）此时只有两个0的情况不能再补齐，不满足条件；</p>
<p><strong>根据以上情况总结：</strong></p>
<ul>
<li>五个数连续的条件是最大值和最小值的间隔小于等于4个单位，当有一个王时，只能补齐一个位置，两个王时补齐两个位置，<code>实质就是通过最大值和最小值的差值来看中间有几个空缺的位置</code>；</li>
<li>数组中不能包含重复数字；</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> knums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) knums++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">4</span>]-nums[knums]&lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/2021/01/21/%E5%89%91%E6%8C%87offer-12/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p>
</blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>该题属于矩阵的搜索问题，可以想到使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历算法</a>来解决。通过DFS递归，先朝一个方向搜索，当路径上遇到一个节点k+1不满足条件时，再回溯至上个节点，沿其它方向搜索，以此类推。如<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/hui-su-suan-fa-qiu-jie-by-sdwwld/">下图</a>所示：</p>
<p><img src="/2021/01/21/%E5%89%91%E6%8C%87offer-12/%E7%9F%A9%E9%98%B5.png"></p>
<p>首先，在矩阵中任选一个节点，作为一条path的起点；</p>
<p>然后，通过DFS以该节点作为起始点，开始递归。递归的结束结果有两种可能：</p>
<p>1、返回false：说明在递归的过程中，存在一个节点（r，c）假设它对应的字符串中第k个字符值，它的四个相邻的格子（r-1，c）（r+1，c）（r，c-1）（r，c+1）都找不到字符串的下一个字符值（k+1）；</p>
<p>2、返回true：如上图所示，从A点开始，到B、C、C、E每个点总有一个方向的字符值能和给定的字符串的下一个字符值相等，则递归结束，可以看出递归成功结束的条件是已经在矩阵中找到了与给定的字符串所有的字符。</p>
<p>最后，循环结束说明矩阵中没有该路径，返回false。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words=word.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;board.length;r++)&#123;<span class="comment">//以矩阵的第一行为起始行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;board[<span class="number">0</span>].length;c++)&#123;<span class="comment">//以矩阵的第一列为起始列，依次以每个格子作为起始点，开启DFS遍历</span></span><br><span class="line">            <span class="keyword">if</span>(DFS(board,words,r,c,<span class="number">0</span>))&#123;<span class="comment">//每次传入的参数就是board、words、起始点坐标、字符串起始点0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//当找到对应路径，返回true，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//找不到对应的路径，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>||r&gt;board.length-<span class="number">1</span>||c&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||board[r][c]!=words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*递归的结束条件：</span></span><br><span class="line"><span class="comment">                       1、越界 r&lt;0||c&lt;0||r&gt;board.length-1||c&gt;board[0].length-1</span></span><br><span class="line"><span class="comment">                       2、矩阵的网格字符值与字符串的字符值不同 board[r][c]!=words[k]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//该行表示递归成功的出口</span></span><br><span class="line">        board[r][c]=<span class="string">&#x27; &#x27;</span>;<span class="comment">//每当一个网格字符值满足条件，将该值置为空值，防止二次访问</span></span><br><span class="line">        <span class="keyword">boolean</span> res=DFS(board,words,r+<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r-<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r,c+<span class="number">1</span>,k+<span class="number">1</span>)||DFS(board,words,r,c-<span class="number">1</span>,k+<span class="number">1</span>);<span class="comment">//每当访问到一个网格，对它的上下左右四个方向递归，只要有一个方向满足条件即可，当四个方向都返回false，说明此路不通，换下一个方向或者重新选择起始点</span></span><br><span class="line">        board[r][c]=words[k];<span class="comment">//当一个格点四个方向的邻接点都不合要求，将该网格值还原</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//返回递归结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2021/01/19/%E5%89%91%E6%8C%87offer-34/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p>
</blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<img src="/2021/01/19/%E5%89%91%E6%8C%87offer-34/1.png" style="zoom:50%;">

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于路径是从根节点出发到叶节点，也就是路径总是以根节点作为起始点，因此我们需要先遍历根节点，考虑使用前序遍历。</p>
<p>对于上图中的二叉树，其前序遍历过程如下表所示：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>是否叶节点</th>
<th>路径</th>
<th>路径节点的和</th>
<th>是否符合要求</th>
</tr>
</thead>
<tbody><tr>
<td>访问节点5</td>
<td>否</td>
<td>5</td>
<td>5</td>
<td>否</td>
</tr>
<tr>
<td>访问节点4</td>
<td>否</td>
<td>5,4</td>
<td>9</td>
<td>否</td>
</tr>
<tr>
<td>访问节点11</td>
<td>否</td>
<td>5,4,11</td>
<td>20</td>
<td>否</td>
</tr>
<tr>
<td>访问节点7</td>
<td>是</td>
<td>5,4,11,7</td>
<td>27</td>
<td>否</td>
</tr>
<tr>
<td>访问节点2</td>
<td>是</td>
<td>5,4,11,2</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>访问节点8</td>
<td>否</td>
<td>5,8</td>
<td>13</td>
<td>否</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<p>通过表，我们可以得到算法的执行流程：</p>
<p>当访问一个节点时，首先判断该节点是不是null，当节点为null时，直接返回；</p>
<p>当访问的节点不为null，将该节点的值加到动态数组temp中，并在目标值tar上减去该节点的数值。通过上表可知当一个节点为<strong>叶子节点</strong>且<strong>路径的和等于sum</strong>时该路径复合题目要求（此处当tar的值为零时表示路径的和等于sum）；</p>
<p>当被访问的节点不为null，也不满足第二条的要求时，进行左右子树的递归；</p>
<p>一个被访问的节点递归结束，要从temp中删除该节点的值，比如：5→4→11→7，当节点7访问结束，要将7从temp删除，然后返回        到访问节点11的函数，开始递归它的右子树，也就是节点2。</p>
<blockquote>
<p><strong>Note：</strong>当一条路径满足要求时，要新建一个LinkedList(temp)对象传入res中（复制），因为如果直接res.add(temp)相当于传入temp对象，当temp改变时，res也会随之变化。</p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//res中存储的是满足要求的所有路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//temp存储动态变化的路径</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        path(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar-=root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(tar==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> LinkedList(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        path(root.left,tar);</span><br><span class="line">        path(root.right,tar);</span><br><span class="line">        temp.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
</search>

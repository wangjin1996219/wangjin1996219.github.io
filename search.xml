<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AQS原理分析</title>
    <url>/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-J-U-C-类结构"><a href="#1-1-J-U-C-类结构" class="headerlink" title="1.1 J.U.C 类结构"></a>1.1 J.U.C 类结构</h2><p> <strong>J.U.C（java.util.concurrent）包：</strong>提供了很多高性能的并发类，大大提高了并发性能。研究具体的类原理前需要对整个框架有一个大概的认识，整个框架分为五个模块，部分高级模块会依赖其他基础模块，如图所示：</p>
<p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-07-27-AQS原理分析\图片04.png" alt="image-20210620113447451"></p>
<h2 id="1-2-AQS-原理分析"><a href="#1-2-AQS-原理分析" class="headerlink" title="1.2 AQS 原理分析"></a>1.2 AQS 原理分析</h2><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的<strong>框架</strong></p>
<p><strong>AQS 核心思想</strong></p>
<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p><strong>CLH(Craig,Landin,and Hagersten)队列：</strong>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS 原理如图所示：</p>
<p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-07-27-AQS原理分析\图片03.png" alt="AQS原理图"></p>
<p><strong>AQS 使用一个 int 成员变量 state 来表示同步状态</strong>，当 state&gt;0 时表示已经获取锁，当 state=0 时表示释放了锁。用 volatile 修饰共享变量 state 保证线程同步，线程通过 CAS 去改变状态符，成功则获取锁成功，失败则被 AQS 封装成 Node 进入等待队列，等待被唤醒。通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p>
<blockquote>
<p><strong>AQS 是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋的方式，不停地尝试获取锁，直到被其他线程获取成功。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p><strong>AQS 提供了三种方法对状态信息修改：</strong>protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-AQS-对资源的共享方式"><a href="#1-AQS-对资源的共享方式" class="headerlink" title="1. AQS 对资源的共享方式"></a>1. AQS 对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<h3 id="2-AQS-底层模板方法模式"><a href="#2-AQS-底层模板方法模式" class="headerlink" title="2. AQS 底层模板方法模式"></a>2. AQS 底层模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 </p>
<p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到A线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state 会累加），这就是<strong>可重入</strong>的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 为例，任务分为N个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS(Compare and Swap) 减1。等到所有子线程都执行完后(即state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p><strong>总结：</strong> </p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<p>AQS 解决了实现同步器是涉及到的大量细节问题，如：获取同步状态、FIFO 同步队列等。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。</p>
<p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态。</p>
<h1 id="2-实现不可重入锁"><a href="#2-实现不可重入锁" class="headerlink" title="2.实现不可重入锁"></a>2.实现不可重入锁</h1><h2 id="1-自定义同步器"><a href="#1-自定义同步器" class="headerlink" title="1.自定义同步器"></a>1.自定义同步器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//加锁，将当前持有锁的线程设置为当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acquires == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前线程设为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//将状态值设为0</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//是否持有独占锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-自定义锁"><a href="#2-自定义锁" class="headerlink" title="2.自定义锁"></a>2.自定义锁</h2><p>有了自定义同步器，很容易复用 AQS ，实现一个功能完备的自定义锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> MySync sync = <span class="keyword">new</span> MySync();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，可打断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 生成条件变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAqs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;locking...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;unlocking...&quot;</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22:29:28.727 c.TestAqs [t1] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t1] - unlocking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - locking... </span><br><span class="line">22:29:29.732 c.TestAqs [t2] - unlocking... </span><br></pre></td></tr></table></figure>

<h1 id="3-ReentrantLock-原理"><a href="#3-ReentrantLock-原理" class="headerlink" title="3. ReentrantLock 原理"></a>3. ReentrantLock 原理</h1><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片01.png" alt="image-20210727202338191" style="zoom: 80%;">

<p>内部也是维护了一个同步器 Sync，它有两种实现：公平锁和非公平锁</p>
<h2 id="1-非公平锁实现原理"><a href="#1-非公平锁实现原理" class="headerlink" title="1.非公平锁实现原理"></a>1.非公平锁实现原理</h2><h3 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h3><p>先从构造器开始看，默认为非公平锁实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NonfairSync 继承自 AQS</p>
<p><strong>没有竞争时：</strong></p>
<p>通过 cas 将状态 state 置为 1，并将当前的线程设置为线程本身。</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片05.png" alt="image-20210727215938412" style="zoom:67%;">

<p><strong>第一个竞争出现时：</strong></p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片06.png" alt="image-20210727220243625" style="zoom:67%;">

<p>Thread-1 执行了</p>
<ol>
<li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p>
</li>
<li><p>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败 </p>
</li>
<li><p>接下来进入 addWaiter 逻辑，构造 Node 队列 </p>
<p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态 </p>
<p>Node 的创建是懒惰的 </p>
<p>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</p>
</li>
</ol>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片07.png" alt="image-20210727220431998" style="zoom:67%;">

<p>当前线程进入 acquireQueued 逻辑 </p>
<ol>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞 </li>
<li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 （仍然会自旋一下）</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false（前驱节点为-1，表示有责任唤醒它的后继节点）</li>
</ol>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片08.png" alt="image-20210727220659132" style="zoom:67%;">

<ol start="4">
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败 </li>
<li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true </li>
<li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li>
</ol>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片09.png" alt="image-20210727220801956" style="zoom:67%;">

<p>再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片10.png" alt="image-20210727220831897" style="zoom:80%;">

<ul>
<li>Thread-0 释放锁，进入 tryRelease 流程，如果成功 设置 exclusiveOwnerThread 为 null </li>
<li>state = 0</li>
</ul>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片11.png" alt="image-20210727220940026" style="zoom: 80%;">

<ul>
<li>当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程 </li>
<li>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1 </li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/Users\王进\AppData\Roaming\Typora\typora-user-images\image-20210727221037145.png" alt="image-20210727221037145" style="zoom: 80%;">

<p>如果加锁成功<strong>（没有竞争）</strong>，会设置 </p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state = 1 </li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread </li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
<p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片12.png" alt="image-20210727221208737" style="zoom:80%;">

<p>如果不巧又被 Thread-4 占了先 </p>
<ul>
<li>Thread-4 被设置为 exclusiveOwnerThread，state = 1 </li>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当线程在等待队列中被唤醒时，按照本来应该是队列中的头结点对应的线程，将线程设置为本身，并将 state 状态置1的，但是这时候来了一个新的获取锁的线程，抢先一步完成了这个操作，那么该线程获取执行权。</p>
<h2 id="2-可重入原理"><a href="#2-可重入原理" class="headerlink" title="2.可重入原理"></a>2.可重入原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可重入锁对于第一次获取时，判断 state == 0，会将 state 设置为 1 ，并将线程设置为当前线程，返回 true 表示设置成功；</p>
<p>当第二次获取锁时，只要判断线程还是当前线程, 表示发生了锁重入，这是只将状态++就可。</p>
<h2 id="3-可打断原理"><a href="#3-可打断原理" class="headerlink" title="3.可打断原理"></a>3.可打断原理</h2><p><strong>不可打断模式</strong></p>
<p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sync 继承自 AQS</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果打断标记已经是 true, 则 park 会失效</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// interrupted 会清除打断标记</span></span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 还是需要获得锁后, 才能返回打断状态</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                        shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                                parkAndCheckInterrupt()</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 如果是因为 interrupt 被唤醒, 返回打断状态为 true</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 如果打断状态为 true</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重新产生一次中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可打断模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 如果没有获得到锁, 进入 ㈠</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ 可打断的获取锁流程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                        parkAndCheckInterrupt()) &#123;</span><br><span class="line">                    <span class="comment">// 在 park 过程中如果被 interrupt 会进入此</span></span><br><span class="line">                    <span class="comment">// 这时候抛出异常, 而不会再次进入 for (;;)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-公平锁实现原理"><a href="#4-公平锁实现原理" class="headerlink" title="4.公平锁实现原理"></a>4.公平锁实现原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">                !tryAcquire(arg) &amp;&amp;</span><br><span class="line">                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span><br><span class="line">        ) &#123;</span><br><span class="line">            selfInterrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与非公平锁主要区别在于 tryAcquire 方法的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先检查 AQS 队列中是否有前驱节点, 没有才去竞争</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ㈠ AQS 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="comment">// h != t 时表示队列中有 Node</span></span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">                (</span><br><span class="line">                    <span class="comment">// (s = h.next) == null 表示队列中还有没有老二</span></span><br><span class="line">                    (s = h.next) == <span class="keyword">null</span> ||</span><br><span class="line">                    <span class="comment">// 或者队列中老二线程不是此线程</span></span><br><span class="line">                    s.thread != Thread.currentThread()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁的实现，它在尝试获取锁之前会，先检查 AQS 队列中是否有前驱节点, 没有才去竞争，这样就避免了在等待队列之前的线程获取到锁。</p>
<h2 id="5-条件变量实现原理"><a href="#5-条件变量实现原理" class="headerlink" title="5.条件变量实现原理"></a>5.条件变量实现原理</h2><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>
<h3 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h3><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程 </p>
<p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片13.png" alt="image-20210727222806003" style="zoom:80%;">

<p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片14.png" alt="image-20210727222843874" style="zoom:80%;">

<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片15.png" alt="image-20210727222913544" style="zoom:80%;">

<p>park 阻塞 Thread-0</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片16.png" alt="image-20210727222944967" style="zoom:80%;">

<h3 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h3><p>假设 Thread-1 要来唤醒 Thread-0</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片17.png" alt="image-20210727223020830" style="zoom:80%;">

<p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片18.png" alt="image-20210727223052269" style="zoom:80%;">

<p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的 waitStatus 改为 -1</p>
<img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source\_posts\2021-07-27-AQS原理分析\图片19.png" alt="image-20210727223124810" style="zoom:80%;">

<p>Thread-1 释放锁，进入 unlock 流程，略</p>
<h1 id="4-其它组件"><a href="#4-其它组件" class="headerlink" title="4.其它组件"></a>4.其它组件</h1><h2 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1. CountDownLatch"></a>1. CountDownLatch</h2><p><strong>CountDownLatch的内部实现如下：</strong></p>
<p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\countdownlatch.png" alt="img"></p>
<ul>
<li><strong>CountDownLatch</strong>内部维护一个计数器，CountDownLatch.countDown（）每被执行一次都会使计数器值减少1。 </li>
<li><strong>当计数器不为0时</strong>，CountDownLatch.await（）方法的调用将会导致执行线程被暂停，这些线程就叫做该 CountDownLatch 上的等待线程。 </li>
<li>CountDownLatch.countDown（）相当于一个通知方法，<strong>当计数器值达到0时</strong>，唤醒所有等待线程。当然对应还有指定等待时间长度的CountDownLatch.await( long , TimeUnit)方法。 </li>
</ul>
<p><strong>Demo0：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..end..run..</span><br></pre></td></tr></table></figure>

<p><strong>Demo1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end..</span><br></pre></td></tr></table></figure>

<ul>
<li>由 Demo0 可知，当主线程不等待时，那 end 输出就可能在任意时刻执行，也就是主线程与其它线程是并行的；</li>
<li>由 Demo1可知，当主线程 await 一下，那主线程就会等其它线程执行到 countDownLatch==0 来唤醒主线程，那么输出 end 的操作就会最后执行。</li>
</ul>
<h2 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行，在实际工作中可以用来<strong>模拟高并发请求测试</strong>。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<p><img src="/2021/07/27/AQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\CyclicBarrier.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;王进..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before..before..before..before..before..王进..after..after..after..after..after..</span><br></pre></td></tr></table></figure>

<p><strong>reset 方法的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 reset 方法实现了 “屏障” 的循环使用。</p>
<h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    String time = sim.format(satrtTime);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;时刻访问了资源&quot;</span>);</span><br><span class="line">                    System.out.println(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-6</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-8</span><br><span class="line">pool-1-thread-7</span><br><span class="line">pool-1-thread-9</span><br><span class="line">pool-1-thread-10</span><br><span class="line">线程pool-1-thread-2在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-5在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-6在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-1在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-3在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">线程pool-1-thread-4在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-7在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">线程pool-1-thread-9在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-8在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-10在2021-06-20 22:11:11时刻访问了资源</span><br><span class="line">2 </span><br></pre></td></tr></table></figure>

<p>多个线程可以并发执行，一共十个线程对应十个请求访问资源，但是同时最多只能有三个线程访问共享资源。也就是控制并发量。</p>
<h2 id="4-AQS-组件总结"><a href="#4-AQS-组件总结" class="headerlink" title="4. AQS 组件总结"></a>4. AQS 组件总结</h2><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS机制</title>
    <url>/2021/07/20/CAS%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h1><p>启动两个线程，每个线程中让变量 count 循环累加 100 次：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出的 count 结果一定是 200 吗？因为这段代码是非线程安全的，所以最终的自增结果很可能会小于 200。这是因为 i++ 这种操作并不是原子性的, 实际上它的操作是首先从<strong>内存</strong>中取出数据放在<strong>cpu寄存器</strong>中进行计算, 然后再将计算好的结果返回到<strong>内存</strong>中。</p>
<p>我们再加上 synchronized 同步锁，再来看一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyRunnable.class)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了同步锁之后，count 自增的操作变成了原子性操作，所以最终输出一定是 count=200，代码实现了线程安全。虽然 synchronized 确保了线程安全，但是在某些情况下，这并不是一个最优的选择。</p>
<p>synchronized 关键字会让没有得到锁资源的线程进入 BLOCKED 状态，而后在争夺到锁资源后恢复为 RUNNABLE 状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p>
<p>尽管 JAVA 1.6 为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过过度，但是在最终转变为重量级锁之后，性能仍然比较低。所以面对这种情况，我们就可以使用 java 中的“原子操作类”。</p>
<p>所谓原子操作类，指的是 java.util.concurrent.atomic 包下，一系列以 Atomic 开头的包装类。如 AtomicBoolean，AtomicUInteger，AtomicLong。它们分别用于 Boolean，Integer，Long 类型的原子性操作。</p>
<p>现在我们尝试使用 AtomicInteger 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            count.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myRunnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(myRunnable.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 AtomicInteger 之后，最终的输出结果同样可以保证是 200。并且在某些情况下，代码的性能会比 synchronized 更好。</p>
<p>而 Atomic 操作类的底层正是用到了“CAS机制”。</p>
<h1 id="2-CAS-机制"><a href="#2-CAS-机制" class="headerlink" title="2. CAS 机制"></a>2. CAS 机制</h1><p>CAS 是英文单词 Compare and Swap 的缩写，翻译过来就是比较并替换。</p>
<p>CAS 机制中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。</p>
<p>更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</p>
<p><strong>例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在内存地址V当中，存储着值为10的变量。</span><br><span class="line">2.此时线程1想把变量的值增加1。对线程1来说，旧的预期值A&#x3D;10，要修改的新值B&#x3D;11.</span><br><span class="line">3.在线程1要提交更新之前，另一个线程2抢先一步，把内存 地址V中的变量值率先更新成了11。</span><br><span class="line">4.线程1开始提交更新，首先进行A和地址V的实际值比较，发现A不等于V的实际值，提交失败。</span><br><span class="line">5.线程1重新获取内存地址V的当前值，并重新计算想要修改的值。此时对线程1来说，A&#x3D;11，B&#x3D;12。这个重新尝试的过程被称为自旋。</span><br><span class="line">6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行比较，发现A和地址V的实际值是相等的。</span><br><span class="line">7.线程1进行交换，把地址V的值替换为B，也就是12。</span><br></pre></td></tr></table></figure>

<p>从思想上来说，synchronized 属于悲观锁，悲观的认为程序中的并发情况严重，所以严防死守，CAS 属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去重试更新。</p>
<p>在 java 中除了上面提到的 Atomic 系列类，以及 Lock 系列类夺得底层实现，甚至在 JAVA1.6 以上版本，synchronized 转变为重量级锁之前，也会采用 CAS 机制。</p>
<h1 id="3-CAS-的缺点"><a href="#3-CAS-的缺点" class="headerlink" title="3. CAS 的缺点"></a>3. CAS 的缺点</h1><ol>
<li><p><strong>CPU 开销过大</strong></p>
<p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</p>
</li>
<li><p><strong>不能保证代码块的原子性</strong></p>
<p>CAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 3 个变量共同进行原子性的更新，就不得不使用 synchronized 了。</p>
</li>
<li><p><strong>ABA 问题</strong></p>
<p>这是 CAS 机制最大的问题所在。（后面有介绍）</p>
</li>
</ol>
<h1 id="4-JAVA-中-CAS-的底层实现"><a href="#4-JAVA-中-CAS-的底层实现" class="headerlink" title="4. JAVA 中 CAS 的底层实现"></a>4. JAVA 中 CAS 的底层实现</h1><p>我们看一下 AtomicInteger 当中常用的自增方法 incrementAndGet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个无限循环，也就是 CAS 的自旋，循环体中做了三件事：</p>
<ol>
<li>获取当前值</li>
<li>当前值+1，计算出目标值</li>
<li>进行 CAS 操作，如果成功则跳出循环，如果失败则重复上述步骤</li>
</ol>
<p>这里需要注意的重点是 get 方法，这个方法的作用是获取变量的当前值。</p>
<p>如何保证获取的当前值是内存中的最新值？很简单，用 volatile 关键字来保证（保证线程间的可见性）。我们接下来看一下 compareAndSet 方法的实现：</p>
<p><img src="https://img-blog.csdn.net/2018031217514825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzI5OTgxNTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>compareAndSet 方法的实现很简单，只有一行代码。这里涉及到两个重要的对象，一个是 unsafe，一个是 valueOffset。</p>
<p>什么是 unsafe 呢？Java 语言不像 C，C++ 那样可以直接访问底层操作系统，但是 JVM 为我们提供了一个后门，这个后门就是 unsafe。unsafe 为我们提供了硬件级别的原子操作。</p>
<p>至于 valueOffset 对象，是通过 unsafe.objectFiledOffset 方法得到，所代表的是 AtomicInteger 对象 value 成员变量在内存中的偏移量。我们可以简单的把 valueOffset 理解为 value 变量的内存地址。</p>
<p>我们上面说过，CAS 机制中使用了 3 个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。</p>
<p>而 unsafe 的 compareAndSwapInt 方法的参数包括了这三个基本元素：valueOffset 参数代表了 V，expect 参数代表了A，update 参数代表了 B。</p>
<p>正是 unsafe 的 compareAndSwapInt 方法保证了 Compare 和 Swap 操作之间的原子性操作。</p>
<h1 id="5-ABA-问题"><a href="#5-ABA-问题" class="headerlink" title="5. ABA 问题"></a>5. ABA 问题</h1><p>我们现在来说什么是 ABA 问题。假设内存中有一个值为 A 的变量，存储在地址 V 中。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片09.png" alt="img"></p>
<p>此时有三个线程想使用 CAS 的方式更新这个变量的值，每个线程的执行时间有略微偏差。线程1和线程2已经获取当前值，线程3还未获取当前值。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片10.png" alt="img"></p>
<p>接下来，线程1先一步执行成功，把当前值成功从A更新为B；同时线程2因为某种原因被阻塞住，没有做更新操作；线程3在线程1更新之后，获取了当前值B。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片11.png" alt="img"></p>
<p>在之后，线程2仍然处于阻塞状态，线程3继续执行，成功把当前值从B更新成了A。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片12.png" alt="img"></p>
<p>最后，线程2终于恢复了运行状态，由于阻塞之前已经获得了“当前值A”，并且经过compare检测，内存地址V中的实际值也是A，所以成功把变量值A更新成了B。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片13.png" alt="img"></p>
<p>看起来这个例子没啥问题，但如果结合实际，就可以发现它的问题所在：</p>
<ol>
<li>我们假设一个提款机的例子。假设有一个遵循 CAS 原理的提款机，小灰有 100 元存款，要用这个提款机来提款 50 元。</li>
<li>由于提款机硬件出了点问题，小灰的提款操作被同时提交了两次，开启了两个线程，两个线程都是获取当前值 100 元，要更新成 50 元。</li>
<li>理想情况下，应该一个线程更新成功，一个线程更新失败，小灰的存款值被扣一次。</li>
<li>线程1首先执行成功，把余额从 100 改成 50，线程2因为某种原因阻塞。这时，小灰的妈妈刚好给小灰汇款 50 元。</li>
<li>线程2仍然是阻塞状态，线程3执行成功，把余额从 50 改成了 100。</li>
<li>线程2恢复运行，由于阻塞之前获得了“当前值”100，并且经过 compare 检测，此时存款实际值也是100，所以会成功把变量值100更新成50。</li>
<li>原本线程2应当提交失败，小灰的正确余额应该保持100元，结果由于ABA问题提交成功了。</li>
</ol>
<h2 id="解决方法—加版本号"><a href="#解决方法—加版本号" class="headerlink" title="解决方法—加版本号"></a>解决方法—加版本号</h2><p>真正要做到严谨的 CAS 机制，我们在 compare 阶段不仅要比较期望值A和地址V中的实际值，还要比较变量的版本号是否一致。</p>
<p>我们仍然以刚才的例子来说明，假设地址V中存储着变量值A，当前版本号是01。线程1获取了当前值A和版本号01，想要更新为B，但是被阻塞了。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片14.png" alt="img"></p>
<p>这时候，内存地址V中变量发生了多次改变，版本号提升为03，但是变量值仍然是A。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片15.png" alt="img"></p>
<p>随后线程1恢复运行，进行 compare 操作。经过比较，线程1所获得的值和地址的实际值都是A，但是版本号不相等，所以这一次更新失败。</p>
<p><img src="/2021/07/20/CAS%E6%9C%BA%E5%88%B6/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片16.png" alt="img"></p>
<p>在 Java 中，AtomicStampedReference 类就实现了用版本号作比较额 CAS 机制。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-volatile-简介"><a href="#1-volatile-简介" class="headerlink" title="1. volatile 简介"></a>1. volatile 简介</h1><p>volatile 是 Java 提供的一种轻量级的同步机制。相比于 synchronized（synchronized通常称为重量级锁），volatile 更轻量级，因为它不会引起线程上下文的切换和调度。可以保证可见性和有序性，但是不能保证原子性。</p>
<h1 id="2-Java-内存模型（JMM）"><a href="#2-Java-内存模型（JMM）" class="headerlink" title="2. Java 内存模型（JMM）"></a>2. Java 内存模型（JMM）</h1><h2 id="2-1现代计算机内存模型"><a href="#2-1现代计算机内存模型" class="headerlink" title="2.1现代计算机内存模型"></a>2.1现代计算机内存模型</h2><p>其实早期计算机中 cpu 和内存的速度是差不多的，但在现代计算机中，cpu 的指令速度远超内存的存取速度，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲。</p>
<p>将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（CacheCoherence）。</p>
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。</p>
<p><img src="/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-20-volatile关键字\图片01.png" alt="img"></p>
<h2 id="2-2-JavaMemoryModel"><a href="#2-2-JavaMemoryModel" class="headerlink" title="2.2 JavaMemoryModel"></a>2.2 JavaMemoryModel</h2><p><strong>Java 内存模型(JavaMemoryModel)：</strong>描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量，存储到内存和从内存中读取变量这样的底层细节。</p>
<p><strong>JMM 有以下规定：</strong></p>
<p>所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p>
<p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p>
<p>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</p>
<p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
<p><img src="/2021/07/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-20-volatile关键字\图片02.png" alt="img"></p>
<p>对于普通的共享变量来讲，线程 A 将其修改为某个值发生在线程 A 的本地内存中，此时还未同步到主内存中去；而线程 B 已经缓存了该变量的旧值，所以就导致了共享变量值的不一致。解决这种共享变量在多线程模型中的不可见性问题，较粗暴的方式自然就是加锁，但是此处使用 synchronized 或者 Lock 这些方式太重量级了，比较合理的方式其实就是 volatile。</p>
<p>需要注意的是，JMM 是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应 cpu 缓存和物理内存</p>
<h1 id="3-volatile-关键字的特性"><a href="#3-volatile-关键字的特性" class="headerlink" title="3. volatile 关键字的特性"></a>3. volatile 关键字的特性</h1><h2 id="3-1保证可见性"><a href="#3-1保证可见性" class="headerlink" title="3.1保证可见性"></a>3.1保证可见性</h2><ul>
<li>当写一个 volatile 变量时，JMM 会把该线程本地内存中的变量强制刷新到主内存中去；</li>
<li>这个写会操作会导致其他线程中的 volatile 变量缓存无效。</li>
</ul>
<h2 id="3-2禁止指令重排"><a href="#3-2禁止指令重排" class="headerlink" title="3.2禁止指令重排"></a>3.2禁止指令重排</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p>
<ol>
<li><p>重排序操作不会对存在数据依赖关系的操作进行重排序。</p>
<p>比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p>
</li>
<li><p>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p>
<p>比如：a=1;b=2;c=a+b 这三个操作，第一步（a=1) 和第二步 (b=2) 由于不存在数据依赖关系， 所以可能会发生重排序，但是 c=a+b 这个操作是不会被重排序的，因为需要保证最终的结果一定是 c=a+b=3。</p>
<p>重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行 status=true 再执行 a=2。而此时线程 B 会顺利到达4处，而线程 A 中 a=2 这个操作还未被执行，所以 b=a+1 的结果也有可能依然等于 2。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">boolean</span> status = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//状态切换为true</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> changeStatus&#123;</span><br><span class="line">		a = <span class="number">2</span>;   <span class="comment">//1</span></span><br><span class="line">		status = <span class="keyword">true</span>;  <span class="comment">//2</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//若状态为true，则为running</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(status)&#123;   <span class="comment">//3</span></span><br><span class="line">			<span class="keyword">int</span> b = a + <span class="number">1</span>;  <span class="comment">//4</span></span><br><span class="line">			System.out.println(b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用 volatile 关键字修饰共享变量便可以禁止这种重排序。若用 volatile 修饰共享变量，在编译时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序，volatile 禁止指令重排序也有一些规则：</p>
<ol>
<li><p>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；</p>
</li>
<li><p>在进行指令优化时，不能将对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</p>
<p>即执行到 volatile 变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。</p>
</li>
</ol>
<h1 id="4-volatile-与-synchronized-的区别"><a href="#4-volatile-与-synchronized-的区别" class="headerlink" title="4. volatile 与 synchronized 的区别"></a>4. volatile 与 synchronized 的区别</h1><ol>
<li>volatile 是一种轻量级锁，不会造成线程阻塞，synchronized 是重量级锁，所以同样场景下 volatile 关键字的性能更高，比如说多线程修改一个共享变量只是赋值操作，，因为赋值本身具有原子性，再由 volatile 保证可见性即可实现线程安全；</li>
<li>volatile 关键字只能保证可见性和有序性，但是不能保证原子性，synchronized 关键字都可以保证；</li>
<li> volatile 只能修饰变量，而 synchronized 可以修饰变量、方法和类。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-synchronized-介绍"><a href="#1-synchronized-介绍" class="headerlink" title="1. synchronized 介绍"></a>1. synchronized 介绍</h1><p>synchronized 是 Java 中的一个关键字，解决的是多个线程之间访问共享资源的同步性。它可以用在普通方法、静态方法和代码块上，synchronized 关键字可以保证在多线程环境下，同步方法或者同步代码块在同一时刻只允许有一个线程在执行，其余线程都在等待获取锁，也就是实现了整体并发中的局部串行。</p>
<h1 id="2-synchronized-的三种应用方式"><a href="#2-synchronized-的三种应用方式" class="headerlink" title="2. synchronized 的三种应用方式"></a>2. synchronized 的三种应用方式</h1><h2 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h2><p>同步代码块的格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象)&#123;</span><br><span class="line">    多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized(任意对象)：相当于给代码加锁了，任意时刻只能有一个线程访问共享的代码块，并且<strong>任意对象都可以看成是一把锁</strong>。</p>
<p>下面我们写一个包含同步代码块的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个任意对象，作为同步代码块的锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过synchronized关键字锁住共享资源</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">                Method1();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//让线程Thread-1执行方法2</span></span><br><span class="line">                Method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//同步代码块：创建两个对象my5、my6</span></span><br><span class="line">        MyRunnable2 my5 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        MyRunnable2 my6 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">19</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">25</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>同一时刻只有获取到锁对象 obj 的线程才能访问同步代码块</strong></p>
<p>如果将线程2的构造对象传入 My6，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my6);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>可以看到两个线程可以同时访问同步代码块，这是因为他俩访问的并不是同一块同步代码块，并且锁对象 obj 也并不是同一个锁对象，可以检验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(my5.obj==my6.obj);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<h2 id="2-同步实例方法"><a href="#2-同步实例方法" class="headerlink" title="2.同步实例方法"></a>2.同步实例方法</h2><p>同步方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法就是把 synchronized 关键字加到方法上，同步方法的锁对象是同一对象。</p>
<p>下面我们写一个包含同步方法的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步方法：创建两个对象my1、my2</span></span><br><span class="line">        MyRunnable my1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        MyRunnable my2 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">26</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">32</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>我们将线程2构造的对象替换成 my2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my2);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>我们开始传入的是同一个对象，所以线程串行访问共享资源，当我们传入的不是同一个对象时，每个对象都相当于一把锁，所以执行没有冲突。</p>
<p><strong>结论：</strong>所以同步方法的锁对象是 this 对象</p>
<h2 id="3-静态同步方法"><a href="#3-静态同步方法" class="headerlink" title="3.静态同步方法"></a>3.静态同步方法</h2><p>静态同步方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态同步方法就是把 synchronized 关键字加到静态方法上，静态同步方法的锁对象是类名。</p>
<p>下面我们写一个包含静态同步方法的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态同步方法：创建两个对象my3、my4</span></span><br><span class="line">        MyRunnable1 my3 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line">        MyRunnable1 my4 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:48:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:48:56:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>我们将线程2构造的对象替换成 my4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my4);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:49:47:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:49:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>我们可以看到，修改前后，线程的执行顺序是一样的，也就是说静态同步方法只有拿到这个 class 才能访问，而运行时 JVM 只有这一个类，所以同一时间只能有一个线程访问共享资源。</p>
<p><strong>结论：</strong>所以静态同步方法的锁对象是类名</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li>
</ul>
<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) ，因为 JVM 中，字符串常量池具有缓存功能！</p>
<h1 id="3-synchronized-底层实现"><a href="#3-synchronized-底层实现" class="headerlink" title="3. synchronized 底层实现"></a>3. synchronized 底层实现</h1><h2 id="3-1底层语义原理"><a href="#3-1底层语义原理" class="headerlink" title="3.1底层语义原理"></a>3.1底层语义原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。</p>
<h2 id="3-2-Java-对象头与-Monitor"><a href="#3-2-Java-对象头与-Monitor" class="headerlink" title="3.2 Java 对象头与 Monitor"></a>3.2 Java 对象头与 Monitor</h2><p>我们都知道对象是放在堆内存中的，对象大致可以分为三个部分，分别是<strong>对象头，实例变量和填充字节</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210212204438565.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>实例变量：</strong>存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按 4 字节对齐。</li>
<li><strong>填充数据：</strong>由于虚拟机要求对象起始地址必须是 8 字节的整数倍。<strong>填充数据不是必须存在的，仅仅是为了字节对齐</strong>，这点了解即可。</li>
</ul>
<p><strong>Java 头对象：</strong>它是实现 synchronized 锁对象的基础，一般而言，synchronized 使用的锁对象是存储在 Java 对象头里的，jvm 中采用 2 个字来存储对象头(如果对象是数组则会分配 3 个字，多出来的 1 个字记录的是数组长度)，其主要结构是由 Mark Word 和 Class Metadata Address 组成，其结构说明如下表：</p>
<table>
<thead>
<tr>
<th align="center">虚拟机位数</th>
<th align="center">头对象结构</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64bit</td>
<td align="center">Mark Word</td>
<td align="center">存储对象的 hashCode、锁信息或分代年龄或 GC 标志等信息</td>
</tr>
<tr>
<td align="center">32/64bit</td>
<td align="center">Class Metadata Address</td>
<td align="center">类型指针指向对象的类元数据，JVM 通过这个指针确定该对象是哪个类的实例。</td>
</tr>
</tbody></table>
<p>其中 Mark Word 在默认情况下存储着对象的 HashCode、分代年龄、锁标记位等以下是 32 位 JVM 的 Mark Word 默认存储结构：</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25bit</th>
<th align="center">4bit</th>
<th align="center">1bit是否是偏向锁</th>
<th align="center">2bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象HashCode</td>
<td align="center">对象分代年龄</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
</tbody></table>
<p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到 JVM 的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如 32 位 JVM 下，除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：</p>
<p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片01.png" alt="img"></p>
<p>其中轻量级锁和偏向锁是 Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说 synchronized 的对象锁，锁标识位为 10，其中指针指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的，其主要数据结构如下（位于 HotSpot 虚拟机源码 ObjectMonitor.hpp 文件，C++实现的）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor 中有两个队列，WaitSet 和 EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter 对象)，owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 EntryList 集合，当线程获取到对象的 monitor 后进入 Owner 区域并把 monitor 中的 owner 变量设置为当前线程同时 monitor 中的计数器 count 加 1，若线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减 1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor(锁)并复位变量的值，以便其他线程进入获取 monitor(锁)。如下图所示：</p>
<p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片02.png" alt="img"></p>
<p>由此看来，monitor 对象存在于每个 Java 对象的对象头中(存储的指针的指向)，synchronized 锁便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是 notify/notifyAll/wait 等方法存在于顶级对象 Object 中的原因</p>
<h2 id="3-3-synchronized-代码块底层原理"><a href="#3-3-synchronized-代码块底层原理" class="headerlink" title="3.3 synchronized 代码块底层原理"></a>3.3 synchronized 代码块底层原理</h2><p>现在我们重新定义一个 synchronized 修饰的同步代码块，在代码块中操作共享变量 i，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码库</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译上述代码并使用 javap 反编译后得到字节码如下(这里我们省略一部分没有必要的信息)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncCodeBlock.class</span><br><span class="line">  Last modified <span class="number">2017</span>-<span class="number">6</span>-<span class="number">2</span>; size <span class="number">426</span> bytes</span><br><span class="line">  MD5 checksum c80bc322c87b312de760942820b4fed5</span><br><span class="line">  Compiled from <span class="string">&quot;SyncCodeBlock.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">zejian</span>.<span class="title">concurrencys</span>.<span class="title">SyncCodeBlock</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  <span class="comment">//........省略常量池中数据</span></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="keyword">public</span> com.zejian.concurrencys.SyncCodeBlock();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">  <span class="comment">//===========主要看看syncTask方法实现================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         6: getfield      #2             // Field i:I</span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        11: putfield      #2            // Field i:I</span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SyncCodeBlock.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们主要关注字节码中的如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>: monitorenter  <span class="comment">//进入同步方法</span></span><br><span class="line"><span class="comment">//..........省略其他  </span></span><br><span class="line"><span class="number">15</span>: monitorexit   <span class="comment">//退出同步方法</span></span><br><span class="line"><span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line"><span class="comment">//省略其他.......</span></span><br><span class="line"><span class="number">21</span>: monitorexit <span class="comment">//退出同步方法</span></span><br></pre></td></tr></table></figure>

<p>从字节码中可知同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置，当执行 monitorenter 指令时，当前线程将试图获取 objectref (即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即 monitorexit 指令被执行，执行线程将释放 monitor (锁)并设置计数器值为 0，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个 monitorexit 指令，它就是异常结束时被执行的释放 monitor 的指令。</p>
<h2 id="3-4-synchronized-方法底层原理"><a href="#3-4-synchronized-方法底层原理" class="headerlink" title="3.4 synchronized 方法底层原理"></a>3.4 synchronized 方法底层原理</h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM 可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有 monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放 monitor。在方法执行期间，执行线程持有了 monitor，其他任何线程都无法再获得同一个 monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的 monitor 将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap 反编译后的字节码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncMethod.class</span><br><span class="line">  Last modified <span class="number">2017</span>-<span class="number">6</span>-<span class="number">2</span>; size <span class="number">308</span> bytes</span><br><span class="line">  MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94</span><br><span class="line">  Compiled from <span class="string">&quot;SyncMethod.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">zejian</span>.<span class="title">concurrencys</span>.<span class="title">SyncMethod</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略没必要的字节码</span></span><br><span class="line">  <span class="comment">//==================syncTask方法======================</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    <span class="comment">//方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法</span></span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SyncMethod.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>从字节码中可以看出，synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是 synchronized 锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Java 6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下 Java 官方在 JVM 层面对 synchronized 锁的优化。</p>
<h1 id="4-JVM-对-synchronized-的优化"><a href="#4-JVM-对-synchronized-的优化" class="headerlink" title="4. JVM 对 synchronized 的优化"></a>4. JVM 对 synchronized 的优化</h1><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。然后我们来看一下锁的原理和膨胀（升级）过程。</p>
<p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片03.png"></p>
<h2 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1.偏向锁"></a>1.偏向锁</h2><p><strong>偏向锁的原理：</strong></p>
<p>偏向锁是 Java 6 之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<p><strong>偏向锁的升级：</strong></p>
<p>当线程 1 访问代码块并获取锁对象时，会在 java 对象头和栈帧中记录偏向的锁的 threadID，因为偏向锁不会主动释放锁，因此以后线程 1 再次获取锁的时候，需要比较当前线程的 threadID 和 Java 对象头中的 threadID 是否一致，如果一致（还是线程 1 获取锁对象），则无需使用 CAS 来加锁、解锁；如果不一致（其他线程，如线程 2 要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程 1 的 threadID），那么需要查看 Java 对象头中记录的线程 1 是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程 1，撤销偏向锁，升级为轻量级锁，如果线程 1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p>
<h2 id="2-轻量级锁与自旋锁"><a href="#2-轻量级锁与自旋锁" class="headerlink" title="2.轻量级锁与自旋锁"></a>2.轻量级锁与自旋锁</h2><p><strong>为什么要有轻量级锁？</strong></p>
<p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要 CPU 从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</p>
<p><strong>轻量级锁与自旋锁原理与锁升级过程：</strong></p>
<p>线程 1 获取轻量级锁时会先把锁对象的对象头 MarkWord 复制一份到线程 1 的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），然后使用 CAS 把对象头中的内容替换为线程 1 存储的锁记录（DisplacedMarkWord）的地址；</p>
<p>如果在线程 1 复制对象头的同时（在线程1 CAS 之前），线程 2 也准备获取锁，复制了对象头到线程 2 的锁记录空间中，但是在线程2 CAS 的时候，发现线程 1 已经把对象头换了，线程 2 的 CAS 失败，那么线程 2 就尝试使用自旋锁来等待线程 1 释放锁。 自旋锁简单来说就是让线程 2 在循环中不断 CAS</p>
<p>但是如果自旋的时间太长也不行，因为自旋是要消耗 CPU 的，因此自旋的次数是有限制的，比如 10 次或者 100 次，如果自旋次数到了线程 1 还没有释放锁，或者线程 1 还在执行，线程 2 还在自旋等待，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止 CPU 空转。</p>
<h2 id="3-几种锁的对比"><a href="#3-几种锁的对比" class="headerlink" title="3.几种锁的对比"></a>3.几种锁的对比</h2><p><img src="/2021/07/19/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/GitHub\MyBlogs\source_posts\2021-07-19-synchronized关键字\图片04.png" alt="在这里插入图片描述"></p>
<h1 id="5-如何保证原子性、有序性和可见性"><a href="#5-如何保证原子性、有序性和可见性" class="headerlink" title="5.如何保证原子性、有序性和可见性"></a>5.如何保证原子性、有序性和可见性</h1><h2 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h2><p><strong>原子性：</strong> 即一个操作或者多个操作 <strong>要么全部执行并且执行的过程不会被任何因素打断</strong>，要么就都<strong>不执行</strong>。</p>
<p><strong>实现方式：</strong>Java 内存模型提供了字节码指令<code>monitorenter</code>和<code>monitorexit</code>来隐式的使用这两个操作，在 synchronized 块之间的操作是具备原子性的。</p>
<p><strong>例：</strong>线程 1 在执行 monitorenter 指令的时候，会对 Monitor 进行加锁，加锁后其他线程无法获得锁，除非线程 1 主动解锁。即使在执行过程中，由于某种原因，比如 CPU 时间片用完，线程 1 放弃了 CPU，但是它并没有进行解锁。而由于 synchronized 的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。</p>
<h2 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h2><p><strong>有序性：</strong> 程序执行的顺序按照代码的先后顺序执行。</p>
<p><strong>实现方式：</strong>在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。但是 synchronized 提供了有序性保证，这其实和 as-if-serial 语义有关。<br>as-if-serial 语义是指不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的，由于 synchronized 修饰的代码，同一时间只能被同一线程访问。那么可以认为是单线程执行的。所以可以保证其有序性。</p>
<blockquote>
<p><strong>Note：</strong>需要注意的是<code>synchronized</code>虽然能够保证有序性，但是<code>无法禁止指令重排和处理器优化的</code>。</p>
</blockquote>
<h2 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3.可见性"></a>3.可见性</h2><p><strong>可见性：</strong> 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p><strong>实现方式：</strong>被<code>synchronized</code>修饰的代码，在开始执行时会加锁，执行完成后会进行解锁，但在一个变量解锁之前，必须先把此变量<code>同步回主存</code>中，这样解锁后，后续其它线程就可以访问到被修改后的值，从而保证可见性。</p>
<ul>
<li>获得锁之后，需要<strong>刷新处理器缓存</strong>，使得前面写线程所做的更新可以同步到本线程。 </li>
<li>释放锁需要<strong>冲刷处理器缓存</strong>，使得当前线程对共享数据的改变可以被推送到下一个线程处理器的高速缓冲中。</li>
</ul>
<h1 id="6-JVM-对-synchronized-内部锁的调度"><a href="#6-JVM-对-synchronized-内部锁的调度" class="headerlink" title="6. JVM 对 synchronized 内部锁的调度"></a>6. JVM 对 synchronized 内部锁的调度</h1><p><strong>先来看下 JVM 对锁这种资源的两种调度方式：公平调度和非公平调度。</strong></p>
<p><strong>1.公平调度方式</strong></p>
<p>按照<strong>申请的先后顺序</strong>授予资源的独占权。</p>
<ul>
<li>优点：线程申请资源所需的时间偏差较小；不会出现线程饥饿的现象；适合在资源的持有线程占用资源的时间相对长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。</li>
<li>缺点：吞吐率较小 </li>
</ul>
<p><strong>2.非公平调度方式</strong></p>
<p>在该策略中，资源的持有线程释放该资源的时候，等待队列中一个线程会被唤醒，而该线程从被唤醒到其继续执行可能需要一段时间。在该段时间内，<strong>新来的线程（活跃线程）</strong>可以先被授予该资源的独占权。</p>
<p>如果新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续执行前释放相应的资源，从而不影响该被唤醒的线程申请资源。</p>
<ul>
<li>优点：吞吐率较高，单位时间内可以为更多的申请者调配资源 </li>
<li>缺点：资源申请者申请资源所需的时间偏差可能较大，并可能出现线程饥饿的现象 </li>
</ul>
<p><strong>JVM 对 synchronized 内部锁的调度：</strong></p>
<p>JVM 对内部锁的调度是一种<strong>非公平的调度方式</strong>，JVM 会给每个内部锁分配一个<strong>入口集（Entry Set）</strong>，用于记录等待获得相应内部锁的线程。当锁被持有的线程释放的时候，该锁的入口集中的任意一个线程将会被唤醒，从而得到再次申请锁的机会。被唤醒的线程等待占用处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放的锁。也就是并不是先到先得的顺序。</p>
<h1 id="7-synchronized-和-ReentrantLock-的区别"><a href="#7-synchronized-和-ReentrantLock-的区别" class="headerlink" title="7. synchronized 和 ReentrantLock 的区别"></a>7. synchronized 和 ReentrantLock 的区别</h1><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReentrantLock 首先是使用更加灵活了，synchronized 的锁定粒度比较大，在方法层面，而 ReentrantLock 能够锁定任意的代码区域。并且 ReentrantLock 增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><p><strong>ReentrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p>
</li>
<li><p><strong>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</p>
</li>
<li><p>synchronized 关键字与 wait() 和 notify()/notifyAll() 方法相结合可以实现等待/通知机制，ReentrantLock 类当然也可以实现，但是需要借助于Condition接口与 newCondition() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll() 方法 只会唤醒注册在该 Condition 实例中的所有等待线程。</p>
</li>
<li><p><strong>附加：</strong>ReentrantLock 提供了一个 tryLock 方法，该方法尝试获取锁，成功的话返回 true ，失败的话不会导致尝试获取锁的线程暂停而是返回 false，可以避免死锁。（起预判作用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deathLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//如果获取成功则执行业务逻辑，如果获取失败，则释放lock1的锁，自旋重新尝试获得锁</span></span><br><span class="line">                            <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;Thread1：已成功获取 lock1 and lock2 ...&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock2.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock1.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread1：获取锁失败，重新获取---&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//防止发生活锁</span></span><br><span class="line">                        TimeUnit.NANOSECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock2.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//如果获取成功则执行业务逻辑，如果获取失败，则释放lock2的锁，自旋重新尝试获得锁</span></span><br><span class="line">                            <span class="keyword">if</span> (lock1.tryLock()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;Thread2：已成功获取 lock2 and lock1 ...&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    lock1.unlock();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock2.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2：获取锁失败，重新获取---&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//防止发生活锁</span></span><br><span class="line">                        TimeUnit.NANOSECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            deathLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例启动两个线程。线程1首先获取lock1的锁，然后再获取lock2的锁；线程2首先获取lock2的锁，然后再获取lock1的锁。这样如果这时线程1获得了lock1的锁，同时线程2获得lock2的锁，然后线程1尝试去获得lock2的锁，线程2尝试获得线程1的锁，就会造成死锁。</p>
<p>我们这里使用 tryLock 来获取两个锁，如果一个线程不能同时获取两把锁，那么就回退并自旋重新尝试（使用 while 循环）。</p>
</li>
</ul>
<p><strong>应该怎么选择这两种锁：</strong></p>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据和空间限制与系统设计题目汇总</title>
    <url>/2021/07/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="海量数据处理例题"><a href="#海量数据处理例题" class="headerlink" title="海量数据处理例题"></a>海量数据处理例题</h1><h2 id="1-如何从大量的-URL-中找出相同的-URL？"><a href="#1-如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="1.如何从大量的 URL 中找出相同的 URL？"></a>1.如何从大量的 URL 中找出相同的 URL？</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。</p>
<h3 id="思路一（分治-HashSet）"><a href="#思路一（分治-HashSet）" class="headerlink" title="思路一（分治+HashSet）"></a>思路一（分治+HashSet）</h3><p><strong>分析：</strong></p>
<p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。</p>
<p>对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p>
<p><strong>思路：</strong></p>
<p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, …, a<sub>999</sub>，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b<sub>0</sub>, b<sub>1</sub>, b<sub>2</sub>, …, b<sub>999</sub> 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a<sub>0</sub> 对应 b<sub>0</sub>, …, a<sub>999</sub> 对应 b<sub>999</sub>， 。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。（这里要注意因为使用的是 Hash，所以不同对中一定没有相同的元素）</p>
<p>接着遍历 a<sub>i</sub>( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 b<sub>i</sub> 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p>
<h3 id="思路二（分治-前缀树）"><a href="#思路二（分治-前缀树）" class="headerlink" title="思路二（分治+前缀树）"></a>思路二（分治+前缀树）</h3><p>在比较每一对中是否有相同元素的时候，可以通过前缀树来比较，因为一般而言，URL 的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>这种数据结构来进行存储。</p>
<p>字典树的优势：<strong>降低存储成本的同时，提高查询效率</strong>。</p>
<h2 id="2-如何从大量数据中找出高频词？"><a href="#2-如何从大量数据中找出高频词？" class="headerlink" title="2.如何从大量数据中找出高频词？"></a>2.如何从大量数据中找出高频词？</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。</p>
<h3 id="思路一（分治-HashMap-小顶堆）"><a href="#思路一（分治-HashMap-小顶堆）" class="headerlink" title="思路一（分治+HashMap+小顶堆）"></a>思路一（分治+HashMap+小顶堆）</h3><p><strong>分析：</strong></p>
<p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。</p>
<p><strong>思路：</strong></p>
<p>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 a<sub>i</sub> 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。</p>
<p>接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。</p>
<p>上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</p>
<h2 id="3-如何在大量的数据中找出不重复的整数？"><a href="#3-如何在大量的数据中找出不重复的整数？" class="headerlink" title="3.如何在大量的数据中找出不重复的整数？"></a>3.如何在大量的数据中找出不重复的整数？</h2><h3 id="方案（BitMap-布隆过滤器）"><a href="#方案（BitMap-布隆过滤器）" class="headerlink" title="方案（BitMap+布隆过滤器）"></a>方案（BitMap+布隆过滤器）</h3><p><strong>BitMap 介绍：</strong></p>
<p>布隆过滤器是基于 BitMap+Hash 实现的。</p>
<p>Bit-map 的基本思想就是用一个 bit 位来标记某个元素对应的 Value，而 Key 即是该元素。由于采用了 Bit 为单位来存储数据，因此在存储空间方面，可以大大节省。（PS：划重点 <strong>节省存储空间</strong>）</p>
<p>假设有这样一个需求：在 20 亿个随机整数中找出某个数 m 是否存在其中，并假设 32 位操作系统，4G 内存</p>
<p>在 Java 中，int 占 4 字节，1字节=8位（1 byte = 8 bit）</p>
<p>如果每个数字用 int 存储，那就是 20 亿个 int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈<strong>7.45</strong>G</p>
<p>如果按位存储就不一样了，20 亿个数就是 20 亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈<strong>0.233</strong>G</p>
<p>那么，问题来了，如何表示一个数呢？</p>
<p>刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制</p>
<p>这样我们可以很容易表示 {1,2,4,6} 这几个数：</p>
<p><img src="/2021/07/16/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/GitHub\MyBlogs\source_posts\2021-07-16-大数据和空间限制与系统设计题目汇总\图片01.png" alt="img"></p>
<p><strong>适用场景：</strong>海量数据中的数据重复问题，像消息过滤啥的。</p>
<h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p>不安全网页的黑名单包含 100 亿个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一种网页过滤系统，可以根据网页的 URL 判断该网页是否在黑名单上，如何设计该系统。</p>
<p><strong>要求：</strong>允许有万分之一以下的判断失误率；使用的额外空间不能超过 30GB</p>
<p><strong>分析：</strong>我们可以选择用 <strong>HashMap或者数据库</strong> 来将 100 亿个 url 都保存下来，但是这样至少需要 640GB 的内存空间，并且允许一定程度的失误率，所以考虑使用 BitMap，或者说布隆过滤器。</p>
<p><strong>总结：</strong>如果遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，并且系统容忍一定程度的失误率以及对空间要求比较严格，那么需要用<strong>布隆过滤器（BitMap）</strong>来解答。布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。但是想做到完全正确是不可能的。布隆过滤器的优势就在于使用很少的空间就可以将准确率做到很高的程度。</p>
<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><p>32 位无符号整数的范围是 0~4294967295，现在正好有一个包含 40 亿个无符号整数的文件，所有在文件中没有出现过的数。</p>
<p><strong>Q1：</strong>最多使用1GB，找到所有没出现过的数。</p>
<p><strong>分析：</strong>如果 40 亿个数都不同，则哈希表记录数为 40 亿条，所需要空间 40亿×4B=16GB，显然不符合要求。</p>
<p><strong>解决办法：</strong>由于哈希表需要占用很多空间，因此可以使用 BitMap 的方式来表示数出现的情况。即申请一个长度为 4294967295 的 bit 类型的数组bitArr，bitArr 上每一个位置只可以表示0或1。由于 1B=8bit，所以 4294967295 个 bit 占用空间为 500MB。遍历完成后，<strong>再遍历一遍，发现哪个位置上的值不是1，就说明这个数不在 40 亿个数中。</strong></p>
<p><strong>Q2：</strong>最多使用1GB，找出所有出现了两次的数。</p>
<p><strong>解决办法：</strong>使用 BitMap 的方式来表示数出现的情况，即申请一个<strong>长度为 4294967295×2 的 bit 类型的数组 bitArr</strong>，由于 1B=8bit，所以所以 4294967295 ×  2 个 bit 占用空间为1GB。遍历这40亿个数，如果第一次遇到 num，就把 bitArr[num * 2+1] 和 bitArr[num * 2] 设置为 01，第二次设置为 10，第三次设置为 11，之后就不再管了。然后依次遍历 bitArr，如果发现 bitArr[num * 2+1] 和 bitArr[num * 2] 为 10，那么i就是出现了两次的数。</p>
<p><strong>Q3：</strong>最多使用 10MB，只用找到一个没出现过的数即可。</p>
<p><strong>解决办法：</strong>将 0~4294967295 区间平均分成 64 个区间，每个区间是 67108864 个数，由于只有 40 亿个数，因此至少有一个区间上的计数少于 67108864。</p>
<p>第一次遍历：申请长度为 64 的整形数组 countArr[0…63]，<strong>countArr[i] 表示区间i上的数有多少个</strong>。例如，遍历到 3422552090 时， 3422552090/67108864=51，因此 countArr[51]++。遍历完 40 亿个数之后，一定存在 count[i] 小于 67108864，找到第一个 i 即可。此时内存为 64×4B。</p>
<p>第二次遍历：假设第一步的 i=37。申请<strong>长度为 67108864 的 bit map</strong>，内存大小大约为 8MB，记为 bitArr[0…67108863]。然后再遍历一次 40 亿个数，此时只关注落在第 37 区间的数，即满足 num/67108864=37的num。然后将 bitArr[num  - 67108864*37]=1，然后遍历 bitArr，找到 bitArr[i] 不等于 1 的 i 值，然后 67108864×37+i 就是第一个没出现过的数。</p>
<h2 id="4-最多使用-10MB，找到-40-亿个整数的中位数。"><a href="#4-最多使用-10MB，找到-40-亿个整数的中位数。" class="headerlink" title="4.最多使用 10MB，找到 40 亿个整数的中位数。"></a>4.最多使用 10MB，找到 40 亿个整数的中位数。</h2><h3 id="思路一（分治）"><a href="#思路一（分治）" class="headerlink" title="思路一（分治）"></a>思路一（分治）</h3><p>长度为 2MB 的无符号整型数组占用的空间为 8MB，所以将区间的数量定位 4294967295/2M=2148 个。申请一个长度为 2148 的无符号整型数组 arr[0…2147]，arr[i] 表示第i区间有多少个数。然后遍历这 40 亿个数，将对应的进行 arr[num/2M]++ 操作，然后累加每个区间的出现次数，如果 0~K-1 区间上的数的个数为 19.998 亿，但是当加上第 K 个区间上的数的个数后就超过了 20 亿，因此第 20 亿个数是第K区间上第 0.002 亿个数。</p>
<p>然后申请一个长度为 2MB 的无符号整型数组 countArr[0…2M-1]，占用空间是 8MB。然后遍历这 40 亿个数，只对第 K 区间的数做统计，countArr[numi - K * 2M]++，然后只在第K区间上找到第 0.002 亿个数即可。</p>
<h3 id="思路二（双堆法）"><a href="#思路二（双堆法）" class="headerlink" title="思路二（双堆法）"></a>思路二（双堆法）</h3><p>维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数<strong>小于等于</strong>小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。</p>
<p>若数据总数为<strong>偶数</strong>，当这两个堆建好之后，<strong>中位数就是这两个堆顶元素的平均值</strong>。当数据总数为<strong>奇数</strong>时，根据两个堆的大小，<strong>中位数一定在数据多的堆的堆顶</strong>。</p>
<h1 id="海量数据处理方法总结"><a href="#海量数据处理方法总结" class="headerlink" title="海量数据处理方法总结"></a>海量数据处理方法总结</h1><h2 id="1-Bloom-filter（布隆过滤器）"><a href="#1-Bloom-filter（布隆过滤器）" class="headerlink" title="1.Bloom filter（布隆过滤器）"></a>1.Bloom filter（布隆过滤器）</h2><p><strong>原理：</strong>上面有</p>
<p><strong>适用场景：</strong>可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<h2 id="2-哈希"><a href="#2-哈希" class="headerlink" title="2.哈希"></a>2.哈希</h2><p><strong>原理：</strong>哈希函数</p>
<p><strong>适用场景：</strong>快速查找，删除的基本数据结构，还可以通过 HashMap 进行频率的统计等，通常需要总数据量可以放入内存</p>
<h2 id="3-位数组"><a href="#3-位数组" class="headerlink" title="3.位数组"></a>3.位数组</h2><p><strong>原理：</strong>上面有</p>
<p><strong>适用场景：</strong>可进行数据的快速查找，判重（判断元素是否存在），删除</p>
<h2 id="4-分治"><a href="#4-分治" class="headerlink" title="4.分治"></a>4.分治</h2><p><strong>原理：</strong>将数据交给不同的机器去处理，数据划分，结果归约</p>
<p><strong>适用场景：</strong>通常是大量的数据不能放入内存中的情况，分成多个小文件，最后再整合处理</p>
<h1 id="系统设计问题"><a href="#系统设计问题" class="headerlink" title="系统设计问题"></a>系统设计问题</h1>]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>场景题</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁问题</title>
    <url>/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1.死锁的概念"></a>1.死锁的概念</h1><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<h1 id="2-死锁产生的必要条件"><a href="#2-死锁产生的必要条件" class="headerlink" title="2.死锁产生的必要条件"></a>2.死锁产生的必要条件</h1><p>线程死锁的发生离不开下面四个条件：</p>
<ol>
<li><strong>互斥条件：</strong>该资源任意一个时刻只由一个线程占用。只有互斥使用的资源才会导致死锁（如打印机设备），像内存、扬声器这种可以让多个进程共享使用的资源不可能造成死锁（因为进程不用阻塞等待）。</li>
<li><strong>请求与保持条件：</strong>已经得到了某个资源的进程可以再请求新的资源，但是新的资源被其它进程占用，此时进程阻塞，但是又对已获得的资源保持不放。</li>
<li><strong>不剥夺条件：</strong>线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后主动释放资源。</li>
<li><strong>循环等待条件：</strong>存在一种进程资源的循环等待链，链中的每一个进程已经获得的资源同时被下一个进程所请求。</li>
</ol>
<blockquote>
<p><strong>Note：</strong>发生死锁一定有循环等待关系，但是有循环等待关系不一定发生死锁，有同类型的资源可满足其中一个进程的需求时。</p>
</blockquote>
<h1 id="3-死锁的处理策略"><a href="#3-死锁的处理策略" class="headerlink" title="3.死锁的处理策略"></a>3.死锁的处理策略</h1><ol>
<li>预防死锁：破坏死锁产生的四个必要条件中的一个或几个；</li>
<li>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）；</li>
<li>死锁的检测和接触：允许死锁的发生，不过操作系统会检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<p>前两种方式不会产生死锁，但是最后一种会产生，产生之后再解决。</p>
<h2 id="3-1预防死锁"><a href="#3-1预防死锁" class="headerlink" title="3.1预防死锁"></a>3.1预防死锁</h2><p>核心思想：破坏死锁产生的四个必要条件</p>
<ol>
<li><p><strong>破坏互斥条件：</strong>将原来的互斥使用的资源，通过 SPOOLing 技术改造成共享资源，其实是将请求放到了输出进程中，然后请求进程可以继续向下执行的一种策略，且在并发请求的进程看来，好像资源是可以共享的。</p>
<p>但是并不是所有的资源都可以这样改造，所以应用比较少。</p>
</li>
<li><p><strong>不可剥夺条件：</strong></p>
<p>方案一：当某个进程请求新的资源得不到满足时，他必须立刻释放保持的所有资源，待以后需要时再申请，也就是某些资源还没使用完，也要主动释放，这就破坏了不可剥夺条件；</p>
<p>方案二：当某个进程需要的资源被其它进程所占用的时候，可以根据优先级由操作系统配合将低优先级进程的资源剥夺给高优先级的进程使用。</p>
</li>
<li><p><strong>破坏请求与保持条件：</strong>一次性申请所有的资源。比如使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。<strong>（即加大锁的粒度）</strong></p>
</li>
<li><p><strong>破坏循坏等待条件：</strong>可以采用顺序资源分配法，首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完。这样一个进程只有已占有小编号的资源时，才有资格去申请大编号的资源，已经持有大编号资源的进程不可能逆向地回来申请小编号资源，就不会产生循环等待的问题。</p>
<p>但是如果系统有新增资源，就可能需要重新分配所有编号；进程实际使用资源顺序可能和编号递增顺序不一致，可能造成资源浪费；必须按照次序申请资源，造成编程复杂。</p>
</li>
</ol>
<h2 id="3-2避免死锁"><a href="#3-2避免死锁" class="headerlink" title="3.2避免死锁"></a>3.2避免死锁</h2><h3 id="1-安全序列与安全状态"><a href="#1-安全序列与安全状态" class="headerlink" title="1.安全序列与安全状态"></a>1.安全序列与安全状态</h3><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片01.png" alt="img"></p>
<p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和  A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>所谓的安全序列就是指，如果系统按照这种序列分配资源，每个进程都能顺利完成，只要能找到一个安全序列，系统就是安全状态。当然安全序列可以有多个。</p>
<p>但是如果分配了资源以后，系统找不出任何一个安全序列，系统就进入了不安全状态，这就意味着所有进程无法执行下去。当然不排除有些进提前释放了资源，回到安全状态，但是我们一般考虑到最坏的情况。</p>
<h3 id="2-安全状态与死锁的关系"><a href="#2-安全状态与死锁的关系" class="headerlink" title="2.安全状态与死锁的关系"></a>2.安全状态与死锁的关系</h3><p>如果系统处于安全状态，就一定不会发生死锁，如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但是发生死锁一定是不安全状态）</p>
<p>因此可以在系统分配资源之前预判是否会使系统进入不安全状态，以此决定是否分配请求，这也是“银行家算法”的核心思想。</p>
<h3 id="3-单个资源的银行家算法"><a href="#3-单个资源的银行家算法" class="headerlink" title="3.单个资源的银行家算法"></a>3.单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片02.png" alt="img"></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h3 id="4-多个资源的银行家算法"><a href="#4-多个资源的银行家算法" class="headerlink" title="4.多个资源的银行家算法"></a>4.多个资源的银行家算法</h3><p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片03.png" alt="img"></p>
<blockquote>
<p>将资源变成向量的形式。</p>
</blockquote>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A  分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1，0，2，0)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h2 id="3-3死锁的检测与解除"><a href="#3-3死锁的检测与解除" class="headerlink" title="3.3死锁的检测与解除"></a>3.3死锁的检测与解除</h2><h3 id="1-死锁的检测"><a href="#1-死锁的检测" class="headerlink" title="1.死锁的检测"></a>1.死锁的检测</h3><p><strong>1.每种类型一个资源的死锁检测</strong></p>
<p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片04.png" alt="img"></p>
<p>上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。</p>
<p>图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p>
<p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<p><strong>2.每种类型多个资源的死锁检测</strong></p>
<p><img src="/2021/07/15/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/GitHub\MyBlogs\source_posts\2021-07-15-死锁问题\图片05.png" alt="img"></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果没有这样一个进程，算法终止。</li>
</ol>
<h3 id="2-死锁的恢复"><a href="#2-死锁的恢复" class="headerlink" title="2.死锁的恢复"></a>2.死锁的恢复</h3><p>检测到死锁的存在，并不是说系统中所有的进程都是死锁进程。</p>
<ol>
<li><strong>资源剥夺法：</strong>挂起某些死锁进程，并抢占它的资源，将这些资源分配给其它的死锁进程，但是也要防止被挂起的进程长时间得不到资源而饥饿；</li>
<li><strong>撤销进程法：</strong>强制撤销所有的死锁进程，并剥夺这些进程的资源，这种方式实现比较简单，但是代价比较大，可能有些资源已经接近完成，最后被撤销。</li>
<li><strong>进程回退法：</strong>让一个进程回退到之前的一种状态，可以阻止死锁的时候，可以将资源先给其它进程，这就要求系统记录还原点。</li>
</ol>
<p>如何决定对谁动手？</p>
<ol>
<li>进程优先级</li>
<li>已执行时间</li>
<li>还要多久完成</li>
<li>进程使用的资源数量</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<h1 id="4-线程的活性故障"><a href="#4-线程的活性故障" class="headerlink" title="4.线程的活性故障"></a>4.线程的活性故障</h1><p>线程的活性故障是由于资源的稀缺性或者程序自身的问题导致线程<strong>一直处于非Runnable状态</strong>，并且其处理的任务<strong>一直无法完成的现象</strong>被称为是线程活性故障。常见的线程活性故障包括<strong>死锁，锁死，活锁与线程饥饿</strong>。</p>
<p><strong>解析：</strong>每一个线程都有其特定的任务处理逻辑。由于资源的稀缺性或者资源本身的一些特性，导致多个线程需要共享一些排他性资源，比如说处理器，数据库连接等。当出现资源争用的时候，部分线程会进入等待状态。</p>
<h2 id="4-1线程锁死与死锁"><a href="#4-1线程锁死与死锁" class="headerlink" title="4.1线程锁死与死锁"></a>4.1线程锁死与死锁</h2><p><strong>1.线程锁死的外部表现，以及与死锁的区别</strong></p>
<p>线程锁死是指等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务 一直无法进展。</p>
<p>线程死锁和线程锁死的外部表现是一致的，即故障线程一直处于非运行状态使得其所执行的任务没有进展。但是锁死的产生条件和线程死锁不一样，即使产生死锁的4个必要条件都没有发生，线程锁死仍然可能已经发生。</p>
<p><strong>2.线程锁死发生的几种情况</strong></p>
<ul>
<li><p><strong>信号丢失锁死</strong></p>
<p>信号丢失锁死是因为没有对应的通知线程来将等待线程唤醒，导致等待线程一直处于等待状态。</p>
<p><strong>典型例子</strong>是等待线程在执行Object.wait( )/Condition.await( )前<strong>没有对保护条件进行判断，而此时保护条件实际上可能已经成立</strong>，此后可能并无其他线程更新相应保护条件涉及的共享变量使其成立并通知等待线程，这就使得等待线程一直处于等待状态，从而使其任务一直无法进展。</p>
</li>
<li><p><strong>嵌套监视器锁死</strong></p>
<p>嵌套监视器锁死是由于嵌套锁导致等待线程永远无法被唤醒的一种故障。</p>
<p>比如一个线程，只释放了内层锁Y.wait()，但是没有释放外层锁X; 但是通知线程必须先获得外层锁X，才可以通过 Y.notifyAll()来唤醒等待线程，这就导致出现了嵌套等待现象。</p>
</li>
</ul>
<h2 id="4-2线程活锁与死锁"><a href="#4-2线程活锁与死锁" class="headerlink" title="4.2线程活锁与死锁"></a>4.2线程活锁与死锁</h2><p><strong>1.线程活锁的概念</strong></p>
<p>线程活锁是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的 CPU 时间。</p>
<p><strong>2.线程活锁与死锁的区别</strong></p>
<p>活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是一直在不断改变的，活锁不会被阻塞，而是不停检测一个永远不可能为真的条件。除去进程本身持有的资源外，活锁状态的进程会持续耗费宝贵的 CPU 时间。活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行。</p>
<h2 id="4-3线程饥饿与死锁"><a href="#4-3线程饥饿与死锁" class="headerlink" title="4.3线程饥饿与死锁"></a>4.3线程饥饿与死锁</h2><p><strong>1.线程饥饿的概念</strong></p>
<p>饥饿是指如果线程 T1 占用了资源 R，线程 T2 又请求锁 R，于是 T2 等待。T3 也请求资源 R，当 T1 释放了 R 上的封锁后，系统首先批准了 T3 的请求，T2 仍然等待。然后 T4 又请求封锁 R，当 T3 释放了 R 上的封锁之后，系统又批准了 T4 的请求……，T2 可能永远等待。</p>
<p>这也就是 ReentrantLock 显示锁里提供的不公平锁机制（当然了，ReentrantLock 也提供了公平锁的机制，由用户根据具体的使用场景而决定到底使用哪种锁策略），不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿。</p>
<p><strong>2.线程饥饿与死锁活锁的区别</strong></p>
<p>进程会处于饥饿状态是因为持续地有其它优先级更高的进程请求相同的资源。不像死锁或者活锁，饥饿能够被解开。例如，当其它高优先级的进程都终止时并且没有更高优先级的进程到达。</p>
<h2 id="4-4线程活性故障总结"><a href="#4-4线程活性故障总结" class="headerlink" title="4.4线程活性故障总结"></a>4.4线程活性故障总结</h2><ul>
<li>线程饥饿发生时，如果线程处于可运行状态，也就是其一直在申请资源，那么就会转变为活锁 </li>
<li>只要存在一个或多个线程因为获取不到其所需的资源而无法进展就是线程饥饿，所以线程死锁、活锁其实也算是线程饥饿 </li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统相关</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）优惠券系统-系统通用组件搭建</title>
    <url>/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-SpringCloud-四大组件"><a href="#1-SpringCloud-四大组件" class="headerlink" title="1. SpringCloud 四大组件"></a>1. SpringCloud 四大组件</h1><h2 id="1-1-Eureka"><a href="#1-1-Eureka" class="headerlink" title="1.1 Eureka"></a>1.1 Eureka</h2><h3 id="Eureka-的组成"><a href="#Eureka-的组成" class="headerlink" title="Eureka 的组成"></a>Eureka 的组成</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片01.png" style="zoom: 50%;">

<p>Eureka 可以分成两大部分：Server 与 Client。</p>
<p>Client 的四个基本功能有：</p>
<ol>
<li><p>服务注册：客户端Client 在启动后，向配置的 服务端Server 发起注册，把自身信息提供给 Server。</p>
</li>
<li><p>心跳续约：Client 和 Server 之间维护的一个定时心跳（Eureka 发起的主动操作 （Client ping Server）），表示还在存活着。</p>
</li>
<li><p>下线：EurekaClient 关闭后，向 Server 发起通知，Server 把信息清理掉。</p>
</li>
<li><p>获取服务注册信息：Eureka Client 之间相互调用，需要知道不同的 Eureka 之间的源信息。从 Eureka Server 中获取。</p>
</li>
</ol>
<h3 id="Eureka-的工作原理"><a href="#Eureka-的工作原理" class="headerlink" title="Eureka 的工作原理"></a>Eureka 的工作原理</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片02.png" style="zoom:67%;">

<p>上图中我们首先会启动一个或多个 Eureka server，这些 eureka server 同步保留着所有的服务信息。然后我们启动不同的 eureka client，向服务端发起服务注册和服务查询。<strong>不论我们是向那个 eureka server 进行的注册，最终都会同步给所有配置好的 eureka server。我们获取的服务信息，也同样都是一致的。</strong></p>
<p>要知道 Eureka 与 Zookeeper 的对比，参考《SpringCloud相关》</p>
<p><strong>Eureka Server 是怎么存储服务元信息的：</strong></p>
<p>通过一个两层的 HashMap 来存储</p>
<ul>
<li>第一层的 HashMap：Key 存放的是<strong>应用的名称</strong>，每个微服务都是一个应用，一个应用中可以包含多个实例</li>
<li>第二层的 HashMap：Key 存放的是<strong>实例的名称</strong>，Value 存放实例的地址，比如实例的 IP、端口号、状态信息等</li>
</ul>
<h3 id="Eureka-模块搭建"><a href="#Eureka-模块搭建" class="headerlink" title="Eureka 模块搭建"></a>Eureka 模块搭建</h3><p><strong>1.搭建父模块</strong></p>
<p>修改 pom.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 子模块，新建model后会自动生成 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 项目的打包类型, 即项目的发布形式, 默认为 jar. 对于聚合项目的父模块来说, 必须指定为 pom --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- springCloud 也是基于Springboot开发，引入springboot 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- SpringCloud版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok 工具通过在代码编译时期动态的将注解替换为具体的代码,</span></span><br><span class="line"><span class="comment">       IDEA 需要添加 lombok 插件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 测试用例依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 标识springcloud版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置远程仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.搭建 coupon-eureka 模块</strong></p>
<p>修改 pom.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块名及描述信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>coupon-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Cloud Eureka For Coupon<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- eureka server: 提供服务发现与服务注册 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将</span></span><br><span class="line"><span class="comment">        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.编写一个应用启动类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//标识为一个EurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//标识是一个SpringBoot应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.配置 EurekaServer：</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 标识是否从 Eureka Server 获取注册信息, 默认是 true. 如果这是一个单节点的 Eureka Server</span></span><br><span class="line"><span class="comment">    # 不需要同步其他节点的数据, 设置为 false</span></span><br><span class="line">    <span class="meta">fetch-registry</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 是否将自己注册到 Eureka Server, 默认是 true. 由于当前应用是单节点的 Eureka Server</span></span><br><span class="line"><span class="comment">    # 需要设置为 false</span></span><br><span class="line">    <span class="meta">register-with-eureka</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # 设置 Eureka Server 所在的地址, 查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p><strong>5.启动 springboot 程序，测试 Eureka Server：</strong></p>
<p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片03.png"></p>
<h3 id="集群-Eureka-Server-模块搭建"><a href="#集群-Eureka-Server-模块搭建" class="headerlink" title="集群 Eureka Server 模块搭建"></a>集群 Eureka Server 模块搭建</h3><p>除了新建一个与上面相同的 Eureka Server 应用之外，最主要的区别就是修改配置文件：</p>
<p><strong>1.修改配置文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点1</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server1</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8000</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server1</span></span><br><span class="line"><span class="comment">    #是否允许一台机器部署多个实例</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line"><span class="comment">      #实现相互注册，配置集群其它节点的地址</span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server2:8001/eureka/,http://server3:8002/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="comment">#节点2</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server2</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8001</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server2</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/,http://server3:8002/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="comment">#节点3</span></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-eureka</span></span><br><span class="line">  <span class="attr">profiles</span>: <span class="string">server3</span></span><br><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">8002</span></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">instance</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">server3</span></span><br><span class="line">    <span class="meta">prefer-ip-address</span>: <span class="string">false</span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/,http://server2:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<p>注意：bootstrap.yml 比 application.yml 优先级要高，也就是优先根据这个配置来</p>
<p><strong>2.配置 hosts 文件</strong></p>
<p>windows 系统，打开路径 <strong>C:\Windows\System32\drivers\etc，</strong>修改配置文件添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1  server1</span><br><span class="line">127.0.0.1  server2</span><br><span class="line">127.0.0.1  server3</span><br></pre></td></tr></table></figure>

<p><strong>3.执行 maven 命令打包</strong></p>
<p>a.打开 idea 终端页面：</p>
<ul>
<li><p>方法一：在IDEA中点击view→tool window→Terminal即可开启</p>
</li>
<li><p>方法二：按住ALT+F12(如果是笔记本按不出来的话再加个Fn键)</p>
</li>
</ul>
<p>打开 idea terminal 窗口，切换到<code>根路径</code>：F:\2021JOB\0-javaguide面经v4\JavaGuide\7 Spring Cloud微服务实战 打造企业级优惠券系统 \imooc-coupon&gt;（就是项目的根目录）</p>
<p>执行指令将 Eureka Server 服务进行打包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true -U</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片04.png"></p>
<p>打包后在 coupon-eureka 模块下能看到相关 jar 包</p>
<p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片05.png"></p>
<p>b.选择性的使用配置文件 bootstrap.yml 部分属性运行 jar 包：</p>
<p>前两个窗口报错正常（因为还没启动第二、三个 server），第三个 server 不应该报错。</p>
<p>e.1 第一个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打包：mvn clean package -Dmaven.test.skip&#x3D;true -U</span><br><span class="line"></span><br><span class="line">切换目录：</span><br><span class="line">cd coupon-eureka\target</span><br><span class="line"></span><br><span class="line">启动服务：</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server1</span><br></pre></td></tr></table></figure>

<p>e.2 打开第二个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd coupon-eureka\target</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server2</span><br></pre></td></tr></table></figure>

<p>e.3 打开第三个 ideaterminal 窗口，切到 coupon-eureka 的 target 路径下（jar 包路径）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd coupon-eureka\target</span><br><span class="line">java -jar coupon-eureka-1.0-SNAPSHOT.jar --spring.profiles.active&#x3D;server3</span><br></pre></td></tr></table></figure>

<p>上边步骤完成后，eureka 集群已经起来了，浏览器分别输入：<a href="http://server1:8001，http://server2:8002，http://server3:8003">http://server1:8001，http://server2:8002，http://server3:8003</a> 访问即可</p>
<p>以下是访问 <a href="http://localhost:8001/">http://localhost:8001/</a> 端口的 Eureka 界面，也就是集群中 Server2 的注册中心界面：</p>
<img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片06.png" alt="img" style="zoom: 67%;">

<p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片07.png" alt="img"></p>
<p>界面内容的解释：</p>
<ul>
<li><strong>System Status</strong>：系统状态信息，包含启动时间，当前时间，数据中心，环境</li>
<li><strong>Ds Replicas：</strong>父本，说明该服务器从哪里同步数据，如上图，从 server2 和 server3 同步数据</li>
<li><strong>Instances currently registered with Eureka：</strong>当前实例注册到 eureka 的信息（如上图，有三个 server）</li>
<li><strong>General Info：</strong>通用信息，关于 eureka 的一些信息采集信息</li>
<li><strong>instance info：</strong> 当前实例信息</li>
</ul>
<h2 id="1-2-Zuul"><a href="#1-2-Zuul" class="headerlink" title="1.2 Zuul"></a>1.2 Zuul</h2><h3 id="Zuul-的过滤器"><a href="#Zuul-的过滤器" class="headerlink" title="Zuul 的过滤器"></a>Zuul 的过滤器</h3><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片08.png" alt="img" style="zoom: 80%;">

<p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code></p>
<ol>
<li>pre filters 前置过滤器：在请求到达路由之前调用，进行身份验证，在集群中选择微服务，记录调试信息等。</li>
<li>routing filters 路由过滤器：将请求路由到微服务，用于构建发送给微服务请求。</li>
<li>post filters 后置过滤器：在请求路由到微服务以后执行，可以为响应添加标准的 HTTP header, 收集统一信息和指标，将响应从微服务发送给客户端。</li>
<li>error fiilters 异常处理过滤器：任何阶段执行发生了错误，都会调用。</li>
<li>custom filters 自定义过滤器：我们为了满足一些特定的需求，而自己定义的过滤器。例如 TokenFilter、RateLimiterFilter 等。</li>
</ol>
<p><strong>自定义过滤器实现的四个方法。四个抽象方法：</strong></p>
<ul>
<li><p>filterType：对应 Zuul 生命周期的四个阶段：pre、post、route 和 error </p>
</li>
<li><p>filterOrder：过滤器的优先级，数字越小，优先级越高</p>
</li>
<li><p>shouldFilter：方法返回 boolean 类型，true 时表示是否执行该过滤器的 run 方法，false 则表示不执行</p>
</li>
<li><p>run：过滤器的过滤逻辑</p>
</li>
</ul>
<h3 id="Zuul-模块搭建"><a href="#Zuul-模块搭建" class="headerlink" title="Zuul 模块搭建"></a>Zuul 模块搭建</h3><p><strong>1.修改 pom.xml 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc-coupon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.coupon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>coupon-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 模块名及描述信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>coupon-gateway<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Cloud Gateway For Coupon<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Eureka 客户端, 客户端向 Eureka Server 注册的时候会提供一系列的元数据信息, 例如: 主机, 端口, 健康检查url等</span></span><br><span class="line"><span class="comment">            Eureka Server 接受每个客户端发送的心跳信息, 如果在某个配置的超时时间内未接收到心跳信息, 实例会被从注册列表中移除</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 服务网关 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- apache 工具类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        SpringBoot的Maven插件, 能够以Maven的方式为应用提供SpringBoot的支持，可以将</span></span><br><span class="line"><span class="comment">        SpringBoot应用打包为可执行的jar或war文件, 然后以通常的方式运行SpringBoot应用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.编写网关的启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;网关应用启动入口&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * 1. <span class="doctag">@EnableZuulProxy</span> 标识当前的应用是 Zuul Server</span></span><br><span class="line"><span class="comment"> * 2. <span class="doctag">@SpringCloudApplication</span> 组合了 SpringBoot 应用 + 服务发现 + 熔断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(ZuulGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.配置网关应用</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">port</span>: <span class="string">9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">coupon-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">client</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">service-url</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">defaultZone</span>: <span class="string">http://server1:8000/eureka/</span></span><br></pre></td></tr></table></figure>

<p><strong>4.启动网关应用，注册到 Eureka Server（单体）</strong></p>
<p>先启动 Eureka Server 应用，再启动 gatway 应用，打开Eureka Server 应用所在的 8000 端口我们在 Eureka Server 的界面就可以看到 gatway 应用成功注册到注册中心：</p>
<p><img src="/2021/07/13/%EF%BC%88%E5%9B%9B%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%94%A8%E7%BB%84%E4%BB%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source_posts\2021-07-13-（四）优惠券系统-系统通用组件搭建\图片09.png"></p>
<h3 id="自定义过滤器类"><a href="#自定义过滤器类" class="headerlink" title="自定义过滤器类"></a>自定义过滤器类</h3><p><strong>1.定义通用的抽象过滤器类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;通用的抽象过滤器类&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * Created by Qinyi.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZuulFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于在过滤器之间传递消息, 数据保存在每个请求的 ThreadLocal 中</span></span><br><span class="line">    <span class="comment">// 扩展了 Map,任何类型的数据都能存到 RequestContext 中</span></span><br><span class="line">    RequestContext context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识请求是否继续执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NEXT = <span class="string">&quot;next&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器是否执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">boolean</span>) ctx.getOrDefault(NEXT, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的执行逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Some arbitrary artifact may be returned. Current implementation ignores it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException if an error occurs during execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line"></span><br><span class="line">        context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">return</span> cRun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">cRun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">fail</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        context.set(NEXT, <span class="keyword">false</span>);</span><br><span class="line">        context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">        context.getResponse().setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        context.setResponseStatusCode(code);</span><br><span class="line">        context.setResponseBody(String.format(<span class="string">&quot;&#123;\&quot;result\&quot;: \&quot;%s!\&quot;&#125;&quot;</span>, msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        context.set(NEXT, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义前置抽象过滤器类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承自通用的抽象过滤器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPreZuulFilter</span> <span class="keyword">extends</span> <span class="title">AbstractZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.自定义后置抽象过滤器类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承自通用的抽象过滤器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPostZuulFilter</span> <span class="keyword">extends</span> <span class="title">AbstractZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>优惠券系统项目</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动装配原理</title>
    <url>/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<blockquote>
<p>转载自**<a href="https://www.cnblogs.com/hellokuangshen/p/12450327.html">狂神博客</a>**。</p>
</blockquote>
<h1 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1.pom.xml"></a>1.pom.xml</h1><h2 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h2><p>它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>点进去，发现还有一个父依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里才是真正管理 SpringBoot 应用里面所有依赖版本的地方，SpringBoot 的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了。</strong></p>
<h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>springboot-boot-starter-xxx</strong>：就是 spring-boot 的 xxx 场景下的启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了 web 模块正常运行所依赖的组件；</p>
<p>SpringBoot 将所有的功能场景都抽取出来，做成一个个的 starter （启动器），只需要在项目中引入这些 starter 即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ，我们未来也可以自己自定义 starter。</p>
<h1 id="2-主启动类"><a href="#2-主启动类" class="headerlink" title="2.主启动类"></a>2.主启动类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//以为是启动了一个方法，没想到启动了一个服务</span></span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是注解的构成体系：</p>
<p><img src="/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-07-10-SpringBoot自动装配原理\图片01.png" alt="img"></p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者 bean ， 将这个 bean 定义加载到 IOC 容器中</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>作用：SpringBoot 的配置类 ，标注在某个类上 ， 表示这是一个 SpringBoot 的配置类；</p>
<p>我们继续进去这个注解查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点进去得到下面的 @Component</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 @Configuration，说明这是一个配置类 ，<strong>配置类就是对应 Spring 的 xml 配置文件</strong>，也就是支持 Java 配置的方式；</p>
<p>里面的 @Component 这就说明，启动类本身也是 Spring 中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在 SpringBoot 可以自动帮我们配置 。</p>
<p>@EnableAutoConfiguration 告诉 SpringBoot 开启自动配置功能，这样自动配置才能生效，并且可以帮我们配置不同场景下所需要的依赖。</p>
<p>点进注解接续查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p><strong>作用：</strong>自动配置包</p>
<p>往下继续点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@import：</strong>Spring 底层注解 @import ， 给容器中导入一个组件</p>
<p><strong>Registrar.class 作用：</strong>将主启动类的所在包及包下面所有子包里面的所有组件扫描注册到 SpringIOC 容器，与 ComponentScan 区别就是扫描的组件不同 ；</p>
<h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p><strong>作用：</strong>给容器导入组件</p>
<p>AutoConfigurationImportSelector.class：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点进去这个类看源码：</p>
<ol>
<li><p>这个类中有一个这样的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得候选的配置</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的getSpringFactoriesLoaderFactoryClass（）方法</span></span><br><span class="line">    <span class="comment">//返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入 SpringFactoriesLoader 类 loadFactoryNames() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">//这里它又调用了 loadSpringFactories 方法</span></span><br><span class="line">    <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们继续点击查看 loadSpringFactories 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    <span class="comment">//获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//去获取一个资源 &quot;META-INF/spring.factories&quot;</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>) : ClassLoader.getSystemResources(<span class="string">&quot;META-INF/spring.factories&quot;</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将读取到的资源遍历，封装成为一个Properties</span></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryName = var9[var11];</span><br><span class="line">                        result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [META-INF/spring.factories]&quot;</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现一个多次出现的文件：META-INF/spring.factories，全局搜索它</p>
<p><img src="/2021/07/10/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-07-10-SpringBoot自动装配原理\图片02.png" alt="img"></p>
<p>这就是 SpringBoot 自动配置的核心所在。</p>
<p>可以看到这些一个个的都是 JavaConfig 配置类，而且都注入了一些 Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，<strong>自动配置的核心是从 META-INF/spring.factories 路径下找你所配置的 jar 包，然后把其包装成对应的 properties 文件，然后遍历 properties, 加载到 ioc 容器中。</strong></p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li>SpringBoot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值</li>
<li>将这些值作为自动配置类导入容器，自动配置类就生效，帮我们进行自动配置工作；</li>
<li>整个 J2EE 的整体解决方案和自动配置都在 springboot-autoconfigure 的 jar 包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ，并配置好这些组件 ；</li>
<li>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作。</li>
</ol>
]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>SpringBoot相关</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）优惠券系统-SpringBoot开发框架</title>
    <url>/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-SpringBoot-特性"><a href="#1-SpringBoot-特性" class="headerlink" title="1. SpringBoot 特性"></a>1. SpringBoot 特性</h1><p>项目主体业务使用 SpringCloud 框架开发实现，但是 SpringCloud 基于 SpringBoot 实现。为便于更顺畅学习，本章中会对 SpringBoot 开发框架进行介绍，下面先看 SpringBoot 的常见特性，如图所示：</p>
<img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source\_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片01.png" style="zoom:50%;">

<h1 id="2-编写-SpringBoot-应用"><a href="#2-编写-SpringBoot-应用" class="headerlink" title="2.编写 SpringBoot 应用"></a>2.编写 SpringBoot 应用</h1><p><strong>1.创建 Maven 工程</strong></p>
<p>定义坐标和工程的位置</p>
<p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片02.png"></p>
<p><strong>2. pom.xml 文件的基本结构</strong></p>
<ol>
<li><p>parent 标签加入 springboot，标识 springboot 项目（引入 springboot 依赖）</p>
</li>
<li><p>添加 maven 坐标，标识 maven 项目</p>
</li>
<li><p>dependency 标签引入其它依赖</p>
</li>
<li><p>build 引入其他插件</p>
</li>
</ol>
<p><strong>3.修改 pom.xml 文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1  引入springboot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2  maven 坐标信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc.springboot.study<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>imooc_springboot_study<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  项目名字介绍--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-study<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Study project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3  引入相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 专门用于数据绑定的依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4  引入相关插件--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>imooc-springboot-study<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.编写启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBootApplication</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootStudyApplication.class,args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动 main 方法：</strong>这样就成功启动了 SpringBoot 工程</p>
<p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片03.png" alt="image-20210708160931954"></p>
<h1 id="3-SpringBoot-应用启动入口"><a href="#3-SpringBoot-应用启动入口" class="headerlink" title="3. SpringBoot 应用启动入口"></a>3. SpringBoot 应用启动入口</h1><p><strong>SpringBoot 主要包括以下三种启动方式：</strong></p>
<ol>
<li>SpringApplication 静态方法 run</li>
<li>通过 API 调整应用行为</li>
<li>SpringApplicationBuilder 的 Fluent API ，实现链式调用</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.Banner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.WebApplicationType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringBootApplication</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动，通过静态run方法</span></span><br><span class="line">        SpringApplication.run(SpringBootStudyApplication.class,args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动，通过 API 调整应用行为</span></span><br><span class="line">      <span class="comment">/*  </span></span><br><span class="line"><span class="comment">      SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非web启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第三种方式启动 链式调用</span></span><br><span class="line"><span class="comment">        new SpringApplicationBuilder(SpringBootStudyApplication.class)</span></span><br><span class="line"><span class="comment">                .bannerMode(Banner.Mode.OFF)</span></span><br><span class="line"><span class="comment">                .web(WebApplicationType.NONE)</span></span><br><span class="line"><span class="comment">                .run(args);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面已经演示了通过静态的 run 方法启动。下面来看剩下的两种：</p>
<p><strong>2.第二种方式启动，通过 API 调整应用行为</strong></p>
<p>启动后，控制台输出如下：</p>
<p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片04.png" alt="image-20210708200147745"></p>
<p>这里我们通过 API 设置了项目是非 web 应用，所以也没有默认开放的端口号，而且进程自动就结束了。</p>
<p><strong>3.第三种方式启动，SpringApplicationBuilder 的 Fluent API ，实现链式调用</strong></p>
<p>链式调用就是每次方法的调用返回一个 this 指针，然后通过这个指针调用方法来实现的。</p>
<p>启动后，控制台输出如下：</p>
<p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片04.png" alt="image-20210708200147745"></p>
<h1 id="4-SpringBoot-自动配置原理"><a href="#4-SpringBoot-自动配置原理" class="headerlink" title="4. SpringBoot 自动配置原理"></a>4. SpringBoot 自动配置原理</h1><p>已经整理</p>
<h1 id="5-SpringBoot-配置文件"><a href="#5-SpringBoot-配置文件" class="headerlink" title="5. SpringBoot 配置文件"></a>5. SpringBoot 配置文件</h1><h2 id="5-1-application-和-bootstrap"><a href="#5-1-application-和-bootstrap" class="headerlink" title="5.1 application 和 bootstrap"></a>5.1 application 和 bootstrap</h2><ul>
<li>  同一目录下的 bootstrap 优先级高于 application，优先被加载</li>
<li>  bootstrap 用于应用程序上下文的引导阶段，由父 ApplicationContext 加载 bootstrap 是系统级别的配置（不变的参数），</li>
<li>  application 是应用级别的配置</li>
</ul>
<p><strong>Demo：</strong></p>
<p>在 resources 文件下，创建 application.yml 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<p>通过启动器启动项目：</p>
<p><img src="/2021/07/08/%EF%BC%88%E4%B8%89%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-SpringBoot%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/GitHub\MyBlogs\source_posts\2021-07-08-（三）优惠券系统-SpringBoot开发框架\图片06.png" alt="image-20210710155222311"></p>
<p>可以看到 Tomcat 在 8000 端口启动，上下文路径是 /imooc</p>
<p>有一种场景，就是我们在线上或者测试环境中需要不同的配置，那么就需要创建不同的配置文件进行选择：</p>
<p>创建 application-prod.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc-prod</span></span><br></pre></td></tr></table></figure>

<p>创建 application-dev.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc-dev</span></span><br></pre></td></tr></table></figure>

<p>修改 application.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#修改这里，就可以实现对不同配置文件的选择</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment">#  这里没有用了，因为不同的配置文件会有自己的上下文路径</span></span><br><span class="line"><span class="comment">#  servlet:</span></span><br><span class="line"><span class="comment">#    context-path: /imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2不同目录配置文件加载顺序"><a href="#5-2不同目录配置文件加载顺序" class="headerlink" title="5.2不同目录配置文件加载顺序"></a>5.2不同目录配置文件加载顺序</h2><ul>
<li>  sfile:/config/- 优先级最高（项目根路径下的 config）</li>
<li>  file:./- 优先级第二（项目根路径下）</li>
<li>  classpath:/config/- 优先级第三（项目 resources/config 下）</li>
<li>  classpath/- 优先级第四（项目 resources 目录下）</li>
</ul>
<blockquote>
<p><strong>Note：</strong></p>
<p>高优先级覆盖低优先级相同配置</p>
<p>多个配置文件互补</p>
</blockquote>
<p><strong>Demo：</strong></p>
<p>刚才我们是在 resources 目录下创建的配置文件，也就是优先级最低，现在我们在项目根路径下创建 config 文件夹，然后创建 application.yml 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8085</span></span><br><span class="line"> <span class="attr">servlet:</span></span><br><span class="line">   <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br></pre></td></tr></table></figure>

<p>常规 resource 路径下的 application.xml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"> <span class="comment"># 注意：这里不能有profiles active: dev，否则 按application-dev配置文件的端口号</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="string">端口号</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"> <span class="attr">servlet:</span></span><br><span class="line">   <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br></pre></td></tr></table></figure>

<p>通过启动类启动后，就会是按照优先级更高的配置文件 8085 端口启动，然后选择线上环境的配置文件</p>
<h1 id="6-SpringBoot-配置注入的方式"><a href="#6-SpringBoot-配置注入的方式" class="headerlink" title="6. SpringBoot 配置注入的方式"></a>6. SpringBoot 配置注入的方式</h1><h2 id="6-1-Value-注入方式"><a href="#6-1-Value-注入方式" class="headerlink" title="6.1 @Value 注入方式"></a>6.1 @Value 注入方式</h2><p>application.yml 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">imooc:</span></span><br><span class="line">  <span class="attr">springboot:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2.1</span><span class="string">,2.1.4</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">study</span></span><br></pre></td></tr></table></figure>

<p>要通过 @Value 注解将配置文件中的内容注入到 application 应用中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/conf_inject_1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;first conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, version, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-ConfigurationProperties-配置注入"><a href="#6-2-ConfigurationProperties-配置注入" class="headerlink" title="6.2 @ConfigurationProperties 配置注入"></a>6.2 @ConfigurationProperties 配置注入</h2><p>配置文件不变，我们创建一个配置类 SpringBootConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;imooc.springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其注入到测试类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/springboot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SpringBootConfig springBootConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;imooc.springboot.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Controller</span><span class="params">(SpringBootConfig springBootConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springBootConfig = springBootConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第一种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/conf_inject_1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;first conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, version, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第二种方式的配置注入</span></span><br><span class="line"><span class="comment">    127.0.0.1：8000/imooc/springboot/conf_inject_2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/conf_inject_2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sencondConfigInject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;second conf inject: &#123;&#125;, &#123;&#125;&quot;</span>, springBootConfig.getVersion(), springBootConfig.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-SpringBoot-定时任务"><a href="#7-SpringBoot-定时任务" class="headerlink" title="7. SpringBoot 定时任务"></a>7. SpringBoot 定时任务</h1><p><strong>定时任务需要配置：</strong></p>
<p>启动器开启定时任务注解 @EnableScheduling</p>
<p><code>启动类：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动</span></span><br><span class="line">        <span class="comment">//SpringApplication.run(SpringBootStudyApplication.class,args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动</span></span><br><span class="line">        <span class="comment">/*SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非wub启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式启动 链式调用</span></span><br><span class="line">       <span class="keyword">new</span> SpringApplicationBuilder(SpringBootStudyApplication.class)</span><br><span class="line">                <span class="comment">//.bannerMode(Banner.Mode.OFF)</span></span><br><span class="line">               <span class="comment">// .web(WebApplicationType.NONE)</span></span><br><span class="line">               .run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>定时任务类：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h1&gt;SpringBoot 定时任务&lt;/h1&gt;</span></span><br><span class="line"><span class="comment"> * Created by wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootSchedule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DateTimeFormatter fmt = DateTimeFormatter.ofPattern(</span><br><span class="line">            <span class="string">&quot;HH:mm:ss&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;上一次开始执行时间点之后3000毫秒再执行&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule01 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;上一次执行完毕时间点之后3s再执行&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule02 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;第一次延迟2s之后执行, 之后按照每3s执行一次&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 2000, fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule03 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;h2&gt;每3s执行一次&lt;/h2&gt;</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;*/3 * * * * ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;schedule04 -&gt; &#123;&#125;&quot;</span>, LocalDateTime.now().format(fmt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定时任务不同使用方式（四种）：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Scheduled(fixedRate &#x3D; 3000)　　上一次开始执行时间点之后3000毫秒再执行</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Scheduled(fixedDelay &#x3D; 3000)　　上一次执行完毕时间点之后3s再执行</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Scheduled(initialDelay &#x3D; 2000, fixedRate &#x3D; 3000)　　第一次延迟2s之后执行, 之后按照每3s执行一次</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Scheduled(cron &#x3D; &quot;*&#x2F;3 * * * * ?&quot;)　　每3s执行一次</span><br></pre></td></tr></table></figure>

<h1 id="8-SpringBoot-异步任务"><a href="#8-SpringBoot-异步任务" class="headerlink" title="8. SpringBoot 异步任务"></a>8. SpringBoot 异步任务</h1><p><strong>1.启动类</strong></p>
<p>加入 @EnableAsync 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> </span><br><span class="line"><span class="meta">@EnableAsync</span>  <span class="comment">//允许异步任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式启动</span></span><br><span class="line">        <span class="comment">//SpringApplication.run(SpringBootStudyApplication.class,args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式启动</span></span><br><span class="line">        <span class="comment">/*SpringApplication springApplication = new SpringApplication(SpringBootStudyApplication.class);</span></span><br><span class="line"><span class="comment">        //关掉打印logo相关日志</span></span><br><span class="line"><span class="comment">        springApplication.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"><span class="comment">        //非wub启动，控制台启动后会关闭，不会一直保持开启状态</span></span><br><span class="line"><span class="comment">        springApplication.setWebApplicationType(WebApplicationType.NONE);</span></span><br><span class="line"><span class="comment">        springApplication.run(args);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式启动 链式调用</span></span><br><span class="line">       <span class="keyword">new</span> SpringApplicationBuilder(SpringBootStudyApplication.class)</span><br><span class="line">                <span class="comment">//.bannerMode(Banner.Mode.OFF)</span></span><br><span class="line">               <span class="comment">// .web(WebApplicationType.NONE)</span></span><br><span class="line">               .run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.创建异步任务</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有返回的异步任务</span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@Async(&quot;getAsyncExecutor&quot;)</span> <span class="comment">//注解表明是异步任务，并且声明使用的线程池配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncNotReturn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//记一下sleep</span></span><br><span class="line">        log.info(<span class="string">&quot;无返回自定义线程名字为&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有返回的异步任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span> <span class="meta">@Async(&quot;getAsyncExecutor&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Integer&gt; <span class="title">asyncHasReturn</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;有返回自定义线程名字为&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记一下</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.创建线程池配置类</strong></p>
<p>因为 SpringBoot 不可能通过主线程去执行异步任务，因为会阻塞，所以肯定是新开线程，但是新开的线程使用默认的线程池（比较简单）无法重复利用，所以要定义线程池的配置类，来使用自定义的线程池配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">//记一下实现的接口(实现异步任务配置类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncThreadPoolConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将线程池初始化到springioc容器中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.线程池设置参数</span></span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        threadPoolTaskExecutor.setCorePoolSize(<span class="number">20</span>);<span class="comment">//核心线程20个，能同时处理20个客户端请求</span></span><br><span class="line">        threadPoolTaskExecutor.setQueueCapacity(<span class="number">10</span>);<span class="comment">//缓冲队列允许10个线程等待</span></span><br><span class="line">        threadPoolTaskExecutor.setMaxPoolSize(<span class="number">30</span>);<span class="comment">//超出缓冲队列最多允许30个线程处理</span></span><br><span class="line">        threadPoolTaskExecutor.setKeepAliveSeconds(<span class="number">60</span>);<span class="comment">//线程存活时间60秒</span></span><br><span class="line">        threadPoolTaskExecutor.setThreadNamePrefix(<span class="string">&quot;hcx_&quot;</span>);<span class="comment">//线程名称前缀</span></span><br><span class="line"></span><br><span class="line">        threadPoolTaskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        threadPoolTaskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.拒绝策略</span></span><br><span class="line">        threadPoolTaskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.线程池初始化</span></span><br><span class="line">        threadPoolTaskExecutor.initialize();</span><br><span class="line">        <span class="keyword">return</span> threadPoolTaskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法仅能处理无返回值异步任务的异常，有返回值的异步任务异常客户端处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncExceptionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义异常处理类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AsyncExceptionHandler</span> <span class="keyword">implements</span> <span class="title">AsyncUncaughtExceptionHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable throwable, Method method, Object... objects)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1     打印日志</span></span><br><span class="line">            log.info(<span class="string">&quot;wdd异常打印&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&quot;</span>+throwable.getMessage(),method.getName(),JSON.toJSONString(objects));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2     正常跑出异常</span></span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3     发短信或者邮件通知运维人员</span></span><br><span class="line">            <span class="comment">//todo</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-SpringBoot-单元测试"><a href="#9-SpringBoot-单元测试" class="headerlink" title="9. SpringBoot 单元测试"></a>9. SpringBoot 单元测试</h1><p><strong>创建测试用例</strong></p>
<p>加入两个注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//带有SpringBoot支持的引导程序，提供了可指定外部环境的参数</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span><span class="comment">//junit引用spring的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootStudyTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//至少有一个测试用例，否则报 java.lang.Exception: No runnable methods 异常</span></span><br><span class="line">    <span class="comment">//这个空方法主要是用于测试外部环境是否好用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blankFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-开机启动"><a href="#10-开机启动" class="headerlink" title="10.开机启动"></a>10.开机启动</h1><p>开机启动，也就是程序启动时，要自动完成什么功能。</p>
<p>两种开机启动方式：</p>
<p><strong>1.实现 BootApplicationRunner 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;BootApplicationRunner&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;=启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.实现 BootCommandRunner 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCommandRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;BootCommandRunner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式明显的不同就是，传递参数的方式不同。</p>
<p><strong>3.通过 @Order 调整先后顺序</strong></p>
<p><code>BootApplicationRunner 方式：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;BootApplicationRunner&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;=启动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BootCommandRunner 方式：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCommandRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;BootCommandRunner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-SpringBoot-Jackson-的使用技巧"><a href="#11-SpringBoot-Jackson-的使用技巧" class="headerlink" title="11. SpringBoot Jackson 的使用技巧"></a>11. SpringBoot Jackson 的使用技巧</h1><p><strong>1.创建 POJO：</strong></p>
<p>注意看 Jackson 相关的注解作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonFormat;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span><span class="comment">//getset和toString方法</span></span><br><span class="line"><span class="meta">@Builder</span><span class="comment">//buil方法，参见Controller层的调用</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span><span class="comment">//无参构造方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">//全参构造器</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;address&quot;&#125;)</span><span class="comment">//忽略一组属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IMoocer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(&quot;name&quot;)</span></span><br><span class="line">    <span class="comment">//别名，传值后key值变为name </span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@JsonIgnore指示忽略掉该属性</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定日期属性的格式</span></span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date registerTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2.创建配置类：</strong></p>
<p>用于指定一些通用属性的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">buildJackson</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//初始化objectMapper,公共配置类，初始化日期的格式（JacksonConfig 是作用于全局的）。</span></span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)); </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//属性为null,不参与序列化</span></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); </span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.修改 Controller，进行测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.config.SpringBootConfig;</span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.vo.IMoocer;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/userController&quot;)</span>  </span><br><span class="line"><span class="comment">//注解可以将HTTP请求映射给controller来处理，包括返回视图页面的controller和Rest服务的controller。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span>   </span><br><span class="line"><span class="comment">//@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@Controller标识的类，该类代表控制器类(控制层/表现层)。这里控制层里面的每个方法，都可以去调用@Service标识的类（业务逻辑层），@Service标识的类中的方法可以继续调用@Resposity标识的接口实现类（Dao层/持久层）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.imooc.userid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userid;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;com.imooc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入objectMapper对象</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span><span class="comment">//自动注入Compenent组件</span></span><br><span class="line">    <span class="keyword">private</span> SpringBootConfig springBootConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用构造方法</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testInjectOne</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testInjectOne&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigInjectOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*      System.out.println(&quot;userid=&quot;+this.userid);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;username=&quot;+this.username);*/</span></span><br><span class="line">        log.info(<span class="string">&quot;userid=&quot;</span>+<span class="keyword">this</span>.userid);</span><br><span class="line">        log.info(<span class="string">&quot;username=&quot;</span>+<span class="keyword">this</span>.username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testInjectTwo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testInjectTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConfigInjectTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;userid=&quot;</span>+springBootConfig.getUserid());</span><br><span class="line">        log.info(<span class="string">&quot;username=&quot;</span>+springBootConfig.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  访问地址：127.0.0.1:8081/imooc/userController/testJackson</span></span><br><span class="line"><span class="comment">     *  测试jackson序列化和反序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testJackson&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMoocer <span class="title">testJackson</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//builder方法</span></span><br><span class="line">        IMoocer iMoocer = IMoocer.builder() .userName(<span class="string">&quot;小魏&quot;</span>) .age(<span class="string">&quot;18&quot;</span>) .address(<span class="string">&quot;北京&quot;</span>) .birthday(<span class="keyword">new</span> Date()) .build(); </span><br><span class="line">        <span class="comment">//序列化方式</span></span><br><span class="line">        String sJsonString = objectMapper.writeValueAsString(iMoocer);</span><br><span class="line">        log.info(<span class="string">&quot;序列化方法：&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&lt;mark&gt;&lt;/mark&gt;&quot;</span>+sJsonString);</span><br><span class="line">        <span class="comment">//反序列化方式</span></span><br><span class="line">        IMoocer iMoocer1 = objectMapper.readValue(sJsonString,IMoocer.class); <span class="keyword">return</span> iMoocer1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-SpringBoot-Actuator-监控-1"><a href="#12-SpringBoot-Actuator-监控-1" class="headerlink" title="12. SpringBoot Actuator 监控(1)"></a>12. SpringBoot Actuator 监控(1)</h1><p><strong>1.开启 Actuator 监控</strong></p>
<p>a.引入相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b. application.yml 配置文件开启监控功能：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line">  	<span class="attr">application:</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">imooc_springboot_study</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/imooc</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoint:</span></span><br><span class="line">    <span class="attr">shutdown:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment">#最特殊的监控端点，开通后可以通过shutdown url对程序进行关闭动作。一般不会开启</span></span><br><span class="line">  <span class="attr">endpoints:</span> </span><br><span class="line">  	<span class="attr">web:</span> </span><br><span class="line">  		<span class="attr">exposure:</span> </span><br><span class="line">  			<span class="attr">include:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#打开所有的监控点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8081/imooc/actuator/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info:</span> <span class="comment">#自定义的应用程序配置信息</span></span><br><span class="line">	<span class="attr">app:</span> </span><br><span class="line">		<span class="attr">name:</span> <span class="string">imooc_springboot_study</span> </span><br><span class="line">			<span class="attr">groupid:</span> <span class="string">org.springframework.boot</span> </span><br><span class="line">				<span class="attr">version:</span> <span class="number">2.1</span><span class="number">.4</span><span class="string">.RELEASE</span></span><br></pre></td></tr></table></figure>

<p><strong>2.原生端点三类监控</strong></p>
<ol>
<li><p><strong>应用配置类常用监控</strong>  </p>
<p>自己配置的应用程序 info 信息：/actuator/info  </p>
<p>应用中 bean 的信息：/actuator/beans  </p>
<p>应用中 URI 路径信息：/actuator/mappings</p>
</li>
<li><p><strong>度量指标类常用监控</strong>  </p>
<p>检查应用的运行状态：/actuator/health  </p>
<p>当前线程活动快照：/actuator/threaddump</p>
</li>
<li><p><strong>操作控制类常用监控</strong>  </p>
<p>关闭应用（POST）：/actuator/shutdown  </p>
<p>​        curl -X POST “<a href="http://localhost：8080/actuator/shutdown（POST请求）">http://localhost：8080/actuator/shutdown（POST请求）</a></p>
</li>
</ol>
<h1 id="13-SpringBoot-Actuator-监控-2"><a href="#13-SpringBoot-Actuator-监控-2" class="headerlink" title="13. SpringBoot Actuator 监控(2)"></a>13. SpringBoot Actuator 监控(2)</h1><p><strong>1.自定义端点类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.Endpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.ReadOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.WriteOperation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Endpoint(id=&quot;datetime&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeEndPoint</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String forMat = <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取端点注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ReadOperation</span><span class="comment">//显示监控指标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">readPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小魏&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;birthday&quot;</span>,<span class="keyword">new</span> SimpleDateFormat(forMat).format(<span class="keyword">new</span> Date()));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态更改监控指标</span></span><br><span class="line">    <span class="meta">@WriteOperation</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writePoint</span><span class="params">(String forMat)</span></span>&#123; <span class="keyword">this</span>.forMat = forMat; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.自定义端点配置类</strong></p>
<p>告诉 SpringBoot ，DateTimeEndPoint 是我们自定义的端点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springboot.application.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.imooc.springboot.application.endpoint.DateTimeEndPoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.actuate.autoconfigure.endpoint.condition.ConditionalOnEnabledEndpoint;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span><span class="comment">//当该bean缺少的时候注入bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnEnabledEndpoint</span><span class="comment">//当监控端点开启的时候（application.yml打开监控端点）才会注入应用程序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTimeEndPoint <span class="title">dateTimeEndPoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DateTimeEndPoint();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-SpringBoot-自定义-Starter"><a href="#14-SpringBoot-自定义-Starter" class="headerlink" title="14. SpringBoot 自定义 Starter"></a>14. SpringBoot 自定义 Starter</h1>]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>优惠券系统项目</tag>
      </tags>
  </entry>
  <entry>
    <title>MessageQueue基础知识</title>
    <url>/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-消息队列的基本概念"><a href="#1-消息队列的基本概念" class="headerlink" title="1.消息队列的基本概念"></a>1.消息队列的基本概念</h1><p><strong>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。</strong>队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p>
<p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片01.png" alt="Message queue"></p>
<h1 id="2-为什么要用消息队列"><a href="#2-为什么要用消息队列" class="headerlink" title="2.为什么要用消息队列"></a>2.为什么要用消息队列</h1><p>我觉得使用消息队列主要有三点好处：</p>
<ol>
<li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li>
<li><strong>削峰/限流</strong></li>
<li><strong>降低系统耦合性。</strong></li>
</ol>
<p>面试中问到的话，要结合自己的项目来回答。</p>
<h2 id="2-1异步处理提高系统性能"><a href="#2-1异步处理提高系统性能" class="headerlink" title="2.1异步处理提高系统性能"></a>2.1异步处理提高系统性能</h2><p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片02.png" alt="通过异步处理提高系统性能"></p>
<p><strong>不使用消息队列时：</strong></p>
<p>用户的访问数据会通过服务器直接访问数据库，在高并发的场景下，会对数据库造成很大的压力，同时也会使得响应延迟加剧。</p>
<p><strong>使用消息队列时：</strong></p>
<p>在使用消息队列后，用户的请求数据会加入消息队列后直接返回，再由消息队列的消费进程从消息队列中获取数据，异步写入数据库，由于消息队列服务器处理速度远快于数据库（消息队列服务器处理请求的性能更高），因此用户的相应延迟也可以得到很好的改善。</p>
<p>需要注意的是，因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h2 id="2-2-削峰-限流"><a href="#2-2-削峰-限流" class="headerlink" title="2.2 削峰/限流"></a>2.2 削峰/限流</h2><p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉（转嫁高并发压力到消息队列服务器）。</strong></p>
<p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片04.png" alt="削峰"></p>
<h2 id="2-3-降低系统耦合性"><a href="#2-3-降低系统耦合性" class="headerlink" title="2.3 降低系统耦合性"></a>2.3 降低系统耦合性</h2><p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。还是直接上图吧：</p>
<p><img src="/2021/07/07/MessageQueue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-MessageQueue基础知识\图片05.png" alt="解耦"></p>
<p>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合， 这显然也提高了系统的扩展性。</p>
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。</strong> </p>
<h1 id="3-使用消息队列的问题"><a href="#3-使用消息队列的问题" class="headerlink" title="3.使用消息队列的问题"></a>3.使用消息队列的问题</h1><ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>MQ相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基础知识</title>
    <url>/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>Kafka 是一个基于<strong>分布式</strong>的基于<strong>发布/订阅模式</strong>的<strong>消息队列</strong>，主要应用于<strong>大数据实时处理</strong>领域。</p>
<h1 id="2-为什么使用消息队列"><a href="#2-为什么使用消息队列" class="headerlink" title="2.为什么使用消息队列"></a>2.为什么使用消息队列</h1><p>还需要根据自己这个项目实际说一下</p>
<ol>
<li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li>
<li><strong>削峰/限流</strong></li>
<li><strong>降低系统耦合性。</strong></li>
</ol>
<h1 id="3-Kafka-与其它消息队列的对比"><a href="#3-Kafka-与其它消息队列的对比" class="headerlink" title="3. Kafka 与其它消息队列的对比"></a>3. Kafka 与其它消息队列的对比</h1><p>属于技术选型，结合项目说一下，为什么要选 Kafka</p>
<h1 id="4-消息模型"><a href="#4-消息模型" class="headerlink" title="4. 消息模型"></a>4. 消息模型</h1><h2 id="4-1点对点消息系统"><a href="#4-1点对点消息系统" class="headerlink" title="4.1点对点消息系统"></a>4.1点对点消息系统</h2><p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片01.png" alt="img"></p>
<p><strong>点对点消息系统的特点：</strong></p>
<ol>
<li>点对点消息系统是把消息持久化到消息队列中，不同消费者不能消费同一个消息</li>
<li>消费者消费掉消息队列的数据后，或者消息超时后，数据会从消息队列中删除</li>
<li>顺序发送消息</li>
</ol>
<p>例：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）。</p>
<p><strong>点对点消息系统存在的问题：</strong></p>
<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h2 id="4-2发布订阅消息系统（Kafka）"><a href="#4-2发布订阅消息系统（Kafka）" class="headerlink" title="4.2发布订阅消息系统（Kafka）"></a>4.2发布订阅消息系统（Kafka）</h2><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片02.png" alt="img"></p>
<p><strong>发布订阅消息系统的特点：</strong></p>
<ol>
<li>消息持久化到 topic 中，不同的 topic 标识信息属于不同的 topic，消费者可订阅一个或多个 topic 的消息，也就是不同的消费者可以消费同一个消息</li>
<li>数据被消费后不会被删除</li>
<li>异步处理消息</li>
</ol>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<blockquote>
<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>
</blockquote>
<h1 id="5-Kafka-常见术语"><a href="#5-Kafka-常见术语" class="headerlink" title="5. Kafka 常见术语"></a>5. Kafka 常见术语</h1><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片03.png" alt="Kafka Topic Partition"></p>
<ul>
<li><strong>Producer（生产者）：</strong>生产者发送消息存储到 Partition 中，也可指定数据存储到哪个 Partition 中，通过代码设定即可。</li>
<li><strong>Consumer（消费者）：</strong>可从 Broker 中读取数据，消费者可消费多个 Topic 中的数据，多个消费者构成消费者组。</li>
<li><strong>Broker（代理）：</strong> 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
<li><strong>Topic（主题）：</strong> 数据所属类（类似于数据库中的表名的概念）。</li>
<li><strong>Partition（分区）：</strong> Partition 属于 Topic 的一部分（创建 kafka Topic 时，默认使用一个 partition，另外可在 kafka 命令行客户端，指定 partition 个数）。一个 Topic 可以有多个 Partition（至少有一个） ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 实现负载均衡。每个 partition，可能使用多个文件存储（冗余文件备份，超过一定限制后，会对文件切分）。</li>
<li><strong>Offset（偏移量）：</strong>每个 Partition 都有偏移量，每个消息都有针对 Partition 的 64 字节的偏移量，指定消息在数据中的起始位置。</li>
<li><strong>副本：</strong>副本是对 Partition 的备份，作用为防止数据丢失（单机版 Kafka 不能设置副本，副本分布在不同的机器上）。消费者不会从副本读取数据，它会从 Kafka Leader 中读取数据。</li>
</ul>
<h1 id="6-Kafka-多副本机制及好处"><a href="#6-Kafka-多副本机制及好处" class="headerlink" title="6. Kafka 多副本机制及好处"></a>6. Kafka 多副本机制及好处</h1><p><strong>1.多副本机制介绍</strong></p>
<p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<p><img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source_posts\2021-07-07-Kafka基础知识\图片05.png" alt="img"></p>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
<p><strong>2.多分区（Partition）以及多副本（Replica）机制的好处</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h1 id="7-Kafka-如何保证消息的消费顺序"><a href="#7-Kafka-如何保证消息的消费顺序" class="headerlink" title="7. Kafka 如何保证消息的消费顺序"></a>7. Kafka 如何保证消息的消费顺序</h1><p><strong>场景：</strong>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：更改用户会员等级、根据会员等级计算订单价格。假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/KafkaTopicPartionsLayout.png" alt="img"></p>
<p>每次添加消息到 Partition（分区）的时候都会采用尾加法，如上图所示。消息在被追加到 Partition（分区）的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）为我们保证 Partition（分区）中的消息有序，而不能保证 Topic（主题）中的 Partition（分区）的有序，比如上面的两条消息分别发送到同一 Topic 中不同的 Partition 中，在消费的时候就可能是无序的。</p>
<p>针对这种场景，我们简单提出下面两种方案：</p>
<p><strong>方案一：</strong>1 个 Topic 只对应一个 Partition。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
<p><strong>方案二：</strong>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p>
<img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片06.png" alt="img" style="zoom:67%;">

<h1 id="8-Kafka-如何保证消息不丢失"><a href="#8-Kafka-如何保证消息不丢失" class="headerlink" title="8. Kafka 如何保证消息不丢失"></a>8. Kafka 如何保证消息不丢失</h1><h2 id="8-1生产者丢失消息的情况"><a href="#8-1生产者丢失消息的情况" class="headerlink" title="8.1生产者丢失消息的情况"></a>8.1生产者丢失消息的情况</h2><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。 </p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是  Kafka 生产者(Producer) 使用  <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>

<p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p><strong>另外这里推荐为 Producer 的<code>retries </code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你 3 次一下子就重试完了。</strong></p>
<blockquote>
<p>可以通过 countDownLatch 来实现，重试的代码抽取成方法，主线程 countDownLatch.await() 阻塞，然后去执行方法，重试次数减到 0 唤醒主线程继续执行。</p>
</blockquote>
<h2 id="8-2消费者丢失消息的情况"><a href="#8-2消费者丢失消息的情况" class="headerlink" title="8.2消费者丢失消息的情况"></a>8.2消费者丢失消息的情况</h2><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片04.png" alt="kafka offset" style="zoom: 67%;">

<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了，这样就会让没有消费的消息丢失。</p>
<p><strong>解决办法：我们手动关闭闭自动提交 offset，每次在真正消费完消息之后之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h2 id="8-3-Kafka-丢失消息的情况"><a href="#8-3-Kafka-丢失消息的情况" class="headerlink" title="8.3 Kafka 丢失消息的情况"></a>8.3 Kafka 丢失消息的情况</h2><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>场景：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p><strong>设置 request.required.acks = -1</strong></p>
<p>解决办法就是我们设置  <strong>request.required.acks = -1</strong>。acks 是 Kafka 生产者(Producer)  很重要的一个参数。</p>
<p>acks 的默认值即为1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 <strong>request.required.acks = -1</strong> 代表则所有副本 follower 都从 leader 复制过去才会回 ack，该消息才算真正成功被发送。</p>
<p><strong>设置 replication.factor &gt;= 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>该参数用于保证当前集群中处于正常同步状态的副本 follower 数量，当实际值小于配置值时，集群停止服务。一般情况下需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了，因为始终满足不了最小工作数了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable = false</strong></p>
<blockquote>
<p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p>
</blockquote>
<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong>  的话，当 leader 副本发生故障时就不会从  follower 副本中和 leader 同步程度达不到要求的副本中选择出  leader ，这样降低了消息丢失的可能性。</p>
<p><strong>通过 ack、replication.factor、min.insync.replicas 和 unclean.leader.election.enable 的配合，保证在 Kafka 配置为 CP 系统时，要么不工作，要么得到 ack 后，消息不会丢失且消息状态一致。</strong></p>
<h1 id="9-Kafka-如何保证消息不重复消费"><a href="#9-Kafka-如何保证消息不重复消费" class="headerlink" title="9. Kafka 如何保证消息不重复消费"></a>9. Kafka 如何保证消息不重复消费</h1><p>上文中我们知道，kafka 有个 offset(偏移量) 的概念，就是每个消息写进去，都有一个 offset ，代表他的序号，然后 consumer 消费了数据之后，每隔一段时间，会把自己消费过的消息的 offset 提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧。</p>
<p><strong>场景：</strong>但是如果我们在消费完一条消息后，还没来得及更改偏移量，系统突然重启，或者进程被 kill 了，这样 offset 没有被修改，在系统重启之后，少数的消息就会被重复消费。</p>
<p>举个例子,假设你有个系统，消费一条往数据库里插入一条，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下已经消费过了，直接扔了，不就保留了一条数据？</p>
<p>一条数据或者请求重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<p>通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。 </p>
<p><strong>解决思路：</strong></p>
<ol>
<li>如果你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下即可；</li>
<li>如果你是写 redis，那没问题了，反正每次都是 set，天然幂等性；</li>
<li>如果你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 redis 。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>再比如基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为 kafka 消费者还没来得及提交 offset，重复数据拿到了以后我们插入的时候，因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据</li>
</ol>
<p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p>
<h1 id="10-Kafka-消费者组"><a href="#10-Kafka-消费者组" class="headerlink" title="10. Kafka 消费者组"></a>10. Kafka 消费者组</h1><p>消费者和 topic 内的 partition 关联方式：</p>
<p>消费者组协作消费同一个 topic 方法，<strong>kafka 能保证每个  topic 内的 partition 被消费者组内的一个消费者消费</strong>。</p>
<ul>
<li>1 个消费者组包含一个消费者，消费一个 topic 中的 4 个分区，该消费者消费全部分区</li>
<li>1 个消费者组包含两个消费者，消费一个 topic 中的 4 个分区，两个消费者平均随机消费两个不同的分区</li>
<li>1 个消费者组包含 4 个消费者，消费一个 topic 中的 4 个分区，4 个消费者平均随机消费一个不同的分区</li>
<li>1 个消费这组包含 5 个消费者，消费一个 topic 中的 4 个分区，4 个消费者平均随机消费一个不同的分区，第 5 个消费者处于空闲状态（注意<strong>消费者组的消费者个数应小于等于 partition 个数</strong>，避免资源浪费）</li>
<li>2 个消费者组消费一个 topic 中的 4 个分区，<strong>每个消费者组是独立消费，并不和其他消费者组关联</strong></li>
</ul>
<img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片07.png" style="zoom: 67%;">



<img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片08.png" style="zoom:67%;">



<img src="/2021/07/07/Kafka%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GitHub\MyBlogs\source\_posts\2021-07-07-Kafka基础知识\图片09.png" style="zoom:67%;">

<h1 id="11-Zookeeper-在-Kafka-中的作用"><a href="#11-Zookeeper-在-Kafka-中的作用" class="headerlink" title="11. Zookeeper 在 Kafka 中的作用"></a>11. Zookeeper 在 Kafka 中的作用</h1><blockquote>
<p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong> 一定不要光看不实践，这样学来的也终会忘记！这部分内容参考和借鉴了这篇文章：<a href="https://www.jianshu.com/p/a036405f989c">https://www.jianshu.com/p/a036405f989c</a> 。</p>
</blockquote>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zookeeper-kafka.jpg" style="zoom:50%;">

<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong>：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong>：在 Kafka 中，同一个 <strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong>：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Kafka相关</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）优惠券系统-项目介绍</title>
    <url>/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-课程目的"><a href="#1-课程目的" class="headerlink" title="1.课程目的"></a>1.课程目的</h1><ol>
<li><p><strong>单体服务的缺点：</strong></p>
<p>整个工程任何一个功能点问题，都可能拖垮整个业务系统，所以需要去学习微服务。</p>
</li>
<li><p><strong>微服务的优点</strong></p>
<p>作为微服务，就是将原本大系统中的功能点拆分为独立的小系统并独立部署，可见原本单体服务中的各种功能变成了服务。</p>
<p>另外，客户端不再直接与微服务进行交互，而是通过网关做路由分发，且功能之间的方法调用变成了各个微服务之间的服务调用。这样的设计架构会让开发部署过程变得简单，易维护，且微服务出现问题不会影响其他的维护，对业务系统的高可用要求提供了保障。</p>
</li>
</ol>
<img src="/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/GitHub\MyBlogs\source\_posts\2021-07-06-（一）优惠券系统-项目介绍\图片01.png" alt="img" style="zoom:120%;">

<h1 id="2-课程内容"><a href="#2-课程内容" class="headerlink" title="2.课程内容"></a>2.课程内容</h1><p><strong>设计思想：</strong>注册中心，优惠券模版微服务，优惠券分发微服务，优惠券结算微服务</p>
<img src="/2021/07/06/%EF%BC%88%E4%B8%80%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/GitHub\MyBlogs\source\_posts\2021-07-06-（一）优惠券系统-项目介绍\图片02.png" alt="img" style="zoom:120%;">

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>优惠券系统项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）优惠券系统-准备工作</title>
    <url>/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-Maven"><a href="#1-Maven" class="headerlink" title="1. Maven"></a>1. Maven</h1><h2 id="1-1-pom-xml"><a href="#1-1-pom-xml" class="headerlink" title="1.1 pom.xml"></a>1.1 pom.xml</h2><h2 id="1-2坐标组成"><a href="#1-2坐标组成" class="headerlink" title="1.2坐标组成"></a>1.2坐标组成</h2><ul>
<li><p>groupid：这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，优 groupld 蕉等项目com.imooc.coupon 拥有所有的和优惠券相关的项目。</p>
</li>
<li><p>artifactd：这是工程的标识。它通常是工程的名称。例如，优惠券结算系统。</p>
<p>groupld 和 artifactId 一起定义了 artifact 在仓库中的位置。</p>
</li>
<li><p>versionid ：这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：com.imooc.coupon.setlement1.0。</p>
</li>
</ul>
<h2 id="1-3-maven-常用命令"><a href="#1-3-maven-常用命令" class="headerlink" title="1.3 maven 常用命令"></a>1.3 maven 常用命令</h2><p>常用命令含义/功能：</p>
<ul>
<li>mvn -v ：查看 Maven 的版本，也用来检查 Maven 是否安装成功</li>
<li>mvn compile：编译，将 Java 源文件编译成 class 文件</li>
<li>mvn test：执行 test 目录下的测试用例</li>
<li>mvn package：打包，将 Java 工程打成 jar 包</li>
<li>mvn clean：清理环境，清除 target 文件夹</li>
<li>mvn install ：安装，将当前项目安装到 Maven 的本地仓库中</li>
</ul>
<h2 id="1-4-idea-运行-maven-命令"><a href="#1-4-idea-运行-maven-命令" class="headerlink" title="1.4 idea 运行 maven 命令"></a>1.4 idea 运行 maven 命令</h2><p>terminal 命令窗口，可以执行 maven 命令</p>
<h1 id="2-Maven-相关特性"><a href="#2-Maven-相关特性" class="headerlink" title="2. Maven 相关特性"></a>2. Maven 相关特性</h1><h1 id="3-Maven-多模块项目"><a href="#3-Maven-多模块项目" class="headerlink" title="3. Maven 多模块项目"></a>3. Maven 多模块项目</h1><h1 id="4-Redis支持的数据类型"><a href="#4-Redis支持的数据类型" class="headerlink" title="4. Redis支持的数据类型"></a>4. Redis支持的数据类型</h1><h1 id="5-Redis-特性以及问题规避"><a href="#5-Redis-特性以及问题规避" class="headerlink" title="5. Redis 特性以及问题规避"></a>5. Redis 特性以及问题规避</h1><h1 id="6-Redis-的-I-O-模型"><a href="#6-Redis-的-I-O-模型" class="headerlink" title="6. Redis 的 I/O 模型"></a>6. Redis 的 I/O 模型</h1><h1 id="7-MySql-版本与配置"><a href="#7-MySql-版本与配置" class="headerlink" title="7. MySql 版本与配置"></a>7. MySql 版本与配置</h1><h1 id="8-Mysql-索引"><a href="#8-Mysql-索引" class="headerlink" title="8. Mysql 索引"></a>8. Mysql 索引</h1><h1 id="9-Spring-Data-JPA"><a href="#9-Spring-Data-JPA" class="headerlink" title="9. Spring Data JPA"></a>9. Spring Data JPA</h1><h2 id="9-1-ORM"><a href="#9-1-ORM" class="headerlink" title="9.1 ORM"></a>9.1 ORM</h2><p><strong>1.什么是 ORM</strong></p>
<p>ORM，即 Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间作一个映射，这样，我们在具体的操作业务对象的时候，就不需要再去和复杂的 SQL 语句打交道，只需简单的操作对象的属性和方法。</p>
<p><strong>2.为什么会出现ORM思想</strong></p>
<p>先从项目中数据流存储形式这个角度说起，简单拿MVC这种分层模式来说：Model 作为数据承载实体，在用户界面层和业务逻辑层之间数据实现面向对象OO形式传递.，当我们需要通过 Control 层分发请求把数据持久化时我们会发现. ，内存中的面向对象的OO如何持久化成关系型数据中存储一条实际数据记录呢？</p>
<p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两者之间是不匹配的，而 ORM 作为项目中间件形式实现数据在不同场景下数据关系映射，对象关系映射（Object Relational Mapping，简称ORM）是一种<strong>为了解决面向对象与关系数据库存在的互不匹配的现象的技术</strong>，ORM 就是这样而来的。</p>
<p><img src="/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/GitHub\MyBlogs\source_posts\2021-07-06-（二）优惠券系统-准备工作\图片01.png" alt="img"></p>
<p><strong>3.常用的 ORM 框架</strong></p>
<ol>
<li>Hibernate 全自动需要些 hql 语句</li>
<li>iBATIS 半自动自己写 sql 语句,可操作性强,小巧</li>
<li>EclipseLink 一个可扩展的支持 JPA 的 ORM 框架，供强大的缓存功能，缓存支持集群。</li>
<li>Apache OJB 等等</li>
</ol>
<h2 id="9-2-Spring-Data-JPA"><a href="#9-2-Spring-Data-JPA" class="headerlink" title="9.2 Spring Data JPA"></a>9.2 Spring Data JPA</h2><p><strong>1.SpringData jpa</strong></p>
<p>JPA(Java Persistence API) 是当年的 Sun 官方提出的 <strong>Java 持久化规范</strong>。<br>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，<strong>可使开发者用极简的代码即可实现对数据的访问和操作</strong>。</p>
<p><strong>2. JPA 包含的技术</strong>  </p>
<ul>
<li><p>ORM 映射元数据：支持 <strong>xml</strong> 和<strong>注解</strong>来标识源数据的形式，对象的增删改查映射到表  </p>
</li>
<li><p>查询语言（JPQL）：面向对象查询数据</p>
</li>
</ul>
<p><strong>3.什么是 SpringData JPA</strong></p>
<p>即 Java PersistenceAPI，用于对象持久化的 <strong>API</strong>，它是 <strong>ORM 规范</strong>，使得应用程序以统一的方式访问持久层。</p>
<p><strong>4. JPA 和 Hibernate 的关系</strong></p>
<ul>
<li><p>JPA 是 Hibernate 的一个抽象</p>
</li>
<li><p>JPA 是 ORM 规范，不是 ORM 框架</p>
</li>
<li><p>Hibernate 是 JPA 的一种实现</p>
</li>
<li><p>JPA 是 Hibernate 的一个功能子集</p>
</li>
</ul>
<img src="/2021/07/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BC%98%E6%83%A0%E5%88%B8%E7%B3%BB%E7%BB%9F-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/GitHub\MyBlogs\source\_posts\2021-07-06-（二）优惠券系统-准备工作\图片02.png" style="zoom:150%;">



<p><strong>4. JPA 优点</strong></p>
<ul>
<li><p>标准化：相同 api，代码层面修改较少便能在不同框架下使用</p>
</li>
<li><p>简单易用：创建实体，只需要 @entity 注解即可</p>
</li>
<li><p>面向对象：定义了 jpql (类似于 sql)，支持批量修改更新 join,group by,having 等，支持类之间的继承，多态等</p>
</li>
</ul>
<p><strong>5. JPA 包含的技术</strong></p>
<ul>
<li><p>ORM 映射元数据：支持 <strong>xml</strong> 和<strong>注解</strong>来标识源数据的形式，对象的增删改查映射到表</p>
</li>
<li><p>查询语言（JPQL）：面向对象查询数据</p>
</li>
<li><p>提供了查询 API</p>
</li>
</ul>
<p><strong>6. Spring Data 项目</strong></p>
<ul>
<li><p>Spring Data 是 Spring 的一个子项目，用于简化数据库访问</p>
</li>
<li><p>Spring Data JPA 是 Spring Data 的一个子项目</p>
</li>
<li><p>Spring Data JPA 致力于减少数据访问层（DAO）的开发量</p>
</li>
</ul>
<h1 id="10-数据库连接池"><a href="#10-数据库连接池" class="headerlink" title="10.数据库连接池"></a>10.数据库连接池</h1><h2 id="10-4-SpringBoot2-HikariCP-的配置"><a href="#10-4-SpringBoot2-HikariCP-的配置" class="headerlink" title="10.4 SpringBoot2 HikariCP 的配置"></a>10.4 SpringBoot2 HikariCP 的配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.hikari.connection-timeout 客户端等待连接池连接的最大毫秒数</span><br><span class="line">spring.datasource.hikari.minimum-idle连接池中维护的最小空闲连接数</span><br><span class="line">spring.datasource.hikari.maximum-pool-size 最大池大小</span><br><span class="line">spring.datasource.hikari.idle-timeout 允许连接在连接池中空闲的最长时间（毫秒）</span><br><span class="line">spring.datasource.hikari.max-lifetime 池中连接关闭后的最长生命周期（毫秒）</span><br><span class="line">spring.datasource.hikari.auto-commit从池返回的连接的默认自动提交行为（默认为true）</span><br></pre></td></tr></table></figure>

<h2 id="10-1数据库连接池的功能"><a href="#10-1数据库连接池的功能" class="headerlink" title="10.1数据库连接池的功能　"></a>10.1数据库连接池的功能　</h2><p><strong>连接复用：</strong>通过建立一个数据库连接池以及一套连接使用管理策略，<strong>使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销</strong>。较为频繁的使用数据库时，数据库连接的使用成为系统的瓶颈，所以需要数据库连接池</p>
<h2 id="10-2数据库连接池的基本原理"><a href="#10-2数据库连接池的基本原理" class="headerlink" title="10.2数据库连接池的基本原理"></a>10.2数据库连接池的基本原理</h2><p>数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。  </p>
<ul>
<li>getConnection ：得到数据库连接</li>
<li>releaseConnection：释放数据库链接，并不关闭，管理回收下次使用（无框架的时候进行这 getConnection 和 releaseConnection）</li>
</ul>
<h2 id="10-3数据库连接池的优势"><a href="#10-3数据库连接池的优势" class="headerlink" title="10.3数据库连接池的优势"></a>10.3数据库连接池的优势</h2><ul>
<li>资源重用，连接池中的数据库连接可以复用</li>
<li>更快的系统响应，维护一些可用的连接，避免了数据库连接创建销毁的开销，提升了系统效应速度</li>
<li>优化资源分配</li>
<li>统一的连接管理 ，避免数据库泄露，占用超时设定，强制回收被占用的连接</li>
</ul>
<h2 id="10-4-SpringBoot2-HikariCP-的配置-1"><a href="#10-4-SpringBoot2-HikariCP-的配置-1" class="headerlink" title="10.4 SpringBoot2 HikariCP 的配置"></a>10.4 SpringBoot2 HikariCP 的配置</h2><p>SpringBoot1 的默认连接池是 Tomcat 数据库连接池，HikariCP 是 SpringBoot2 中的默认连接池，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.hikari.connection-timeout 客户端等待连接池连接的最大毫秒数</span><br><span class="line">spring.datasource.hikari.minimum-idle连接池中维护的最小空闲连接数</span><br><span class="line">spring.datasource.hikari.maximum-pool-size 最大池大小</span><br><span class="line">spring.datasource.hikari.idle-timeout 允许连接在连接池中空闲的最长时间（毫秒）</span><br><span class="line">spring.datasource.hikari.max-lifetime 池中连接关闭后的最长生命周期（毫秒）</span><br><span class="line">spring.datasource.hikari.auto-commit从池返回的连接的默认自动提交行为（默认为true）</span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot2 如何选择连接池？</strong></p>
<p>优先选择 hikaricp, 不存在依赖的话，选择 tomcat 连接池，如果 tomcat 连接池也不存在，会继续选择优先级更低的 commons,db2 等连接池。</p>
<h1 id="11-Kafka-相关"><a href="#11-Kafka-相关" class="headerlink" title="11. Kafka 相关"></a>11. Kafka 相关</h1><h1 id="12-Kafka-的安装与使用"><a href="#12-Kafka-的安装与使用" class="headerlink" title="12. Kafka 的安装与使用"></a>12. Kafka 的安装与使用</h1>]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>优惠券系统项目</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式锁</title>
    <url>/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p>原本的单体单机部署的系统被演化成分布式集群系统之后，由于分布式系统的多进程、多线程分布在不同的机器上，这就使得原先的并发控制策略失效，也就是我们在集群中一个节点上加的锁不能被其它节点所识别，所以要实现分布式锁来解决该问题。</p>
<h1 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2.分布式锁"></a>2.分布式锁</h1><p>分布式锁主流的实现方案：</p>
<ul>
<li><input disabled type="checkbox"> 基于数据库实现分布式锁</li>
<li><input checked disabled type="checkbox"> 基于缓存（Redis等）</li>
<li><input disabled type="checkbox"> 基于Zookeeper</li>
</ul>
<h1 id="3-Redis-实现分布式锁"><a href="#3-Redis-实现分布式锁" class="headerlink" title="3. Redis 实现分布式锁"></a>3. Redis 实现分布式锁</h1><h2 id="3-1简单实现"><a href="#3-1简单实现" class="headerlink" title="3.1简单实现"></a>3.1简单实现</h2><p><strong>实现架构图：</strong></p>
<p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片01.png" alt="image-20210630161443209"></p>
<p>实现流程：</p>
<ol>
<li><p>多个客户端同时获取锁（setnx 命令实现）</p>
<ul>
<li>当且仅当 key 不存在，可将 key 的值设为 value，并返回 1 ，该客户端获得锁。</li>
<li>若给定的 key 已经存在，则 SETNX 不做任何动作。并返回 0 ，表示该锁没有被释放，获取锁失败。</li>
<li>客户端最后可以通过 DEL lock-key 来释放该锁。</li>
</ul>
</li>
<li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
</li>
<li><p>其他客户端等待重试</p>
</li>
</ol>
<p><strong>Redis 操作指令：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;释放锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; del users </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setnx</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2优化之设置锁的过期时间"><a href="#3-2优化之设置锁的过期时间" class="headerlink" title="3.2优化之设置锁的过期时间"></a>3.2优化之设置锁的过期时间</h2><p>上面的实现中缺乏原子性，setnx 刚好获取到锁，业务逻辑出现异常，导致锁无法释放，所以就要设置过期时间。但是如果在 setnx 和 expire 之间出现异常，锁也无法释放，所以设置过期时间还不够，要在 set 时加锁并指定过期时间</p>
<p><strong>实现架构图：</strong></p>
<p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片02.png" alt="image-20210630162701714"></p>
<p><strong>Redis 操作指令：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加锁&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; setnx users 10</span><br><span class="line">(integer) 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;设置过期时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; expire users 10</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl users </span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; ttl users </span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; setnx users 20</span><br><span class="line">(integer) 1</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;加锁的同时设置过期时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">127.0.0.1:6379&gt; set users 20 nx ex 10</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>代码实现修改：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>，<span class="number">3</span>，TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h2 id="3-3优化之-UUID-防误删"><a href="#3-3优化之-UUID-防误删" class="headerlink" title="3.3优化之 UUID 防误删"></a>3.3优化之 UUID 防误删</h2><p><strong>问题：</strong>可能会释放其他服务器的锁。</p>
<p><strong>场景：</strong>如果业务逻辑的执行时间是 7s。执行流程如下</p>
<ol>
<li><p>index1 业务逻辑没执行完，3 秒后锁被自动释放。</p>
</li>
<li><p>index2 获取到锁，执行业务逻辑，3 秒后锁被自动释放。</p>
</li>
<li><p>index3 获取到锁，执行业务逻辑</p>
</li>
<li><p>index1 业务逻辑执行完成，开始调用 del 释放锁，这时释放的是 index3 的锁，导致 index3 的业务只执行 1s 就被别人释放。</p>
</li>
</ol>
<p>最终等于没锁的情况。</p>
<p><strong>解决：</strong>setnx 获取锁时，设置一个指定的唯一值（例如：uuid），释放前获取这个值，判断是否自己的锁，只有自己的锁才能释放。</p>
<p><strong>实现架构图：</strong></p>
<p><img src="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/GitHub\MyBlogs\source_posts\2021-06-30-Redis分布式锁\图片03.png" alt="image-20210630163248866"></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setnx</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4判断是不是自己的锁，并释放锁，del</span></span><br><span class="line">        <span class="keyword">if</span>(uuid.equals((String)redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">            redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4优化之-LUA-脚本保证删除的原子性"><a href="#3-4优化之-LUA-脚本保证删除的原子性" class="headerlink" title="3.4优化之 LUA 脚本保证删除的原子性"></a>3.4优化之 LUA 脚本保证删除的原子性</h2><p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<ol>
<li><p>index1 执行删除时，查询到的 lock 值确实和 uuid 相等                        </p>
</li>
<li><p>index1 执行删除前，lock 刚好过期时间已到，被 redis 自动释放。在 redis 中没有了 lock，没有了锁。</p>
</li>
<li><p>index2 获取了 lock，index2 线程获取到了 cpu 的资源，开始执行方法</p>
</li>
<li><p>index1 执行删除，此时会把index2的lock删除</p>
<p>index1 因为判断完 uuid 之后，已经在方法中了，所以不需要重新上锁。index1 有执行的权限。index1 已经比较完成了，这个时候，开始执行删除的 index2 的锁！</p>
</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLockLua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    String skuId = <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    String locKey = <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来释放锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua脚本</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lua 脚本详解：</strong></p>
<p>支持原子性操作，脚本在执行的时候，不能被其它事务打断，所以我们可以将删除操作放到脚本中，来保证它的原子性。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5总结"><a href="#3-5总结" class="headerlink" title="3.5总结"></a>3.5总结</h2><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
<li>加锁和解锁必须具有原子性。</li>
</ol>
<h1 id="4-解决并发竞争-Key-问题"><a href="#4-解决并发竞争-Key-问题" class="headerlink" title="4.解决并发竞争 Key 问题"></a>4.解决并发竞争 Key 问题</h1><p><strong>介绍：</strong>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>这里的并发指的是多个 Redis 的 client 同时 set key 引起的并发问题。</p>
<h2 id="方案一：分布式锁-时间戳"><a href="#方案一：分布式锁-时间戳" class="headerlink" title="方案一：分布式锁+时间戳"></a>方案一：分布式锁+时间戳</h2><p><strong>分布式锁：</strong>传统的加锁的做法（如 java 的 synchronized 和 Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。分布式锁可以基于很多种方式实现，比如 Zookeeper、Redis 等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p>
<p>利用 SETNX 非常简单地实现分布式锁。例如：某客户端要获得一个名字 users 的锁，客户端使用下面的命令进行获取：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">SETNX lock.users&lt;current Unix <span class="built_in">time</span> + lock timeout + <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>

<p>把 lock.users 的键值设置为时间值表示该键已被锁定</p>
<p><strong>时间戳</strong></p>
<p>由于上面举的例子，要求key的操作需要顺序执行，所以需要<strong>在缓存中</strong>保存一个时间戳判断set顺序。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">系统 A key <span class="number">1</span> &#123;ValueA <span class="number">7</span>:<span class="number">00</span>&#125;</span><br><span class="line">系统 B key <span class="number">1</span> &#123;ValueB <span class="number">7</span>:<span class="number">05</span>&#125;</span><br></pre></td></tr></table></figure>

<p>假设系统 B 先抢到锁，将 key1 设置为{ValueB 7:05}。接下来系统 A 抢到锁，发现自己的 key1 的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。（因为操作的发出本身就是有时间信息的，所以可以与缓存中 Set 操作的时间戳做比较）</p>
<h2 id="方案二：利用消息队列"><a href="#方案二：利用消息队列" class="headerlink" title="方案二：利用消息队列"></a>方案二：利用消息队列</h2><p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p>
<p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p>
<h2 id="附加：zookeeper-分布式锁"><a href="#附加：zookeeper-分布式锁" class="headerlink" title="附加：zookeeper 分布式锁"></a>附加：zookeeper 分布式锁</h2><p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>Redis相关</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理</title>
    <url>/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-数据库基础知识"><a href="#1-数据库基础知识" class="headerlink" title="1.数据库基础知识"></a>1.数据库基础知识</h1><h2 id="1-1什么是SQL？"><a href="#1-1什么是SQL？" class="headerlink" title="1.1什么是SQL？"></a>1.1什么是SQL？</h2><p>结构化查询语言（Structure Query Language）简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取、查询、更新和管理关系型数据库</p>
<h2 id="1-2关系型数据库与非关系型数据库"><a href="#1-2关系型数据库与非关系型数据库" class="headerlink" title="1.2关系型数据库与非关系型数据库"></a>1.2关系型数据库与非关系型数据库</h2><p><strong>关系型数据库：</strong>由数据库中的二维表及其之间的联系组成的一个数据库组织</p>
<p><strong>常见：</strong>MySQL、SQL Server、Oracle</p>
<p><strong>优点：</strong></p>
<ol>
<li>易于维护：都是表结构，格式统一</li>
<li>使用方便：SQL语言通用</li>
<li>支持复杂查询：可以使用SQL语句用于一个表以及多个表之间的查询</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>当操作海量数据时，读写性能比较差</li>
<li>表结构固定，灵活度稍差</li>
<li>对于高并发读写需求，硬盘I/O是一个很大的瓶颈</li>
</ol>
<p><strong>非关系型数据库：</strong>非关系型数据库是一种数据结构化存储方法的集合，可以是文档或者键值对</p>
<p><strong>常见：</strong>Redis</p>
<p><strong>优点：</strong></p>
<ol>
<li>格式灵活，可以是键值对的形式、文档形式、图片形式等等，而关系型数据库只支持基本的数据类型</li>
<li>速度快</li>
<li>高扩展性</li>
<li>成本低</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不提供SQL支持，学习和使用成本较高</li>
<li>无事务处理</li>
<li>数据结构相对复杂</li>
<li>复杂查询方面欠缺</li>
</ol>
<h2 id="1-3数据库三大范式是什么"><a href="#1-3数据库三大范式是什么" class="headerlink" title="1.3数据库三大范式是什么"></a>1.3数据库三大范式是什么</h2><ul>
<li><p>1NF：有主键，字段是原子性的，不可分；（保证字段的原子性）</p>
</li>
<li><p>2NF：有主键，非主键列完全依赖于主键，而不能是依赖于主键的一部分；（保证一张表只能描述一件事）</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。</p>
</li>
<li><p>3NF：<strong>非主键字段不能相互依赖</strong>。 每列都与主键有<strong>直接关系</strong>，<strong>不存在传递的依赖。</strong></p>
<p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p>
</li>
</ul>
<p><strong>不符合第一范式的例子：</strong></p>
<p> <strong>表：</strong>字段1、 字段2、字段3 (字段3.1、字段3.2)……</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>湖北武汉市，12345678</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>山东滨州市，1234567</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>河北沧州市，123456</td>
</tr>
</tbody></table>
<p>这个表中主键重复，信息字段可以再分。</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>家庭住址</th>
<th>联系电话</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>湖北武汉市</td>
<td>12345678</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>山东滨州市</td>
<td>1234567</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>河北沧州市</td>
<td>123456</td>
</tr>
</tbody></table>
<p><strong>不符合第二范式的例子：</strong></p>
<p><strong>表：</strong></p>
<table>
<thead>
<tr>
<th>学号</th>
<th>教师编号</th>
<th>学生姓名</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>001</td>
<td>张三</td>
<td>王老师</td>
</tr>
<tr>
<td>1002</td>
<td>002</td>
<td>李四</td>
<td>张老师</td>
</tr>
<tr>
<td>1003</td>
<td>001</td>
<td>王五</td>
<td>王老师</td>
</tr>
<tr>
<td>1001</td>
<td>002</td>
<td>张三</td>
<td>张老师</td>
</tr>
</tbody></table>
<p>在这张表中，学生编号+教师编号做联合主键，复合主键（学生编号+教师编号）。</p>
<p>但是学生依赖于学生编号，教师依赖于教师编号，所以产生了部分依赖。这样张三、王老师等都重复了，也就是产生了数据冗余。可以通过分表的方式来表示多对多的关系。</p>
<p><strong>学生表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
</tr>
</tbody></table>
<p><strong>教师表：</strong></p>
<table>
<thead>
<tr>
<th>教师编号（pk）</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>王老师</td>
</tr>
<tr>
<td>002</td>
<td>张老师</td>
</tr>
</tbody></table>
<p><strong>学生教师关系表：</strong></p>
<table>
<thead>
<tr>
<th>id（pk）</th>
<th>学号（fk）</th>
<th>教师编号（fk）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>001</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>002</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>001</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>002</td>
</tr>
</tbody></table>
<p><strong>不符合第三范式的例子:</strong></p>
<p><strong>表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
<th>班级编号</th>
<th>班级名称</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
<td>一年三班</td>
</tr>
<tr>
<td>1004</td>
<td>张三</td>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody></table>
<p>存在依赖传递: (班级名称) → (班级编号) → (学号)，产生了数据的冗余，即重复的一年三班，存在一对多的关系，仍然通过拆分表来解决。</p>
<p><strong>学生表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
<th>班级编号（fk）</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
</tr>
<tr>
<td>1004</td>
<td>张三</td>
<td>03</td>
</tr>
</tbody></table>
<p><strong>班级表：</strong></p>
<table>
<thead>
<tr>
<th>班级编号（pk）</th>
<th>班级名称</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody></table>
<p><strong>总结：多对多、一对多应该如何设计表</strong></p>
<p>多对多：三张表，关系表两个外键</p>
<p>一对多：两张表，多的表加外键</p>
<h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h1><h2 id="2-1概念"><a href="#2-1概念" class="headerlink" title="2.1概念"></a>2.1概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片01.png" alt="img" style="zoom:80%;">

<h2 id="2-2四大特性（ACID）"><a href="#2-2四大特性（ACID）" class="headerlink" title="2.2四大特性（ACID）"></a>2.2四大特性（ACID）</h2><p><strong>1. 原子性（Atomicity）</strong></p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<ul>
<li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
<p><strong>2. 一致性（Consistency）</strong></p>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<blockquote>
<p>我们在理解数据库时，要把数据库想象成现实生活中的映射，如果数据库中的数据全都符合现实生活中的约束，那么这些数据就是一致的，或者说符合一致性的。</p>
</blockquote>
<p><strong>3. 隔离性（Isolation）</strong></p>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<p><strong>4. 持久性（Durability）</strong></p>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<ul>
<li>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
<p><strong>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</strong></p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片02.png" alt="img" style="zoom:80%;">

<h2 id="2-3-AUTOCOMMIT"><a href="#2-3-AUTOCOMMIT" class="headerlink" title="2.3 AUTOCOMMIT"></a>2.3 AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h1 id="3-并发一致性问题"><a href="#3-并发一致性问题" class="headerlink" title="3.并发一致性问题"></a>3.并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1.丢失修改"></a>1.丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<h2 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<h2 id="5-原因分析"><a href="#5-原因分析" class="headerlink" title="5.原因分析"></a>5.原因分析</h2><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是<strong>封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p>
<h1 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4.隔离级别"></a>4.隔离级别</h1><p>隔离级别的存在也是为了解决隔离性的问题</p>
<h2 id="1-读取未提交"><a href="#1-读取未提交" class="headerlink" title="1.读取未提交"></a>1.读取未提交</h2><p> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<h2 id="2-读取已提交"><a href="#2-读取已提交" class="headerlink" title="2.读取已提交"></a>2.读取已提交</h2><p>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<h2 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3.可重复读"></a>3.可重复读</h2><p>对同一字段的多次读取结果都是一致的，除非数据是被事务本身所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<h2 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4.可串行化"></a>4.可串行化</h2><p>最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<h1 id="5-锁机制"><a href="#5-锁机制" class="headerlink" title="5.锁机制"></a>5.锁机制</h1><h2 id="5-1锁的粒度"><a href="#5-1锁的粒度" class="headerlink" title="5.1锁的粒度"></a>5.1锁的粒度</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁、表级锁和页级锁。</p>
<p><strong>行级锁：</strong> 行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁：</strong> 表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁：</strong> 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h2 id="5-2锁的类型"><a href="#5-2锁的类型" class="headerlink" title="5.2锁的类型"></a>5.2锁的类型</h2><p><strong>1.读写锁</strong></p>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新，即执行 INSERT、UPDATE 或 DELETE 命令时。<strong>加锁期间其它事务不能对 A 加任何锁</strong>。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行 select 读取操作，但是不能进行更新操作。<strong>加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</strong>。</li>
</ul>
<p>锁的兼容关系如下：</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片03.png" alt="img" style="zoom:80%;">

<p><strong>2.意向锁</strong></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片04.png" alt="img" style="zoom:80%;">



<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h2 id="5-3锁协议"><a href="#5-3锁协议" class="headerlink" title="5.3锁协议"></a>5.3锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片06.png" alt="img" style="zoom:50%;">



<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片07.png" alt="img" style="zoom:50%;">



<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片08.png" alt="img" style="zoom:50%;">

<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p><strong>两段锁协议：</strong> 是指所有的事务必须分两个阶段对数据项加锁和解锁。即<code>事务分两个阶段</code>，第一个阶段是<code>获得封锁</code>。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是<code>释放封锁</code>，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p>
<p>第一阶段是获得封锁的阶段，称为<code>扩展阶段</code>：其实也就是该阶段可以进入加锁操作，<code>在对任何数据进行读操作之前要申请获得S锁</code>，<code>在进行写操作之前要申请并获得X锁</code>，<code>加锁不成功，则事务进入等待状态</code>，直到加锁成功才继续执行。就是<code>加锁后就不能解锁</code>了。</p>
<p>第二阶段是释放封锁的阶段，称为<code>收缩阶段</code>：当事务释放一个封锁后，事务进入封锁阶段，在该阶段<code>只能进行解锁而不能再进行加锁操作</code>。</p>
<p><strong>加锁时机</strong></p>
<p>当对记录进行更新操作或者select for update(X锁)、lock in share mode(S锁)时，会对记录进行加锁。</p>
<p><strong>解锁时机</strong></p>
<p>commit或者rollback时。</p>
<p><strong>例：</strong></p>
<p>T1 事务：满足两段锁协议</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>T2 事务：不满足两段锁协议</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如 T1 事务满足两段锁协议，它是可串行化调度。但是 T2 事务不满足，还可以是可串行化调度。</p>
<blockquote>
<p><strong>可串行化调度：</strong>是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
</blockquote>
<h3 id="3-MySQL-隐式与显式锁定"><a href="#3-MySQL-隐式与显式锁定" class="headerlink" title="3. MySQL 隐式与显式锁定"></a>3. MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-InnoDB-存储引擎的锁的算法"><a href="#6-InnoDB-存储引擎的锁的算法" class="headerlink" title="6. InnoDB 存储引擎的锁的算法"></a>6. InnoDB 存储引擎的锁的算法</h1><h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p>锁直接加在索引记录上面，锁住的是key。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p>在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。Gap 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<h2 id="3-Next-Key-Lock"><a href="#3-Next-Key-Lock" class="headerlink" title="3. Next-Key Lock"></a>3. Next-Key Lock</h2><p>Next-Key Lock 是行锁和间隙锁的组合，锁定索引记录两边的间隙，并锁定记录本身，对于行的查询都是采用该方法，主要是解决幻读的问题。</p>
<p><strong>间隙锁的缺点：</strong></p>
<p>间隙锁有一个缺点就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入键值锁定范围内的任何数据，在某些场景下可能会对并发性能造成较大的危害。</p>
<h1 id="7-多版本并发控制"><a href="#7-多版本并发控制" class="headerlink" title="7.多版本并发控制"></a>7.多版本并发控制</h1><h2 id="7-1什么是-MVCC"><a href="#7-1什么是-MVCC" class="headerlink" title="7.1什么是 MVCC"></a>7.1什么是 MVCC</h2><p><strong>MVCC</strong> 全称<code>Multi-Version Concurrency Control</code>，即<strong>多版本并发控制。</strong>MVCC 在 MySQL 中的实现主要是为了<strong>提高数据库并发性能</strong>，用<strong>更好的去处理读-写冲突</strong>。</p>
<p>它是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现<strong>读取已提交</strong>和<strong>可重复读</strong>这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="7-2当前读和快照读"><a href="#7-2当前读和快照读" class="headerlink" title="7.2当前读和快照读"></a>7.2当前读和快照读</h2><p>在学习 MVCC 多版本并发控制之前，我们必须先了解一下，什么是 MySQL InnoDB 下的当前读和快照读?</p>
<ul>
<li><strong>当前读</strong><br>像 select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁) 这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li><strong>快照读</strong><br>像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读（一个事务读的肯定是最新版本）；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC，可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>
</ul>
<p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p>
<p><strong>当前读，快照读和MVCC的关系：</strong></p>
<ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念，仅仅是一个理想概念。</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。</li>
</ul>
<h2 id="7-3-MVCC-能解决什么问题"><a href="#7-3-MVCC-能解决什么问题" class="headerlink" title="7.3 MVCC 能解决什么问题"></a>7.3 MVCC 能解决什么问题</h2><p><strong>数据库并发场景有三种，分别为：</strong></p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题</li>
</ul>
<p><strong>MVCC带来的好处是？</strong><br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>总结MVCC的作用：</strong><br>MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h2 id="7-4-MVCC-的实现原理"><a href="#7-4-MVCC-的实现原理" class="headerlink" title="7.4 MVCC 的实现原理"></a>7.4 MVCC 的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖<strong>数据库记录</strong>中的 <strong><code>3个隐式字段</code>**，</strong><code>undo日志</code>** ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念：</p>
<p><strong>隐式字段：</strong>  <strong>数据库表中</strong>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li><strong>DB_TRX_ID</strong><br>最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong><br>回滚指针，用于配合undo日志，指向上一个旧版本（存储于rollback segment里）</li>
<li><strong>DB_ROW_ID</strong><br>隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><strong>undo日志：</strong>undo log主要分为两种</p>
<ul>
<li><strong>insert undo log</strong><br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li><strong>update undo log（最重要）</strong><br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
<p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p>
<p><strong>Read View(读视图)</strong></p>
<p><code>Read View</code>就是事务进行<code>快照读</code>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)**</p>
<p>所以我们知道 <code>Read View</code>主要是<strong>用来做可见性判断</strong>的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p>
<p><code>Read View</code>遵循一个可见性算法，主要是将要<code>被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟<code>Read View</code>的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个<code>DB_TRX_ID</code>所在的旧记录就是当前事务能看见的最新老版本</p>
<p><strong>读视图中的字段，小的那个记录的是活跃的事务中的最小ID，还有一个记录系统分配的最新事务ID，也就是这个范围内的事务要么是活跃的，要么是结束的，结束的可以看因为是在该事务执行快照读之前提交的，还有有数据库隐式字段记录的事务ID在最小值之前，也就是与执行该快照读的事务没有交集，当前事务也能够读到，但是当隐式字段的ID是最新分配的就读不到了</strong></p>
<h2 id="7-5-MVCC-工作整体流程"><a href="#7-5-MVCC-工作整体流程" class="headerlink" title="7.5 MVCC 工作整体流程"></a>7.5 MVCC 工作整体流程</h2><ul>
<li><p>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.01.png" style="zoom: 67%;">
</li>
<li><p><code>Read View</code>不仅仅会通过一个列表<code>trx_list</code>来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录<code>trx_list</code>列表中事务ID最小的ID），<code>low_limit_id</code>(记录<code>trx_list</code>列表中快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3。</p>
</li>
<li><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的<code>undo log</code>，如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和活跃事务ID列表(<code>trx_list</code>)进行比较，判断当前事务2能看到该记录的版本是哪个。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片05.png" style="zoom: 67%;">
</li>
<li><p>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID 4去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看4是否小于<code>up_limit_id(1)</code>，所以不符合条件，继续判断 4 是否大于等于 <code>low_limit_id(5)</code>，也不符合条件，最后判断4是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p>
<p><strong>总结：</strong>这个事务是活跃的不能看，执行快照之后分配的事务ID不能看，只有在执行快照之前提交完成 的事务数据能看</p>
</li>
<li><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p>
</li>
</ul>
<h2 id="7-6-MVCC-相关问题"><a href="#7-6-MVCC-相关问题" class="headerlink" title="7.6 MVCC 相关问题"></a>7.6 MVCC 相关问题</h2><p><strong>1. RR 是如何在 RC 级的基础上解决不可重复读的？</strong></p>
<p><strong>当前读和快照读在RR级别下的区别：</strong></p>
<p><code>表1:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读(无影响)查询金额为500</td>
<td align="center">快照读查询金额为500</td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为500</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p>
<p><code>表2:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读（无影响）查询金额为500</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为400</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<p><strong>2. RC，RR 级别下的 InnoDB 快照读有什么不同？</strong></p>
<p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<code>Read View</code>, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个<code>Read View</code>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个<code>Read View</code>，所以对之后更新的修改不可见；</li>
<li>即RR级别下，快照读生成<code>Read View</code>时，<code>Read View</code>会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<code>Read View</code>创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因（不可重复读）</li>
</ul>
<p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>数据库系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行时数据区</title>
    <url>/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-JVM-运行时数据区"><a href="#1-JVM-运行时数据区" class="headerlink" title="1. JVM 运行时数据区"></a>1. JVM 运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）,如图所示：</p>
<img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片01.png" alt="img" style="zoom: 50%;">

<h1 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h1><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
<h1 id="3-Java-虚拟机栈"><a href="#3-Java-虚拟机栈" class="headerlink" title="3. Java 虚拟机栈"></a>3. Java 虚拟机栈</h1><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈（被指令操作的数据）、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
<img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片02.png" alt="img" style="zoom:80%;">

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError（OOM） 异常。</li>
</ul>
<h1 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h1><p>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p>
<h1 id="5-Java-堆"><a href="#5-Java-堆" class="headerlink" title="5. Java 堆"></a>5. Java 堆</h1><p>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例和数组都在这里分配内存；<strong>（线程共享）</strong></p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代（Young Generation）、老年代（Old Generation）。在细致一点的有Eden空间、From Survivor 空间、To Survior 空间等。</p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>

<p>​       上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。（年轻代：老年代=8:1）</p>
<h1 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h1><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译（ JIT 编译）后的代码等数据。<strong>（线程共享）</strong></p>
<p>方法区可以看成是一块独立于 Java 堆的内存空间。但是与 Java 堆一样都是线程共享的内存区域。</p>
<p>方法区在 JVM 启动的时候创建，它的内存分配与 Java 堆一样，可以是不连续的。</p>
<p>方法区的大小跟堆内存一样，可以选择固定或者是可扩展的。方法区的大小决定了可以保存多少个类，如果定义了太多的类，导致方法区溢出，虚拟机会抛出内存溢出错误：java.lang.OutOfMemoryError : PermGen（永久代实现） 或者 java.lang.OutOfMemoryError : Metaspace（元空间实现）。比如：加载大量的第三方 jar 包、Tomcat 部署的工程过多、动态生成大量的反射类就会出现 OOM。</p>
<p>关闭 JVM 就会释放这个区域的内存。</p>
<h2 id="6-1-Hotspot-虚拟机中方法区的演进过程"><a href="#6-1-Hotspot-虚拟机中方法区的演进过程" class="headerlink" title="6.1 Hotspot 虚拟机中方法区的演进过程"></a>6.1 Hotspot 虚拟机中方法区的演进过程</h2><p>要注意，只有在 Hotspot 虚拟机中才有永久代的概念，方法区是 Java 虚拟机的一种规范，并不要求每个实现版本的统一。</p>
<p><strong>Hotspot 中方法区的变化：</strong></p>
<ul>
<li><strong>jdk1.6 之前：</strong>有永久代，静态变量存放在永久代上，之所以落地在永久代，是因为存活时间比较长，不用频繁 GC。</li>
<li><strong>jdk1.7：</strong>有永久代，但是逐渐“去永久代”，字符串常量池、静态变量移除，保存在堆中（拿走了一部分内容）</li>
<li><strong>jdk1.8 及之后：</strong>无永久代的概念了，通过元空间来存放类型信息、字段、方法、运行时常量池，注意这时的元空间是使用的本地内存，也就是 JVM 之外的内存。但是字符串常量池、静态变量仍在堆中。</li>
</ul>
<p>演变过程示意图：</p>
<p><strong>jdk1.6:</strong></p>
<img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片03.png" alt="image-20210621172036767" style="zoom:60%;">

<p><strong>jdk1.7:</strong></p>
<img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片04.png" alt="image-20210621172445798" style="zoom:60%;">

<p><strong>jdk1.8:</strong></p>
<img src="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/GitHub\MyBlogs\source\_posts\2021-06-21-JVM运行时数据区\图片05.png" alt="image-20210621172649516" style="zoom:60%;">

<h2 id="6-2-永久代为什么要被元空间替换"><a href="#6-2-永久代为什么要被元空间替换" class="headerlink" title="6.2 永久代为什么要被元空间替换"></a>6.2 永久代为什么要被元空间替换</h2><p>从 jdk1.8 之后，永久代就消失了，取而代之的是用元空间来存储类的元信息，元空间是落地在本地内存中的，因此元空间的最大可用内存就是系统的可用内存空间。</p>
<p>这项改动的原因主要是因为以下两个方面：</p>
<ol>
<li><p>为永久代设置空间大小是很难确定的</p>
<p>在某些场景下，如果分配的内存空间较小，容易造成 FullGC 的次数变多，导致 Stop World 的次数多，系统运行停顿时间变长，另一方面是动态加载的类过多，容易产生永久代的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中需要动态加载很多类，容易发生 OOM 错误。</p>
<p>如果盲目分配很大的内存空间，就会造成资源浪费。</p>
<p>而元空间和永久代的最大区别就是：元空间不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li><p>对永久代的调优比较困难</p>
<p>虽然永久代的 FullGC 的机会比较少，但是也会出现。</p>
<p>方法区的垃圾回收内容：常量池中废弃的常量和不再使用的类。对于废弃常量的回收比较简单，但是判断是否需要回收一个类需要特别复杂的机制，是一个比较耗时的过程。</p>
<p>所以使用元空间可以尽可能地少出现 FullGC ，对于 JVM 是一个很好的优化。</p>
</li>
</ol>
<h2 id="6-3字符串常量池"><a href="#6-3字符串常量池" class="headerlink" title="6.3字符串常量池"></a>6.3字符串常量池</h2><p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到 string pool 中（记住： string pool 中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在 HotSpot VM 里实现的 string  pool 功能的是一个 StringTable 类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个 StringTable 引用之后就等同被赋予了”驻留字符串”的身份。这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。</p>
<h2 id="6-4-Class-文件常量池"><a href="#6-4-Class-文件常量池" class="headerlink" title="6.4 Class 文件常量池"></a>6.4 Class 文件常量池</h2><p>class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池表(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。  字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值（int count = 20 中的 20 ）等。  符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p><strong>作用：</strong>一个 Java 源文件经过编译后会产生一个字节码文件。而这一个程序的执行需要很多的数据支持，像各种类型的类等，如果我们都将这些数据放到字节码文件中，这个文件会非常大，即便是一个很简单的程序。换另一种方式，可以将需要的类型用一个符号代替，将这些符号放到常量池中，就会大大减小编程后的字节码文件大小。</p>
<h2 id="6-5运行时常量池"><a href="#6-5运行时常量池" class="headerlink" title="6.5运行时常量池"></a>6.5运行时常量池</h2><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p>
<p>jvm 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而<strong>当类或者接口文件加载到虚拟机内存中后，jvm就会将class常量池中的内容存放到运行时常量池中</strong>，由此可知，<strong>运行时常量池也是每个类都有一个</strong>。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是<strong>把符号引用替换为直接引用</strong>，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p>
<h2 id="6-6实例说明"><a href="#6-6实例说明" class="headerlink" title="6.6实例说明"></a>6.6实例说明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String（<span class="string">&quot;abc&quot;</span>）；<span class="comment">//创建了几个对象？</span></span><br></pre></td></tr></table></figure>

<p>这行代码形式上很简单，其实很复杂。有一个常见的 Java 笔试题就是问上面这行代码创建了几个 String 对象。</p>
<p>你可能认为它创建了一个对象，其实它是创建了两个 String 对象。</p>
<p>JVM为了提高性能，将一下两种形式的字符串放在一个称之为字符串驻留池的内存块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">形式一：String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">形式二：<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>其实，形式一和形式二都是字符串的字面常量。所以，可以这样理解，即把字符串的字面常量都放在了字符串驻留池中。对形式一来说， str 其实就是引用的字符串驻留池中 “abc” 这个 String 对象。</p>
<p>如果有如下的两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么，上面的两行代码创建了几个 String 对象？答案是一个。根据我们刚才所述，那么第一行语句将在池中创建一个 String 对象，第二行会先在池中寻找是否有值与 “abc” 相同的 String 对象，如果有，就直接引用，没有这在池中新建 String 对象。这下，就明白了为什么上面的两行语句仅仅创建了一个 String 对象。</p>
<p>然后，让我们来看一看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>)；</span><br></pre></td></tr></table></figure>

<p>先不讨论到底创建了几个 String 对象。我们在这里，比较一下这种 new 的方式和上面的直接赋值方式两种创建 String 对象的不同，直接赋值的方式是在字符串驻留池中创建对象，但 new 这种方式是在堆中创建对象。即 new 创建的 String 对象是不会放入字符串驻留池中的。如果一定要把某个通过 new 创建的字符串对象放入驻留池，可以使用 intern() 方法。如 String strt =  str.intern()，将把 str 的值放在驻留池中（当然，是在驻留池原来没有这个值对应的 String 对象的情况下），并返回驻留池中 String 对象的引用。</p>
<p>现在，可以分析 String str = new String(“abc”); 创建了几个 String 对象了。很明显，传入的 “abc” 字符串字面常量在驻留池中创建了一个对象，new 操作符在堆中创建了一个对象，所以，一共创建了两个 String 对象。</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">		String str1 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">		String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>); </span><br><span class="line">		String str3 = <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">		String str4 = str2.intern(); </span><br><span class="line">		String str5 = <span class="string">&quot;def&quot;</span>; </span><br><span class="line">		System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">		System.out.println(str2 == str4);<span class="comment">//false </span></span><br><span class="line">		System.out.println(str4 == str5);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的内存分配过程：</p>
<p>首先，在堆中会有一个 ”abc” 实例，全局 StringTable 中存放着 ”abc” 的一个引用值</p>
<p>然后，在运行第二句的时候会生成<strong>两个实例：</strong>一个是<strong>字符串常量池</strong>中的 ”def” 实例对象，并且 StringTable 中存储一个 ”def” 的引用值，还有一个是<strong>堆内存</strong>中 new 出来的一个 ”def” 的实例对象，与上面那个是不同的实例</p>
<p>当在解析 str3 的时候查找 StringTable，里面有 ”abc” 的全局驻留字符串引用，所以 str3 的引用地址与之前的那个已存在的相同</p>
<p>str4 是在运行的时候调用 intern() 函数，返回 StringTable 中 ”def” 的引用值，如果没有就将 str2 的引用值添加进去，在这里，StringTable 中已经有了 ”def” 的引用值了，所以返回上面在 new str2 的时候添加到 StringTable 中的  “def” 引用值，最后 str5 在解析的时候就也是指向存在于 StringTable 中的 ”def” 的引用值</p>
<p>上面程序的首先经过编译之后，在该类的 class 常量池中存放一些符号引用，然后类加载之后，将 class 常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中 str1 所指向的 ”abc” 实例对象），然后将这个对象的引用存到全局 String Pool 中，也就是 StringTable 中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询 StringTable，保证 StringTable 里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p>
<h2 id="6-7补充说明"><a href="#6-7补充说明" class="headerlink" title="6.7补充说明"></a>6.7补充说明</h2><h3 id="1-符号引用与直接引用"><a href="#1-符号引用与直接引用" class="headerlink" title="1.符号引用与直接引用"></a>1.符号引用与直接引用</h3><p><strong>在JVM中类加载过程中，在解析阶段，Java虚拟机会把类的二级制数据中的符号引用替换为直接引用。</strong></p>
<ol>
<li><p>符号引用</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在 Class 文件中它以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在 Java 中，一个 java 类将会编译成一个 class 文件。<strong>在编译时， java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</strong>比如 org.simple.People 类引用了 org.simple.Language 类，在编译时 People 类并不知道 Language 类的实际内存地址，因此只能使用符号 org.simple.Language（假设是这个，当然实际中是由类似于 CONSTANT_Class_info 的常量来表示的）来表示 Language 类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。</p>
</li>
<li><p>直接引用</p>
<p>直接引用可以是</p>
<p>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</p>
<p>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</p>
<p>（3）一个能间接定位到目标的句柄</p>
<p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器原理</title>
    <url>/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>布隆过滤器的作用就是用来过滤非法 key ，避免缓存穿透，布隆过滤器用的是位数组，很节省空间，性能也相当好。</p>
<p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：<strong>如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在</strong>。这就是布隆过滤器的基本思想。</p>
<p><img src="/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-06-21-布隆过滤器原理\图片02.png" alt="这里写图片描述"></p>
<p><img src="/2021/06/21/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source_posts\2021-06-21-布隆过滤器原理\图片03.png" alt="这里写图片描述"></p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你的布隆过滤器容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">28</span>;</span><br><span class="line">    <span class="comment">//bit数组，用来存放key</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BitSet bitSet = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</span><br><span class="line">    <span class="comment">//后面hash函数会用到，用来生成不同的hash值，可随意设置，别问我为什么这么多8，图个吉利</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">58</span>, <span class="number">68</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add方法，计算出key的hash值，并将对应下标置为true</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Arrays.stream(ints).forEach(i -&gt; bitSet.set(hash(key, i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断key是否存在，true不一定说明key存在，但是false一定说明不存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i : ints) &#123;</span><br><span class="line">        	 <span class="comment">//短路与，只要有一个bit位为false，则返回false</span></span><br><span class="line">             result = result &amp;&amp; bitSet.get(hash(key, i));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash函数，借鉴了hashmap的扰动算法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="number">0</span> : (i * (DEFAULT_SIZE - <span class="number">1</span>) &amp; ((h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>testDemo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyNewBloomFilter myNewBloomFilter = <span class="keyword">new</span> MyNewBloomFilter();</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;郭德纲&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="string">&quot;蔡徐鸡&quot;</span>);</span><br><span class="line">    myNewBloomFilter.add(<span class="number">666</span>);</span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友 &quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;张学友1&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;郭德纲&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="string">&quot;蔡徐老母鸡&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="number">666</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(myNewBloomFilter.isContain(<span class="number">888</span>));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比hash算法计算出来的下标，注意，我们是对比一组，而不是只看一次，一次hash结果对应一个下标</p>
<p>把同一个key进行多次hash运算，将hash出来的下标放入数组，数组默认全为0，放入元素后该下标就为1，后面判断是否存在元素的时候也是进行同样次数的hash运算，看下结果对应的所有下标是否全为1，若全为1，则代表该key可能存在，若存在不为1的，则说明该key一定不存在；</p>
<p>默认位数组：[0，0，0，0，0，0]<br>比方说有个已知key的下标是0，2，5</p>
<p>对应位数组：[1，0，1，0，0，1]<br>判断某个未知key存不存在的时候，假设我们计算出来的下标是0，2，4</p>
<p>对应位数组：[1，0，1，0，1，0]<br>此时位数组内5对应下标值为0，而已知key位数组的5对应下标位1，说明这两个一定不是同一个key</p>
<p>相反，如果某个key计算出来的下标为[1，0，1，0，0，1]，只能说这个key可能存在，因为这个key可能是其它key计算出来的</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty任务队列</title>
    <url>/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-Netty中的-TaskQueue-有-3-种典型使用场景"><a href="#1-Netty中的-TaskQueue-有-3-种典型使用场景" class="headerlink" title="1.Netty中的 TaskQueue 有 3 种典型使用场景"></a>1.Netty中的 TaskQueue 有 3 种典型使用场景</h1><ol>
<li><p>用户程序自定义的普通任务</p>
</li>
<li><p>用户自定义定时任务</p>
</li>
<li><p>非当前 Reactor 线程调用 Channel 的各种方法</p>
<p>例如在<strong>推送系统</strong>的业务线程里面，根据<strong>用户的标识</strong>，找到对应的 <strong>Channel</strong> <strong>引用</strong>，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被<strong>异步消费</strong></p>
</li>
</ol>
<h1 id="2-自定义的普通任务"><a href="#2-自定义的普通任务" class="headerlink" title="2.自定义的普通任务"></a>2.自定义的普通任务</h1><p>Netty 如果不做特定的操作当有<strong>耗时高的业务</strong>，handler 会阻塞，如下所示：</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.自定义的handler需要继承netty规定的handlerAdapter</span></span><br><span class="line"><span class="comment">*重写一些方法，自定义的handler才能称为一个handler</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">    <span class="comment">//ChannelHandlerContext是上下文对象，含有管道pipeline,通道channel</span></span><br><span class="line">    <span class="comment">//Object msg客户端发送的数据，默认Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//当有耗时高的业务时</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , 阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sever go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//write加Flush方法，将数据写入缓存并刷新</span></span><br><span class="line">        <span class="comment">//对发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列01.png" alt="在这里插入图片描述"></p>
<p>因为 Handler 中有高耗时的方法，所以服务器端在执行到该方法时，就会阻塞，客户端也会阻塞之后才收到消息。</p>
<h2 id="使用任务队列"><a href="#使用任务队列" class="headerlink" title="使用任务队列"></a>使用任务队列</h2><p><strong>修改一下服务端的 Handler：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1.自定义的handler需要继承netty规定的handlerAdapter</span></span><br><span class="line"><span class="comment">*重写一些方法，自定义的handler才能称为一个handler</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取客户端发送的数据</span></span><br><span class="line">    <span class="comment">//ChannelHandlerContext是上下文对象，含有管道pipeline,通道channel</span></span><br><span class="line">    <span class="comment">//Object msg客户端发送的数据，默认Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当有耗时高的业务时- 通过异步解决</span></span><br><span class="line">        <span class="comment">//提交该channel对应的NIOEventLoop的taskQueue上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.用户自定义的普通任务</span></span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , 阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sever go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//write加Flush方法，将数据写入缓存并刷新</span></span><br><span class="line">        <span class="comment">//对发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行结果：</strong></p>
<p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列02.png" alt="在这里插入图片描述"></p>
<p>TaskQueue 实现了异步处理，先执行 channelReadComplete，再执行阻塞事件，所以我们看到服务器很快就能启动，然后客户端间隔十秒收到消息，实现了异步获取服务。</p>
<p><strong>Note：</strong></p>
<ul>
<li>任务队列也可以放下多个任务</li>
<li>任务在 taskQueue 运行是顺序的，并且是一次运行单个任务（串行执行）</li>
</ul>
<h1 id="3-自定义的定时任务"><a href="#3-自定义的定时任务" class="headerlink" title="3.自定义的定时任务"></a>3.自定义的定时任务</h1><p>用户自定义定时任务与普通任务区别并不大，有一点不同：将<strong>任务提交到 scheduleTaskQueue</strong></p>
<p><strong>修改一下服务端的 Handler：</strong>在 channelRead 方法中添加下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.用户自定义定时任务-》任务提交到scheduleTaskQueue</span></span><br><span class="line">ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello , scheduleTaskQueue阻塞10秒&quot;</span>,  CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="/2021/06/15/Netty%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/GitHub\MyBlogs\source_posts\2021-06-15-Netty任务队列\任务队列03.png" alt="在这里插入图片描述"></p>
<p>这里我们又加入了一个阻塞 20 秒的任务，证明任务队列中的任务是串行执行的。</p>
<h1 id="4-非当前-Reactor-线程调用-Channel-的方法"><a href="#4-非当前-Reactor-线程调用-Channel-的方法" class="headerlink" title="4.非当前 Reactor 线程调用 Channel 的方法"></a>4.非当前 Reactor 线程调用 Channel 的方法</h1><p><strong>实现方式：</strong></p>
<p>可以使用一个集合管理所有的 SocketChannel，当我们想要推送消息时，将业务加入到该 Channel 对应的 NioEventLoop 的 TaskQueue 或者 ScheduleTaskQueue。</p>
<p>其实操作与上面两种类似<br>服务器使用集合保存管理所有的 SocketChannel，ctx.channel() 获得想要的通道， ctx.channel().eventLoop().schedule()或者.execute(）操作调用 Write 方法向该用户推送消息</p>
<p>其实我们前面已经往客户端推送消息了，这里只是对推送的通道做一定的限制（也就是要根据标识找到用户对应的 Channel ）。</p>
]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>Netty相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty线程模型</title>
    <url>/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-线程模型的基本介绍"><a href="#1-线程模型的基本介绍" class="headerlink" title="1.线程模型的基本介绍"></a>1.线程模型的基本介绍</h1><p><strong>目前存在的线程模型有：</strong></p>
<ul>
<li>传统阻塞 I/O 服务模型</li>
<li>Reactor 模式</li>
</ul>
<p><strong>然后根据 Reactor 的数量和处理资源线程池的数量不同，有三种典型的表现：</strong></p>
<ol>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程 </li>
</ol>
<h1 id="2-传统的阻塞-I-O-服务模型"><a href="#2-传统的阻塞-I-O-服务模型" class="headerlink" title="2.传统的阻塞 I/O 服务模型"></a>2.传统的阻塞 I/O 服务模型</h1><p><strong>工作原理图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\传统阻塞模型.png" alt="image-20210615163611563"></p>
<p><strong>模型特点：</strong></p>
<ol>
<li>采用阻塞 IO 模式获取输入的数据</li>
<li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li>
</ol>
<p><strong>问题分析：</strong></p>
<ol>
<li>当并发数很大，就会创建大量的线程，占用很大系统资源</li>
<li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 read 操作，造成线程资源浪费</li>
</ol>
<h1 id="3-Reactor-模型"><a href="#3-Reactor-模型" class="headerlink" title="3. Reactor 模型"></a>3. Reactor 模型</h1><p><strong>针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</strong></p>
<ol>
<li>基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li>
<li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</li>
</ol>
<p><strong>工作原理图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Reactor模式.png" alt="image-20210615164010482"></p>
<p><strong>工作流程：</strong></p>
<ol>
<li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此 Reactor 模式也叫 Dispatcher 模式</li>
<li>Reactor 模式使用 I/O 复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键</li>
</ol>
<p><strong>Reactor 模式中核心组成：</strong></p>
<p><strong>Reactor：</strong>Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。</p>
<p><strong>Handlers：</strong>处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</p>
<h2 id="3-1单-Reactor-单线程"><a href="#3-1单-Reactor-单线程" class="headerlink" title="3.1单 Reactor 单线程"></a>3.1单 Reactor 单线程</h2><p><strong>工作原理示意图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\单线程模型.png" alt="image-20210615165549406"></p>
<p><strong>工作流程：</strong></p>
<ol>
<li>Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li>
<li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li>
<li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后续业务处理</li>
<li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li>
<li>Handler 会完成 Read→业务处理→Send 的完整业务流程</li>
</ol>
<p><strong>优缺点分析：</strong></p>
<ul>
<li><strong>优点：</strong>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li><strong>缺点：</strong><ol>
<li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ol>
</li>
</ul>
<p><strong>使用场景：</strong></p>
<p>客户端的数量有限，业务处理非常快速，比如 Redis 在业务处理的时间复杂度 O(1) 的情况</p>
<h2 id="3-2单-Reactor-多线程"><a href="#3-2单-Reactor-多线程" class="headerlink" title="3.2单 Reactor 多线程"></a>3.2单 Reactor 多线程</h2><p><strong>工作原理示意图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\多线程模型.png" alt="image-20210615170532648"></p>
<p><strong>工作流程：</strong></p>
<ol>
<li>Reactor 对象通过 select 监控客户端请求事件, 收到事件后，通过 dispatch 进行分发</li>
<li>如果建立连接请求, 则右 Acceptor 通过 accept 处理连接请求, 然后创建一个 Handler 对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由 reactor 分发调用连接对应的 handler 来处理</li>
<li>handler 只负责响应事件，不做具体的业务处理, 通过 read 读取数据后，会分发给后面的 worker 线程池的某个线程处理业务</li>
<li>worker 线程池会分配独立线程完成真正的业务，并将结果返回给 handler</li>
<li>handler 收到响应后，通过 send 将结果返回给 client</li>
</ol>
<p><strong>优缺点分析：</strong></p>
<ul>
<li><strong>优点：</strong>可以充分的利用多核 cpu 的处理能力</li>
<li><strong>缺点：</strong>多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈</li>
</ul>
<h2 id="3-3主从-Reactor-多线程"><a href="#3-3主从-Reactor-多线程" class="headerlink" title="3.3主从 Reactor 多线程"></a>3.3主从 Reactor 多线程</h2><p>针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行</p>
<p><strong>工作原理示意图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\主从多线程模型.png" alt="image-20210615171159338"></p>
<p><strong>工作流程：</strong></p>
<ol>
<li>Reactor 主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过 Acceptor(接收器) 处理连接事件</li>
<li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给 SubReactor </li>
<li>Subreactor 将连接加入到连接队列进行监听，并创建 handler 进行各种事件处理</li>
<li>当有新事件发生时， Subreactor 就会调用对应的 handler 处理</li>
<li>handler 通过 read 读取数据，分发给后面的 worker 线程处理</li>
<li>worker 线程池分配独立的 worker 线程进行业务处理，并返回结果</li>
<li>handler 收到响应的结果后，再通过 send 将结果返回给 client</li>
<li>Reactor 主线程可以对应多个 Reactor 子线程, 即 <strong>MainRecator 可以关联多个 SubReactor</strong></li>
</ol>
<p><strong>优缺点分析：</strong></p>
<ul>
<li><strong>优点：</strong><ol>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li>
<li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li>
</ol>
</li>
<li><strong>缺点：</strong>编程复杂度较高</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p>
<h2 id="3-4-Reactor-模型小结"><a href="#3-4-Reactor-模型小结" class="headerlink" title="3.4 Reactor 模型小结"></a>3.4 Reactor 模型小结</h2><p><strong>3</strong> <strong>种模式用生活案例来理解</strong></p>
<ol>
<li>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服</li>
<li>单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从 Reactor 多线程，多个前台接待员，多个服务生</li>
</ol>
<p><strong>Reactor</strong> <strong>模式具有如下的优点：</strong></p>
<ol>
<li>响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的</li>
<li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源</li>
<li>复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ol>
<h1 id="4-Netty模型"><a href="#4-Netty模型" class="headerlink" title="4. Netty模型"></a>4. Netty模型</h1><h2 id="4-1基础版"><a href="#4-1基础版" class="headerlink" title="4.1基础版"></a>4.1基础版</h2><p>Netty 主要基于<strong>主从</strong> <strong>Reactors</strong> <strong>多线程模型</strong>（如图）做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor。</p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Netty模型01.png" alt="image-20210615203144413"></p>
<p>每个线程就是 NioEventLoop ，包含一个 Selector、以及任务队列等。</p>
<h2 id="4-2高级版"><a href="#4-2高级版" class="headerlink" title="4.2高级版"></a>4.2高级版</h2><p><strong>Netty 的服务端工作原理图：</strong></p>
<p><img src="/2021/06/15/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/GitHub\MyBlogs\source_posts\2021-06-15-Netty线程模型\Netty模型02.png" alt="image-20210615203430618"></p>
<p><strong>工作流程：</strong></p>
<ul>
<li>Netty 抽象出两组线程池 BossGroup 专门负责接收客户端的连接,，WorkerGroup 专门负责网络的读写</li>
<li>BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</li>
<li>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop</li>
<li>NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个 NioEventLoop 都有一个 selector , 用于监听绑定在其上的 socket 的网络通讯</li>
<li>NioEventLoopGroup 可以有多个线程, 即可以含有多个 NioEventLoop</li>
<li>每个 Boss NioEventLoop 循环执行的步骤有3步<ol>
<li>轮询 accept 事件</li>
<li>处理 accept 事件 , 与 client 建立连接 , 生成 NioScocketChannel , 并将其注册到某个 worker NIOEventLoop 上的 selector</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ol>
</li>
<li>每个 Worker NIOEventLoop 循环执行的步骤<ol>
<li>轮询 read, write 事件</li>
<li>处理 I/O 事件， 即 read , write 事件，在对应 NioScocketChannel 处理</li>
<li>处理任务队列的任务 ， 即 runAllTasks</li>
</ol>
</li>
<li>每个 Worker NIOEventLoop  处理业务时，会使用 pipeline (管道), pipeline 中包含了 channel , 即通过 pipeline 可以获取到对应通道, 管道中维护了很多的处理器</li>
</ul>
]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>Netty相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Java同步方法的锁对象</title>
    <url>/2021/06/05/Java%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E9%94%81%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h1><p>同步代码块的格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象)&#123;</span><br><span class="line">    多条语句操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized(任意对象)：相当于给代码加锁了，任意时刻只能有一个线程访问共享的代码块，并且<strong>任意对象都可以看成是一把锁</strong>。</p>
<p>下面我们写一个包含同步代码块的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个任意对象，作为同步代码块的锁对象</span></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过synchronized关键字锁住共享资源</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">                Method1();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//让线程Thread-1执行方法2</span></span><br><span class="line">                Method2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">//同步代码块：创建两个对象my5、my6</span></span><br><span class="line">        MyRunnable2 my5 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line">        MyRunnable2 my6 = <span class="keyword">new</span> MyRunnable2();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my5);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">19</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">22</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">24</span>:<span class="number">25</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>可以看到<strong>同一时刻只有获取到锁对象 obj 的线程才能访问同步代码块</strong></p>
<p>如果将线程2的构造对象传入 My6，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my6);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">01</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">26</span>:<span class="number">04</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>可以看到两个线程可以同时访问同步代码块，这是因为他俩访问的并不是同一块同步代码块，并且锁对象 obj 也并不是同一个锁对象，可以检验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(my5.obj==my6.obj);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<h1 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h1><p>同步方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法就是把 synchronized 关键字加到方法上，同步方法的锁对象是同一对象。</p>
<p>下面我们写一个包含同步方法的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//同步方法：创建两个对象my1、my2</span></span><br><span class="line">        MyRunnable my1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        MyRunnable my2 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my1);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">26</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">29</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">38</span>:<span class="number">32</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>我们将线程2构造的对象替换成 my2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my2);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">0</span>访问了同步方法<span class="number">1</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">13</span>:【Thread-<span class="number">1</span>访问了同步方法<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">1</span>准备退出这个同步方法了<span class="number">2</span>】</span><br><span class="line"><span class="number">2021</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">09</span>:<span class="number">40</span>:<span class="number">16</span>:【Thread-<span class="number">0</span>准备退出这个同步方法了<span class="number">1</span>】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>我们开始传入的是同一个对象，所以线程串行访问共享资源，当我们传入的不是同一个对象时，每个对象都相当于一把锁，所以执行没有冲突。</p>
<p><strong>结论：</strong>所以同步方法的锁对象是 this 对象</p>
<h1 id="3-静态同步方法"><a href="#3-静态同步方法" class="headerlink" title="3.静态同步方法"></a>3.静态同步方法</h1><p>静态同步方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123;</span><br><span class="line">     方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态同步方法就是把 synchronized 关键字加到静态方法上，静态同步方法的锁对象是类名。</p>
<p>下面我们写一个包含静态同步方法的共享资源 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让线程Thread-0执行同步方法1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;Thread-0&quot;</span>.equals(Thread.currentThread().getName())) &#123;</span><br><span class="line">            synchronizedMethod();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//让线程Thread-1执行同步方法2</span></span><br><span class="line">            synchronizedMethod2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法1】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了1】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronizedMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time = sim.format(satrtTime);</span><br><span class="line">        System.out.println(time + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;访问了同步方法2】&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠3秒</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">        String time2 = sim.format(endTime);</span><br><span class="line">        System.out.println(time2 + <span class="string">&quot;:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;准备退出这个同步方法了2】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态同步方法：创建两个对象my3、my4</span></span><br><span class="line">        MyRunnable1 my3 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line">        MyRunnable1 my4 = <span class="keyword">new</span> MyRunnable1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(my3);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">//让主线程做个等待，等线程一和线程二都执行完它才继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:48:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">2021-06-06 09:48:53:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:48:56:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p>我们将线程2构造的对象替换成 my4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(my4);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行开始</span><br><span class="line">2021-06-06 09:49:47:【Thread-0访问了同步方法1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-0准备退出这个同步方法了1】</span><br><span class="line">2021-06-06 09:49:50:【Thread-1访问了同步方法2】</span><br><span class="line">2021-06-06 09:49:53:【Thread-1准备退出这个同步方法了2】</span><br><span class="line">运行结束</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong>我们可以看到，修改前后，线程的执行顺序是一样的，也就是说静态同步方法只有拿到这个 class 才能访问，而运行时 JVM 只有这一个类，所以同一时间只能有一个线程访问共享资源。</p>
<p><strong>结论：</strong>所以静态同步方法的锁对象是类名</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</li>
</ul>
<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) ，因为 JVM 中，字符串常量池具有缓存功能！</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程实现火车售票系统</title>
    <url>/2021/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%81%AB%E8%BD%A6%E5%94%AE%E7%A5%A8%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p><strong>案例需求：</strong></p>
<p>某火车站临时放出车票，共有100张票，有3个窗口卖票，请设计一个程序模拟该火车站卖票</p>
<h1 id="1-初步实现"><a href="#1-初步实现" class="headerlink" title="1.初步实现"></a>1.初步实现</h1><p><strong>实现步骤：</strong></p>
<ul>
<li>定义一个类 SellTicket 实现 Runnable 接口，里面定义一个成员变量：private int tickets = 100;</li>
<li>在 SellTicket 类中重写 run() 方法实现卖票，代码步骤如下：<ol>
<li>判断票数大于0，就卖票，并告知是哪个窗口卖的，卖了票之后，总票数要减 1 票</li>
<li>没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行 </li>
</ol>
</li>
<li>定义一个测试类 SellTicketDemo，里面有 main 方法，代码步骤如下： <ol>
<li>创建 SellTicket 类的对象 </li>
<li>创建三个 Thread 类的对象，把 SellTicket 对象作为构造方法的参数，并给出对应的窗口名称 </li>
<li>启动线程</li>
</ol>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义变量，表示车票的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法，打印窗口的售票情况，并将车票数目减一</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//通过sleep来模拟出票的时间</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出第&quot;</span> + <span class="keyword">this</span>.tickets + <span class="string">&quot;张车票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个SellTicket对象</span></span><br><span class="line">        SellTicket se = <span class="keyword">new</span> SellTicket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个 Thread 类的对象，把 SellTicket 对象作为构造方法的参数，并给出对应的窗口名称 </span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(se, <span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(se, <span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(se, <span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码执行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗口一售出第22张车票</span><br><span class="line">窗口一售出第19张车票</span><br><span class="line">窗口三售出第19张车票</span><br><span class="line">窗口二售出第19张车票</span><br><span class="line">窗口二售出第16张车票</span><br><span class="line">窗口三售出第16张车票</span><br><span class="line">窗口一售出第16张车票</span><br><span class="line">窗口二售出第13张车票</span><br><span class="line">窗口一售出第13张车票</span><br><span class="line">窗口三售出第13张车票</span><br><span class="line">窗口二售出第10张车票</span><br><span class="line">窗口三售出第10张车票</span><br><span class="line">窗口一售出第10张车票</span><br><span class="line">窗口二售出第7张车票</span><br><span class="line">窗口三售出第7张车票</span><br><span class="line">窗口一售出第7张车票</span><br><span class="line">窗口一售出第4张车票</span><br><span class="line">窗口三售出第4张车票</span><br><span class="line">窗口二售出第4张车票</span><br><span class="line">窗口一售出第1张车票</span><br><span class="line">窗口三售出第1张车票</span><br><span class="line">窗口二售出第1张车票</span><br></pre></td></tr></table></figure>

<p><strong>卖票出现了问题：</strong></p>
<ul>
<li>相同的票出现了多次</li>
<li>出现了负数的票</li>
</ul>
<p><strong>问题分析：</strong></p>
<p>问题一：相同的票出现了多次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//tickets = 100;</span></span><br><span class="line">            <span class="comment">//t1,t2,t3</span></span><br><span class="line">            <span class="comment">//假设t1线程抢到CPU的执行权</span></span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//t1线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设线程按照顺序醒过来</span></span><br><span class="line">                <span class="comment">//t1抢到CPU的执行权，在控制台输出：窗口1正在出售第100张票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出第&quot;</span> + <span class="keyword">this</span>.tickets + <span class="string">&quot;张车票&quot;</span>);</span><br><span class="line">                <span class="comment">//t2抢到CPU的执行权，在控制台输出：窗口2正在出售第100张票</span></span><br><span class="line">                <span class="comment">//t3抢到CPU的执行权，在控制台输出：窗口3正在出售第100张票</span></span><br><span class="line">                tickets--;</span><br><span class="line">                <span class="comment">//如果这三个线程还是按照顺序来，这里就执行了3次--的操作，最终票就变成了97</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>问题二：出现了负数的票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//tickets = 100;</span></span><br><span class="line">            <span class="comment">//t1,t2,t3</span></span><br><span class="line">            <span class="comment">//假设t1线程抢到CPU的执行权</span></span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//t1线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t2线程抢到了CPU的执行权，t2线程就开始执行，执行到这里的时候，t2线程休息100毫秒</span></span><br><span class="line">                    <span class="comment">//t3线程抢到了CPU的执行权，t3线程就开始执行，执行到这里的时候，t3线程休息100毫秒</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设线程按照顺序醒过来</span></span><br><span class="line">                <span class="comment">//t1抢到了CPU的执行权，在控制台输出：窗口1正在出售第1张票</span></span><br><span class="line">                <span class="comment">//假设t1继续拥有CPU的执行权，就会执行tickets--;操作，tickets = 0;</span></span><br><span class="line">                <span class="comment">//t2抢到了CPU的执行权，在控制台输出：窗口1正在出售第0张票</span></span><br><span class="line">                <span class="comment">//假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -1;</span></span><br><span class="line">                <span class="comment">//t3抢到了CPU的执行权，在控制台输出：窗口3正在出售第-1张票</span></span><br><span class="line">                <span class="comment">//假设t2继续拥有CPU的执行权，就会执行tickets--;操作，tickets = -2;</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出第&quot;</span> + <span class="keyword">this</span>.tickets + <span class="string">&quot;张车票&quot;</span>);               </span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-同步代码块解决线程安全问题"><a href="#2-同步代码块解决线程安全问题" class="headerlink" title="2.同步代码块解决线程安全问题"></a>2.同步代码块解决线程安全问题</h1><p>通过同步代码块的方法给售票的共享代码资源加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//tickets = 100;</span></span><br><span class="line">            <span class="comment">//t1,t2,t3</span></span><br><span class="line">            <span class="comment">//假设t1抢到了CPU的执行权</span></span><br><span class="line">            <span class="comment">//假设t2抢到了CPU的执行权</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//t1进来后，就会把这段代码给锁起来</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//t1休息100毫秒</span></span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出第&quot;</span> + <span class="keyword">this</span>.tickets + <span class="string">&quot;张车票&quot;</span>);</span><br><span class="line">                    tickets--;<span class="comment">//tickets = 99</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//t1出来了，这段代码的锁就被释放了</span></span><br><span class="line">                <span class="comment">//下次得到CPU时间片的不一定是线程2，而是随机的一个线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-同步方法解决线程安全问题"><a href="#3-同步方法解决线程安全问题" class="headerlink" title="3.同步方法解决线程安全问题"></a>3.同步方法解决线程安全问题</h1><p>通过同步方法的方式给售票的共享代码资源加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> +</span><br><span class="line">                    tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-静态同步方法解决线程安全问题"><a href="#4-静态同步方法解决线程安全问题" class="headerlink" title="4.静态同步方法解决线程安全问题"></a>4.静态同步方法解决线程安全问题</h1><p>通过静态同步方法的方式给售票的共享代码资源加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> +</span><br><span class="line">                    tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Lock-锁解决线程安全问题"><a href="#5-Lock-锁解决线程安全问题" class="headerlink" title="5. Lock 锁解决线程安全问题"></a>5. Lock 锁解决线程安全问题</h1><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了 锁，为了更清晰的表达如何加锁和释放锁， JDK5 以后提供了一个新的锁对象 Lock </p>
<p>Lock 是接口不能直接实例化，这里采用它的实现类 ReentrantLock 来实例化</p>
<p>加锁解锁方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody></table>
<p>通过 Lock 锁的方式给售票的共享代码资源加锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出第&quot;</span> + <span class="keyword">this</span>.tickets + <span class="string">&quot;张车票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程实现生产者消费者模式</title>
    <url>/2021/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-生产者消费者模式概述"><a href="#1-生产者消费者模式概述" class="headerlink" title="1.生产者消费者模式概述"></a>1.生产者消费者模式概述</h1><p>所谓生产者消费者问题，实际上主要是包含了两类线程：</p>
<ul>
<li>一类是生产者线程用于生产数据 </li>
<li>一类是消费者线程用于消费数据 </li>
</ul>
<p>为了解耦生产者和消费者的关系，通常会<strong>采用共享的数据区域</strong>，就像是一个仓库 </p>
<ul>
<li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 </li>
<li>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</li>
</ul>
<h1 id="2-Object类的等待和唤醒方法"><a href="#2-Object类的等待和唤醒方法" class="headerlink" title="2.Object类的等待和唤醒方法"></a>2.Object类的等待和唤醒方法</h1><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody></table>
<h1 id="3-案例（应用）"><a href="#3-案例（应用）" class="headerlink" title="3.案例（应用）"></a>3.案例（应用）</h1><p><strong>案例需求：</strong></p>
<p>生产者消费者案例中包含的类： </p>
<ul>
<li>奶箱类(Box)：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作 </li>
<li>生产者类(Producer)：实现Runnable接口，重写run()方法，调用存储牛奶的操作 </li>
<li>消费者类(Customer)：实现Runnable接口，重写run()方法，调用获取牛奶的操作 </li>
<li>测试类(BoxDemo)：里面有main方法，main方法中的代码步骤如下 <ol>
<li>创建奶箱对象，这是共享数据区域 </li>
<li>创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作 </li>
<li>对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</li>
<li>创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递 </li>
<li>启动线程</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个成员变量，表示第几瓶奶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//定义奶箱的状态：true-有牛奶，false-没有牛奶</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> state = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步方法，生产牛奶的方法，改变牛奶数量count</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putMilk</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//state==true表示有牛奶，等待消费</span></span><br><span class="line">        <span class="keyword">if</span> (state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有牛奶，就生产牛奶</span></span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者将第&quot;</span> + <span class="keyword">this</span>.count + <span class="string">&quot;瓶奶放入奶箱&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产完后，修改状态，表示有牛奶</span></span><br><span class="line">        state = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//生产完后唤醒消费线程，来取奶</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getMilk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当没有奶时，等待生产者生产牛奶</span></span><br><span class="line">        <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者拿到第&quot;</span> + <span class="keyword">this</span>.count + <span class="string">&quot;瓶奶&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取到奶之后，修改状态，表示没有牛奶了</span></span><br><span class="line">        state = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//唤醒生产者线程，来生产牛奶</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Box box)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box = box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span> &amp;&amp; box.count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            box.getMilk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Box box;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.box=box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            box.putMilk(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建奶箱对象，这是共享数据区域</span></span><br><span class="line">        Box b = <span class="keyword">new</span> Box();</span><br><span class="line">        <span class="comment">//创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作</span></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(b);</span><br><span class="line">        <span class="comment">//创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</span></span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(b);</span><br><span class="line">        <span class="comment">//创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(p);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程实现交替打印AB</title>
    <url>/2021/06/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0AB/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-实现多线程的两种方式"><a href="#1-实现多线程的两种方式" class="headerlink" title="1.实现多线程的两种方式"></a>1.实现多线程的两种方式</h1><p>首先看实现多线程的两种方式：继承 Thread 类和 实现 Runnable 接口</p>
<h2 id="1-1继承-Thread-类"><a href="#1-1继承-Thread-类" class="headerlink" title="1.1继承 Thread 类"></a>1.1继承 Thread 类</h2><p><strong>实现步骤：</strong></p>
<ol>
<li>定义一个 MyThread 类继承 Thread 类，并重写 run 方法</li>
<li>创建 MyThread 类的对象</li>
<li>调用 start 方法，启动线程</li>
</ol>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread my1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread my2=<span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>start 方法与 run 方法：</strong></p>
<ul>
<li>run 方法：封装了线程实际执行的代码，直接调用时，相当于普通方法的执行</li>
<li>start 方法：启动线程，线程启动后，由 JVM 调用 run 方法并执行</li>
</ul>
<h2 id="1-2实现-Runnable-接口"><a href="#1-2实现-Runnable-接口" class="headerlink" title="1.2实现 Runnable 接口"></a>1.2实现 Runnable 接口</h2><p><strong>实现步骤：</strong></p>
<ol>
<li>定义一个类MyRunnable实现Runnable接口，在MyRunnable类中重写run()方法</li>
<li>创建MyRunnable类的对象 </li>
<li>创建Thread类的对象</li>
<li><strong>把MyRunnable对象作为构造方法的参数</strong></li>
<li>启动线程</li>
</ol>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两种方式实现多线程的对比（或者说通过实现 Runnable 接口实现多线程的好处）：</strong></p>
<ul>
<li>避免了 Java 单继承的局限性，在实现 Runnable 接口的同时，还可以继承其他的类</li>
<li>Runnable 接口实现多线程比继承 Thread 类更加能描述数据共享的概念，在这种方式下，可以多个线程共享同一个目标(target)对象，所以非常适合多个相同线程来处理同一份资源的情况。</li>
</ul>
<h2 id="1-3实现-Callable-接口"><a href="#1-3实现-Callable-接口" class="headerlink" title="1.3实现 Callable 接口"></a>1.3实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        myCallable my=<span class="keyword">new</span> myCallable();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(my);</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask 源码实现了 Runnable 接口，并重写了 run 方法，传入 Callable 对象后，在 run 方法中直接调用 call 方法，并将结果记录，最后可以通过 call 方法来获取返回值。</p>
<h1 id="2-Synchronized-同步法"><a href="#2-Synchronized-同步法" class="headerlink" title="2. Synchronized 同步法"></a>2. Synchronized 同步法</h1><h2 id="2-1-基本思路"><a href="#2-1-基本思路" class="headerlink" title="2.1 基本思路"></a>2.1 基本思路</h2><p>使用同步块和 wait 、 notify 的方法控制三个线程的执行次序。具体方法如下：</p>
<ul>
<li>从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是 ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA 循环执行三个线程</li>
<li>为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能进行打印操作。一个对象锁是 prev：就是前一个线程所对应的对象锁，其主要作用是保证当前线程一定是在前一个线程操作完成后（即前一个线程释放了其对应的对象锁）才开始执行。还有一个锁是 self：就是自身对象锁。</li>
<li>主要的思想就是，为了控制执行的顺序，必须要先持有 prev 锁（也就前一个线程要释放其自身对象锁），然后当前线程再申请自己对象锁，两者兼备时打印。之后首先调用 self.notifyAll() 唤醒等待获取 self 对象锁的线程（注意 notifyAll() 不会立即释放对象锁，只有等到同步块代码执行完毕后才会释放），再调用 prev.wait() 立即释放 prev 对象锁，当前线程进入休眠，等待其他线程的 notifyAll() 操作再次唤醒。</li>
</ul>
<h2 id="2-2-代码及注释"><a href="#2-2-代码及注释" class="headerlink" title="2.2 代码及注释"></a>2.2 代码及注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Object prev;</span><br><span class="line">    <span class="keyword">private</span> Object self;</span><br><span class="line"></span><br><span class="line">    MyPrinter(String name, Object prev, Object self) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        <span class="keyword">this</span>.self = self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 多线程并发，不能用if，必须使用whil循环</span></span><br><span class="line">            <span class="keyword">synchronized</span> (prev) &#123; <span class="comment">// 先获取 prev 锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (self) &#123;<span class="comment">// 再获取 self 锁</span></span><br><span class="line">                    System.out.print(name);<span class="comment">//打印</span></span><br><span class="line">                    count--;</span><br><span class="line"></span><br><span class="line">                    self.notifyAll();<span class="comment">// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时执行完self的同步块，这时self锁才释放。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    prev.wait(); <span class="comment">// 立即释放 prev锁，当前线程休眠，等待唤醒</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object a = <span class="keyword">new</span> Object();</span><br><span class="line">        Object b = <span class="keyword">new</span> Object();</span><br><span class="line">        Object c = <span class="keyword">new</span> Object();</span><br><span class="line">        MyPrinter pa = <span class="keyword">new</span> MyPrinter(<span class="string">&quot;A&quot;</span>, c, a);</span><br><span class="line">        MyPrinter pb = <span class="keyword">new</span> MyPrinter(<span class="string">&quot;B&quot;</span>, a, b);</span><br><span class="line">        MyPrinter pc = <span class="keyword">new</span> MyPrinter(<span class="string">&quot;C&quot;</span>, b, c);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(pa);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);<span class="comment">//保证初始ABC的启动顺序</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(pb);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(pc);</span><br><span class="line">        t3.start();</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到程序一共定义了 a,b,c 三个对象锁，分别对应 t1、t2、t3 三个线程。t1 线程最先运行，t1 线程按顺序申请 c,a 对象锁，打印操作后按顺序释放 a,c 对象锁，并且通过 notifyAll() 操作唤醒等待获取 a 对象锁的线程 t2。线程 t2 首先等待获取 a 锁，再申请 b 锁，后打印B，再释放 b，a 锁，唤醒 t3。线程 t3 等待 b 锁，再申请 c 锁，后打印C，再释放 c , b 锁，唤醒 t1 。</p>
<h2 id="2-3存在问题及解决"><a href="#2-3存在问题及解决" class="headerlink" title="2.3存在问题及解决"></a>2.3存在问题及解决</h2><p><strong>原实现存在的问题</strong>：<br>如果把上述代码放到 Idea 上运行，可以发现程序虽然完成了交替打印 ABC 十次的任务，但是打印完毕后无法自动结束线程。这是为什么呢？原因就在于下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            prev.wait(); <span class="comment">// 立即释放 prev锁，当前线程休眠，等待唤醒</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>prev.wait();  是释放 prev 锁并休眠线程，等待唤醒。在最后一次打印完毕后，因为 count 为 0 ，无法进入 while 循环的同步代码块，自然就不会触发 notifyAll 操作。这样一来，执行完打印操作后，线程就一直处于休眠待唤醒状态，导致线程无法正常结束。我们在测试代码中加入以下代码检查线程活性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;t1线程：&quot;</span>+t1.isAlive());</span><br><span class="line">System.out.println(<span class="string">&quot;t2线程：&quot;</span>+t2.isAlive());</span><br><span class="line">System.out.println(<span class="string">&quot;t3线程：&quot;</span>+t3.isAlive());</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1线程：false</span><br><span class="line">t2线程：true</span><br><span class="line">t3线程：true</span><br></pre></td></tr></table></figure>

<p>也就是说除了 t1 线程外，其它两个线程处于等待状态，因为执行打印最后一个 A 操作后，t1 进入等待状态，唤醒线程 t2 ,线程 t2 执行结束唤醒了 t3 线程并释放了 a 对象锁，并进入等待状态，t3 线程执行，唤醒了 t1 线程，t1 线程发现 count == 0，跳出循环并结束。剩下的两个线程仍然处于等待状态。</p>
<p>所以对代码进行修改如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 多线程并发，不能用if，必须使用whil循环</span></span><br><span class="line">        <span class="keyword">synchronized</span> (prev) &#123; <span class="comment">// 先获取 prev 锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (self) &#123;<span class="comment">// 再获取 self 锁</span></span><br><span class="line">                System.out.print(name);<span class="comment">//打印</span></span><br><span class="line">                count--;</span><br><span class="line"></span><br><span class="line">                self.notifyAll();<span class="comment">// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时执行完self的同步块，这时self锁才释放。</span></span><br><span class="line">            <span class="comment">// 此时执行完self的同步块，这时self锁才释放。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;<span class="comment">// 如果count==0,表示这是最后一次打印操作，通过notifyAll操作释放对象锁。</span></span><br><span class="line">                    prev.notifyAll();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prev.wait(); <span class="comment">// 立即释放 prev锁，当前线程休眠，等待唤醒</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里，我们也可以得出 wait 和 notify 操作的异同：</p>
<ul>
<li>wait() 与 notify/notifyAll() 是 Object 类的方法，在执行两个方法时，要先获得锁。</li>
<li>当线程执行 wait() 时，会把当前的对象锁释放，然后让出 CPU，进入等待状态。</li>
<li>当执行 notify/notifyAll 方法时，<strong>会唤醒一个处于等待该对象锁的线程</strong>，然后继续往下执行，直到执行完退出对象锁锁住的区域（ synchronized 修饰的代码块）后再释放锁。</li>
</ul>
<p>从这里可以看出，notify/notifyAll() 执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。所以在实际编程中，我们应该尽量在线程调用 notify/notifyAll() 后，立即退出临界区。即不要在 notify/notifyAll() 后面再写一些耗时的代码。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现SpringMVC</title>
    <url>/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-Spring-与-SpringMVC-的区别"><a href="#1-Spring-与-SpringMVC-的区别" class="headerlink" title="1. Spring 与 SpringMVC 的区别"></a>1. Spring 与 SpringMVC 的区别</h1><p><strong>Spring 框架：</strong>两大特性 IOC 和 AOP 。</p>
<ul>
<li>SpringIOC 特性：让 Spring 可以理解为一个管理 Bean 的容器</li>
<li>SpringMVC 特性：提供了面向切面编程，可以在不改变源代码的基础上，将模块通用的功能提取出来，不仅降低了代码的冗余，还大大降低了模块间的耦合性</li>
</ul>
<p><strong>SpringMVC 框架：</strong>核心类是 DispatcherServlet ，其实 SpringMVC 的本质就是一个 Servlet ，用来拦截前台的请求，调用 Service 层和 持久层 ，返回数据再通过 SpringMVC 把数据渲染成视图并返回给前台。而且 SpringMVC 要基于 Spring 框架才能跑起来。</p>
<h1 id="2-SpringMVC-的执行流程"><a href="#2-SpringMVC-的执行流程" class="headerlink" title="2. SpringMVC 的执行流程"></a>2. SpringMVC 的执行流程</h1><h2 id="2-1流程图"><a href="#2-1流程图" class="headerlink" title="2.1流程图"></a>2.1流程图</h2><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p>
<img src="/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/GitHub\MyBlogs\source\_posts\2021-06-01-手写实现SpringMVC\SpringMVC执行流程.png" style="zoom:80%;">

<h2 id="2-2组件作用"><a href="#2-2组件作用" class="headerlink" title="2.2组件作用"></a>2.2组件作用</h2><ul>
<li><p><strong>DispatcherServlet：</strong>前端控制器。</p>
<p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p>
</li>
<li><p><strong>HandlerMapping：</strong>处理器映射器</p>
<p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p>
</li>
<li><p><strong>HandlerExecution：</strong>具体的Handler</p>
<p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p>
</li>
<li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p>
</li>
<li><p><strong>HandlAdapter：</strong>处理器适配器</p>
<p><strong>作用1：</strong>按照特定的规则去执行Handler；</p>
<p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p>
<p><strong>注：</strong>Model表示具体的数据，View表示视图</p>
</li>
<li><p><strong>View Resolver：</strong>视图解析器</p>
<p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>View：</strong>视图</p>
<p><strong>作用：</strong>向用户展示结果</p>
</li>
</ul>
<h2 id="2-3执行流程"><a href="#2-3执行流程" class="headerlink" title="2.3执行流程"></a>2.3执行流程</h2><ol>
<li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li>
<li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li>
<li>HandlerExecution就是具体的Controller；</li>
<li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li>
<li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li>
<li>HandlAdapter找到相应的Controller去执行；</li>
<li>Controller将执行结果返回给HandlAdapter；</li>
<li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li>
<li>dispatcherServlet调用View Resolver得到相应的页面地址；</li>
<li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li>
<li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li>
</ol>
<h1 id="3-项目概况"><a href="#3-项目概况" class="headerlink" title="3.项目概况"></a>3.项目概况</h1><img src="/2021/06/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringMVC/GitHub\MyBlogs\source\_posts\2021-06-01-手写实现SpringMVC\项目概况.png" alt="image-20210601171822437" style="zoom: 67%;">

<p>前一章中，我们在写 SpringIOC 框架时，采用的是自下而上的方式，这里我们采用自上而下的方式来写 SpringMVC 框架。</p>
<h2 id="3-1-pom-xml-导包"><a href="#3-1-pom-xml-导包" class="headerlink" title="3.1 pom.xml(导包)"></a>3.1 pom.xml(导包)</h2><p>我们都知道，SpringMVC 是基于 Java 的 Servelt 技术实现的，那么我们就需要导入 Servlet 的支持包，将这个项目改造成为一个 Web 项目。</p>
<p>在 Maven 中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-web-xml"><a href="#3-2-web-xml" class="headerlink" title="3.2 web.xml"></a>3.2 web.xml</h2><p>在项目的根目录下建立一个 web 文件夹，再在 web 文件夹下建立 WEB-INF 文件夹，再在其中新建 <code>web.xml</code> 文件。这就是这个 web 项目的配置文件，即 Servlet 的配置文件。内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xmlns=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> xmlns:web=<span class="string">&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;3.0&quot;</span>&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;MySpringMVC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">top</span>.<span class="title">wangjin</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">DispatcherServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">contextConfigLocation</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">            &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">application</span>.<span class="title">properties</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;1&lt;/<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">MySpringMVC</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">web</span>-<span class="title">app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们在 web.xml 文件中配置了一个 Servlet ，也就是 SpringMVC 的核心 DispatcherServlet ，并且设置这个 Servlet 处理所有的 URL 请求。</p>
<p>在这里我们配置了一个参数 contextConfigLocation ，参数的值为 application.properties 。这个文件作为我们的 SpringMVC 的配置文件，我们的 SpringMVC 并不需要太多配置，只需要知道 Controller 的扫描路径就可以了。在 resources 文件夹下新建这个文件，里面我只写了一行：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">scanPackage</span>=<span class="string">top.guoziyang.main.controller</span></span><br></pre></td></tr></table></figure>

<p>表示我的所有的 Controller 都会放在<code>top.guoziyang.main.controller</code>包及其子包下，到时候启动时 SpringMVC 会去扫描这个包。</p>
<h2 id="3-3-package-springframework"><a href="#3-3-package-springframework" class="headerlink" title="3.3 package-springframework"></a>3.3 package-springframework</h2><h3 id="3-3-1-package-web"><a href="#3-3-1-package-web" class="headerlink" title="3.3.1 package-web"></a>3.3.1 package-web</h3><p>增加一个 web 包，用来放我们的核心类 DispatcherServlet ，表示与 web 处理应用有关。</p>
<p><strong>DispatcherServlet 类：</strong>重写了父类 HttpServlet 中三个重要的方法：init 方法、doGet 方法、doPost 方法</p>
<p>**<code>init 方法：</code>**初始化了一个 Spring 容器，调用方法完成：读取配置文件、扫描包下所有的 Controller、实例化所有 Controller 、并绑定 URL 路由</p>
<p><code>doGet 方法：</code>初始化之后，<strong>当一个请求到来，首先到达 doGet 和 doPost 方法。</strong></p>
<p><code>doPost 方法：</code>略</p>
<p>**<code>doDispatch 方法：</code>**我们自定义的实际处理请求的方法，主要逻辑就是从请求中获取请求的 Url 也就是请求的方法，然后用一个数组存放请求的参数，最后方法和方法的参数都获取到之后，通过反射的方式调用方法处理参数。</p>
<p><code>doLoadConfig 方法：</code>读取配置文件，获取 web.xml 文件中 DispatcherServlet 的配置文件路径</p>
<p><code>doScanner 方法：</code>扫描包下所有的 Controller，获取要扫描包的范围，并将范围内所有类放入 classNames 集合中</p>
<p><code>doInstance 方法：</code>实例化所有 Controller ，遍历 classNames 集合中所有的类，如果是加了 @Controller 注解的类就将 BeanDefinition 先注入到容器中，那么容器中有 Bean 是没有被实例化的，再调用 refreshBeanFactory 方法手动刷新，也就是将 BeanDefinition 中的 Bean 属性进行注入就将所有的 Controller 进行实例化了。</p>
<p><code>initHandlerMapping 方法：</code>遍历类集合 classes 如果类上有 RequestMapping 注解，根据注解的值来拼接 URL，并将 URL 与类（Controller）的映射存储在 controllerMap 中，将 URL 与 方法 的映射存储在 handlerMapping 这个 map 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; classNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Method&gt; handlerMapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Class&gt; classes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; controllerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassPathXmlApplicationContext xmlApplicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取SpringIOC容器</span></span><br><span class="line">            xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application-annotation.xml&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        doLoadConfig(config.getInitParameter(<span class="string">&quot;contextConfigLocation&quot;</span>));</span><br><span class="line">        doScanner(properties.getProperty(<span class="string">&quot;scanPackage&quot;</span>));</span><br><span class="line">        doInstance();</span><br><span class="line">        initHandlerMapping();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求HttpServletRequest，并返回结果HttpServletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理请求</span></span><br><span class="line">            doDispatch(req, resp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;500!! Server Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实际处理请求的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlerMapping.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//获取请求的URL</span></span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        <span class="comment">//获取项目的相对路径</span></span><br><span class="line">        String contextPath = request.getContextPath();</span><br><span class="line">        url = url.replace(contextPath, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">//如果请求的URL不存在，返回404错误</span></span><br><span class="line">        <span class="keyword">if</span> (!handlerMapping.containsKey(url)) &#123;</span><br><span class="line">            response.getWriter().write(<span class="string">&quot;404 NOT FOUND!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取要请求的方法</span></span><br><span class="line">        Method method = handlerMapping.get(url);</span><br><span class="line">        <span class="comment">//获取请求方法的参数类型</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//获取请求中的参数键值对</span></span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        <span class="comment">//存放请求中的参数</span></span><br><span class="line">        Object[] paramValues = <span class="keyword">new</span> Object[parameterTypes.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            String requestParam = parameterTypes[i].getSimpleName();</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletRequest&quot;</span>)) &#123;</span><br><span class="line">                paramValues[i] = request;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;HttpServletResponse&quot;</span>)) &#123;</span><br><span class="line">                paramValues[i] = response;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestParam.equals(<span class="string">&quot;String&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; param : parameterMap.entrySet()) &#123;</span><br><span class="line">                    <span class="comment">//获取实际的请求值</span></span><br><span class="line">                    String value = Arrays.toString(param.getValue()).replaceAll(<span class="string">&quot;\\[|\\]&quot;</span>, <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;,\\s&quot;</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    paramValues[i] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过方法名和参数，反射调用方法</span></span><br><span class="line">            method.invoke(controllerMap.get(url), paramValues);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取web.xml文件中DispatcherServlet的配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLoadConfig</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把web.xml中的contextConfigLocation对应value值的文件加载到流里面</span></span><br><span class="line">        InputStream resourceAsStream = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用Properties文件加载文件里的内容</span></span><br><span class="line">            properties.load(resourceAsStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != resourceAsStream) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resourceAsStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取DispatcherServlet要扫描包的范围，并将范围内所有类放入classNames集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doScanner</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把所有的.替换成/</span></span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;/&quot;</span> + packageName.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>));</span><br><span class="line">        File dir = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">        <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">//递归读取包</span></span><br><span class="line">                doScanner(packageName + <span class="string">&quot;.&quot;</span> + file.getName());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String className = packageName + <span class="string">&quot;.&quot;</span> + file.getName().replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                classNames.add(className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化Controller</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classNames.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历集合中的所有类</span></span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//把类搞出来,反射来实例化(只有加@Controller需要实例化)</span></span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(Controller.class)) &#123;</span><br><span class="line">                    classes.add(clazz);</span><br><span class="line">                    BeanDefinition definition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">                    definition.setSingleton(<span class="keyword">true</span>);</span><br><span class="line">                    definition.setBeanClassName(clazz.getName());</span><br><span class="line">                    xmlApplicationContext.addNewBeanDefinition(clazz.getName(), definition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            xmlApplicationContext.refreshBeanFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取RequestMapping这个注解的值，并且拼接出完整的URL:</span></span><br><span class="line"><span class="comment">     * 1.将URL与方法的映射存储在handlerMapping这个map中</span></span><br><span class="line"><span class="comment">     * 2.将URL与类的映射存储在controllerMap中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classes.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">                String baseUrl = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (clazz.isAnnotationPresent(RequestMapping.class)) &#123;</span><br><span class="line">                    baseUrl = clazz.getAnnotation(RequestMapping.class).value();</span><br><span class="line">                &#125;</span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!method.isAnnotationPresent(RequestMapping.class)) <span class="keyword">continue</span>;</span><br><span class="line">                    String url = method.getAnnotation(RequestMapping.class).value();</span><br><span class="line">                    url = (baseUrl + <span class="string">&quot;/&quot;</span> + url).replaceAll(<span class="string">&quot;/+&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    handlerMapping.put(url, method);</span><br><span class="line">                    controllerMap.put(url, xmlApplicationContext.getBean(clazz));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-package-context"><a href="#3-3-2-package-context" class="headerlink" title="3.3.2 package-context"></a>3.3.2 package-context</h3><p>因为我们已经在获取 Bean 工厂时，就完成了读取 BeanDefinition 并注入 Bean 属性的过程，在 SpringMVC 框架中我们还要向容器中注入添加了 @Controller 注解的 Bean ，那么就要在 Spring 中的核心类 ApplicationContext 的实现类中开一个口子，能够调用方法，实现先向容器中添加 BeanDefinition ，再注入 Bean 属性的操作，因此我们在 <strong>ClassPathXmlApplicationContext</strong> 类中添加了下面两个方法：</p>
<p><code>addNewBeanDefinition 方法：</code>向容器中注册 BeanDefinition（解析过程在 DispatcherServlet 类中的 doInstance 方法中完成）</p>
<p><code>refreshBeanFactory 方法：</code>手动刷新，注入 Bean 的属性值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader.processAnnotationProperty(beanDefinition.getBeanClass(), beanDefinition);</span><br><span class="line">        beanFactory.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    prepareBeanFactory((AbstractBeanFactory) beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-package-annotation"><a href="#3-3-3-package-annotation" class="headerlink" title="3.3.3 package-annotation"></a>3.3.3 package-annotation</h3><p>新建几个注解：</p>
<p><strong>Controller 注解：</strong>说明实体类是一个 Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RequestParam 注解：</strong>放在参数上，说明是请求需要传入的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestParam &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RequestMapping 注解：</strong>放在类和方法上，用来表示请求的路由 Url</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-package-main"><a href="#3-4-package-main" class="headerlink" title="3.4 package-main"></a>3.4 package-main</h2><h3 id="3-4-1-package-controller"><a href="#3-4-1-package-controller" class="headerlink" title="3.4.1 package-controller"></a>3.4.1 package-controller</h3><p>我们写了一个 Controller，同时还注入了一个对象 HelloWorldService ，这个test1方法还需要传入一个参数param，用于测试传参。</p>
<p><strong>TestController ：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="meta">@RequestParam(&quot;param&quot;)</span> String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String text = helloWorldService.getString();</span><br><span class="line">            response.getWriter().write(text + <span class="string">&quot; and the param is &quot;</span> + param);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-Test"><a href="#3-5-Test" class="headerlink" title="3.5 Test"></a>3.5 Test</h2><p>把项目通过Tomcat启动在8080端口后，访问<a href="http://localhost:8080/test/test1?param=abc%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%A6%82%E4%B8%8B%E7%BB%93%E6%9E%9C%EF%BC%9A">http://localhost:8080/test/test1?param=abc，出现如下结果：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello world and the param is abc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现SpringIOC</title>
    <url>/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-SpringIOC-与-DI"><a href="#1-SpringIOC-与-DI" class="headerlink" title="1.SpringIOC 与 DI"></a>1.SpringIOC 与 DI</h1><h2 id="1-1-SpringIOC-是什么"><a href="#1-1-SpringIOC-是什么" class="headerlink" title="1.1 SpringIOC 是什么"></a>1.1 SpringIOC 是什么</h2><p><strong>IoC（Inversion of Control，控制反转）</strong>。这是 <strong>spring 的核心</strong>，贯穿始终。<strong>所谓 IoC ，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</strong>这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的 mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如 Connection 等），对象始终会和其他的接口或类藕合起来。</p>
<p>那么 IoC 是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：<strong>婚姻介绍所</strong>。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。<strong>Spring 所倡导的开发方式</strong>就是如此，<strong>所有的类都会在 spring 容器中登记，告诉 spring 你是个什么东西，你需要什么东西，然后 spring 会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是 spring 。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被 spring 控制，所以这叫控制反转。</strong></p>
<p>所以<strong>控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方</strong>，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了 IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。</p>
<h2 id="1-2-DI-是什么"><a href="#1-2-DI-是什么" class="headerlink" title="1.2 DI 是什么"></a>1.2 DI 是什么</h2><p><strong>DI（Dependency Injection，即“依赖注入”）</strong>：<strong>组件之间依赖关系</strong>由容器在运行期决定，形象的说，即<strong>由容器动态的将某个依赖关系注入到组件之中</strong>。<strong>依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。</strong>通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<h2 id="1-3-SpringIOC-与-DI-之间的关系"><a href="#1-3-SpringIOC-与-DI-之间的关系" class="headerlink" title="1.3 SpringIOC 与 DI 之间的关系"></a>1.3 SpringIOC 与 DI 之间的关系</h2><p><strong>IoC和DI</strong>由什么<strong>关系</strong>呢？其实它们<strong>是同一个概念的不同角度描述</strong>，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p>总结：<strong>DI 就是 SpringIOC 的另一种说法</strong>。</p>
<h1 id="2-XML-注入方式"><a href="#2-XML-注入方式" class="headerlink" title="2.XML 注入方式"></a>2.XML 注入方式</h1><h2 id="2-1项目概况"><a href="#2-1项目概况" class="headerlink" title="2.1项目概况"></a>2.1项目概况</h2><p><img src="/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/GitHub\MyBlogs\source_posts\2021-05-27-手写实现SpringIOC\XML1.png" alt="image-20210530215030327"></p>
<h2 id="2-2-packaeg-main"><a href="#2-2-packaeg-main" class="headerlink" title="2.2 packaeg-main"></a>2.2 packaeg-main</h2><h3 id="2-2-1-package-service"><a href="#2-2-1-package-service" class="headerlink" title="2.2.1 package-service"></a>2.2.1 package-service</h3><p>存放需要 SpringIOC 管理的 Bean 实例</p>
<p><strong>HelloWorldService 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloWorldServiceImpl 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WrapService 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloWorldService.saySomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更好地说明在实例化 Bean 时的过程，在需要注入 IOC 的两个 Bean 中，HelloWorldServiceImpl 的属性都是<strong>基本类型</strong> String ，而 WrapService 的属性是<strong>引用类型</strong> HelloWorldService。</p>
<h2 id="2-3-package-Springwork"><a href="#2-3-package-Springwork" class="headerlink" title="2.3 package-Springwork"></a>2.3 package-Springwork</h2><p>springIOC 实现的核心部分，我们将采用<strong>自下而上</strong>的步骤来解释项目每部分的功能。</p>
<h3 id="2-3-1-package-entity"><a href="#2-3-1-package-entity" class="headerlink" title="2.3.1 package-entity"></a>2.3.1 package-entity</h3><p>通常描述 Bean 包括：这个 Bean 是不是单例、它对应的类和类名、Bean的具体属性等，我们将其定义为 BeanDefinition。</p>
<p><strong>BeanDefinition 类：</strong>Bean 的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bean的实例</span></span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line">    <span class="comment">//Bean所对应的类</span></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">    <span class="comment">//Bean所对应的类名</span></span><br><span class="line">    <span class="keyword">private</span> String beanClassName;</span><br><span class="line">    <span class="comment">//是否是单例模式</span></span><br><span class="line">    <span class="keyword">private</span> Boolean singleton;</span><br><span class="line">    <span class="comment">//Bean的属性</span></span><br><span class="line">    <span class="keyword">private</span> PropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getBeanClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClass</span><span class="params">(Class beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClass = beanClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanClassName = beanClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanClass = Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(propertyValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">            propertyValues = <span class="keyword">new</span> PropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(PropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSingleton</span><span class="params">(Boolean singleton)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singleton = singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，PropertyValues 是 Bean 具体属性的集合，它的定义如下：</p>
<p><strong>PropertyValues 类：</strong>它是一个 ArrayList 集合，存放的元素是 PropertyValue 类型的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValues</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValues</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPropertyValue</span><span class="params">(PropertyValue propertyValue)</span> </span>&#123;</span><br><span class="line">        propertyValueList.add(propertyValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PropertyValue&gt; <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PropertyValue 类：</strong>只有两个属性，一个是 Bean 的字段名，一个是 Bean 的字段值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bean的属性名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//Bean的属性值（可能是基本类型也可能是引用类型）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean 的属性值可能为基本类型，也可能为引用类型，当 Bean 的属性值为引用类型时，也就是它的值应该是一个对象，我们将这个对象定义为 BeanReference：</p>
<p><strong>BeanReference 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanReference</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanReference</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bean = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清楚 Bean 的定义后，我们在配置文件中定义我们要传入的两个 Bean。</p>
<h3 id="2-3-2-package-io"><a href="#2-3-2-package-io" class="headerlink" title="2.3.2 package-io"></a>2.3.2 package-io</h3><p>配置文件中对于Bean的配置如下：我们只将 scope=”prototype” 加到配置文件中，在程序读取配置文件时，只判断是不是 prototype 即可，不是就是单例的 Bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.wangjin.main.service.HelloWorldServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello World&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;wrapService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;top.wangjin.main.service.WrapService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helloWorldService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloWorldService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了从 resources 包下获取配置文件的内容，我们将读取配置的功能抽象为一个接口：</p>
<p><strong>Resource 接口：</strong>将配置文件中的内容读取到输入流中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UrlResource 类：</strong>实现了 Resource 接口，通过 URL 的方式获取配置文件的内容</p>
<blockquote>
<p><strong>Note：</strong>有了 URLConnection 对象后，可以通过 getInputStream() 来获取一个 InputStream ，由此读取 URL 所引用的资源数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlResource</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        URLConnection urlConnection = url.openConnection();</span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        <span class="keyword">return</span> urlConnection.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ResourceLoader 类：</strong>将 UrlResource 封装成资源加载器，构造时要传入 URL ，构造 UrlResource 对象，然后调用 getInputStream 方法获取配置文件内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        URL url = <span class="keyword">this</span>.getClass().getClassLoader().getResource(location);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-package-reader"><a href="#2-3-3-package-reader" class="headerlink" title="2.3.3 package-reader"></a>2.3.3 package-reader</h3><p>调用上面实现的资源加载器，从配置文件中读取对于 BeanDefinition 的定义信息，我们还是先把这个功能抽象为一个接口：</p>
<p><strong>BeanDefinitionReader 接口：</strong>接口中只有一个方法，方法的参数是一个文件路径，我们大体上猜一下就知道这个方法大概就是根据路径创建资源加载器然后再从输入流 InputStream 中提取出 BeanDefinition 注册到一个容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractBeanDefinitionReader 抽象类：</strong>通过抽象类来实现接口，抽象类中的 registry 作为容器来存放读取到的 Bean 名称和 BeanDefinition 的键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; registry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, BeanDefinition&gt; <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>XmlBeanDefinitionReader 实现类：</strong>该实现类具体来实现 BeanDefinitionReader 接口中的 loadBeanDefinitions 方法。</p>
<p>注册 BeanDefinition 的流程：</p>
<ol>
<li><p>根据配置文件的路径将配置文件准换成 InputStream 输入流</p>
</li>
<li><p>根据配置文件的输入流解析出 BeanDefinition ，具体的解析过程为：</p>
<ul>
<li><p>从配置文件的根 root ，递归地解析每个节点</p>
</li>
<li><p>对于 BeanDefinition 的实际解析过程，也就是获取 BeanDefinition 实体类的每个属性，其中在给 BeanDefinition 的 PropertyValues 赋值时，存在两种情况：</p>
<p>1.当属性值为基本类型时，可以直接赋值；</p>
<p>2.当属性值是引用类型时，不是立即初始化，而是创建一个只有名称的 BeanReference 引用对象，因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Note：</strong>通过抽象类实现接口，然后抽象类的子类继承抽象类来具体实现接口中的方法，这是一种思想。比如当我们想用接口中的某个特定方法时（不是所有的方法），那么我们通过抽象类来实现接口（方法体中为空），然后再用子类继承这个抽象类，重写我们想要实现的方法即可。如果我们直接实现接口，就要重写接口中的所有方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的路径获取BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location 配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据配置文件的路径，获取配置文件的文件输入流</span></span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的输入流解析出BeanDefinition，并注册到临时Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件的根root，递归地将每个节点解析成BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i ++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于BeanDefinition的实际解析过程，也就是获取实体类的每个属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值：</span></span><br><span class="line"><span class="comment">     * 1.当是基本类型时直接赋值</span></span><br><span class="line"><span class="comment">     * 2.当是引用类型时不是立即初始化，而是创建一个只有名称的引用对象，</span></span><br><span class="line"><span class="comment">     * 因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i ++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-package-factory"><a href="#2-3-4-package-factory" class="headerlink" title="2.3.4 package-factory"></a>2.3.4 package-factory</h3><p>上面我们在 reader 包中完成了 BeanDefinition 的读取和注册，下面我们要完成 Bean 的实例化。我们将这个实例化的操作抽象成工厂接口。</p>
<p><strong>BeanFactory 接口：</strong></p>
<p><code>getBean 方法：</code>两个，分别是通过实例名称和类名获取 Bean 实例</p>
<p><code>registerBeanDefinition 方法：</code>注册 BeanDefinition ，在获取 BeanFactory 时，将 reader 包读取到容器中的 BeanDefinition 注册到工厂容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractBeanFactory 抽象类：</strong>实现了工厂类，重写了根据名称返回 Bean 实例的方法，具体 Bean 的创建由它的子类实现</p>
<p>根据名称来获取 Bean 实例，因此我们选用 Map 结构来作为实际容器，为了保证线程安全，最后选取 ConcurrentHashMap 作为底层的容器结构。</p>
<p>在实际调用获取 Bean 实例的方法之前，我们已经调用 registerBeanDefinition 方法，将 BeanDefinition 装载到了容器中。</p>
<p><code>getBean（Bean 名称）方法：</code>先通过名称获取 BeanDefinition ，如果 Bean 不是单例的，或者 Bean 此时为空，调用 doCreateBean 方法创建一个 Bean，否则，也就是这个 Bean 是单例的并且已经实例化的，直接返回 Bean 即可</p>
<p><code>getBean（Class 名称）方法：</code>遍历容器中的 BeanDefinition ，并将其对应的类和要查询的类名匹配，匹配成功将获取 BeanDefinition ，也就是还是通过 BeanDefinition 的方式来获取实例</p>
<p><code>registerBeanDefinition 方法：</code>向工厂容器中注册 BeanDefinition 的方法</p>
<p><code>doCreateBean 方法：</code>实际创建 Bean 实例的方法，由子类实现具体的逻辑</p>
<p><code>populateBeans 方法：</code>批量创建 Bean 的方法，将容器中的 BeanDefinition 全都实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitionMap.get(name);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!beanDefinition.isSingleton() || beanDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> doCreateBean(beanDefinition);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取beanDefinitionMap容器中所有映射关系的集合，并遍历</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//获取每组映射的Bean所对应的类</span></span><br><span class="line">            Class tmpClass = entry.getValue().getBeanClass();</span><br><span class="line">            <span class="keyword">if</span>(tmpClass == clazz || clazz.isAssignableFrom(tmpClass)) &#123;</span><br><span class="line">                <span class="comment">//得到对应的BeanDefinition</span></span><br><span class="line">                beanDefinition = entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!beanDefinition.isSingleton() || beanDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> doCreateBean(beanDefinition);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String name, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateBeans</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, BeanDefinition&gt; entry : beanDefinitionMap.entrySet()) &#123;</span><br><span class="line">            doCreateBean(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AutowiredCapableBeanFactory 类：</strong>将实现的 BeanFactory ，变成可以自动注入属性的 BeanFactory ，可以通过<strong>反射</strong>的方式创建完成实例对象后，注入其中的属性，如果属性是一个对象引用，那么就去创建那个被引用的实例对象，并<strong>递归地完成属性注入</strong>。</p>
<p>具体的实现逻辑如下注释所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体创建Bean的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//如果对象是单例的并且已经创建完成，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton() &amp;&amp; beanDefinition.getBean() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则通过反射的方式，获取Bean的实例</span></span><br><span class="line">        Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">        <span class="comment">//根据Bean属性，如果是单例的，也就是第一次创建该对象时，将Bean set进beanDefinition，便于下次直接获取</span></span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton()) &#123;</span><br><span class="line">            beanDefinition.setBean(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为新创建的Bean注入属性</span></span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为新创建的Bean注入属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 待注入属性的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean的定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 反射异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            <span class="comment">//获取Bean属性的字段名</span></span><br><span class="line">            Field field = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            <span class="comment">//获取Bean属性字段值</span></span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="comment">//如果Bean的属性字段值是引用类型时，递归地创建所有引用对象</span></span><br><span class="line">            <span class="comment">//instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span></span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) propertyValue.getValue();</span><br><span class="line">                BeanDefinition refDefinition = beanDefinitionMap.get(beanReference.getName());</span><br><span class="line">                <span class="keyword">if</span>(refDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    value = doCreateBean(refDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-package-context"><a href="#2-3-5-package-context" class="headerlink" title="2.3.5 package-context"></a>2.3.5 package-context</h3><p>BeanFactory 创建完成之后，我们就来实现 Spring 框架中最核心的类，也是 Spring 的入口类 ApplicationContext ，即应用程序上下文。我们只实现其核心的功能，也就是获取 Bean 的功能。我认为这个类可以视为将 BeanFatory 做了一次封装，传入一个 BeanFactory 对象，在内部调用工厂类的获取 Bean 的方法。</p>
<p><strong>ApplicationContext 接口：</strong>应用程序上下文接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类名从SpringIOC中获取实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过实例的名称从SpringIOC中获取对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractApplicationContext 抽象类：</strong>实现ApplicationContext中获取实例的两个方法,运用代理模式（静态代理）的思想，内部保存一个BeanFactory实例来实现其功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ClassPathXmlApplicationContext 类：</strong></p>
<p>我们在子类中创建 BeanFactory ，在创建时先初步将 BeanDefinition 注册到工厂容器中，然后再通过创建的工厂对象 beanFactory 调用 populateBeans 来将所有的 Bean 实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object startupShutdownMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.location = location;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">            AbstractBeanFactory beanFactory = obtainBeanFactory();</span><br><span class="line">            prepareBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanFactory <span class="title">obtainBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">new</span> ResourceLoader());</span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(location);</span><br><span class="line">        AbstractBeanFactory beanFactory = <span class="keyword">new</span> AutowiredCapableBeanFactory();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : beanDefinitionReader.getRegistry().entrySet()) &#123;</span><br><span class="line">            beanFactory.registerBeanDefinition(beanDefinitionEntry.getKey(), beanDefinitionEntry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(AbstractBeanFactory beanFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanFactory.populateBeans();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Test"><a href="#2-4-Test" class="headerlink" title="2.4 Test"></a>2.4 Test</h2><p>测试类的代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        WrapService wrapService = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService.say();</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        HelloWorldService helloWorldService2 = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;prototype验证：&quot;</span> + (helloWorldService == helloWorldService2));</span><br><span class="line">        WrapService wrapService2 = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService2.say();</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton验证：&quot;</span> + (wrapService == wrapService2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World</span><br><span class="line">prototype验证：false</span><br><span class="line">Hello World</span><br><span class="line">singleton验证：true</span><br></pre></td></tr></table></figure>

<p>这里验证了一下 prototype 和 singleton ，这里首先获取了两次 HelloWorldService 的实例，由于这个 Bean 在配置文件中被标为 prototype ，所以两次获取到的都不是同一个对象，使用等号比较时得到了 false 。而后面获取的 wrapService ，和第一次获取的 WrapService 比较，由于是 singleton 的，所以使用等号比较时返回 true 。</p>
<h1 id="3-注解注入方式"><a href="#3-注解注入方式" class="headerlink" title="3.注解注入方式"></a>3.注解注入方式</h1><h2 id="3-1项目概况"><a href="#3-1项目概况" class="headerlink" title="3.1项目概况"></a>3.1项目概况</h2><p><img src="/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/GitHub\MyBlogs\source_posts\2021-05-27-手写实现SpringIOC\注解1.png" alt="image-20210531223813945"></p>
<p>还是自底向上的思想来重构项目</p>
<h2 id="3-2-package-Springwork"><a href="#3-2-package-Springwork" class="headerlink" title="3.2 package-Springwork"></a>3.2 package-Springwork</h2><h3 id="3-2-1-package-annotation"><a href="#3-2-1-package-annotation" class="headerlink" title="3.2.1 package-annotation"></a>3.2.1 package-annotation</h3><p>注解的注入方式就是省去了 XML 文件对于 Bean 的配置，而是在需要注入的 Bean 上直接加注解，Spring 通过扫描特定范围下的类将实体类实例化注入到 SpringIOC 容器中。因此我们先定义几个注解常用注解：</p>
<p>在定义注解时，我们通常用到<strong>元注解</strong>，它用来描述我们定义的注解使用在什么地方、什么时间范围有效等。常用的两种元注解及其参数值如下：</p>
<p><strong>@Target：</strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p>
<p>取值(ElementType)有：</p>
<ol>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域</li>
<li>LOCAL_VARIABLE:用于描述局部变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>PARAMETER:用于描述参数</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ol>
<p><strong>@Retention：</strong>表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p>
<p>取值（RetentionPoicy）有：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在class文件中有效（即class保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<p><strong>在项目中，我们定义了以下几个常用的注解：</strong></p>
<p><strong>Autowired 注解：</strong>默认根据类型进行注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Qualifier 注解：</strong>如果有<code>多个类型一样</code>的Bean候选者，则需要 Qualifier 注解限定其中一个候选者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Component 注解：</strong>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Scope 注解：</strong>描述 Bean 的作用域，singleton 或者 prototype</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;singleton&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Value 注解：</strong>把对应的值注入到变量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Value &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-package-reader"><a href="#3-2-2-package-reader" class="headerlink" title="3.2.2 package-reader"></a>3.2.2 package-reader</h3><p>因为我们不是 SpringBoot ，所以还是要自定义注解的扫描范围，也就是哪些包下有需要注入的 Bean，自定义一个 XML 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!--该配置文件声明扫描包的范围--&gt;</span><br><span class="line">    &lt;component-scan base-package=&quot;top.wangjin.main&quot;&gt;&lt;/component-scan&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>通过上面的分析我们知道 reader 包下类的作用是读取并解析配置文件中的 BeanDefinition ，那么换成注解注入方式后，功能仍然是不变的，但是在解析配置文件时，要进行判断，如果配置文件的节点标签是 component-scan 时，就要调用解析注解的方法来解析对应包下实体类的 BeanDefinition。</p>
<p><strong>XmlBeanDefinitionReader 类：</strong>注解注入和 XML 方式注入的判断在 parseBeanDefinitions 方法中，循环遍历配置文件中的节点，如果发现节点的标签名是 component-scan 时，就会调用注解解析方法来向容器中注入 BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的路径获取BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location 配置文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//根据配置文件的路径，获取配置文件的文件输入流</span></span><br><span class="line">        InputStream inputStream = getResourceLoader().getResource(location).getInputStream();</span><br><span class="line">        doLoadBeanDefinitions(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据配置文件的输入流解析出BeanDefinition，并注册到临时Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder documentBuilder = factory.newDocumentBuilder();</span><br><span class="line">        Document document = documentBuilder.parse(inputStream);</span><br><span class="line">        <span class="comment">// 解析xml document并注册bean</span></span><br><span class="line">        registerBeanDefinitions(document);</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册BeanDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> document</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document document)</span> </span>&#123;</span><br><span class="line">        Element root = document.getDocumentElement();</span><br><span class="line">        <span class="comment">// 从文件根递归解析</span></span><br><span class="line">        parseBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件的根root，递归地将每个节点解析成BeanDefinition</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        NodeList nodeList = root.getChildNodes();</span><br><span class="line">        <span class="comment">//先判断是否是注解配置：</span></span><br><span class="line">        <span class="comment">//1.是，选用注解解析成BeanDefinition</span></span><br><span class="line">        <span class="comment">//2.否，选用XML文件解析成BeanDefinition</span></span><br><span class="line">        String basePackage = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeList.item(i) <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) nodeList.item(i);</span><br><span class="line">                <span class="keyword">if</span> (ele.getTagName().equals(<span class="string">&quot;component-scan&quot;</span>)) &#123;</span><br><span class="line">                    basePackage = ele.getAttribute(<span class="string">&quot;base-package&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (basePackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parseAnnotation(basePackage);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">            Node node = nodeList.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                processBeanDefinition((Element) node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseAnnotation</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取basePackage包下所有类，放入Set集合中</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">            processAnnotationBeanDefinition(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据注解来解析BeanDefinition，并将其注册到注册表Map中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationBeanDefinition</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Component注解表示需要注入到SpringIOC中</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Component.class)) &#123;</span><br><span class="line">            <span class="comment">//通过反射的方式获取注解的值</span></span><br><span class="line">            String name = clazz.getAnnotation(Component.class).name();</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                name = clazz.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            String className = clazz.getName();</span><br><span class="line">            <span class="comment">//确定Bean是Singleton还是prototype</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (clazz.isAnnotationPresent(Scope.class) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(clazz.getAnnotation(Scope.class).value())) &#123;</span><br><span class="line">                singleton = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            <span class="comment">//给Bean的属性赋值</span></span><br><span class="line">            processAnnotationProperty(clazz, beanDefinition);</span><br><span class="line">            <span class="comment">//给BeanDefinition实体类赋值</span></span><br><span class="line">            beanDefinition.setBeanClassName(className);</span><br><span class="line">            beanDefinition.setSingleton(singleton);</span><br><span class="line">            <span class="comment">//将BeanDefinition注册到注册表Map中</span></span><br><span class="line">            getRegistry().put(name, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationProperty</span><span class="params">(Class&lt;?&gt; clazz, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取Bean所对应类的字段</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">//获取属性的名称</span></span><br><span class="line">            String name = field.getName();</span><br><span class="line">            <span class="comment">// 属性上的注解有两种情况：</span></span><br><span class="line">            <span class="comment">// 1.如果属性上添加了Value注解，属于基本类型，将Value上的值赋给该属性</span></span><br><span class="line">            <span class="comment">// 2.如果属性上添加了Autowired注解，属于引用类型，又分为两种情况：</span></span><br><span class="line">            <span class="comment">// a.如果属性上有Qualifier注解，根据注解值将对应名称的Bean注入beanDefinitionMap</span></span><br><span class="line">            <span class="comment">// b.如果属性上没有Qualifier注解，就根据Autowired注解，将对应类型的类名注入beanDefinitionMap</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(Value.class)) &#123;</span><br><span class="line">                Value valueAnnotation = field.getAnnotation(Value.class);</span><br><span class="line">                String value = valueAnnotation.value();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (field.isAnnotationPresent(Autowired.class)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(Qualifier.class)) &#123;</span><br><span class="line">                    Qualifier qualifier = field.getAnnotation(Qualifier.class);</span><br><span class="line">                    String ref = qualifier.value();</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the value of Qualifier should not be null!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = field.getType().getName();</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取packageName包下所有的类，并返回一个Set集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件，并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以文件的形式获取包下所有的Class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> recursive</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者 也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于BeanDefinition的实际解析过程，也就是获取BeanDefinition实体类的每个属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        String name = ele.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        String className = ele.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> singleton = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(<span class="string">&quot;scope&quot;</span>) &amp;&amp; <span class="string">&quot;prototype&quot;</span>.equals(ele.getAttribute(<span class="string">&quot;scope&quot;</span>))) &#123;</span><br><span class="line">            singleton = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">        processProperty(ele, beanDefinition);</span><br><span class="line">        beanDefinition.setBeanClassName(className);</span><br><span class="line">        beanDefinition.setSingleton(singleton);</span><br><span class="line">        getRegistry().put(name, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给Bean的属性赋值：</span></span><br><span class="line"><span class="comment">     * 1.当是基本类型时直接赋值</span></span><br><span class="line"><span class="comment">     * 2.当是引用类型时不是立即初始化，而是创建一个只有名称的引用对象，</span></span><br><span class="line"><span class="comment">     * 因为BeanDefinition是在读取配置文件时就被创建的，这时还没有任何Bean被初始化，BeanReference仅仅是一个记录而已</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processProperty</span><span class="params">(Element ele, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        NodeList propertyNode = ele.getElementsByTagName(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyNode.getLength(); i++) &#123;</span><br><span class="line">            Node node = propertyNode.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element propertyEle = (Element) node;</span><br><span class="line">                String name = propertyEle.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String value = propertyEle.getAttribute(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 优先进行值注入</span></span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, value));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String ref = propertyEle.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ref == <span class="keyword">null</span> || ref.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Configuration problem: &lt;property&gt; element for property &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; must specify a ref or value&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    BeanReference beanReference = <span class="keyword">new</span> BeanReference(ref);</span><br><span class="line">                    beanDefinition.getPropertyValues().addPropertyValue(<span class="keyword">new</span> PropertyValue(name, beanReference));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>在 processAnnotationProperty 方法中，根据注解的值对 Bean 属性进行注入时有几种情况：<br>             1.如果属性上添加了Value注解，属于基本类型，将Value上的值赋给该属性<br>             2.如果属性上添加了Autowired注解，属于引用类型，又分为两种情况：<br>                a.如果属性上有Qualifier注解，根据注解值将对应名称的Bean注入beanDefinitionMap<br>                b.如果属性上没有Qualifier注解，就根据Autowired注解，将对应类型的类名注入beanDefinitionMap</p>
<p>注意最后一种情况，如果引用类型我们没有添加Qualifier注解时是根据类名添加的，这时根据 Bean 的名称是找不到对应的 Bean 的，所以要进行空值判断，当根据 Bean 的名称找不到时，就要根据类名找，所以有了下面代码的改写。</p>
</blockquote>
<h3 id="3-2-3-package-factory"><a href="#3-2-3-package-factory" class="headerlink" title="3.2.3 package-factory"></a>3.2.3 package-factory</h3><p><strong>AutowiredCapableBeanFactory 类：</strong>主要改写的是为创建的 Bean 注入属性的方法，两种注入方式：通过 Bean 名称注入和通过类名注入，分别对应在 reader 中注册 BeanDefinition 时，两种注册属性的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体创建Bean的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition Bean定义对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">doCreateBean</span><span class="params">(BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton() &amp;&amp; beanDefinition.getBean() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> beanDefinition.getBean();</span><br><span class="line">        &#125;</span><br><span class="line">        Object bean = beanDefinition.getBeanClass().newInstance();</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition.isSingleton()) &#123;</span><br><span class="line">            beanDefinition.setBean(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        applyPropertyValues(bean, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为新创建的Bean注入属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean 待注入属性的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean的定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 反射异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(Object bean, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(PropertyValue propertyValue : beanDefinition.getPropertyValues().getPropertyValues()) &#123;</span><br><span class="line">            Field field = bean.getClass().getDeclaredField(propertyValue.getName());</span><br><span class="line">            Object value = propertyValue.getValue();</span><br><span class="line">            <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BeanReference) &#123;</span><br><span class="line">                BeanReference beanReference = (BeanReference) propertyValue.getValue();</span><br><span class="line">                <span class="comment">// 优先按照自定义名称匹配（字段上有Qualifier注解，按照注解值注入beanDefinitionMap的情况）</span></span><br><span class="line">                BeanDefinition refDefinition = beanDefinitionMap.get(beanReference.getName());</span><br><span class="line">                <span class="keyword">if</span>(refDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!refDefinition.isSingleton() || refDefinition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        value = doCreateBean(refDefinition);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value = refDefinition.getBean();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 按照类型匹配，返回第一个匹配的（字段上没有Qualifier注解，按照类型名称注入beanDefinitionMap的情况）</span></span><br><span class="line">                    Class clazz = Class.forName(beanReference.getName());</span><br><span class="line">                    <span class="keyword">for</span>(BeanDefinition definition : beanDefinitionMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(clazz.isAssignableFrom(definition.getBeanClass())) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!definition.isSingleton() || definition.getBean() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                value = doCreateBean(definition);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                value = definition.getBean();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;无法注入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(bean, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-package-main"><a href="#3-3-package-main" class="headerlink" title="3.3 package-main"></a>3.3 package-main</h2><h3 id="3-3-1-package-service"><a href="#3-3-1-package-service" class="headerlink" title="3.3.1 package-service"></a>3.3.1 package-service</h3><p>添加注解后的实体类：</p>
<p><strong>HelloWorldService 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HelloWorldServiceImpl 类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(name = &quot;helloWorldService&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;Hello, world&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WrapService 类：</strong></p>
<blockquote>
<p><strong>Note：</strong>字段上加了 @Qualifier(“helloWorldService”) 注解与不加都可以，但是在 reader 进行 BeanDefinition 注册添加属性时是不一样的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(name = &quot;wrapService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;helloWorldService&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> HelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloWorldService.saySomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Test"><a href="#3-4-Test" class="headerlink" title="3.4 Test"></a>3.4 Test</h2><p>测试类的代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;application-annotation.xml&quot;</span>);</span><br><span class="line">        WrapService wrapService = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        wrapService.say();</span><br><span class="line">        HelloWorldService helloWorldService = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        HelloWorldService helloWorldService2 = (HelloWorldService) applicationContext.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;prototype验证：相等&quot;</span> + (helloWorldService == helloWorldService2));</span><br><span class="line">        WrapService wrapService2 = (WrapService) applicationContext.getBean(<span class="string">&quot;wrapService&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;singleton验证：相等&quot;</span> + (wrapService == wrapService2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello, world</span><br><span class="line">prototype验证：相等false</span><br><span class="line">singleton验证：相等true</span><br></pre></td></tr></table></figure>

<p>结果没有问题，而且在 WrapService 类的 helloWorldService 属性上加不加 @Qualifier(“helloWorldService”)  注解都是可以实现注入的。</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>（八）RPC项目总结</title>
    <url>/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-项目模块概述"><a href="#1-项目模块概述" class="headerlink" title="1.项目模块概述"></a>1.项目模块概述</h1><ul>
<li><strong>roc-api</strong>    ——    通用接口（供消费者调用）</li>
<li><strong>rpc-common</strong>    ——    实体对象、工具类等公用类</li>
<li><strong>rpc-core</strong>    ——    框架的核心实现</li>
<li><strong>test-client</strong>    ——    服务消费侧</li>
<li><strong>test-server</strong>    ——    服务提供侧</li>
</ul>
<h2 id="1-1roc-api模块"><a href="#1-1roc-api模块" class="headerlink" title="1.1roc-api模块"></a>1.1roc-api模块</h2><blockquote>
<p>模块间添加依赖就可以导入被依赖模块的package</p>
</blockquote>
<p>这个模块下的接口可以供给消费侧调用，而在服务侧实现。</p>
<p>两个通用接口：</p>
<ol>
<li><p><strong>HelloService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ByeService</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-2test-server模块"><a href="#1-2test-server模块" class="headerlink" title="1.2test-server模块"></a>1.2test-server模块</h2><p>作为服务的提供者，完成的功能就是实现服务和向Nacos中注册服务</p>
<p><strong>一、两个服务的实现类</strong></p>
<ol>
<li><p><strong>HelloServiceImpl</strong></p>
<p>对传入的对象处理后返回处理结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Impl1方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ByeServiceImpl</strong></p>
<p>返回传入的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByeServiceImpl</span> <span class="keyword">implements</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bye, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>二、编写服务提供者</strong></p>
<p>选用 Netty 传输方式，并且指定序列化方式为 Google Protobuf 方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选用 Socket 传输方式，并且指定序列化方式为 HESSIAN 方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> SocketServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9998</span>, CommonSerializer.HESSIAN_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也体现了 Java 语言中的优越性，将 RpcServer 抽象成接口，不同的实现类来实现它，创建不同的实现类对象就会得到不同的服务端</p>
<h2 id="1-3test-client模块"><a href="#1-3test-client模块" class="headerlink" title="1.3test-client模块"></a>1.3test-client模块</h2><p>服务侧主要是通过<strong>动态代理方式</strong>远程调用服务，看起来调用本地方法一样简单</p>
<p><strong>编写服务消费者</strong></p>
<p>客户端选用 Netty 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端选用 Socket 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = proxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4rpc-common模块"><a href="#1-4rpc-common模块" class="headerlink" title="1.4rpc-common模块"></a>1.4rpc-common模块</h2><p>存放一些服务端和客户端都能用到的实体对象、枚举、工具类等等</p>
<h3 id="1-4-1package-entity"><a href="#1-4-1package-entity" class="headerlink" title="1.4.1package-entity"></a>1.4.1package-entity</h3><p>包括请求实体类和响应实体类</p>
<p><strong>RpcRequest 实体类：</strong>封装了请求接口的定位信息以及接口需要的参数信息</p>
<p>同时可以作为心跳包，验证客户端是否假死。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是心跳包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean heartBeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcResponse 实体类：</strong>封装了调用服务后处理的结果和状态信息，其中包含了两个静态构造方法，分别是处理成功和失败的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应对应的请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2package-enumeration"><a href="#1-4-2package-enumeration" class="headerlink" title="1.4.2package-enumeration"></a>1.4.2package-enumeration</h3><p>包括包的类型、响应状态码、异常以及序列化码等的枚举类型类</p>
<p><strong>PackageType：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PackageType</span> </span>&#123;</span><br><span class="line">    REQUEST_PACK(<span class="number">0</span>),</span><br><span class="line">    RESPONSE_PACK(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ResponseCode：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;调用方法成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">&quot;调用方法失败&quot;</span>),</span><br><span class="line">    METHOD_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定方法&quot;</span>),</span><br><span class="line">    CLASS_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定类&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcError：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RpcError</span> </span>&#123;</span><br><span class="line">    UNKNOWN_ERROR(<span class="string">&quot;出现未知错误&quot;</span>),</span><br><span class="line">    SERVICE_SCAN_PACKAGE_NOT_FOUND(<span class="string">&quot;启动类ServiceScan注解缺失&quot;</span>),</span><br><span class="line">    CLIENT_CONNECT_SERVER_FAILURE(<span class="string">&quot;客户端连接服务端失败&quot;</span>),</span><br><span class="line">    SERVICE_INVOCATION_FAILURE(<span class="string">&quot;服务调用出现失败&quot;</span>),</span><br><span class="line">    SERVICE_NOT_FOUND(<span class="string">&quot;找不到对应的服务&quot;</span>),</span><br><span class="line">    SERVICE_NOT_IMPLEMENT_ANY_INTERFACE(<span class="string">&quot;注册的服务未实现接口&quot;</span>),</span><br><span class="line">    UNKNOWN_PROTOCOL(<span class="string">&quot;不识别的协议包&quot;</span>),</span><br><span class="line">    UNKNOWN_SERIALIZER(<span class="string">&quot;不识别的(反)序列化器&quot;</span>),</span><br><span class="line">    UNKNOWN_PACKAGE_TYPE(<span class="string">&quot;不识别的数据包类型&quot;</span>),</span><br><span class="line">    SERIALIZER_NOT_FOUND(<span class="string">&quot;找不到序列化器&quot;</span>),</span><br><span class="line">    RESPONSE_NOT_MATCH(<span class="string">&quot;响应与请求号不匹配&quot;</span>),</span><br><span class="line">    FAILED_TO_CONNECT_TO_SERVICE_REGISTRY(<span class="string">&quot;连接注册中心失败&quot;</span>),</span><br><span class="line">    REGISTER_SERVICE_FAILED(<span class="string">&quot;注册服务失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SerializerCode：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    KRYO(<span class="number">0</span>),</span><br><span class="line">    JSON(<span class="number">1</span>),</span><br><span class="line">    HESSIAN(<span class="number">2</span>),</span><br><span class="line">    PROTOBUF(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3package-exception"><a href="#1-4-3package-exception" class="headerlink" title="1.4.3package-exception"></a>1.4.3package-exception</h3><p><strong>RpcException：</strong>根据参数选择不同的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error, String detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage() + <span class="string">&quot;: &quot;</span> + detail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SerializeException：</strong>序列化异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-4package-factory"><a href="#1-4-4package-factory" class="headerlink" title="==1.4.4package-factory=="></a>==1.4.4package-factory==</h3><p>==这里的HashMap中是提前存好了所有类吗？==</p>
<p>包括两个工厂：创建单例对象的工厂和创建线程池的工厂</p>
<p><strong>SingletonFactory：</strong>返回一个类对应的单例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class, Object&gt; objectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Object instance = objectMap.get(clazz);</span><br><span class="line">        <span class="keyword">synchronized</span> (clazz) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instance = clazz.newInstance();</span><br><span class="line">                    objectMap.put(clazz, instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadPoolFactory：</strong>创建 ThreadPool(线程池) 的工具类，根据是否给定了线程的前缀名创建线程池</p>
<ol>
<li><p><strong>createDefaultThreadPool方法：</strong>返回一个ExecutorService对象，该对象能够执行实现 <code>Runnable</code>/<code>Callable</code>接口的对象</p>
</li>
<li><p><strong>createDefaultThreadPool方法（两个参数）：</strong>设置了是否为守护线程，都是false，也就是不会创建守护线程。通过 <code>computeIfAbsent</code> 方法判断是否已经创建了能够产生线程名的前缀为 threadNamePrefix 的线程池</p>
<blockquote>
<p><strong>computeIfAbsent：</strong>存在时返回存在的值，不存在时返回新值</p>
</blockquote>
</li>
<li><p><strong>createThreadPool方法：</strong>实际创建线程池</p>
</li>
<li><p><strong>createThreadFactory方法：</strong>线程池中线程的创建对象，如果threadNamePrefix不为空则使用自建ThreadFactory，否则使用defaultThreadFactory</p>
</li>
<li><p><strong>shutDownAll方法：</strong>关闭所有线程池</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ThreadPoolFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ExecutorService&gt; threadPollsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDefaultThreadPool(threadNamePrefix, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = threadPollsMap.computeIfAbsent(threadNamePrefix, k -&gt; createThreadPool(threadNamePrefix, daemon));</span><br><span class="line">        <span class="keyword">if</span> (pool.isShutdown() || pool.isTerminated()) &#123;</span><br><span class="line">            threadPollsMap.remove(threadNamePrefix);</span><br><span class="line">            pool = createThreadPool(threadNamePrefix, daemon);</span><br><span class="line">            threadPollsMap.put(threadNamePrefix, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService <span class="title">createThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = createThreadFactory(threadNamePrefix, daemon);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE_SIZE, KEEP_ALIVE_TIME, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory <span class="title">createThreadFactory</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadNamePrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).setDaemon(daemon).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Executors.defaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutDownAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭所有线程池...&quot;</span>);</span><br><span class="line">        threadPollsMap.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">            ExecutorService executorService = entry.getValue();</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            logger.info(<span class="string">&quot;关闭线程池 [&#123;&#125;] [&#123;&#125;]&quot;</span>, entry.getKey(), executorService.isTerminated());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executorService.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;关闭线程池失败！&quot;</span>);</span><br><span class="line">                executorService.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5package-util"><a href="#1-4-5package-util" class="headerlink" title="1.4.5package-util"></a>1.4.5package-util</h3><p>存放通用的工具类</p>
<p><strong>NacosUtil 工具类：</strong>管理Nacos连接等工具类（Nacos运行在端口8848）</p>
<p><strong>静态代码块：</strong>类只要完成加载就能连接上 Nacos</p>
<p><strong>getNacosNamingService方法：</strong>通过 NamingFactory 连接 Nacos 并返回 NamingService 对象</p>
<p><strong>registerService方法：</strong>通过 namingService 向 Nacos 中注册服务，分别是服务名、地址和端口号，并将服务名保存在 Set 集合中</p>
<p><strong>getAllInstance方法：</strong>通过 namingService 获取所有服务的名称</p>
<p><strong>clearRegistry方法：</strong>从 Nacos 中清空服务，也就是防止服务器关闭时，服务仍然保存在 Nacos 中（其实 Nacos 本身是有保活机制的，一小段时间联系不上服务器就会自动注销），一般将这个方法称为钩子，当 JVM 关闭时执行该方法，这样 Nacos 就会清空服务列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReflectUtil 类：</strong></p>
<p><strong>getStackTrace 方法：</strong>StackTraceElement存储了java代码堆栈调用轨迹，通过这个对象可以获取调用栈中的调用过程信息，包括类名、方法名、文件名、调用行数等，main 方法是第一个被加入栈中的，所以是最后一个</p>
<p><strong>getClasses 方法：</strong>传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回<strong>（ReflectUtil中最重要的方法）</strong></p>
<p><strong>findAndAddClassesInPackageByFile 方法：</strong>以文件的方式扫描整个包下的文件 并添加到集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过调用栈来获取main方法所在的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] stack = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">        <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>].getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件 并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>RpcMessageChecker 工具类：</strong>检查响应与请求</p>
<p>主要是检验响应数据包是否正确：是否为空值，是否与请求包的 Id 一致等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcMessageChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTERFACE_NAME = <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcMessageChecker.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RpcMessageChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rpcRequest.getRequestId().equals(rpcResponse.getRequestId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.RESPONSE_NOT_MATCH, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || !rpcResponse.getStatusCode().equals(ResponseCode.SUCCESS.getCode())) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;,RpcResponse:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5rpc-core模块（核心）"><a href="#1-5rpc-core模块（核心）" class="headerlink" title="1.5rpc-core模块（核心）"></a>1.5rpc-core模块（核心）</h2><p>框架的核心实现</p>
<h3 id="1-5-1package-transport"><a href="#1-5-1package-transport" class="headerlink" title="==1.5.1package-transport=="></a>==1.5.1package-transport==</h3><p>本项目中主要有两种传输方式：Netty 和 Socket </p>
<p><strong>我们将客户端和服务端抽象成两个接口，在接口中定义客户端和服务端要实现的功能</strong></p>
<p><strong>RpcClient接口：</strong>客户端类通用接口，只有一个方法发送请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcServer接口：</strong>服务器类通用接口</p>
<p>**<code>start 方法：</code>**启动服务端</p>
<p>**<code>publishService 方法：</code>**发布服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcClientProxy 类（工厂类，用于获取代理对象）：</strong>RPC客户端动态代理类，通过动态代理类来屏蔽网络传输的细节。当我们去调用一个远程方法的时候，实际上是通过代理对象调用的。</p>
<p>其实也好理解，就是代理模式能够在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，那么扩展的这些功能其实就是实际的网络传输细节，当被代理的对象方法被调用时，实际上是按照我们重写的 invoke 方法中的逻辑执行的。</p>
<p><code>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</code></p>
<p><code>Proxy</code> 类中使用频率最高的方法是： <code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<p>这个方法一共有 3 个参数： </p>
<ol>
<li>loader :类加载器，用于加载代理对象；</li>
<li>interfaces : 代理需要实现的接口，可指定多个； </li>
<li>h : 实现了 InvocationHandler 接口的对象；</li>
</ol>
<p><code>InvocationHandler</code> 接口的实现主要是来自定义处理逻辑。当我们的动态代 理对象调用一个方法时候，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法来调用。当你使用代理对象调用方法的时候实际会调用到这个 invoke 方法。</p>
<p>这个方法一共有 3 个参数： </p>
<ol>
<li>proxy :动态生成的代理类 </li>
<li>method : 与代理类对象调用的方法相对应 </li>
<li>args : 当前 method 方法的参数</li>
</ol>
<p><strong>getProxy 方法：</strong>RpcClientProxy就是一个工厂类，该方法就是用于获取代理对象</p>
<p><strong>invoke 方法：</strong>当调用一个代理对象的方法时，按照该方法中的逻辑执行，该方法的逻辑主要是：</p>
<p>生成 RpcRequest 对象，根据不同的传输方式选择不同的逻辑来接收响应对象 RpcResponse ，调用 RpcMessageChecker 工具类来检验数据的正确性，通过检验后，将返回数据提取，返回给用户</p>
<p> ==CompletableFuture怎么用？==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;方法调用请求发送失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理对象在客户端的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractRpcServer 抽象类：</strong>因为项目中使用了注解功能，无论使用 Netty 传输还是 Socket 传输方式，都要用到 <code>scanServices</code> 这个公共方法，所以通过抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自  AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p>
<blockquote>
<p><strong>Note：</strong></p>
<ul>
<li>抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现；</li>
<li>而普通类即非抽象类则必须实现接口里的全部方法。 </li>
</ul>
</blockquote>
<p><strong>scanServices 方法：</strong>扫描启动类所在包下所有的有Service注解的类，通过反射创建对象，并向Nacos中注册服务</p>
<p>通过调用 ReflectUtil 工具类中的 getStackTrace 的方法来获取栈底的 main 方法的类，并判断 main 方法所在类的注解值，当确定是加了 ServiceScan 注解后，获取 ServiceScan 注解的值，并获取启动类所在的包，然后就是扫描这个包下所有类的注解，只要是 Service 注解的类通过反射创建该对象，并且调 publishService 注册即可</p>
<p><strong>publishService 方法：</strong>向Nacos中注册服务，包括服务名还有服务所在的地址信息</p>
<p>向本地服务表中添加服务名和服务实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取启动类，也就是main方法所在的类</span></span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Class.forName(xxx.xx.xx) 返回具体类</span></span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到所有的 Class ，逐个判断是否有 Service 注解</span></span><br><span class="line">        <span class="comment">//如果有的话，通过反射创建该对象，并且调用 publishService 注册即可</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service.class).name();</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-1package-netty-client"><a href="#1-5-1-1package-netty-client" class="headerlink" title="1.5.1.1package-netty-client"></a>1.5.1.1package-netty-client</h4><p>Netty 客户端的实现</p>
<p><strong>NettyClient 类：</strong>主要是重写sendRequest的代码逻辑，通过 CompletableFuture 异步获取 Netty 请求的响应结果，并将 CompletableFuture 实例返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ChannelProvider 类：</strong>将客户端创建 channel 的逻辑分离出来，按照自定义的逻辑创建 Channel</p>
<p>这里有一个属性是 Map ，这里以服务提供者的地址和序列化器编码作为键， Channel 作为键值，只要已经有这样一个 Channel 并且是活跃状态就直接返回，否则按照自定义的方案来创建一个 Channel ，并放到 Map 中。如果 Map 中 Key 对应的 Channel 失效了，就将 Key 移除，并重新创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接客户端时有错误发生&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//是否开启 TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler 类：</strong></p>
<p>与NettyServerHandler类似，不做介绍，只不过由于客户端没有设置读超时时间，所以不用对服务端的心跳包做识别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UnprocessedRequests 类：</strong>将每个请求对应的CompletableFuture实例都保存在一个Map中，key为请求ID，value为创建的CompletableFuture实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-2package-netty-server"><a href="#1-5-1-2package-netty-server" class="headerlink" title="1.5.1.2package-netty-server"></a>1.5.1.2package-netty-server</h4><p><strong>NettyServer 类：</strong></p>
<p>主要的步骤为：</p>
<ol>
<li>创建 ServerBootstrap 实例</li>
<li>设置并绑定 Reactor 线程池</li>
<li>设置并绑定服务端 Channel</li>
<li>创建并初始化 ChannelPipeline</li>
<li>添加并设置 ChannelHandler</li>
<li>绑定并启动监听端口</li>
</ol>
<p>下面通过注释的方式来说明整个流程：</p>
<blockquote>
<p>其中ServerBootStrap提供的方法有：</p>
<p>group：设置 ServerBootstrap 要用的 EventLoopGroup</p>
<p>channel：设置将要被实例化的 ServerChannel 类</p>
<p>attr：可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性，然后我们可以通过channel.attr()取出这个属性，比如，上面的代码我们指定我们服务端channel的一个serverName属性，属性值为nettyServer，其实说白了就是给NioServerSocketChannel维护一个map而已</p>
<p>childAttr：可以给每一条连接指定自定义属性，然后后续我们可以通过 channel.attr() 取出该属性</p>
<p>childOption：给每条连接设置一些TCP底层相关的属性</p>
<p>option：给服务端channel设置一些属性</p>
<p>handler：用于指定在服务端启动过程中的一些逻辑</p>
<p>childHandler：指定处理新连接数据的读写处理逻辑</p>
<p>bind：绑定 ServerChannel</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在服务器启动时，注册一个钩子，用于自动注销服务</span></span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        <span class="comment">// 创建Netty服务端的两个线程组： boos 和 worker</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ServerBootStrap实例</span></span><br><span class="line">            <span class="comment">// ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 给ServerBootstrap绑定两个线程组，这样Netty的线程模型就确定了</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 设置服务端Channel的IO模型,指定使用的NIO传输的Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 打印服务端启动过程的日志信息</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// BACKLOG用于构造服务端套接字ServerSocket对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度为256</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    <span class="comment">// 启用心跳保活机制。在双方TCP套接字建立连接后（即都进入ESTABLISHED状态）并且在两个小时左右上层没有任何数据传输的情况下，这套机制才会被激活。</span></span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// TCP_NODELAY就是用于启用或关于Nagle算法</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// 处理新连接数据的读写处理逻辑</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 为Channel绑定ChannelPipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 将用于数据处理的Handler添加到ChannelPipeline中</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定服务器端的端口，同步等待成功</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 优雅地关闭两个线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyServerHandler 类：</strong></p>
<p>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，当读取完成后会调用方法 <code>fireChannelReadComplete()</code> 通知 pipline 读取完成，然后触发 <code>channelRead</code> 方法，在 <code>channelRead</code> 方法中对读取到的数据进行消息类型检验，判断当前的 <code>message</code> 是否需要传递到下一个 <code>Handler</code> ，（如果需要传递到下一个Handler，执行的语句是：ctx.fireChannelRead(msg); ），不需要就调用 <code>channelRead0</code> 方法。</p>
<p><strong>channelRead0 方法：</strong>这里我们通过重写 <code>channelRead0</code> 方法来自定义我们对消息的处理逻辑：当消息是心跳包时，不用处理，当消息是其它请求包时，要调用<code>requestHandler</code> 中的 <code>handle</code> 方法对消息进行处理，其实就是通过方法名反射调用方法，然后获取结果。获取结果后通过语句 <code>ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()</code> 来判断channel是否正常的可写状态，调用 <code>writeAndFlush</code> 方法来将结果和消息ID写入 <code>ChannelHandlerContext</code> 中。</p>
<p><strong>userEventTriggered 方法：</strong>超过读超时时间被调用，实现心跳机制，来判断客户端是否假死状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;接收到客户端心跳包...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;通道不可写&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-3package-socket-client"><a href="#1-5-1-3package-socket-client" class="headerlink" title="1.5.1.3package-socket-client"></a>1.5.1.3package-socket-client</h4><p><strong>SocketClient 类：</strong>Socket 的客户端类，完成的任务也是发送一条请求数据，包括了建立 Socket 连接，将请求包按照 ObjectWriter 定义的方法进行编码，获取收到的数据，并对数据进行解码，返回给用户。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">            socket.connect(inetSocketAddress);</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            ObjectWriter.writeObject(outputStream, rpcRequest, serializer);</span><br><span class="line">            Object obj = ObjectReader.readObject(inputStream);</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) obj;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-4package-socket-server"><a href="#1-5-1-4package-socket-server" class="headerlink" title="1.5.1.4package-socket-server"></a>1.5.1.4package-socket-server</h4><p><strong>SocketServer 类：</strong>通过注解自动将服务注册到 Nacos 上，然后将钩子注册到 JVM 中，监听客户端的请求信息，若是发现请求时，将该请求分配线程池中的一个线程并按照 SocketRequestHandlerThread Socket传输方式自定义的消息处理方式，对数据进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        threadPool = ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;socket-rpc-server&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        <span class="keyword">this</span>.serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket()) &#123;</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> SocketRequestHandlerThread(socket, requestHandler, serializer));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketRequestHandlerThread 类：</strong>自定义的消息处理逻辑，包括将消息处理完后，返回给 Socket 客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketRequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketRequestHandlerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketRequestHandlerThread</span><span class="params">(Socket socket, RequestHandler requestHandler, CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = socket.getInputStream();</span><br><span class="line">             OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) ObjectReader.readObject(inputStream);</span><br><span class="line">            Object result = requestHandler.handle(rpcRequest);</span><br><span class="line">            RpcResponse&lt;Object&gt; response = RpcResponse.success(result, rpcRequest.getRequestId());</span><br><span class="line">            ObjectWriter.writeObject(outputStream, response, serializer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-5package-socket-util"><a href="#1-5-1-5package-socket-util" class="headerlink" title="1.5.1.5package-socket-util"></a>1.5.1.5package-socket-util</h4><p>我们希望让 Socket 与 Netty 使用的传输协议保持一致，也就是按照我们自定义的传输协议来对数据包进行封装和拆包，这意味着Socket也要用到序列化器。</p>
<p><strong>ObjectReader 类：</strong>类似于 Netty 中自定义的解码器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ObjectReader.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] numberBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> magic = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> packageCode = bytesToInt(numberBytes);</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> serializerCode = bytesToInt(numberBytes);</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> length = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.read(bytes);</span><br><span class="line">        <span class="keyword">return</span> serializer.deserialize(bytes, packageClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytesToInt</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        value = ((src[<span class="number">0</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">24</span>)</span><br><span class="line">                |((src[<span class="number">1</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">16</span>)</span><br><span class="line">                |((src[<span class="number">2</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">                |(src[<span class="number">3</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ObjectWriter 类：</strong>类似于 Netty 中自定义的编码器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(OutputStream outputStream, Object object, CommonSerializer serializer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.write(intToBytes(MAGIC_NUMBER));</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.REQUEST_PACK.getCode()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.RESPONSE_PACK.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.write(intToBytes(serializer.getCode()));</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(object);</span><br><span class="line">        outputStream.write(intToBytes(bytes.length));</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToBytes(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] src = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        src[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">16</span>)&amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">3</span>] = (<span class="keyword">byte</span>) (value &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2package-annotation"><a href="#1-5-2package-annotation" class="headerlink" title="1.5.2package-annotation"></a>1.5.2package-annotation</h3><p>定义的两个注解类：ServiceScan 和 Service</p>
<p><strong>ServiceScan 注解类：</strong>@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Service 注解类：</strong>@Service 放在一个类上，标识这个类提供一个服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设注解的值都为空的字符串即可</p>
<h3 id="1-5-3package-codec"><a href="#1-5-3package-codec" class="headerlink" title="1.5.3package-codec"></a>1.5.3package-codec</h3><p>存放的是编码器和解码器类，对请求包和发送包进行编码和解码工作（与序列化区分开，这里是我们自定义的传输协议的数据包，数据部分才是序列化的内容）</p>
<h4 id="传输协议（MRF）"><a href="#传输协议（MRF）" class="headerlink" title="传输协议（MRF）"></a>传输协议（MRF）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Magic Number</td>
<td>魔数，表识一个 MRF 协议包，0xCAFEBABE</td>
</tr>
<tr>
<td>Package Type</td>
<td>包类型，标明这是一个调用请求还是调用响应</td>
</tr>
<tr>
<td>Serializer Type</td>
<td>序列化器类型，标明这个包的数据的序列化方式</td>
</tr>
<tr>
<td>Data Length</td>
<td>数据字节的长度</td>
</tr>
<tr>
<td>Data Bytes</td>
<td>传输的对象，通常是一个<code>RpcRequest</code>或<code>RpcClient</code>对象，取决于<code>Package Type</code>字段，对象的序列化方式取决于<code>Serializer Type</code>字段。</td>
</tr>
</tbody></table>
<p><strong>CommonEncoder 类：</strong>将数据包转换成自定义协议的数据包，继承了MessageToByteEncoder，顾名思义就是将数据包转化成字节数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CommonDecoder 类：</strong>将字节数组解码成对象</p>
<p>通过魔数来判断是不是符合我们自定义协议的数据包，下面获取包的类型，获取数据部分使用的序列化器，通过相应的序列化器将数据部分按照对应的类型反序列化为相应的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4package-exception"><a href="#1-5-4package-exception" class="headerlink" title="1.5.4package-exception"></a>1.5.4package-exception</h3><p>自定义的一些异常信息（略）</p>
<h3 id="1-5-5package-handler"><a href="#1-5-5package-handler" class="headerlink" title="1.5.5package-handler"></a>1.5.5package-handler</h3><p><strong>RequestHandler 类：</strong>运行过程中，服务端调用 invoke 方法，通过方法名反射调用相应的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-6package-hook"><a href="#1-5-6package-hook" class="headerlink" title="1.5.6package-hook"></a>1.5.6package-hook</h3><p>由于我们的服务会一直存在于Nacos中（实际Nacos有超时机制，会过期删除），如果我们将服务端关闭后，但是服务名还存在于Nacos中，当客户端调用时就会出错，所以我们要在服务端关闭时，自动注销服务。</p>
<p>但是由于我们并不知道服务端何时关闭，这时我们就要使用钩子（钩子就是一个方法）。</p>
<p><strong>ShutdownHook 构子类：</strong></p>
<p><strong>addClearAllHook 方法：</strong>方法中有一句语句：**<code>Runtime.getRuntime().addShutdownHook();</code>**这个方法的意思就是在jvm中增加一个关闭的钩子，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。</p>
<p>在这里的意思就是在JVM关闭前，开启一个新线程调用钩子方法，来实现服务的自动注销。</p>
<blockquote>
<p>项目中我们是在服务器启动的时候就将钩子类的对象并调用 <code>addClearAllHook</code> 方法，将钩子注册到了 JVM中，在关闭时执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-7package-loadbalancer"><a href="#1-5-7package-loadbalancer" class="headerlink" title="1.5.7package-loadbalancer"></a>1.5.7package-loadbalancer</h3><p>实现负载均衡的接口和类</p>
<p>因为我们在Nacos获取服务提供者时可能不止一个，如果多个客户端总是访问一个服务端的话会造成服务端的压力过大，通过简单的算法可以实现均匀选择服务器，也就实现了服务器端的负载均衡。</p>
<p><strong>LoadBalancer 接口：</strong>只有一个方法，从获取到的服务器列表中选择一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现两个比较经典的算法：随机和转轮</p>
<p><strong>随机算法：</strong>顾名思义，就是随机选一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转轮算法：</strong>按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p>
<p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-8package-provider"><a href="#1-5-8package-provider" class="headerlink" title="1.5.8package-provider"></a>1.5.8package-provider</h3><p><strong>ServiceProvider 接口：</strong>保存和提供服务实例对象</p>
<p><strong>addServiceProvider 方法：</strong>将一个服务注册进注册表</p>
<p><strong>getServiceProvider 方法：</strong>根据服务名称获取服务实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceProviderImpl 实现类：</strong>每个服务提供者维护一个Map和一个Set</p>
<ul>
<li><strong>Map</strong> 来存放服务名称和服务实体的键值对</li>
<li><strong>Set</strong> 用来存放服务名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-9package-registry"><a href="#1-5-9package-registry" class="headerlink" title="1.5.9package-registry"></a>1.5.9package-registry</h3><p>主要是向 Nacos 注册服务，和从 Nacos 中获取服务的接口和实现类</p>
<p> <strong>ServiceRegistry 接口：</strong>服务注册中心通用接口，将服务名称和提供服务的地址注册进服务中心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceDiscovery 接口：</strong>根据服务名查找服务的提供者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceRegistry 实现类：</strong>实现了 ServiceRegistry 接口，服务注册功能的具体实现</p>
<p>基本就是调用NacosUtil工具类中的方法实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceDiscovery 实现类：</strong>实现了 ServiceDiscovery 接口，主要用于发现服务</p>
<p>这里调用 NacosUtil 工具类中的 getAllInstance 方法得到所有的服务实例，然后根据所选的负载均衡算法，找到一个实例并返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;找不到对应的服务: &quot;</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-10package-serializer"><a href="#1-5-10package-serializer" class="headerlink" title="1.5.10package-serializer"></a>1.5.10package-serializer</h3><p>序列化器的相关接口和类，本项目共引用了四个序列化器：Kryo、Json、Hessian、Protobuf</p>
<p><strong>CommonSerializer 接口：</strong>通用的序列化反序列化接口</p>
<p>主要是根据不同的序列化器所对应的编码来选择合适的序列化器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer KRYO_SERIALIZER = <span class="number">0</span>;</span><br><span class="line">    Integer JSON_SERIALIZER = <span class="number">1</span>;</span><br><span class="line">    Integer HESSIAN_SERIALIZER = <span class="number">2</span>;</span><br><span class="line">    Integer PROTOBUF_SERIALIZER = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Integer DEFAULT_SERIALIZER = KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KryoSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProtobufSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有就是序列化器的实现类，这里不做介绍，基本就是实现了序列化与反序列化的两个方法。主要是对常见序列化器作比较：</p>
<ul>
<li><p><strong>JDK自带的序列化方式：</strong></p>
<p><strong>优点：</strong>使用简单，只需实现 java.io.Serializable 接口即可。</p>
<blockquote>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一 致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成默认的序列化号</p>
</blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li>性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
</li>
<li><p><strong>JSON序列化方式：</strong></p>
<p><strong>优点：</strong>JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 xml，Json 比 xml更小、更快更容易解析。</p>
<p><strong>缺点：</strong>JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。（所以通常借助类的参数信息来反序列化）</p>
</li>
</ul>
<p>下面是基于字节的序列化方式</p>
<ul>
<li><p><strong>Kryo ：</strong>是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。</p>
<p>（Kryo解决了Json反序列化要借助类参数信息的问题，因为它在序列化的时候会记录对象的类型信息）</p>
</li>
<li><p><strong>Hessian ：</strong>是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、python、<a href>c++</a>,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效。速度较慢，序列化后的体积较大。</p>
</li>
<li><p><strong>protobuf（<a href>Proto</a>col Buffers）：</strong>是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p>
</li>
</ul>
<h1 id="2-项目相关问题"><a href="#2-项目相关问题" class="headerlink" title="2.项目相关问题"></a>2.项目相关问题</h1><h2 id="2-1RPC相关"><a href="#2-1RPC相关" class="headerlink" title="2.1RPC相关"></a>2.1RPC相关</h2><h3 id="2-1-1什么是RPC"><a href="#2-1-1什么是RPC" class="headerlink" title="2.1.1什么是RPC"></a>2.1.1什么是RPC</h3><p><strong>RPC（Remote Procedure Call）</strong>—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 <code>HTTP请求</code> 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p><strong>最终解决的问题：</strong><code>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单</code>。</p>
<h3 id="2-1-2RPC原理是什么"><a href="#2-1-2RPC原理是什么" class="headerlink" title="2.1.2RPC原理是什么"></a>2.1.2RPC原理是什么</h3><p>首先是服务提供者启动，并向注册中心注册服务，客户端通过 Nacos 提供的 API 发现服务，获取服务的地址，然后发送调用服务的请求，将请求数据序列化，通过自定义的通信协议封装成数据包，通过 Netty 框架发送消息，到达服务器之后拆包，取出数据部分，反序列化，调用本地服务获得处理结果，然后再将结果进行序列化，装包，再到客户端进行拆包，取数据，反序列化，获得请求的结果。而 RPC 框架的目标就是让客户端，也就是服务的调用者只能看到请求数据并接受结果的过程，将其它的过程封装起来。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\RPC1.png" style="zoom:100%;">

<p><strong>一次完整的RPC调用流程（同步调用，异步另说）如下：</strong></p>
<p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>
<p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p>
<p><strong>RPC实现的基本流程：</strong></p>
<p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p>
<h3 id="2-1-3常见的RPC框架"><a href="#2-1-3常见的RPC框架" class="headerlink" title="2.1.3常见的RPC框架"></a>2.1.3常见的RPC框架</h3><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、 Motan、gRPC这些。  如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p>
<ul>
<li><strong>Dubbo:</strong> Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。它提供了三大核心能力：<ol>
<li>面向接口的远程方法调用 </li>
<li>智能容错和负载均衡 </li>
<li>服务自动注册和发现。</li>
</ol>
</li>
<li><strong>Motan：</strong>motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</li>
<li><strong>gRPC：</strong>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf  序列化协议开发，并且支持众多开发语言。</li>
<li><strong>Hessian：</strong> Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 </li>
</ul>
<h3 id="2-1-4为什么要用RPC，不是HTTP"><a href="#2-1-4为什么要用RPC，不是HTTP" class="headerlink" title="2.1.4为什么要用RPC，不是HTTP"></a>2.1.4为什么要用RPC，不是HTTP</h3><p>首先需要指正，这两个并不是并行概念。RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p>
<p>使用 TCP 和使用 HTTP 各有优势：</p>
<p><strong>传输效率</strong>：</p>
<ul>
<li>TCP，通常自定义上层协议，可以让请求报文体积更小 </li>
<li>HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容 </li>
</ul>
<p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p>
<ul>
<li>TCP，可以基于各种序列化框架进行，效率比较高 </li>
<li>HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能 </li>
</ul>
<p><strong>跨平台</strong>：</p>
<ul>
<li>TCP：通常要求客户端和服务器为统一平台 </li>
<li>HTTP：可以在各种异构系统上运行 </li>
</ul>
<p><strong>总结</strong>：<br>  RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p>
<h2 id="2-2Java相关"><a href="#2-2Java相关" class="headerlink" title="2.2Java相关"></a>2.2Java相关</h2><h3 id="2-2-1动态代理与静态代理（客户端无感调用）"><a href="#2-2-1动态代理与静态代理（客户端无感调用）" class="headerlink" title="2.2.1动态代理与静态代理（客户端无感调用）"></a>2.2.1动态代理与静态代理（客户端无感调用）</h3><h4 id="明确静态代理和动态代理的区别："><a href="#明确静态代理和动态代理的区别：" class="headerlink" title="明确静态代理和动态代理的区别："></a>明确静态代理和动态代理的区别：</h4><ul>
<li><strong>静态代理：</strong>程序运行前，代理类的.class文件就已经存在了，也就是写死了代理对象；</li>
<li><strong>动态代理：</strong>在程序运行期间，运用反射机制动态创建需要代理的对象，也就是说要代理的对象是在运行期间确定的。</li>
</ul>
<p><strong>为什么要用动态代理？</strong></p>
<ol>
<li>由于静态代理中的代理类是针对某一个类去做代理的，那么假设一个系统中有100个Service，则需要创建100个代理类</li>
<li>如果一个Service中有很多方法需要事务（增强动作），发现代理对象的方法中还是有很多重复的代码</li>
</ol>
<p>由第一点和第二点可以得出：静态代理的重用性不强</p>
<h4 id="动态代理：JDK-动态代理和-CGlib-动态代理"><a href="#动态代理：JDK-动态代理和-CGlib-动态代理" class="headerlink" title="==动态代理：JDK 动态代理和 CGlib 动态代理=="></a>==动态代理：JDK 动态代理和 CGlib 动态代理==</h4><p><strong>二者区别：</strong>JDK动态代理产生的代理类和目标类实现了相同的接口；cglib动态代理产生的代理类是目标对象的子类。</p>
<p><strong>1. JDK动态代理</strong>：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 中的 invoke 方法来处理。</p>
<p><strong>动态代理步骤：</strong></p>
<ol>
<li>创建一个实现接口InvocationHandler的类作为拦截器，它必须实现invoke方法，让每个被代理类的方法执行时，都必须执行 invoke 方法体中的逻辑</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li>
<li>通过代理调用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;保存成功！&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransaction</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开启事务 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在动态代理在生成代理对象的时候需要一个拦截器 InvocationHandler 因此咱们需要写一个拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">//目标类</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//增强类</span></span><br><span class="line">	<span class="keyword">private</span> MyTransaction myTransaction;</span><br><span class="line">	<span class="comment">//构造函数注入目标类和增强类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PersonServiceInterceptor</span><span class="params">(Object target,MyTransaction myTransaction)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">		<span class="keyword">this</span>.myTransaction = myTransaction;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//代理类的每一个方法被调用的时候都会调用下边的这个invoke方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myTransaction.beginTransaction();</span><br><span class="line">		Object returnValue = method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">		<span class="keyword">this</span>.myTransaction.commit();</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、当客户端执行代理对象.方法时，进入到了拦截器的invoke方法体</p>
<p>2、拦截器中invoke方法体的内容就是代理对象方法体的内容</p>
<p>3、拦截器中invoke方法的method参数是在调用的时候赋值的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object target = <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">		MyTransaction myTransaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line">		PersonServiceInterceptor interceptor = <span class="keyword">new</span> PersonServiceInterceptor(target, myTransaction);</span><br><span class="line">		PersonService personService = (PersonService)Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),interceptor);</span><br><span class="line">		String returnValue = (String)personService.savePerson();</span><br><span class="line">		System.out.println(returnValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>2.CGlib动态代理</strong>：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。（没看懂）==</p>
<h3 id="2-2-2序列化"><a href="#2-2-2序列化" class="headerlink" title="2.2.2序列化"></a>2.2.2序列化</h3><p>上面有</p>
<h2 id="2-3Netty相关"><a href="#2-3Netty相关" class="headerlink" title="2.3Netty相关"></a>2.3Netty相关</h2><h3 id="2-3-1Netty-是什么"><a href="#2-3-1Netty-是什么" class="headerlink" title="2.3.1Netty 是什么"></a>2.3.1Netty 是什么</h3><ol>
<li>Netty 本质是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好。</li>
<li><strong>支持多种应用层协议</strong>，如 FTP，SMTP，HTTP 以及自定义协议。</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h3 id="2-3-2特点和优势"><a href="#2-3-2特点和优势" class="headerlink" title="2.3.2特点和优势"></a>2.3.2特点和优势</h3><p>因为 Netty 具有下面这些优点，并且相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。</p>
<ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。 （支持多种应用层协议）</li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li>
</ul>
<h3 id="2-3-3为什么-Netty-性能高"><a href="#2-3-3为什么-Netty-性能高" class="headerlink" title="2.3.3为什么 Netty 性能高"></a>2.3.3为什么 Netty 性能高</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h3 id="2-3-4BIO、NIO和AIO"><a href="#2-3-4BIO、NIO和AIO" class="headerlink" title="2.3.4BIO、NIO和AIO"></a>2.3.4BIO、NIO和AIO</h3><p><strong>I/O 模型简单的理解：</strong>用什么样的通道将数据发送给对方，I/O 模型在很大程度上决定了框架的性能。Java 共支持 3 种网络编程模型/IO模式：  BIO、NIO 或者 AIO。</p>
<h4 id="BIO模型介绍"><a href="#BIO模型介绍" class="headerlink" title="BIO模型介绍"></a>BIO模型介绍</h4><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个 ServerSocket，然后在客户端启动 Socket 来对服务端进行通信。由于 ServerSocket 的 accept() 方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>这种方式下有一个问题：每个请求都需要独立的线程完成数据 read，业务处理，数据 write 的完整操作。 如下图所示：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\BIO.png" style="zoom:80%;">

<p><strong>问题：</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p>
<p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p>
<h4 id="NIO模型介绍"><a href="#NIO模型介绍" class="headerlink" title="NIO模型介绍"></a>NIO模型介绍</h4><p>NIO 基于 Reactor（事件驱动思想），当 Socket 有流可读或可写入 Socket 时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>BIO 与 NIO 一个比较重要的不同：<strong>我们使用 BIO 的时候往往会引入多线程，每个连接一个单独的线程；而 NIO 则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong>通俗一点的理解就是，NIO 能够做到用一个线程来处理多个操作，假设有 10000 个请求过来，根据实际情况，可以分配 50 或者 100 个线程来处理。不像 BIO 那样，非得分配 10000 个。这样就大大节省了资源的开销。</p>
<p>NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\NIO.png" style="zoom:80%;">

<p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p>
<p><strong>NIO 中一个重要的组件：Selector</strong></p>
<p><strong>Selector</strong>  能够检测多个注册的通道上是否有事件发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\Selector.png" alt="image-20210614102612508" style="zoom: 110%;">

<h4 id="AIO模型介绍"><a href="#AIO模型介绍" class="headerlink" title="AIO模型介绍"></a>AIO模型介绍</h4><p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为， read 或 write 方法都是异步的，完成后会主动调用回调函数。 </p>
<p>相比于 NIO，AIO 才是完全的异步 IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p>
<h4 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h4><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p>
<p>伪异步 IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p>
<p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，[客户端]的 I/O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>但是由于使用同步非阻塞的 I/O 模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p>
<h3 id="2-3-5Netty的线程模型"><a href="#2-3-5Netty的线程模型" class="headerlink" title="2.3.5Netty的线程模型"></a>2.3.5Netty的线程模型</h3><p>Netty 通过 Reactor 模型基于多路复用器（Selector）接收并处理用户请求。我们实现服务端的时候，一般会初始化两个线程组：</p>
<ol>
<li><strong><code>bossGroup</code></strong> :接收连接。</li>
<li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li>
</ol>
<p>其它的线程模型：</p>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a><strong>单线程模型</strong></h4><p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件，即多路复用、事件分发和处理都是在一个Reactor 线程上完成的。一个NIO 线程同时处理成百上千的链路，对于高负载、高并发，并且对性能要求比较高的场景不适用。</p>
<p>对应到 Netty 代码是下面这样的</p>
<blockquote>
<p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a><strong>多线程模型</strong></h4><p>一个 NIO 线程（Acceptor ）线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p>
<p>对应到 Netty 代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;">

<h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;">

<h3 id="2-3-6解决-TCP-的粘包拆包问题"><a href="#2-3-6解决-TCP-的粘包拆包问题" class="headerlink" title="2.3.6解决 TCP 的粘包拆包问题"></a>2.3.6解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p>
<p><strong>TCP 粘包/分包的原因：</strong>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为<strong>面向流的通信是无消息保护边界</strong>的。由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题，看一张图：</p>
<p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source_posts\2021-05-13-（八）RPC项目总结\TCP粘包.png" alt="image-20210615223634724"></p>
<p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2 ，没有粘包和拆包。</li>
<li>服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为<strong>TCP粘包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容；</li>
<li>服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包，这称之为<strong>TCP拆包</strong>。</li>
</ol>
<p><strong>解决方式：</strong></p>
<p>关键就是要解决<strong>服务器端每次读取数据长度的问题</strong>, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 TCP 粘包、拆包 。</p>
<p>1.Netty 自带解决方式：</p>
<ul>
<li>消息定长：FixedLengthFrameDecoder 类，固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。</li>
<li>包尾增加特殊字符分割：<ul>
<li>行分隔符类：LineBasedFrameDecoder ，<code>LineBasedFrameDecoder</code> 的工作原理是它依次遍历 <code>ByteBuf</code> 中的可读字节，判断是否有换行符，然后进行相应的截取。</li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder ，**<code>LineBasedFrameDecoder</code>** 实际上是一种特殊的 <code>DelimiterBasedFrameDecoder</code> 解码器。</li>
</ul>
</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<p>2.自定义序列化编解码器：</p>
<p>自定义协议，其中有字段标明包长度。</p>
<h3 id="2-3-7Netty长连接、心跳机制"><a href="#2-3-7Netty长连接、心跳机制" class="headerlink" title="2.3.7Netty长连接、心跳机制"></a>2.3.7Netty长连接、心跳机制</h3><h4 id="Netty长连接与短连接"><a href="#Netty长连接与短连接" class="headerlink" title="Netty长连接与短连接"></a>Netty长连接与短连接</h4><p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p>
<p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p>
<p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p>
<h4 id="Netty中的心跳机制"><a href="#Netty中的心跳机制" class="headerlink" title="Netty中的心跳机制"></a>Netty中的心跳机制</h4><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 <strong>心跳机制</strong> 。</p>
<p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p>
<p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<code>SO_KEEPALIVE</code>。<code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 keepAlive 设置。</p>
<p>但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 <code>IdleStateHandler</code> 。</p>
<p><code>IdleStateHandler</code> 的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,TimeUnit unit)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第三个参数是全能型参数，隔多久检查读写事件；</p>
<p>第四个参数表示当前的时间单位。</p>
<p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>
<p><strong>项目中的使用：</strong></p>
<p>通过服务器端的空闲检测，也就是服务器端每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可。</p>
<p>在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p>
<p>所以我们需要在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包。</p>
<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">             .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure>

<p>当客户端超过 5 秒没有写事件时，也就是 <code>write</code> 方法超过给定时间没被调用时，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p>
<p>方法逻辑主要就是看是否超过了 <strong>写空闲超时时间设定</strong> ，如果是就获取Channel创建一个心跳包并发送给服务器端。（这里主要是通过ctx中的事件是否为IdleStateEvent事件，再通过事件的状态来实现定时发送）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">            RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">            rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure>

<p>当服务端超过 30 秒没有读到数据时，表示连接假死，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p>
<p>方法逻辑主要就是看是否超过了 <strong>读空闲超时时间设定</strong> ，如果是就判定客户端为假死状态，断开连接，不是的话不予响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==这里其实还有一个提升，就是双方都开始读写超时参数，这样两边假死状态都能判定。==</p>
<h3 id="2-3-8Netty-的零拷贝"><a href="#2-3-8Netty-的零拷贝" class="headerlink" title="2.3.8Netty 的零拷贝"></a>2.3.8Netty 的零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>内部工作流程：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝1.png" alt="image-20210526152344320" style="zoom:80%;">

<ol>
<li><p>Java 本身不具有 IO 读写能力，因此在 read 方法调用后，要从<strong>用户态切换至内核态</strong>，去调用系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程会被阻塞，操作系统使用 <strong>DMA</strong> 来实现文件读，也不会使用 CPU；</p>
<blockquote>
<p>DMA 是在磁盘和内核缓冲区之间建立起一个通道，可以<strong>解放 CPU 直接进行数据交换</strong></p>
</blockquote>
</li>
<li><p><strong>内核态切换回用户态</strong>，将数据从内核缓冲区读入用户缓冲区，这期间 CPU 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时<strong>将数据从用户缓冲区，写入 Socket 缓冲区</strong>，CPU 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这时 Java 同样不具备写的能力，因此<strong>又得从用户态切换至内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡。</p>
</li>
</ol>
<p>可以看到这个过程中，Java 并不具备物理设备级别的读写能力，而是缓存的复制，底层的真正读写是由操作系统完成的：</p>
<ol>
<li>用户态与内核态切换发生了3次</li>
<li>数据拷贝发生了4次</li>
</ol>
<h4 id="NIO优化（mmap）"><a href="#NIO优化（mmap）" class="headerlink" title="NIO优化（mmap）"></a>NIO优化（mmap）</h4><p>通过 DirectByteBuf ：使用的是操作系统内存（而且这块内存 Java 和操作系统都能访问）</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝2.png" alt="image-20210526154313921" style="zoom:80%;">

<p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuf 将堆外内存（系统内存）映射到 jvm 内存中来直接访问使用，省去了这一步的拷贝工作。</strong></p>
<ol>
<li><p>这块内存不受 jvm 垃圾回收机制影响，因此内存地址固定，有助于 IO 读写</p>
</li>
<li><p>Java 中的 DirectByteBuf 对象仅维护了该内存的虚引用，内存回收分为两部分：</p>
<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门的线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li><p>减少了一次数据拷贝，但是由于还是有 Java 参与数据拷贝，没有减少用户态与内核态的切换次数</p>
</li>
</ol>
<h4 id="进一步优化（Linux2-1、sendFile）"><a href="#进一步优化（Linux2-1、sendFile）" class="headerlink" title="进一步优化（Linux2.1、sendFile）"></a>进一步优化（Linux2.1、sendFile）</h4><p>在上面的优化中，都需要通过 Java 提供一个 xxByte 来作为媒介，将数据从操作系统的内核缓冲区复制到 socket 缓冲区，也就是需要 Java 参与的，这样就多了两次用户态与内核态的切换。</p>
<p>（底层采用了Linux 2.1 后提供的 sendFile 方法），Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝3.png" alt="image-20210526160129569" style="zoom:80%;">

<ol>
<li>Java 调用 transferTo 方法后，要从 Java程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入内核缓冲区，不会使用 CPU</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ol>
<p>可以看到：</p>
<ul>
<li><p>只发生了一次用户态与内核态的切换（不需要 Java 参与）</p>
</li>
<li><p>数据拷贝了 3 次</p>
</li>
</ul>
<h4 id="进一步优化（Linux2-4，sendFile-优化）"><a href="#进一步优化（Linux2-4，sendFile-优化）" class="headerlink" title="进一步优化（Linux2.4，sendFile 优化）"></a>进一步优化（Linux2.4，sendFile 优化）</h4><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝4.png" alt="image-20210526161411076" style="zoom:80%;">

<ol>
<li>Java调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>只会将一些 offset 和 length 信息拷贝到 Socket 缓存</li>
<li>也就是使用 DMA 将内核缓冲区的数据写入网卡，不会使用 CPU</li>
</ol>
<p>整个过程只发生了一次用户态与内核态的切换，数据拷贝了两次。所谓的<strong>零拷贝</strong>，不是不需要拷贝，而是不会拷贝重复数据到 JVM 内存中。零拷贝的优势有：</p>
<ol>
<li>更少的用户态和内核态的切换</li>
<li>不利用 CPU 计算</li>
<li>零拷贝适合小文件传输（因为太大了会占满缓存，影响其它文件的传输）</li>
</ol>
<h4 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h4><blockquote>
<p>1.传统的 IO 就有使用 DMA 的方式优化了  </p>
<p>2.传统零拷贝的概念是数据buffer不用再复制到用户空间，但是从内核缓存复制到 socket  buffer，但还是有一次多余的复制（因此需要 CPU 参与复制），于是出现了优化后的零拷贝，去掉在内核中那次多余的复制。 </p>
<p>3.<strong>netty 使用了优化后的零拷贝的 IO 方式，但是 netty 特性中的零拷贝主要是指复制方式与一般复制方式不同</strong>，因此API也不同了。netty 可以将多个ByteBuf 直接组装成一个 Netty ByteBuf，不用自己一个个添加到 buffer 里，还可以不需要拷贝地将一个 buffer 分割成多个小的 buffer 并且提供了更灵活的操作 buffer 的 API。</p>
</blockquote>
<p><strong>体现一：slice</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝5.png" alt="image-20210526162556972" style="zoom:80%;">

<p>对原始的 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原来的 ByteBuf 的内存，只是切片后的 ByteBuf 维护独立的 read 和 write 指针。（也就是通过索引访问原来的 ByteBuf ，并没有申请新的内存来存放分片的 ByteBuf）</p>
<p><strong>体现二：duplicate</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝6.png" alt="image-20210526171439539" style="zoom:80%;">

<p>与 slice 不同，这个是拷贝了原始 ByteBuf 的所有内容，也是与原始的 ByteBuf 使用同一块内存，只是读写指针是独立的。</p>
<p><strong>体现三：composite</strong></p>
<p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。（我认为传统的方式是申请一块更大的内存来存放多个小的 Buffer）</p>
<h3 id="2-3-9核心组件"><a href="#2-3-9核心组件" class="headerlink" title="2.3.9核心组件"></a>2.3.9核心组件</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等</p>
<p>比较常用的<code>Channel</code>接口实现类（或者说Channel类型）是：</p>
<ul>
<li><code>NioServerSocketChannel</code>（异步的服务器端 TCP Socket 连接）</li>
<li><code>NioSocketChannel</code>（异步的客户端 TCP Socket 连接）</li>
</ul>
<p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty 所有的 I/O 操作都为异步的。因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p>
<h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p><code>ChannelHandler</code> 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p>
<p><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler用于处理入站I / O事件，对从客户端发往服务器的报文进行处理，一般用来执行解码、读取客户端数据、进行业务处理等</li>
<li>ChannelOutboundHandler用于处理出站I / O操作，对从服务器发往客户端的报文进行处理，一般用来进行编码、发送报文到客户端</li>
</ul>
<p><strong>执行顺序：</strong> <strong>ChannelInboundHandler按照注册的先后顺序执行；ChannelOutboundHandler按照注册的先后顺序逆序执行</strong></p>
<blockquote>
<p><strong>附：ChannelHandler的类继承体系</strong></p>
</blockquote>
<p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source_posts\2021-05-13-（八）RPC项目总结\ChannelHandler.png"></p>
<p>下面一一对上述类做一个简单的介绍：</p>
<ul>
<li><p><strong>ChannelHandler</strong><br>Netty Channel事件的基础接口，只定义与 Handler 的管理接口相关，具体如下：</p>
<ol>
<li>void handlerAdded(ChannelHandlerContext ctx)<br> 在调用 DefaultChannelPipeline 的 addLast(add) 将事件监听器添加到事件处理链条时调用。</li>
<li>void handlerRemoved(ChannelHandlerContext ctx)<br> 在调用DefaultChannelPipeline 的 addLast(add) 发生异常时被调用；当通道关闭后，通道取消注册后，同时会触发通道移除事件，具体调用入口：DefaultChannelPipeline 的内部类 HeadContext 的 channelUnregistered。</li>
</ol>
</li>
<li><p><strong>ChannelInboundHandler</strong><br>入端类型的事件处理器。</p>
<ol>
<li><p>void channelRegistered(ChannelHandlerContext ctx)<br>通道注册到 Selector 时触发。客户端在调用 connect 方法，通过 TCP 建立连接后，获取 SocketChannel 后将该通道注册在 Selector 时或服务端在调用bind 方法后创建 ServerSocketChannel，通过将通道注册到 Selector 时监听客户端连接上时被调用。</p>
</li>
<li><p>void channelUnregistered(ChannelHandlerContext ctx)<br>通道取消注册到Selector时被调用，通常在通道关闭时触发，首先触发channelInactive 事件，然后再触发 channelUnregistered 事件。</p>
</li>
<li><p>void channelActive(ChannelHandlerContext ctx)<br>通道处于激活的事件，在 Netty 中，处于激活状态表示底层 Socket 的isOpen() 方法与 isConnected() 方法返回 true。</p>
</li>
<li><p>void channelInactive(ChannelHandlerContext ctx)<br>通道处于非激活（关闭），调用了 close 方法时，会触发该事件，然后触发channelUnregistered 事件。</p>
</li>
<li><p>void channelRead(ChannelHandlerContext ctx, Object msg)<br>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，将读取的字节通过事件链进行处理，NIO 的触发入口为AbstractNioByteChannel 的内部类 NioByteUnsafe 的 read 方法。</p>
</li>
<li><p>void channelReadComplete(ChannelHandlerContext ctx)<br>处理完一次通道读事件后触发，在 Netty 中一次读事件处理中，会多次调用SocketChannel 的 read方法。触发入口为AbstractNioByteChannel 的内部类NioByteUnsafe 的 read 方法。</p>
</li>
<li><p>void userEventTriggered(ChannelHandlerContext ctx, Object evt)<br>触发用户自定义的事件，目前只定义了ChannelInputShutdownEvent（如果允许半关闭（输入端关闭而服务端不关闭））事件。</p>
</li>
<li><p>void channelWritabilityChanged(ChannelHandlerContext ctx)<br>Netty 写缓存区可写状态变更事件（可写–》不可写、不可写–》可写），入口消息发送缓存区ChannelOutboundBuffer。</p>
</li>
<li><p>void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)<br>异常事件。</p>
</li>
</ol>
</li>
<li><p><strong>ChannelOutboundHandler</strong><br> 出端类型的事件处理器。</p>
<ol>
<li>void bind(ChannelHandlerContext ctx, SocketAddress add, ChannelPromise p)<br>调用ServerBootstrap 的 bind 方法的处理逻辑。绑定操作，服务端在启动时调用bind方法时触发（手动调用bind）。</li>
<li>void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, ChannelPromise promise)<br>连接操作，客户端启动时调用connect方法时触发（手动调用connect）。</li>
<li>void disconnect(ChannelHandlerContext ctx, ChannelPromise promise)<br>断开连接操作（手动调用disconnect）</li>
<li>void close(ChannelHandlerContext ctx, ChannelPromise promise)<br>关闭通道，手动调用Channel#close方法时触发。(手动调用close)</li>
<li>void deregister(ChannelHandlerContext ctx, ChannelPromise promise)<br>调用Channel#deregister时触发。（手动调用deregister)。</li>
<li>void read(ChannelHandlerContext ctx) throws Exception<br>注册读事件，并不是触发网络读写事件。</li>
<li>void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception<br>调用调用 Channel 的 write(底层 SocketChannel 的 write)时触发。</li>
<li>void flush(ChannelHandlerContext ctx)<br>调用调用Channel#flush(SocketChannel#flush)时触发。</li>
</ol>
</li>
<li><p><strong>ChannelDuplexHandler</strong><br>双向 Handler，包含 Inbound 和 outbound 事件。 </p>
</li>
<li><p><strong>ByteToMessageDecoder</strong><br>解码器：字节流解码成一条一条的消息(Message、协议对象)。</p>
</li>
<li><p><strong>MessageToByteEncoder</strong><br>编码器：消息（协议对象）编码成二进制字节流。</p>
</li>
<li><p><strong>AbstractTrafficShapingHandler</strong><br>流量整形，将在后续章节中详细介绍。</p>
</li>
</ul>
<p>上述详细的介绍了NettyChannel的类继承体系，并重点介绍了ChannelInboundHandler 与 ChannelOutboundHandler 每个方法的含义已经触发时机，接下来再谈一点我对这两个 Handler 的一些理解。</p>
<p><strong>ChannelInboundHandler：</strong>入端操作，可以看出基本上是都是由事件选择器(NIO Selector事件就绪选择)进行触发,事件名称以 channel 开头，例如channelRead。</p>
<p><strong>ChannelOutboundHanlder：</strong>出端操作，其触发点除了 read 事件外都是通过调用api(例如bind、connect、close、write)。</p>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。</p>
<p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\ChannelPipeline.png" style="zoom:80%;">

<p>在 <code>Netty</code> 整个框架里面，一条连接对应着一个 <code>Channel</code>，这条 <code>Channel</code> 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面，<code>ChannelPipeline</code> 是一个双向链表结构，他和 <code>Channel</code> 之间是一对一的关系。</p>
<p><code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 <code>Channel</code> 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。入站事件和出站事件在一个双向链表中，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code> ，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code> ，两种类型的 <code>handler</code> 互不干扰。</p>
<h3 id="2-3-10其它组件"><a href="#2-3-10其它组件" class="headerlink" title="2.3.10其它组件"></a>2.3.10其它组件</h3><h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>上下文对象：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象，比如：管道 pipeline、通道 channel、地址等相关信息。换句话说，只要我们在定义 Handler 时，只要我们想拿数据就从 ChannelHandlerContext 中获取，也可以通过提供的方法将数据处理完写入到 ChannelHandlerContext 中的管道 Channel 中去。</p>
<h4 id="EventloopGroup"><a href="#EventloopGroup" class="headerlink" title="EventloopGroup"></a>EventloopGroup</h4><p>下图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\EventloopGroup.png" style="zoom:80%;">

<p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>bossGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>workerGroup</code> 来处理，然后 <code>workerGroup</code> 负责处理其 IO 相关操作。</p>
<p><code>EventLoopGroup</code> 为 <code>Netty</code> 线程池，它实际上就是 <code>EventLoop</code> 的数组容器。<code>EventLoop</code> 的职责是处理所有注册到本线程多路复用器 <code>Selector</code> 上的 <code>Channel</code>，<code>Selector</code> 的轮询操作由绑定的 <code>EventLoop</code> 线程 <code>run</code> 方法驱动，在一个循环体内循环执行。通俗点讲就是一个死循环，不断的检测 I/O 事件、处理 I/O 事件。</p>
<h4 id="Bootstrap-和-ServerBootstrap"><a href="#Bootstrap-和-ServerBootstrap" class="headerlink" title="Bootstrap 和 ServerBootstrap"></a>Bootstrap 和 ServerBootstrap</h4><p><strong>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件</strong></p>
<p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrap</code> 客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li>
</ol>
<h4 id="EventLoopGroup-默认的构造函数会起多少线程"><a href="#EventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="EventLoopGroup 默认的构造函数会起多少线程"></a>EventLoopGroup 默认的构造函数会起多少线程</h4><p>回顾我们在上面写的服务器端的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 <strong><code>CPU核心数*2</code>**。</strong>（两倍的CPU数目）**</p>
<p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p>
<h3 id="2-3-11Netty执行全过程"><a href="#2-3-11Netty执行全过程" class="headerlink" title="2.3.11Netty执行全过程"></a>2.3.11Netty执行全过程</h3><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\Netty执行全过程.png" style="zoom:80%;">

<ol>
<li><p>ServerBootStrap作为Netty的服务端入口，会对BossGroup和WorkGroup进行相关初始化操作，在BossGroup中，主要是对客户端的新连接请求进行处理（即OP_ACCEPT事件，但其实OP_ACCEPT事件的具体处理也会涉及到读写事件，因为数据不是读就是写），在WorkGroup中，则负责处理IO读写、编解码、业务逻辑等（即OP_READ事件、OP_WRITE事件）。服务端启动的时候会绑定一个端口，作为后续客户端连接入口，绑定端口的时候会在BossGroup(由NioEventLoopGroup类创建的对象）的其中一个NioEventLoop的Selector（多路复用器）上注册一条NioServerSocketChannel通道，后面的连接处理就是在通道中进行的。</p>
</li>
<li><p>BootStrap则作为Netty的客户端入口，会对ClientGroup进行相关初始化操作，在ClientGroup中，第一就是创建与服务端的连接（即OP_CONNECT事件），第二就是进行IO读写、编解码、业务逻辑等操作（即OP_READ事件、OP_WRITE事件）。</p>
</li>
<li><p>服务端和客户端启动之后，当服务端收到客户端发来的连接请求，由于属于OP_ACCEPT事件，在BossGroup中处理。BossGroup(由NioEventLoopGroup类创建的对象）管理着若干个NioEventLoop，每个NioEventLoop持有一个线程（就好比线程池中的一组线程并发处理若干个连接请求），每个NioEventLoop上会创建一个Selector，一个Selector上可以注册多个通道（所以叫多路复用器），且它会以不断轮询的方式同时监听每个通道上是否有IO事件发生，每个通道里都会有个ChannelPipeline管道，管道里全是Handler，包括管道头Head和管道尾Tail，以及进行IO读写、编解码，业务处理的若干个Handler，Handler也可以自定义，把需要的Handler注册进管道就可以执行了。当请求到达Head时，代表“请求数据”已准备好，OP_ACCEPT事件已就绪，Selector监听到事件已就绪，就会让持有的线程对事件进行处理，处理过程是在Handler中进行。首先会创建一个NioSocketChannel实例，然后交给ServerBootStrapAcceptor这个Handler，它是Netty底层代码注册的，Acceptor具体操作就是向WorkGroup中的某个Selector注册刚才创建好的NioSocketChannel，自此客户端连接请求处理结束。</p>
</li>
<li><p>客户端发出连接请求的同时会自己创建一条NioSocketChannel通道与服务端NioSocketChannel进行互通，连接完之后就是WorkGroup的事了，不需要BossGroup管了，一个客户端连接对应一条服务端NioSocketChannel。比如现在客户端要进行一个远程方法的调用，将方法参数传给服务端后，服务端处理完将结果返回给客户端。首先请求从客户端通道传输到WorkGroup中的对应通道，然后Head会申请一块堆外内存来缓冲请求内容，缓冲完之后，代表数据已准备好，OP_READ事件已就绪，selector监听到就绪事件之后，让持有的线程对事件进行处理，这里我定义了Decode解码，Compute方法调用处理和Encode编码三个Handler进行操作，其中Inbound入站Handler包括Decode和Compute（从Head到Tail就是入站），Outbound出站Handler包括Encode（从Tail到Head就是出站），每一个Handler被注册到Pipeline中的时候都会创建一个与之对应的ChannelHandlerContext，它包含着Handler的上下文信息，主要负责管理和其他在同一管道里的Handler之间的交互，它有一个前指针和后指针，可以与其他ChannelHandlerContext关联，这样Handler处理就变得更加灵活，比如这次请求需要三个Handler，而下次请求只涉及到Decode和Encode，那下次就可以执行完Decode然后指针直接指向Encode，next指针具体指向谁是依靠ChannelHandlerContext中的数据类型与其他Handler类型进行匹配得出的。在处理完读事件之后，接着处理Handler中涉及到的写事件，将处理结果写到ByteBuf中，回到Head，执行flush操作将ByteBuf内容写到SocketBuffer中，然后再到网卡buffer，通过互联网把结果传回给客户端，客户端拿到结果之后同样要进行解码，反序列化等操作，那么回过头发现客户端在发送调用请求之前在Pipeline中也进行了Encode处理的。（Head的主要作用：从SocketBuffer读请求内容到ByteBuf，从ByteBuf写返回结果到SocketBuffer）</p>
</li>
<li><p>假设又有另外一个客户端连接了服务端，且和之前那个NioSocketChannel注册到了同一个Selector上，当线程正在处理另一个通道上的事件的时候，这时该客户端也发起了一个处理请求，请求到达服务端通道之后会被Head读到堆外内存中缓冲着，此时OP_READ事件已就绪，Selector监听到了就绪事件，但由于线程正在处理另外一个通道上的事件，所以就要等当前通道的事件处理完，下一轮循环监听再处理了（这也是堆外内存的作用体现之一，数据可以先在缓冲区放着）。当两个通道被注册在不同的Selector上的时候就互不影响了，因为是在不同的线程中并行处理的。另外补充两点，第一个TaskQueue任务队列中的任务都是非IO任务，从性能上来考虑，千万不要将一个需要长时间来运行的任务放入到任务队列中，因为事件任务在一个线程中是串行执行的，这样会阻塞其他任务。解决方案是使用一个专门的EventExecutor来执行它（ChannelPipeline提供了带有EventExecutorGroup参数的addXXX()方法，该方法可以将传入的ChannelHandler绑定到你传入的EventExecutor之中），这样它就会在另一条线程中执行，与其他任务隔离。第二个Channel注册到Selector后返回的是一个SelectionKey，这个SelectionKey有以下几个重要属性：</p>
<ul>
<li>interest set，通道感兴趣的事件集，就是会把该通道可能执行的事件类型都告诉Selector</li>
<li>ready set，感兴趣的事件集中的“就绪事件集”</li>
<li>保存着的Channel</li>
<li>保存着的Selector</li>
</ul>
</li>
</ol>
<p>IO事件类型：</p>
<ul>
<li>SelectionKey.OP_READ </li>
<li>SelectionKey.OP_WRITE </li>
<li>SelectionKey.OP_ACCEPT </li>
<li>SelectionKey.OP_CONNECT </li>
</ul>
<p>因此Selector每次循环监听的其实就是SelectionKey中的就绪事件集，看是否存在已就绪的事件，存在就进行处理。SelectionKey相当于是Selector和Channel之间的桥梁。</p>
<h3 id="2-3-12从-BIO-演进到-NIO，再到-Netty"><a href="#2-3-12从-BIO-演进到-NIO，再到-Netty" class="headerlink" title="2.3.12从 BIO 演进到 NIO，再到 Netty"></a>2.3.12从 BIO 演进到 NIO，再到 Netty</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO 是阻塞 IO ，也称之为传统 IO ，在 Java 的网络编程中，指的就是 ServerSocket、Socket 套接字实现的网络通信，这也是我们最开始学 Java 时接触到的网络编程相关的类。<strong>服务端在有新连接接入时或者在读取网络消息时，它会对主线程进行阻塞</strong>。下面是通过 BIO 来实现上面场景的代码。</p>
<p><strong>服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            InputStream inputStream = accept.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="comment">// read()方法是一个阻塞方法，当没有数据可读时，线程会一直阻塞在read()方法上</span></span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端的代码中，创建了一个 ServerSocket 套接字，并绑定端口 8080 ，然后在 while 死循环中，调用 ServerSocket 的 accept() 方法，让其不停的接收客户端连接。accept() 方法是一个阻塞方法，当没有客户端来连接时，main 线程会一直阻塞在 accept() 方法上（现象：程序一直停在 accept() 方法这一行，不往下执行）。当有客户端连接时，main 线程解阻塞，程序继续向下运行。接着调用 read() 方法来从客户端读取数据，read() 方法也是一个阻塞方法，如果客户端发送来数据，则 read() 能读取到数据；如果没有数据可读，那么 main 线程就又会一直停留在 read() 方法这一行。</p>
<p>这里使用了两个 while 循环，外层的 while 循环是为了保证能不停的接收连接，内层的 while 循环是为了保证不停的从客户端中读取数据。</p>
<p><strong>客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 采用具有定时执行任务的线程池，来模拟客户端每隔一段时间来向服务端发送消息</span></span><br><span class="line">        <span class="comment">// 这里是每隔3秒钟向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="comment">// 向服务端发送消息（消息内容为：客户端的ip+端口+Hello World，示例：/127.0.0.1:999999 Hello World）</span></span><br><span class="line">                String message = socket.getLocalSocketAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                outputStream.write(message.getBytes());</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端的代码中，创建了一个 Socket 套接字，并指定要连接的服务器地址和端口号。然后通过使用一个具有定时执行任务功能的线程池，让客户端每隔3秒钟向服务端发送一条数据。</p>
<p>然后我们分别启动服务端和一个客户端，从服务端的控制台就可以看到，每个3秒钟就会打印一行 <code>客户端的ip+端口+Hello World</code>的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br></pre></td></tr></table></figure>

<p>为了模拟多个客户端的接入，然后我们再启动一个客户端，这个时候我们期待在服务端的控制台，会打印出两个客户端的<code>ip+端口+Hello World</code>，由于服务端和两个客户端都是在同一台机器上，因此这个时候打印出来的两个客户端的ip是相同的，但是端口口应该是不一样的。我们期望的日志输出应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure>

<p>然而，这只是我们期望的，实际现象，并非如此，当我们再启动一个客户端后，发现控制台始终只会出现一个客户端的端口号，并非两个。</p>
<p>那么为什么呢？原因就在于服务端的代码中，read() 方法是一个阻塞方法，当第一个客户端连接后，读取完第一个客户端的数据，由于第一个客户端一直不释放连接，因此服务端也不知道它还有没有数据要发送过来，这个时候服务端的 main 线程就一直等在 read() 方法处，当有第二个客户端接入时，由于 main 线程一直阻塞在 read() 方法处，因此它无法执行到 accept() 方法来处理新的连接，所以此时我们看到的现象就是，只会打印一个客户端发送来的消息。</p>
<p>那么我们该怎么办呢？既然知道了问题出现 main 线程阻塞在 read() 方法处，也就是在读数据的时候出现了阻塞。而要解决阻塞的问题，最直接的方式就是利用多线程技术了，因此我们就在读数据的时候新开启一条线程来进行数据的读取。升级之后的服务端代码如下。</p>
<p><strong>服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServerV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">          Socket accept = serverSocket.accept();</span><br><span class="line">           <span class="comment">// 用另外一个线程来读写数据</span></span><br><span class="line">            handleMessage(accept);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新创建一个线程来读取数据</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的代码不变，依然使用 BioClient 。在服务端的代码 BioServerV2 中，读数据的操作我们提取到了 handleMessage() 方法中进行处理，在该方法中，会新创建一个线程来读取数据，这样就不会造成main线程阻塞在 read() 方法上了。启动服务端和两个客户端进行验证。控制台打印结果如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure>

<p>虽然解决了多个客户端同时接入的问题，但是其中的缺点我们也很容易发现：<strong>每当有一个新的客户端来连接服务端时，我们都需要为这个客户端创建一个线程来处理读数据的操作，当并发度很高时，我们就需要创建很多的线程，这显然这是不可取的。</strong>线程是服务器的宝贵资源，创建和销毁都需要花费很长时间，当线程过多时，CPU 的上线文切换也更加频繁，这样就会造成服务响应缓慢。当线程过多时，甚至还会出现句柄溢出、OOM 等异常，最终导致服务宕机。另外，我们在读取数据时，是基于 IO 流来读取数据的，每次只能读取一个或者多个字节，性能较差。</p>
<p>因此BIO的服务端，适用于并发度不高的应用场景，但是对于高并发，服务负载较重的场景，使用 BIO 显然是不适合的。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>为了解决 BIO 无法应对高并发的问题，JDK 从1.4开始，提供了一种新的网络 IO，即 NIO，通常称它为非阻塞 IO。然而 NIO 的代码极为复杂和难懂，下面简单介绍写 NIO 中的组件。</p>
<p><strong>三大组件：</strong>Selector、Channel 和 Buffer</p>
<p><strong>Selector：</strong>Selector 能够检测多个注册的通道上是否有事件发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。（不同的操作系统有不同的实现方式，在 windows 平台底层实现是 select，在 linux内核中采用 epoll 实现，在 MacOS 中采用 poll 实现。）</p>
<p><em>Selector 会根据不同的事件，在各个通道上切换</em></p>
<p><strong>Buffer（缓冲区）：</strong>Buffer 就是一个内存块 ，底层是有一个数组并提供了一组方法，可以更轻松的使用内存块。NIO 数据的读取写入是通过 Buffer，BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。如图所示：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Users\王进\AppData\Roaming\Typora\typora-user-images\image-20210614114733880.png" alt="image-20210614114733880" style="zoom:80%;">

<p><strong>Channel：</strong>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
<p><strong>NIO 中相关的类</strong></p>
<p>NIO 相关的类均在<code>java.nio</code>包下。与 BIO 中 ServerSocket、Socket 对应，NIO 中提供了 ServerSocketChannle、SocketChannel 分别表示服务端 Channel 和客户端 Channel。</p>
<p>看看如何用 NIO 来实现上面的场景：</p>
<p><strong>NIO 服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 轮询器，不同的操作系统对应不同的实现类</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">       serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 将服务端channel注册到轮询器上，并告诉轮询器，自己感兴趣的事件是ACCEPT事件</span></span><br><span class="line">       serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用轮询器的select()方法，是让轮询器从操作系统上获取所有的事件（例如：新客户端的接入、数据的写入、数据的写出等事件）</span></span><br><span class="line">           selector.select(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">// 调用select()方法后，轮询器将查询到的事件全部放入到了selectedKeys中</span></span><br><span class="line">           Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">           <span class="comment">// 遍历所有事件</span></span><br><span class="line">           Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">           <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果是新连接接入</span></span><br><span class="line">               <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                   SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                   System.out.println(<span class="string">&quot;有新客户端来连接&quot;</span>);</span><br><span class="line">                   socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="comment">// 有新的客户端接入后，就样将客户端对应的channel所感兴趣的时间是可读事件</span></span><br><span class="line">                   socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果是可读事件</span></span><br><span class="line">               <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                   <span class="comment">// 从channel中读取数据</span></span><br><span class="line">                   SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                   ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                   channel.read(byteBuffer);</span><br><span class="line">                   byteBuffer.flip();</span><br><span class="line">                   System.out.println(Charset.defaultCharset().decode(byteBuffer));</span><br><span class="line">                   <span class="comment">// 读完了以后，再次将channel所感兴趣的时间设置为读事件，方便下次继续读。当如果后面要想往客户端写数据，那就注册写时间：SelectionKey.OP_WRITE</span></span><br><span class="line">                   channel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 将SelectionKey从集合中移除，</span></span><br><span class="line">               <span class="comment">// 这一步很重要，如果不移除，那么下次调用selectKeys()方法时，又会遍历到该SelectionKey，这就造成重复处理了，而且最终selectionKeys这个集合的大小会越来越大。</span></span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ul>
<li><p>首先通过<code>ServerSocketChannel.open()</code>这行代码创建了一个服务端的 Channel ，也就是服务端的 Socket 。（在计算机网路的7层模型或者TCP/IP模型中，上层的应用程序通过Socket来和底层沟通）</p>
</li>
<li><p>通过<code>Selector.open()</code>创建了一个轮询器，这个轮询器就是后续用来从操作系统中，遍历有哪些 Socket 准备好了。这么说有点抽象，举个栗子。坐火车时，通常都会有补票环节。每过一站后，乘务员就会在车厢中吼一嗓子，哪些人需要补票的？需要补票的人去几号车厢办理。这个乘务员就对应 NIO 中轮询器，定时去车厢中吼一嗓子（也就是去操作系统中“吼一嗓子”），这个时候如果有人需要补票（有新的客户端接入或者读写事件发生），那么它就会去对应的车厢办理<strong>（这些接入事件或者读写事件就会跑到 selectKeys 集合中）</strong>。而对应 BIO，每对应一个新客户端，都需要新建一个线程，也就是说每出现一个乘客，我们都要为它配备一个乘务员，这显然是不合理的，不可能有那么多的乘务员。因此这就是 NIO 对 BIO 的一个巨大优势。</p>
</li>
<li><p>然后为服务端绑定端口号，并设置为非阻塞模式。我们使用 NIO 的目的就是为了使用它的非阻塞特性，因此这里需要调用 <code>serverSocketChannel.configureBlocking(false)</code>设置为非阻塞</p>
</li>
<li><p>然后将 ServerSocketChannel 注册到轮询器 Selector 上，并告诉轮询器，它感兴趣的事件是 ACCEPT 事件（服务端的 Channel 就是用来处理客户端接入的，因此它感兴趣的事件就是 ACCEPT 事件。为什么要把它注册到轮询器上呢？前面已经说到了，轮询器会定期去操作系统中“吼一嗓子，谁要补票”，如果不注册到轮询器上（不上火车），轮询器吼一嗓子的时候，你怎么听得见呢？）</p>
</li>
<li><p>接着就是在一个 while 循环中，每过一段时间让轮询器去操作系统中轮询有哪些事件发生。select() 方法就是去操作系统中轮询（吼一嗓子），它可以传入一个参数，表示在操作系统中等多少毫秒，如果在这段时间中没有事件发生（没有人要补票），那么就从操作系统中返回。如果有事件发生，那么就将这些事件方法放到轮询器的<code>publicSelectedKeys</code>属性中，当调用<code>selector.selectedKeys()</code>方法时，就将这些事件返回。</p>
</li>
<li><p>接下来就是判断事件是哪种事件，是接收事件还是读事件，亦或是写事件，然后针对每种不同的事件做不同的处理。</p>
</li>
<li><p>最后将 Key 从集合中移除。为什么移除，见代码注释。</p>
</li>
</ul>
<p>上面是服务端 NIO 的写法，这个时候，可以直接利用 BIO 的客户端去进行测试。当然 NIO 也有客户端写法。虽然 NIO 的写法很复杂，但一回生，二回熟，多见几回就习惯了，所以下面还是贴出了 NIO 客户端的写法。</p>
<p><strong>NIO 客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">       socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">boolean</span> connect = socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">       <span class="comment">// 因为连接是一个异步操作，所以需要在下面一行判断连接有没有完成。如果连接还没有完成，就进行后面的操作，会出现异常</span></span><br><span class="line">       <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">           <span class="comment">// 如果连接未完成，就等待连接完成</span></span><br><span class="line">            socketChannel.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 每个3秒向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               String message = socketChannel.getLocalAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                <span class="comment">// 使用ByteBuffer进行数据发送</span></span><br><span class="line">               ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">               socketChannel.write(byteBuffer);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO 客户端的写法相对比较简单，利用 SocketChannel 进行 IP 和端口的绑定，然后调用 connect() 方法进行连接到服务端。最后利用 ByteBuffer 装载数据，通过 SocketChannel 将数据写出去。</p>
<p><strong>NIO 原理分析图：</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\NIO原理分析图.png" alt="image-20210614121139284" style="zoom: 110%;">

<p><strong>执行流程：</strong></p>
<p>当客户端连接时，会通过 ServerSocketChannel 得到 ServerSocketChannel 得到服务端的 Channel ；</p>
<p>将 ServerSocketChannel 注册到 Selector 上，一个轮询器上可以注册多个 Channel ;</p>
<p>注册后返回一个 SelectionKeys 关联集合，通过 SelectionKey 反向获取相应的 SocketChannel ，完成业务处理逻辑；</p>
<p>服务器端通过 Selector 进行监听，调用 select 方法返回有事件发生的通道个数。</p>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>相比BIO而言，NIO不需要为每个连接去创建一个线程，它是通过轮询器，定期的从操作系统中获取到准备好的事件，然后进行批量处理。同时NIO是通过ByteBuffer来读写数据，相比于BIO中通过流来一个字节或多个字节的对数据，NIO的效率更高。但是ByteBuffer的数据结构设计，有点反人类，一不小心就会出BUG。</p>
<p>BIO在高并发下不适合用，而NIO虽然可以应对高并发的场景，但是它一方面因为写法复杂，掌握难度大，更重要的是还存在空轮询的BUG（产生空轮询的原因是操作系统的缘故），因此Netty出现了。Netty是目前应该使用最广泛的一款网络框架，用官方术语讲就是：它是一款基于事件驱动的高性能的网络框架。实际上它是一款将NIO包装了的框架，同时它规避了JDK中空轮训的BUG。虽然它是对NIO的包装，但是它对很多操作进行了优化，其性能更好。目前在很多Java流行框架中，底层都采用了Netty进行网络通信，比如RPC框架中Dubbo、Motan，Spring5的异步编程，消息队列RocketMQ等等都使用了Netty进行网络通信。</p>
<p>接下来就用Netty实现上面的场景：</p>
<p><strong>Netty 服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责处理连接的线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 负责处理IO和业务逻辑的线程组</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 添加日志打印，用来观察Netty的启动日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 添加用来处理客户端channel的处理器handler</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 字符串解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    <span class="comment">// 自定义的handler，用来打印接收到的消息</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            System.out.println(message);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;有新客户端连接&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，并启动</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码虽然看起来也很长，但是这段代码几乎是不变的，它几乎适用于所有场景，我们只需要修改childHandler()这一行相关的方法即可。这里面的代码才是处理我们自定义的业务逻辑的。</p>
<p>启动NettyServer，可以直接使用BioClient或者NioClient来测试NettyServer。当然，Netty也有客户端的写法。代码如下。</p>
<p><strong>Netty 客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个线程组即可</span></span><br><span class="line">        NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 采用Bootstrap而不是ServerBootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(nioEventLoopGroup)</span><br><span class="line">                    <span class="comment">// 设置客户端的SocketChannel</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 添加一个字符串编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line"></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">            executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">                String message = channel.localAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                channel.writeAndFlush(message);</span><br><span class="line">            &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            nioEventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的代码也几乎是固定的，所有场景都可以复用这段代码，唯一需要修改的就是handler()方法这一块，需要针对自己的业务逻辑去添加不同的处理器。</p>
<p>相比于NIO的写法，Netty的写法更加简洁，代码量相对更少，几行简单的代码就搞定了服务的启动，新连接接入，数据读写，编解码等问题。这也是为什么Netty使用这么广泛的原因。相比于NIO，Netty有如下几点优点：</p>
<ul>
<li>JDK的NIO存在空轮询的BUG，而Netty则巧妙的规避了这一点；</li>
<li>JDK的API复杂，开发人员使用起来比较困难，更重要的是，很容易写出BUG；而Netty的API简单，容易上手。</li>
<li>Netty的性能更高，它在JDK的基础上做了很多性能优化，例如将selector中的<code>publicSelectedKeys</code>属性的数据结构由Set集合改成了数组。</li>
<li>Netty底层对IO模型可以随意切换，针对Reactor三种线程模型，只需要通过修改参数就可以实现IO模型的切换。</li>
<li>Netty经过了众多高并发场景的考验，如Dubbo等RPC框架的验证。</li>
<li>Netty帮助我们解决了TCP的粘包拆包等问题，开发人员不用去关心这些问题，只需专注于业务逻辑开发即可。</li>
<li>Netty支持很多协议栈。JDK自带的对象序列化性能很差，序列化后码流较大，而是用其他方式的序列化则性能较高，例如protobuf等。</li>
<li>优点还有很多…</li>
</ul>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（七）RPC实现服务端自动注册服务</title>
    <url>/2021/05/12/%EF%BC%88%E4%B8%83%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>到目前为止，客户端看起来挺完美了，但是在服务端，我们却需要手动创建服务对象，并且手动进行注册，如果服务端提供了很多服务，这个操作就会变得很繁琐。本节就会介绍如何基于注解进行服务的自动注册。</p>
<h1 id="1-如何定义自己的注解"><a href="#1-如何定义自己的注解" class="headerlink" title="1.如何定义自己的注解"></a>1.如何定义自己的注解</h1><p><strong>元注解：</strong>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<ol>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>@Inherited</li>
</ol>
<p><strong>每个元注解的作用和相应分参数的使用说明：</strong></p>
<p><strong>@Target：</strong>用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p>
<p>取值(ElementType)有：</p>
<ol>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域</li>
<li>LOCAL_VARIABLE:用于描述局部变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>PARAMETER:用于描述参数</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ol>
<p><strong>@Retention：</strong>表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</p>
<p>取值（RetentionPoicy）有：</p>
<ol>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在class文件中有效（即class保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ol>
<h1 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2.定义注解"></a>2.定义注解</h1><p>我们需要定义两个注解：Service 和 ServiceScan</p>
<p><strong>Service.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceScan.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。Service 注解的值定义为该服务的名称，默认值是该类的完整类名，而 ServiceScan 的值定义为扫描范围的根包，默认值为入口类所在的包，扫描时会扫描该包及其子包下所有的类，找到标记有 Service 的类，并注册。</p>
<h1 id="3-工具类-ReflectUtil"><a href="#3-工具类-ReflectUtil" class="headerlink" title="3.工具类 ReflectUtil"></a>3.工具类 ReflectUtil</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] stack = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">        <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>].getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件 并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者 也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是 <code>getClasses</code> 方法，传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回。</p>
<h1 id="4-扫描服务"><a href="#4-扫描服务" class="headerlink" title="4.扫描服务"></a>4.扫描服务</h1><p>扫描服务这一步是一个比较公共的方法，无论是 Socket 还是 Netty 的服务端都需要这个方法，于是我对项目做了一点重构，使用了一个抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自 AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取启动类，也就是main方法所在的类</span></span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Class.forName(xxx.xx.xx) 返回具体类</span></span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到所有的 Class ，逐个判断是否有 Service 注解</span></span><br><span class="line">        <span class="comment">//如果有的话，通过反射创建该对象，并且调用 publishService 注册即可</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service.class).name();</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要获得要扫描的包的范围，就需要获取到 ServiceScan 注解的值，而我们前面说过，这个注解是加在启动类上的，那么，我们怎么知道启动类是哪一个呢？答案是通过调用栈。方法的调用和返回是通过方法调用栈来实现的，当调用一个方法时，该方法入栈，该方法返回时，该方法出站，控制回到栈顶的方法。那么，main 方法一定位于调用栈的最底端，在 ReflectUtils 中，我写了一个 getStackTrace 方法（名字起得不好），用于获取 main 所在的类。通过 Class 对象的 isAnnotationPresent 方法来判断该类是否有 ServiceScan 注解。如果有，通过startClass.getAnnotation(ServiceScan.class).value(); 获取注解的值。</p>
<p>当获得扫描的范围后，就可以通过ReflectUtil.getClasses(basePackage) 获取到所有的 Class 了，逐个判断是否有 Service 注解，如果有的话，通过反射创建该对象，并且调用 publishService 注册即可。</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（六）RPC实现自动注销服务和负载均衡策略</title>
    <url>/2021/05/12/%EF%BC%88%E5%85%AD%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>上一章我们实现了服务的注册和发现，但是我们发现，启动完成服务端后把服务端给关闭了，并不会自动地注销 Nacos 中对应的服务信息，这样就导致了当客户端再次向 Nacos 请求服务时，会获取到已经关闭的服务端信息，最终就有可能因为连接不到服务器而调用失败。</p>
<p>那么我们就需要一种办法，<strong>在服务端关闭之前自动向 Nacos 注销服务</strong>。但是有一个问题，我们不知道什么时候服务器会关闭，也就不知道这个方法调用的时机，就没有办法手工去调用。这时，我们就需要钩子。</p>
<p><strong>钩子：</strong>是在某些事件发生后自动去调用的方法。那么我们只<strong>需要把注销服务的方法写到关闭系统的钩子方法里就行了</strong>。</p>
<h1 id="1-服务自动注销功能"><a href="#1-服务自动注销功能" class="headerlink" title="1.服务自动注销功能"></a>1.服务自动注销功能</h1><h2 id="1-1rpc-common-创建工具类NacosUtil"><a href="#1-1rpc-common-创建工具类NacosUtil" class="headerlink" title="1.1rpc-common 创建工具类NacosUtil"></a>1.1rpc-common 创建工具类NacosUtil</h2><p>先写向 Nacos 注销所有服务的方法 <code>clearRegistry</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String host = address.getHostName();</span><br><span class="line">        <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">        Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            String serviceName = iterator.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的服务名称都被存储在 NacosUtils 类中的 serviceNames 中，在注销时只需要用迭代器迭代所有服务名，调用 deregisterInstance 即可。</p>
<h2 id="1-2-rpc-core-创建钩子"><a href="#1-2-rpc-core-创建钩子" class="headerlink" title="1.2 rpc-core 创建钩子"></a>1.2 rpc-core 创建钩子</h2><p>新建一个类 <code>ShutdownHook</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool = ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;shutdown-hook&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了单例模式创建其对象，在 addClearAllHook 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 addShutdownHook 方法增加一个钩子函数，创建一个新线程调用 clearRegistry 方法完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p>
<p>这样在 RpcServer 启动之前，只需要调用 addClearAllHook，就可以注册这个钩子了。例如在 NettyServer 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">future.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>

<h1 id="2-负载均衡策略"><a href="#2-负载均衡策略" class="headerlink" title="2.负载均衡策略"></a>2.负载均衡策略</h1><p>在上一节中客户端在 lookupService 方法中，从 Nacos 获取到的是所有提供这个服务的服务端信息列表，我们就需要从中选择一个，这便涉及到客户端侧的负载均衡策略。也就是说我们在选择服务器时要尽量避免集中访问同一个服务器。</p>
<p><strong>LoadBalancer 接口：</strong>只有一个方法，从获取到的服务器列表中选择一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现两个比较经典的算法：随机和转轮</p>
<p><strong>随机算法：</strong>顾名思义，就是随机选一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转轮算法：</strong>按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p>
<p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在 NacosServiceRegistry 中集成就可以了，这里选择外部传入的方式传入 LoadBalancer：</p>
<p><strong>ServiceDiscovery 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称查找服务实体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceDiscovery 实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;找不到对应的服务: &quot;</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个负载均衡策略，也可以在创建客户端时指定，例如无参构造 NettyClient 时就用默认的策略，也可以有参构造传入策略</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（五）RPC实现基于Nacos的注册中心</title>
    <url>/2021/05/07/%EF%BC%88%E4%BA%94%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<hr>
<a id="more"></a>







<h1 id="1-countdownlatch工具类的使用"><a href="#1-countdownlatch工具类的使用" class="headerlink" title="1.countdownlatch工具类的使用"></a>1.countdownlatch工具类的使用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch begin = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Player(begin,end),String.valueOf(i));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the race begin&quot;</span>);</span><br><span class="line">            begin.countDown();</span><br><span class="line">            end.await();<span class="comment">//await() 方法具有阻塞作用，也就是说主线程在这里暂停</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the race end&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    Player(CountDownLatch begin,CountDownLatch end)&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start !&quot;</span>);;</span><br><span class="line">            begin.await();<span class="comment">//因为此时已经为0了，所以不阻塞</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; arrived !&quot;</span>);</span><br><span class="line"></span><br><span class="line">            end.countDown();<span class="comment">//countDown() 并不是直接唤醒线程,当end.getCount()为0时线程会自动唤醒</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程main被end.await();阻塞，两个副线程继续往下运行，因为benin已经为0，所以不阻塞，操作两次end的downcount（每次减1）之后，主线程继续往下执行。</p>
<p>如果 <code>CountDownLatch end = new CountDownLatch(3)</code>  因为只操作两次 end 的 downcount ，所以主线程 main 会一直被阻塞。</p>
<h1 id="2-实现基于Nacos的注册中心"><a href="#2-实现基于Nacos的注册中心" class="headerlink" title="2.实现基于Nacos的注册中心"></a>2.实现基于Nacos的注册中心</h1><h2 id="2-1获取Nacos"><a href="#2-1获取Nacos" class="headerlink" title="2.1获取Nacos"></a>2.1获取Nacos</h2><p>下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a><br>本文版本：1.3.0</p>
<p>下载完成之后，解压。根据不同平台，执行不同命令，启动单机版Nacos服务：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Linux/Unix/Mac：sh startup.sh -m standalone</span><br><span class="line">Windows：<span class="built_in">cmd</span> startup.<span class="built_in">cmd</span> -m standalone</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>startup.sh</code>脚本位于Nacos解压后的bin目录下。</p>
</blockquote>
<p>启动完成之后，访问：<code>http://127.0.0.1:8848/nacos/</code>，可以进入Nacos的服务管理页面，具体如下:</p>
<img src="/2021/05/07/%EF%BC%88%E4%BA%94%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/GitHub\MyBlogs\source\_posts\2021-05-07-（五）RPC实现基于Nacos的注册中心\nacos1.png" alt="image-20210508110300724" style="zoom:80%;">

<h2 id="2-2-rpc-core-引入-Nacos-依赖"><a href="#2-2-rpc-core-引入-Nacos-依赖" class="headerlink" title="2.2 rpc-core 引入 Nacos 依赖"></a>2.2 rpc-core 引入 Nacos 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-rpc-core-创建-ServiceProvider-接口"><a href="#2-3-rpc-core-创建-ServiceProvider-接口" class="headerlink" title="2.3 rpc-core 创建 ServiceProvider 接口"></a>2.3 rpc-core 创建 ServiceProvider 接口</h2><p>将第二章中本地保存服务的接口 <code>ServiceRegistry</code> 改写为<code>ServiceProvider</code>，作为服务的提供者：</p>
<p><strong>ServiceProvider接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceProviderImpl实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务名与提供服务的对象的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存当前有哪些对象已经被注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务的注册功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务对象实现的接口的完整类名作为注册的服务名（ConcurrentHashMap中的键值）</span></span><br><span class="line">        String serviceName = service.getClass().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//当服务不存在时，注册服务</span></span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        <span class="comment">//获取该对象实现的接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将服务实现的接口的类名</span></span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务获取功能的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据服务的名称，从ConcurrentHashMap中获取服务并返回对应服务</span></span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-rpc-core-创建-ServiceRegistry-接口"><a href="#2-4-rpc-core-创建-ServiceRegistry-接口" class="headerlink" title="2.4 rpc-core 创建 ServiceRegistry 接口"></a>2.4 rpc-core 创建 ServiceRegistry 接口</h2><p><code>ServiceRegistry</code> 作为远程注册表（Nacos）使用，也就是在远端存储<strong>服务的名称和服务对应的地址、端口号</strong>，并能够根据名称找到对应的服务提供地址信息。</p>
<p><strong>ServiceRegistry接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将服务的名称和地址注册进服务注册中心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inetSocketAddress 提供服务的地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称从注册中心获取到一个服务提供者的地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceRegistry实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过 NamingFactory 创建 NamingService 连接 Nacos</span></span><br><span class="line">            namingService = NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//registerInstance方法直接向 Nacos 注册服务</span></span><br><span class="line">            namingService.registerInstance(serviceName, inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//getAllInstances方法可以获得提供某个服务的所有提供者的列表</span></span><br><span class="line">            List&lt;Instance&gt; instances = namingService.getAllInstances(serviceName);</span><br><span class="line">            <span class="comment">//通过 getAllInstance 获取到某个服务的所有提供者列表后，需要选择一个</span></span><br><span class="line">            Instance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nacos 的使用很简单，通过 NamingFactory 创建 NamingService 连接 Nacos（连接的时候没有找到修改用户名密码的方式……是不需要吗），连接的过程写在了静态代码块中，在类加载时自动连接。namingService 提供了两个很方便的接口，registerInstance 和 getAllInstances 方法，前者可以直接向 Nacos 注册服务，后者可以获得提供某个服务的所有提供者的列表。所以接口的这两个方法只需要包装一下就好了。</p>
<p>在 lookupService 方法中，通过 getAllInstance 获取到某个服务的所有提供者列表后，需要选择一个，这里就涉及了负载均衡策略，这里我们先选择第 0 个，后面某节会详细讲解负载均衡。</p>
<h2 id="2-5-rpc-core-注册服务"><a href="#2-5-rpc-core-注册服务" class="headerlink" title="2.5 rpc-core 注册服务"></a>2.5 rpc-core 注册服务</h2><p><strong>RpcServer 接口：</strong></p>
<ul>
<li>在 RpcServer 接口中新增一个方法 publishService，用于向 Nacos 注册服务</li>
<li> setSerializer 用于设置序列化器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(Object service, Class&lt;T&gt; serviceClass)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyServer 实现类：</strong></p>
<p>主要是上面两个新增方法的实现</p>
<p>通过<code>ServiceRegistry</code>、<code>ServiceProvider</code>两个实例对象实现提供服务和向远程nacos注册表注册服务的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(Object service, Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            serviceProvider.addServiceProvider(service);</span><br><span class="line">            serviceRegistry.register(serviceClass.getCanonicalName(), <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程组：bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//3.给引导类配置两大线程组,确定了线程模型（多线程模型）</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">//option()是提供给NioServerSocketChannel用来接收进来的连接</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> KryoSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 6.绑定端口,调用 sync 方法阻塞直到绑定完成</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host,port).sync();</span><br><span class="line">            <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>publishService 需要将服务保存在本地的注册表，同时注册到 Nacos 上。我这里的实现是注册完一个服务后直接调用 start()  方法，这是个不太好的实现……导致一个服务端只能注册一个服务，之后可以多注册几个然后再手动调用 start() 方法。</p>
<h2 id="2-6-rpc-core-发现服务"><a href="#2-6-rpc-core-发现服务" class="headerlink" title="2.6 rpc-core 发现服务"></a>2.6 rpc-core 发现服务</h2><p><strong>创建 ChannelProvider 类用于获取 Channel 对象：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line">    <span class="comment">//最大重新连接次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRY_COUNT = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                <span class="comment">//自定义序列化编解码器:RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//用于线程通信</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取channel</span></span><br><span class="line">            connect(bootstrap, inetSocketAddress, countDownLatch);</span><br><span class="line">            <span class="comment">//线程在这里阻塞</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取channel时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        connect(bootstrap, inetSocketAddress, MAX_RETRY_COUNT, countDownLatch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress, <span class="keyword">int</span> retry, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                channel = future.channel();</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (retry == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;客户端连接失败:重试次数已用完，放弃连接！&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.CLIENT_CONNECT_SERVER_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第几次重连</span></span><br><span class="line">            <span class="keyword">int</span> order = (MAX_RETRY_COUNT - retry) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 本次重连的间隔</span></span><br><span class="line">            <span class="keyword">int</span> delay = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">            logger.error(<span class="string">&quot;&#123;&#125;: 连接失败，第 &#123;&#125; 次重连……&quot;</span>, <span class="keyword">new</span> Date(), order);</span><br><span class="line">            bootstrap.config().group().schedule(() -&gt; connect(bootstrap, inetSocketAddress, retry - <span class="number">1</span>, countDownLatch), delay, TimeUnit</span><br><span class="line">                    .SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回客户端启动引导/辅助类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建单线程组</span></span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//3.指定线程组</span></span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//是否开启 TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>get 方法：</strong>用于获取 channel</p>
<p>通过<code>handler</code>方法给这个引导类创建一个<code>ChannelInitializer</code>，这里主要就是定义后续每条连接的数据读写，业务处理逻辑。</p>
<p>通过<code>CountDownLatch</code>工具，实现主线程的唤醒</p>
<p>调用<code>connect</code> 方法，获取channel</p>
</li>
<li><p><strong>connect 方法：</strong></p>
<p>在网络情况差的情况下，客户端第一次连接可能会连接失败，这个时候我们可能会尝试<strong>重新连接</strong>，相应的代码逻辑如下：</p>
<ol>
<li>如果连接成功则打印连接成功的消息</li>
<li>如果连接失败但是重试次数已经用完，放弃连接</li>
<li>如果连接失败但是重试次数仍然没有用完，则计算下一次重连间隔 <code>delay</code>，然后定期重连</li>
</ol>
<p>我们定时任务是调用 <code>bootstrap.config().group().schedule()</code>, 其中 <code>bootstrap.config()</code> 这个方法返回的是 <code>BootstrapConfig</code>，他是对 <code>Bootstrap</code> 配置参数的抽象，然后 <code>bootstrap.config().group()</code> 返回的就是我们在一开始的时候配置的线程模型 <code>workerGroup</code>，调 <code>workerGroup</code> 的 <code>schedule</code> 方法即可实现定时任务逻辑。</p>
<p>在 <code>schedule</code> 方法块里面，前面四个参数我们原封不动地传递，最后一个重试次数参数减掉一，就是下一次建立连接时候的上下文信息。</p>
</li>
<li><p><strong>initializeBootstrap 方法：</strong>返回客户端启动引导/辅助类对象</p>
<p>通过<code>group</code>方法给客户端启动引导类对象指定线程组，因为是客户端，所以只需要给定一个线程组。</p>
<p>通过<code>channel</code>方法指定 IO 模型</p>
<p>通过<code>option</code>方法给channel设置其它属性</p>
</li>
</ul>
<p>前面几章是直接使用传入的 host 和 port 直接构造 channel ，现在是首先从 ServiceRegistry 中获取到服务的地址和端口，再构造。以 NettyClient 为例，在过去创建 NettyClient 时，需要传入 host 和 port，现在这个 host 和 port 是通过 Nacos 获取的，sendRequest 修改如下：</p>
<p><strong>修改NettyClient类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        AtomicReference&lt;Object&gt; result = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceRegistry.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span>(channel.isActive()) &#123;</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                        logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                channel.closeFuture().sync();</span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span> + rpcRequest.getRequestId());</span><br><span class="line">                RpcResponse rpcResponse = channel.attr(key).get();</span><br><span class="line">                RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">                result.set(rpcResponse.getData());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSerializer</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7测试"><a href="#2-7测试" class="headerlink" title="2.7测试"></a>2.7测试</h2>]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）RPC实现Kryo序列化</title>
    <url>/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>上一章我们实现了一个通用的序列化框架，使得序列化方式具有了较高的扩展性，并且实现了一个基于 JSON 的序列化器。</p>
<p><strong>基于 JSON 的序列化器的问题：</strong></p>
<ol>
<li>在某个类的属性反序列化时，如果属性声明为 Object 的，就会造成反序列化出错，通常会把 Object 属性直接反序列化成 String 类型，就需要其他参数辅助序列化。</li>
<li>并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。</li>
</ol>
<p><strong>Kryo</strong> 是一个快速高效的 Java 对象序列化框架，主要特点是高性能、高效和易用。</p>
<p><strong>最重要的两个特点：</strong></p>
<ol>
<li>基于字节的序列化，对空间利用率较高，在网络传输时可以减小体积；</li>
<li>序列化时记录属性对象的类型信息，这样在反序列化时就不会出现之前的问题了。</li>
</ol>
<h1 id="1-序列化介绍以及序列化协议选择"><a href="#1-序列化介绍以及序列化协议选择" class="headerlink" title="1.序列化介绍以及序列化协议选择"></a>1.序列化介绍以及序列化协议选择</h1><h2 id="1-1序列化和反序列化相关概念"><a href="#1-1序列化和反序列化相关概念" class="headerlink" title="1.1序列化和反序列化相关概念"></a>1.1序列化和反序列化相关概念</h2><p>如果我们需要持久化Java对象比如将Java对象保存在文件中，或者在网络传输Java对象，这些场景都需要用到序列化。 </p>
<p>简单来说： </p>
<ul>
<li><strong>序列化：</strong> 将数据结构或对象转换成二进制字节流的过程 </li>
<li><strong>反序列化：</strong>将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程 对于Java这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型， 而class 对应的是对象类型。</li>
</ul>
<p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中</strong>。</p>
<p><strong>实际开发中有哪些用到序列化和反序列化的场景</strong></p>
<ol>
<li>对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化； </li>
<li>将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化。</li>
</ol>
<h2 id="1-2常见序列化协议对比"><a href="#1-2常见序列化协议对比" class="headerlink" title="1.2常见序列化协议对比"></a>1.2常见序列化协议对比</h2><p>JDK自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 <strong>hessian、kyro、protostuff</strong>。 </p>
<p>下面提到的都是基于二进制的序列化协议，像 JSON 和 XML这种属于文本类序列化方式。虽然 JSON 和 XML可读性比较好，但是性能较差，一般不会选择。</p>
<p><strong>JDK自带的序列化方式</strong></p>
<p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code> 接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一 致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成 默认的序列化号</p>
</blockquote>
<p>我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：</p>
<ol>
<li>**不支持跨语言调用 : ** 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差 ：</strong>相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<p><strong>kyro</strong></p>
<p>Kryo是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p>
<p>另外，Kryo 已经是一种非常成熟的序列化实现了，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive、Storm）中广泛的使用。</p>
<p><strong>Protobuf</strong></p>
<p>Protobuf出自于Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不然灵 活，但是，另一方面导致protobuf没有序列化漏洞的风险。</p>
<blockquote>
<p>Protobuf包含序列化格式的定义、各种语言的库以及一个IDL编译器。正常情况下你需要定义proto文件，然后使用IDL编译器编译成你需要的语言</p>
</blockquote>
<p>一个简单的 proto 文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// protobuf的版本</span></span><br><span class="line"><span class="number">2</span> syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="number">3</span> <span class="comment">// SearchRequest会被编译成不同的编程语言的相应对象，比如Java中的class、Go中的struct</span></span><br><span class="line"><span class="number">4</span> message Person &#123;</span><br><span class="line"><span class="number">5</span> <span class="comment">//string类型字段</span></span><br><span class="line"><span class="number">6</span> string name = <span class="number">1</span>;</span><br><span class="line"><span class="number">7</span> <span class="comment">// int 类型字段</span></span><br><span class="line"><span class="number">8</span> int32 age = <span class="number">2</span>;</span><br><span class="line"><span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ProtoStuff</strong></p>
<p>由于Protobuf的易用性，它的哥哥 Protostuff  诞生了。 </p>
<p>protostuff 基于Google protobuf，但是提供了更多的功能和更简易的用法。虽然更加易用，但是不代表 ProtoStuff 性能更差。</p>
<p><strong>hession</strong></p>
<p>hessian 是一个轻量级的,自定义描述的二进制RPC协议。hessian是一个比较老的序列化实现了，并且同样也是跨语言的。</p>
<img src="/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/GitHub\MyBlogs\source\_posts\2021-05-06-（四）RPC实现Kryo序列化\hession.png" style="zoom:60%;">

<h1 id="2-Kryo序列化"><a href="#2-Kryo序列化" class="headerlink" title="2.Kryo序列化"></a>2.Kryo序列化</h1><h2 id="2-1-rpc-core添加-kryo-依赖"><a href="#2-1-rpc-core添加-kryo-依赖" class="headerlink" title="2.1 rpc-core添加 kryo 依赖"></a>2.1 rpc-core添加 kryo 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-rpc-core-序列化接口"><a href="#2-2-rpc-core-序列化接口" class="headerlink" title="2.2 rpc-core 序列化接口"></a>2.2 rpc-core 序列化接口</h2><p>序列化接口中增加一个选项，返回Kryo序列化序列化器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列化方法</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line">    <span class="comment">//反序列化方法</span></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">    <span class="comment">//通过序列化名称获取序列化码，比如Kryo对应0</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="comment">//把 Kryo 的编号设为 0，后续会作为默认的序列化器</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KryoSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在<code>SerializerCode</code>类中加入Kryo的枚举类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerCode</span> </span>&#123;</span><br><span class="line">    KRYO(<span class="number">0</span>),</span><br><span class="line">    JSON(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据接口<code>CommonSerializer</code>，我们的主要任务就是实现其中的主要两个方法，<code>serialize()</code> 和 <code>deserialize()</code> ，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KryoSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(KryoSerializer.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过ThreadLocal来保证Kryo的线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//初始化Kryo对象</span></span><br><span class="line">        Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">        <span class="comment">//Kryo对象中注册RpcResponse类和RpcRequest类</span></span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="comment">//开启循环引用</span></span><br><span class="line">        kryo.setReferences(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//关闭注册行为</span></span><br><span class="line">        kryo.setRegistrationRequired(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">             <span class="comment">//创建output对象，序列化的目标数组为byteArrayOutputStream字节数组</span></span><br><span class="line">             Output output = <span class="keyword">new</span> Output(byteArrayOutputStream))&#123;</span><br><span class="line">            <span class="comment">//得到线程对应的kryo对象</span></span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">//将对象序写入output对象，完成序列化</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            <span class="comment">//防止内存泄漏（因为ThreadLocal中的key是弱引用，value是强引用）</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="comment">//调用output的toByte()方法，返回一个字符数组</span></span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializeException(<span class="string">&quot;序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">             <span class="comment">//创建input对象，反序列化的目标数组为byteArrayOutputStream字节数组</span></span><br><span class="line">             Input input = <span class="keyword">new</span> Input(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="comment">//得到线程对应的kryo对象</span></span><br><span class="line">            Kryo kryo = kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">//将字节数组的数据转换成对应的实体类对象</span></span><br><span class="line">            Object o = kryo.readObject(input, clazz);</span><br><span class="line">            <span class="comment">//防止内存泄漏</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializeException(<span class="string">&quot;反序列化时有错误发生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;KRYO&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadLocal-保存-kryo-对象"><a href="#ThreadLocal-保存-kryo-对象" class="headerlink" title="ThreadLocal 保存 kryo 对象"></a>ThreadLocal 保存 kryo 对象</h3><ul>
<li><p>由于 kryo 不是线程安全的，所以每个线程都使用独立的 kryo，用ThreadLocal作为容器，当每个线程访问这个 <strong>Kryo</strong> 对象时，ThreadLocal 会为每个线程提供一个对象，各个线程互不影响。</p>
<p><code>withInitial</code> 是一种 Lambda 构造方式，为每个线程创建一个 kryo 局部对象。</p>
</li>
<li><p>另一方面，因为 Kryo 实例的创建/初始化是相当昂贵的，所以在多线程的情况下，您应该池化 Kryo 实例。一个非常简单的解决方案是使用 ThreadLocal 将 Kryo实例绑定到 Threads。</p>
</li>
</ul>
<h3 id="Kryo-使用"><a href="#Kryo-使用" class="headerlink" title="Kryo 使用"></a>Kryo 使用</h3><p><strong>IO</strong></p>
<p>Kryo 的 Input 和 Output 接收一个 InputStream 和 OutputStream，Kryo  通常完成字节数组和对象的转换，所以常用的输入输出流实现为 ByteArrayInputStream/ByteArrayOutputStream。</p>
<p><strong>Reading and writing（读与写）</strong></p>
<p>Kryo有三组读写对象的方法：</p>
<p>1.如果不知道对象的具体类，且对象可以为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kryo.writeClassAndObject(output, object);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Object object = kryo.readClassAndObject(input);</span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> SomeClass) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.如果类已知且对象可以为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kryo.writeObjectOrNull(output, someObject);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">SomeClass someObject = kryo.readObjectOrNull(input, SomeClass.class);</span><br></pre></td></tr></table></figure>

<p><strong>3.如果类已知且对象不能为null:（项目中使用）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kryo.writeObject(output, someObject);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">SomeClass someObject = kryo.readObject(input, SomeClass.class);</span><br></pre></td></tr></table></figure>

<p><strong>Register（注册）与References（引用）</strong></p>
<p>当Kryo写出一个对象的实例时，首先可能需要写出一些标识对象类的东西。默认情况下，写入完整类名，然后写入该对象的字节。后续出现的同一类对象图的对象用变长的int来写（using a variable length int）。写类的名字有点低效，所以类可以事先注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">kryo.register(SomeClass.class);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Output output = ...</span><br><span class="line">SomeClass someObject = ...</span><br><span class="line">kryo.writeObject(output, someObject);</span><br></pre></td></tr></table></figure>

<p>这里，SomeClass 注册到了 Kryo，它将该类与一个 int 型的 ID 相关联。当 Kryo 写出 SomeClass 的一个实例时，它会写出这个 int  ID。这比写出类名更有效。在反序列化期间，注册的类必须具有序列化期间相同的 ID 。上面展示的注册方法分配下一个可用的最小整数  ID，这意味着类被注册的顺序十分重要。注册时也可以明确指定特定 ID，这样的话注册顺序就不重要了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">kryo.register(SomeClass.class, <span class="number">10</span>);</span><br><span class="line">kryo.register(AnotherClass.class, <span class="number">11</span>);</span><br><span class="line">kryo.register(YetAnotherClass.class, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>两个值得注意的点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">kryo.setRegistrationRequired(<span class="keyword">false</span>);<span class="comment">// 关闭注册行为</span></span><br><span class="line">kryo.setReferences(<span class="keyword">true</span>);<span class="comment">// 支持循环引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Kryo 支持对注册行为，如 <strong>kryo.register(SomeClazz.class)**，这会赋予该 Class 一个从 0 开始的编号，但 Kryo 使用注册行为最大的问题在于，其不保证同一个 Class 每一次注册的号码相同，这与注册的顺序有关，也就意味着在</strong>不同的机器<strong>、</strong>同一个机器重启前后**都有可能拥有不同的编号，这会导致序列化产生问题，所以在分布式项目中，一般关闭注册行为。</p>
</li>
<li><p>还有需要注意的就是 Kryo 对循环引用的支持。References即引用，对A对象序列化时，默认情况下 Kryo会在每个成员对象第一次序列化时写入一个数字，该数字逻辑上就代表了对该成员对象的引用，如果后续有引用指向该成员对象，则直接序列化之前存入的数字即可，而不需要再次序列化对象本身。</p>
<p>而 “循环引用” 是指，假设有一个 JavaBean，假设是一个销售订单（SalesOrder），这个订单下面有很多子订单，比如 List<SalesOrderLine> ，而销售子订单中又有其中一个包括一个销售订单，那么这就构成了”循环引用”。Kryo 默认是支持循环引用的，当你确定不会有循环引用发生的时候，可以通过 kryo.setReferences(false); 关闭循环引用检测，从而提高一些性能。关闭后虽然序列化速度更快，但是遇到循环引用，就会报 “栈内存溢出” 错误。</SalesOrderLine></p>
<p>所以，我并不认为关闭它是一件好的选择，**大多数情况下，请保持 kryo.setReferences(true)**。</p>
</li>
</ul>
<h1 id="2-3测试"><a href="#2-3测试" class="headerlink" title="2.3测试"></a>2.3测试</h1><p><strong>替换序列化器</strong></p>
<p>我们只需要把 NettyServer 和 NettyClient 责任链中的 CommonEncoder 传入的参数改成 KryoSerializer 即可使用 Kryo 序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()));</span><br><span class="line"><span class="comment">//将序列化器变成 KryoSerializer</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> KryoSerializer()));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）RPC实现Netty网络通信</title>
    <url>/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-BIO、NIO与AIO"><a href="#1-BIO、NIO与AIO" class="headerlink" title="1.BIO、NIO与AIO"></a>1.BIO、NIO与AIO</h1><p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I/O模型在很大程度上决定了框架的性能</p>
<h2 id="1-1BIO模型介绍"><a href="#1-1BIO模型介绍" class="headerlink" title="1.1BIO模型介绍"></a>1.1BIO模型介绍</h2><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信。由于ServerSocket 的 accept（）方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>这种方式下有一个问题：每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作。 如下图所示：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\BIO.png" style="zoom:80%;">

<p><strong>问题：</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p>
<p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p>
<h2 id="1-2NIO模型介绍"><a href="#1-2NIO模型介绍" class="headerlink" title="1.2NIO模型介绍"></a>1.2NIO模型介绍</h2><p>NIO基于Reactor（事件驱动思想），当socket有流可读或可写入socket时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>BIO与NIO一个比较重要的不同：<strong>我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong></p>
<p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\NIO.png" style="zoom:80%;">

<p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p>
<h2 id="1-3AIO模型介绍"><a href="#1-3AIO模型介绍" class="headerlink" title="1.3AIO模型介绍"></a>1.3AIO模型介绍</h2><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 </p>
<p>相比于NIO，AIO才是完全的异步IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p>
<h2 id="1-4三者比较"><a href="#1-4三者比较" class="headerlink" title="1.4三者比较"></a>1.4三者比较</h2><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p>
<p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p>
<p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，[客户端]的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>但是由于使用同步非阻塞的I/O模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p>
<h1 id="2-Netty-介绍（同步非阻塞）"><a href="#2-Netty-介绍（同步非阻塞）" class="headerlink" title="2.Netty 介绍（同步非阻塞）"></a>2.Netty 介绍（同步非阻塞）</h1><ol>
<li>Netty 是一个<strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。 </li>
<li>它极大地简化并<strong>简化了 TCP 和 UDP 套接字服务器等网络编程</strong>,并且性能以及安全性等很多方面甚 至都要更好。</li>
<li><strong>支持多种协议</strong>如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。 </li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h1 id="3-Netty-特点"><a href="#3-Netty-特点" class="headerlink" title="3.Netty 特点"></a>3.Netty 特点</h1><ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。 </li>
<li>简单而强大的线程模型。 </li>
<li>自带编解码器解决 TCP 粘包/拆包问题。 </li>
<li>自带各种协议栈。 </li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。 </li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。 </li>
<li>社区活跃。</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接 触的 Dubbo、RocketMQ </li>
</ul>
<p>等等…..</p>
<h1 id="4-Netty-能做什么"><a href="#4-Netty-能做什么" class="headerlink" title="4.Netty 能做什么"></a>4.Netty 能做什么</h1><p>理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。</p>
<p>Netty 主要用来做网络通信：</p>
<ol>
<li><strong>作为 RPC 框架的网络通信工具 ：</strong> 我们在分布式系统中，不同服务节点之间经常需要相互调用， 这个时候就需要 RPC 框架了。不同服务之间的通信是如何做的呢？可以使用 Netty 来做。比如：我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！ </li>
<li><strong>实现一个自己的 HTTP 服务器 ：</strong>通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个 大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。 一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请 求等等。 </li>
<li><strong>实现一个即时通讯系统 ：</strong> 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这 方面的开源项目还蛮多的，可以自行去 Github 找一找。 </li>
<li><strong>消息推送系统 ：</strong>市面上有很多消息推送系统都是基于 Netty 来做的。 </li>
</ol>
<p>等等…..</p>
<h1 id="5-Netty-的核心组件"><a href="#5-Netty-的核心组件" class="headerlink" title="5.Netty 的核心组件"></a>5.Netty 的核心组件</h1><h2 id="5-1Channel"><a href="#5-1Channel" class="headerlink" title="5.1Channel"></a>5.1Channel</h2><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等。还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop。</p>
<p>比较常用的<code>Channel</code>接口实现类是<code>NioServerSocketChannel</code>（服务端）和<code>NioSocketChannel</code>（客户端），这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 <code>API</code>，大大地降低了直接与 Socket 进行操作的复杂性。</p>
<h2 id="5-2EventLoop"><a href="#5-2EventLoop" class="headerlink" title="5.2EventLoop"></a>5.2EventLoop</h2><p>这么说吧！<code>EventLoop</code>（事件循环）接口可以说是 Netty 中最核心的概念了！</p>
<p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p>
<p>为了说明Channel、EventLoop、Thread、EventLoopGroup之间的关系，我们可以看下图：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\eventloop.png" style="zoom:80%;">

<p>上图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）。</p>
<p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>Boss EventloopGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>Worker EventloopGroup</code> 来处理，然后 <code>Worker EventloopGroup</code> 负责处理其 IO 相关操作。</p>
<p><strong>EventloopGroup 和 EventLoop 的关系：</strong></p>
<p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code></p>
<p><strong>EventLoop 和 Thread 的关系：</strong></p>
<p>每一个 <code>EventLoop</code> 通常内部包含一个线程，上面我们已经说了 <code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。 <code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 1 : 1 的关系，从而保证线程安全。</p>
<p><strong>那 Channel 和 EventLoop 的关系：</strong></p>
<p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<ul>
<li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li>
<li>一个 EventLoop 可被分配至一个或多个 Channel 。</li>
</ul>
<p>当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p>
<h2 id="5-3ChannelFuture"><a href="#5-3ChannelFuture" class="headerlink" title="5.3ChannelFuture"></a>5.3ChannelFuture</h2><p>Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。</p>
<p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。（异步）</p>
<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作变成同步的。</p>
<h2 id="5-4ChannelHandler-和-ChannelPipeline"><a href="#5-4ChannelHandler-和-ChannelPipeline" class="headerlink" title="5.4ChannelHandler 和 ChannelPipeline"></a>5.4ChannelHandler 和 ChannelPipeline</h2><p><strong>ChannelHandler</strong> </p>
<p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p>
<p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>
<p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。</p>
<p><strong>ChannelPipeline</strong></p>
<p>ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p>
<p>我们可以在 ChannelPipeline 上通过 <code>addLast()</code> 方法添加一个或者多个 ChannelHandler ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 ChannelHandler 处理完之后就将数据交给下一个 ChannelHandler 。</p>
<p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <code>ChannelHandler</code> 处理消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> KryoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ChannelPipeline的工作流程如下图所示：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\ChannelPipeline.png" style="zoom:80%;">

<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>
<p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 过程如下：</p>
<ol>
<li>一个 ChannelInitializer 的实现被注册到了 ServerBootStrap中</li>
<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li>
<li>ChannelInitializer 将它自己从 ChannelPipeline 中移除</li>
</ol>
<h2 id="5-5-Bootstrap-和-ServerBootstrap（不是核心组件）"><a href="#5-5-Bootstrap-和-ServerBootstrap（不是核心组件）" class="headerlink" title="5.5 Bootstrap 和 ServerBootstrap（不是核心组件）"></a>5.5 Bootstrap 和 ServerBootstrap（不是核心组件）</h2><p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，主要作用是配置整个Netty程序，串联各个组件。具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrap</code> 服务端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li>
</ol>
<h1 id="6-NioEventLoopGroup-默认的构造函数会起多少线程"><a href="#6-NioEventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="6.NioEventLoopGroup 默认的构造函数会起多少线程"></a>6.NioEventLoopGroup 默认的构造函数会起多少线程</h1><p>NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的 EventLoopGroup 的实现用来处理不同传输协议。</p>
<p>回顾我们在上面写的服务器端的代码，服务端会创建两个线程组：</p>
<ol>
<li>bossGroup 用于接收连接</li>
<li>workerGroup 用于具体的处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 *<em>CPU核心数</em>2**。</p>
<p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p>
<h1 id="7-Netty-线程模型"><a href="#7-Netty-线程模型" class="headerlink" title="7.Netty 线程模型"></a>7.Netty 线程模型</h1><p>在 Netty 主要靠 <code>NioEventLoopGroup</code> 线程池来实现具体的线程模型的 。</p>
<p>我们实现服务端的时候，一般会初始化两个线程组：</p>
<ol>
<li><strong><code>bossGroup</code></strong> :接收连接。</li>
<li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li>
</ol>
<p>下面我们来详细看一下 Netty 中的线程模型吧！</p>
<p>1.<strong>单线程模型</strong> ：</p>
<p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。</p>
<p>对应到 Netty 代码是下面这样的</p>
<blockquote>
<p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>多线程模型</strong></p>
<p>一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p>
<p>对应到 Netty 代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;">

<p><strong>3.主从多线程模型</strong></p>
<p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;">

<h1 id="8-Netty-实现网络通信"><a href="#8-Netty-实现网络通信" class="headerlink" title="8.Netty 实现网络通信"></a>8.Netty 实现网络通信</h1><h2 id="8-1在-pom-xml-中加入-Netty-依赖"><a href="#8-1在-pom-xml-中加入-Netty-依赖" class="headerlink" title="8.1在 pom.xml 中加入 Netty 依赖"></a>8.1在 pom.xml 中加入 Netty 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;netty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-2-rpc-core-改写-Server-与-Client"><a href="#8-2-rpc-core-改写-Server-与-Client" class="headerlink" title="8.2 rpc-core 改写 Server 与 Client"></a>8.2 rpc-core 改写 Server 与 Client</h2><p>为了保证通用性，我们可以把 Server 和 Client 抽象成两个接口，分别是 RpcServer 和 RpcClient：</p>
<p><strong>RpcClient：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcServer：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketClient 实现 RpcClient 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line">    <span class="comment">//客户端的地址和端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketServer 实现 RpcServer 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一个改动，就是在 <code>DefaultServiceRegistry.java</code> 中，将包含注册信息的 serviceMap 和 registeredService 都改成了 static ，这样就能保证全局唯一的注册信息，并且在创建 RpcServer 时也就不需要传入了。==（为什么要变成静态的，跟原来的区别?）==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将属性serviceMap、registeredService变成静态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"><span class="comment">//变化后：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br></pre></td></tr></table></figure>

<h2 id="8-3-rpc-core-实现-NettyServer"><a href="#8-3-rpc-core-实现-NettyServer" class="headerlink" title="8.3 rpc-core 实现 NettyServer"></a>8.3 rpc-core 实现 NettyServer</h2><p>1.首先创建了两个 <code>NioEventLoopGroup</code> 对象实例：<code>bossGroup</code> 和 <code>workerGroup</code>。</p>
<ul>
<li><code>bossGroup</code> : 用于处理客户端的 TCP 连接请求。</li>
<li><code>workerGroup</code> ： 负责每一条连接的具体读写数据的处理逻辑，真正负责 I/O 读写操作，交由对应的 Handler 处理。</li>
</ul>
<p>举个例子：我们把公司的老板当做 bossGroup，员工当做 workerGroup，bossGroup 在外面接完活之后，扔给 workerGroup 去处理。一般情况下我们会指定 bossGroup 的 线程数为 1（并发连接量不大的时候） ，workGroup 的线程数量为 <strong>CPU 核心数 *2</strong> 。另外，根据源码来看，使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
<p>2.接下来 我们创建了一个服务端启动引导/辅助类： <code>ServerBootstrap</code>，这个类将引导我们进行服务端的启动工作。</p>
<p>3.通过 <code>.group()</code> 方法给引导类 <code>ServerBootstrap</code> 配置两大线程组，确定了线程模型，这里我们使用的是多线程模型。</p>
<p>4.通过<code>channel()</code>方法给引导类 <code>ServerBootstrap</code>指定了 IO 模型为<code>NIO</code></p>
<ul>
<li><code>NioServerSocketChannel</code> ：指定服务端的 IO 模型为 NIO，与 BIO 编程模型中的<code>ServerSocket</code>对应</li>
<li><code>NioSocketChannel</code> : 指定客户端的 IO 模型为 NIO， 与 BIO 编程模型中的<code>Socket</code>对应</li>
</ul>
<p>5.通过调用<code>.childHandler()</code>方法给引导类创建一个<code>ChannelInitializer</code> ，然后指定了服务端消息的业务处理逻辑 <code>HelloServerHandler</code> 对象</p>
<p>Netty 中有一个很重要的设计模式——<strong>责任链模式</strong>，责任链上有多个处理器，每个处理器都会对数据进行加工，并将处理后的数据传给下一个处理器。代码中的 CommonEncoder、CommonDecoder和NettyServerHandler 分别就是编码器，解码器和数据处理器。因为数据从外部传入时需要解码，而传出时需要编码，类似计算机网络的分层模型，每一层向下层传递数据时都要加上该层的信息，而向上层传递时则需要对本层信息进行解码。</p>
<p>6.调用 <code>ServerBootstrap</code> 类的 <code>bind()</code>方法绑定端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程组：bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//3.给引导类配置两大线程组,确定了线程模型（多线程模型）</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">//option()是提供给NioServerSocketChannel用来接收进来的连接</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 6.绑定端口,调用 sync 方法阻塞直到绑定完成</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-rpc-core-实现-NettyClient"><a href="#8-4-rpc-core-实现-NettyClient" class="headerlink" title="8.4 rpc-core 实现 NettyClient"></a>8.4 rpc-core 实现 NettyClient</h2><p>客户端的创建流程：</p>
<p>1.创建一个 <code>NioEventLoopGroup</code> 对象实例</p>
<p>2.创建客户端启动的引导类是 <code>Bootstrap</code></p>
<p>3.通过 <code>.group()</code> 方法给引导类 <code>Bootstrap</code> 配置一个线程组</p>
<p>4.通过<code>channel()</code>方法给引导类 <code>Bootstrap</code>指定了 IO 模型为<code>NIO</code></p>
<p>5.通过 <code>.childHandler()</code>给引导类创建一个<code>ChannelInitializer</code> ，然后指定了客户端消息的业务处理逻辑 <code>HelloClientHandler</code> 对象</p>
<p>6.调用 <code>Bootstrap</code> 类的 <code>connect()</code>方法进行连接，这个方法需要指定两个参数：</p>
<ul>
<li><code>inetHost</code> : ip 地址</li>
<li><code>inetPort</code> : 端口号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(remoteAddress, <span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.validate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doResolveAndConnect(remoteAddress, <span class="keyword">this</span>.config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>connect</code> 方法返回的是一个 <code>Future</code> 类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功，进而打印出连接信息。具体做法很简单，只需要对代码进行以下改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个 NioEventLoopGroup 对象实例</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//3.指定线程组</span></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">// 5.这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()))</span><br><span class="line">                                .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6.尝试建立连接</span></span><br><span class="line">            ChannelFuture future = bootstrap.connect(host, port).sync();</span><br><span class="line">            logger.info(<span class="string">&quot;客户端连接到服务器 &#123;&#125;:&#123;&#125;&quot;</span>, host, port);</span><br><span class="line">            Channel channel = future.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isSuccess()) &#123;</span><br><span class="line">                        logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 7.等待连接关闭（阻塞，直到Channel关闭）</span></span><br><span class="line">                channel.closeFuture().sync();</span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">                RpcResponse rpcResponse = channel.attr(key).get();</span><br><span class="line">                <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态代码块中就直接配置好了 Netty 客户端，等待发送数据时启动，channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 AttributeKey 的方式阻塞获得返回结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">RpcResponse rpcResponse = channel.attr(key).get();</span><br></pre></td></tr></table></figure>

<p>通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 NettyClientHandler 中看到放入的过程。</p>
<h2 id="8-5-rpc-core-自定义传输协议和编码、解码器"><a href="#8-5-rpc-core-自定义传输协议和编码、解码器" class="headerlink" title="8.5 rpc-core 自定义传输协议和编码、解码器"></a>8.5 rpc-core 自定义传输协议和编码、解码器</h2><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。</p>
<p>我们定义的协议是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>魔数（4 bytes）：</strong>魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li>
<li><strong>Package Type（4 bytes）：</strong>标明这是一个调用请求还是调用响应</li>
<li><strong>Serializer Type（4 bytes）：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化 方式。</li>
<li><strong>Data Length（4 bytes）：</strong>实际数据的长度，设置这个字段主要防止<strong>粘包</strong></li>
<li><strong>Data（Length: ${Data Length} ）：</strong>经过序列化后的实际数据，可能是 RpcRequest 也可能是 RpcResponse 经过序列化后的字节，取决于 Package Type。</li>
</ul>
<h2 id="8-6-rpc-core-编码器"><a href="#8-6-rpc-core-编码器" class="headerlink" title="8.6 rpc-core 编码器"></a>8.6 rpc-core 编码器</h2><p>CommonEncoder 继承了MessageToByteEncoder 类，见名知义，就是把 Message（实际要发送的对象）转化成 Byte 数组。CommonEncoder 的工作很简单，就是把 RpcRequest 或者 RpcResponse 包装成协议包。 根据上面提到的协议格式，将各个字段写到管道里就可以了，这里 serializer.getCode() 获取序列化器的编号，之后使用传入的序列化器将请求或响应包序列化为字节数组写入管道即可。</p>
<p><strong>CommonEncoder 编码器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-7-rpc-core-解码器"><a href="#8-7-rpc-core-解码器" class="headerlink" title="8.7 rpc-core 解码器"></a>8.7 rpc-core 解码器</h2><p>CommonDecoder 继承自 ReplayingDecoder ，与 MessageToByteEncoder 相反，它用于将收到的字节序列还原为实际对象。主要就是一些字段的校验，比较重要的就是取出序列化器的编号，以获得正确的反序列化方式，并且读入 length 字段来确定数据包的长度（防止粘包），最后读入正确大小的字节数组，反序列化成对应的对象。</p>
<p><strong>CommonDecoder 解码器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-8-rpc-core-序列化接口"><a href="#8-8-rpc-core-序列化接口" class="headerlink" title="8.8 rpc-core 序列化接口"></a>8.8 rpc-core 序列化接口</h2><p>序列化器接口（<code>CommonSerializer</code>）如下：</p>
<p>主要就是四个方法，序列化，反序列化，获得该序列化器的编号，已经根据编号获取序列化器，这里我已经写了一个示例的 JSON 序列化器，Kryo 序列化器会在后面讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 的序列化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsBytes(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">                obj = handleRequest(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型</span></span><br><span class="line"><span class="comment">        需要重新判断处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handleRequest</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将要反序列化的对象obj传入</span></span><br><span class="line">        RpcRequest rpcRequest = (RpcRequest) obj;</span><br><span class="line">        <span class="comment">//遍历参数的类型数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">            <span class="comment">//获取参数的类信息</span></span><br><span class="line">            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">            <span class="comment">//isAssignableFrom判断参数类型和反序列化后的参数类型是否匹配（不匹配说明反序列化有问题）</span></span><br><span class="line">            <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">                <span class="comment">//把rpcRequest.getParameters()[i]转成json序列，并把结果输出成字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">                <span class="comment">//将不正确的参数，转换成 clazz 类的 Java 类型</span></span><br><span class="line">                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;JSON&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 序列化工具我使用的是 Jackson，在 pom.xml 中添加依赖即可。序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。</p>
<p>上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的类型信息。</p>
<blockquote>
<p>注：isAssignableFrom方法</p>
<p>有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a），以及方法中作为参数的这个类对象（称之为对象b），这两个对象如果满足以下条件则返回true，否则返回false：</p>
<ul>
<li>a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口</li>
<li>a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口</li>
</ul>
</blockquote>
<blockquote>
<p>注：ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</p>
<p><strong>序列化：</strong>ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</p>
<ul>
<li>writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</li>
<li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</li>
<li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</li>
<li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</li>
</ul>
<p><strong>反序列化：</strong></p>
<ul>
<li><p>readValue() 方法：将 json 数据源转换成指定格式的 Java 类型</p>
<p>第一个参数是JSON数据源(字符串, 流或者文件), 第二个参数是解析目标Java类</p>
</li>
</ul>
</blockquote>
<h2 id="8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler"><a href="#8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler" class="headerlink" title="8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler"></a>8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler</h2><p>NettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。</p>
<p><strong>NettyServerhandler</strong> 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            String interfaceName = msg.getInterfaceName();</span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            Object result = requestHandler.handle(msg, service);</span><br><span class="line">            ChannelFuture future = ctx.writeAndFlush(RpcResponse.success(result));</span><br><span class="line">            future.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler</strong> 用于接收 RpcResponse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">            ctx.channel().attr(key).set(msg);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-10-修改代理类-RpcClientProxy"><a href="#8-10-修改代理类-RpcClientProxy" class="headerlink" title="8.10 修改代理类 RpcClientProxy"></a>8.10 修改代理类 RpcClientProxy</h2><p>RpcClientProxy 通过传入不同的 Client（SocketClient、NettyClient）来切换客户端不同的发送方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line"></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes());</span><br><span class="line">        <span class="keyword">return</span> client.sendRequest(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-11测试"><a href="#8-11测试" class="headerlink" title="8.11测试"></a>8.11测试</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>SocketTestClient</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyTestClient</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><strong>SocketTestServer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        SocketServer socketServer = <span class="keyword">new</span> SocketServer(serviceRegistry);</span><br><span class="line">        socketServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyTestServer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry registry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        registry.register(helloService);</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer();</span><br><span class="line">        server.start(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）RPC实现注册多个服务</title>
    <url>/2021/05/03/%EF%BC%88%E4%BA%8C%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-rpc-core-服务注册表"><a href="#1-rpc-core-服务注册表" class="headerlink" title="1. rpc-core 服务注册表"></a>1. rpc-core 服务注册表</h1><p>上一节中，我们使用 JDK 序列化和 Socket 实现了一个最基本的 RPC 框架，当服务端测试时，在注册完 <code>helloService</code> 后，服务器就自行启动了，也就是说，一个服务器只能注册一个服务，这种设计大大降低了服务端的作用。</p>
<p>我们要实现服务端可以注册多个服务，就要实现服务注册和服务端启动的解耦。</p>
<p>创建一个 ServiceRegistry 接口，这个接口具有两个功能：</p>
<ul>
<li>将一个服务注册进注册表</li>
<li>根据服务名称获取服务实体</li>
</ul>
<p>其实就是充当一个容器，这个容器很简单，就是保存一些本地服务的信息，并且在获得一个服务名字的时候能够返回这个服务的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个服务注册进注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 服务实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务名称获取服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口的实现类：<code>DefaultServiceRegistry</code></p>
<blockquote>
<p>注：<code>getCanonicalName()</code>返回 Java 语言规范定义的底层类的规范名称，可以理解为返回的是正常的包含路径的类名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DefaultServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务名与提供服务的对象的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//保存当前有哪些对象已经被注册</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务的注册功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service 待注册的服务实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(T service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取服务对象实现的接口的完整类名作为注册的服务名（ConcurrentHashMap中的键值）</span></span><br><span class="line">        String serviceName = service.getClass().getCanonicalName();</span><br><span class="line">        <span class="keyword">if</span>(registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//当服务不存在时，注册服务</span></span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        <span class="comment">//获取该对象实现的接口数组</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_IMPLEMENT_ANY_INTERFACE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将服务实现的接口的类名</span></span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; i : interfaces) &#123;</span><br><span class="line">            serviceMap.put(i.getCanonicalName(), service);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, interfaces, serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务获取功能的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 服务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">getService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据服务的名称，从ConcurrentHashMap中获取服务并返回对应服务</span></span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span>(service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-tset-server-注册与启动解耦"><a href="#2-tset-server-注册与启动解耦" class="headerlink" title="2.tset-server 注册与启动解耦"></a>2.tset-server 注册与启动解耦</h1><p>上一章中我们的 RPCServer 代码逻辑为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器正在启动...&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接！Ip为：&quot;</span> + socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就使得，我们在注册一个服务时，会同时启动服务端，也就导致了一个服务器只能提供一个服务。</p>
<p>为了<strong>降低服务的注册和服务器启动的耦合度</strong>，我们不会把 ServiceRegistry 和某一个 RpcServer 绑定在一起，而是在创建 RpcServer 对象时，传入一个 ServiceRegistry 作为这个服务的注册表（ServiceRegistry 是已经注册好服务的）。</p>
<p>那么 RpcServer 这个类现在就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在创建 RpcServer 时需要传入一个已经注册好服务的 ServiceRegistry，而原来的 register 方法也被改成了 start 方法，因为服务的注册已经不由 RpcServer 处理了，它只需要启动就行了。</p>
<p>而在每一个请求处理线程（RequestHandlerThread）中也就需要传入 ServiceRegistry 了，这里把处理线程和处理逻辑分成了两个类：RequestHandlerThread 只是一个线程，从ServiceRegistry 获取到提供服务的对象后，就会把 RpcRequest 和服务对象直接交给 RequestHandler 去处理，反射等过程被放到了 RequestHandler 里。</p>
<p><strong>RequesthandlerThread类：</strong>处理线程，接受对象等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandlerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandlerThread</span><span class="params">(Socket socket, RequestHandler requestHandler, ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">            <span class="comment">//从输入流中获取rpcRequest请求的信息</span></span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            <span class="comment">//从rpcRequest中提取需要调用的接口名称</span></span><br><span class="line">            String interfaceName = rpcRequest.getInterfaceName();</span><br><span class="line">            <span class="comment">//根据接口名称从服务注册表中获取服务</span></span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            <span class="comment">//调用requestHandler来处理服务</span></span><br><span class="line">            Object result = requestHandler.handle(rpcRequest, service);</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(result));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RequestHandler：</strong>通过反射进行方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过封装的invokeTargetMethod方法获取返回值</span></span><br><span class="line">            result = invokeTargetMethod(rpcRequest, service);</span><br><span class="line">            logger.info(<span class="string">&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke通过函数名反射调用相应的函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        Method method;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h1><h2 id="3-1服务器端"><a href="#3-1服务器端" class="headerlink" title="3.1服务器端"></a>3.1服务器端</h2><p>实现了注册服务与服务器启动的解耦，一个服务器可以注册多个服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向注册表中注册服务</span></span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        <span class="comment">//将注册表放入服务器中</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer(serviceRegistry);</span><br><span class="line">        <span class="comment">//启动服务器</span></span><br><span class="line">        rpcServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2客户端"><a href="#3-2客户端" class="headerlink" title="3.2客户端"></a>3.2客户端</h2><p>没有变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）RPC的介绍及初步实现</title>
    <url>/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<blockquote>
<p><strong>该项目文章引用自声哥和 Guide 哥！（我只是个搬运工！）</strong></p>
</blockquote>
<h1 id="1-RPC介绍"><a href="#1-RPC介绍" class="headerlink" title="1.RPC介绍"></a>1.RPC介绍</h1><h2 id="1-1什么是RPC"><a href="#1-1什么是RPC" class="headerlink" title="1.1什么是RPC"></a>1.1什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：<strong>客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样</strong>。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。那么我们至少从这样的描述中挖掘出几个要点：</p>
<ol>
<li><strong>RPC是协议：</strong>既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。这里要说明一下，目前技术的发展趋势来看，实现了RPC协议的应用工具往往都会附加其他重要功能，例如Dubbo还包括了服务治等功能。</li>
<li><strong>网络协议和网络IO模型对其透明：</strong>既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。</li>
<li><strong>信息格式对其透明：</strong>我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</li>
<li><strong>应该有跨语言能力：</strong>为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</li>
</ol>
<h2 id="1-2RPC的原理"><a href="#1-2RPC的原理" class="headerlink" title="1.2RPC的原理"></a>1.2RPC的原理</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC1.png" style="zoom:90%;">

<p><strong>一次完整的RPC调用流程（同步调用，异步另说）如下：</strong></p>
<p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>
<p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p>
<p><strong>RPC实现的基本流程：</strong></p>
<p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p>
<h1 id="2-常见的RPC框架"><a href="#2-常见的RPC框架" class="headerlink" title="2.常见的RPC框架"></a>2.常见的RPC框架</h1><h1 id="3-Socket-网络通信基础"><a href="#3-Socket-网络通信基础" class="headerlink" title="3. Socket 网络通信基础"></a>3. Socket 网络通信基础</h1><h2 id="3-1-Socket-套接字-介绍"><a href="#3-1-Socket-套接字-介绍" class="headerlink" title="3.1 Socket(套接字)介绍"></a>3.1 Socket(套接字)介绍</h2><p>Socket是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操 作套接字的时候，和我们读写文件很像。套接字是IP地址与端口的组合，套接字 Socket=（IP地址：端口号）。</p>
<p>要通过互联网进行通信，至少需要一对套接字： </p>
<ol>
<li><p>运行于服务器端的Server Socket </p>
</li>
<li><p>运行于客户机端的Client Socket 在Java 开发中使用Socket 时会常用到两个类，都在 java.net 包中：</p>
<p>Socket : 一般用于客户端 </p>
<p>Server Socket : 用于服务端</p>
</li>
</ol>
<h2 id="3-2-Socket-网络通信过程"><a href="#3-2-Socket-网络通信过程" class="headerlink" title="3.2 Socket 网络通信过程"></a>3.2 Socket 网络通信过程</h2><ol>
<li><p>建立服务端并且监听客户端请求 </p>
</li>
<li><p>客户端请求，服务端和客户端建立连接 </p>
</li>
<li><p>两端之间可以传递数据</p>
</li>
<li><p>关闭资源 </p>
</li>
</ol>
<p>对应到服务端和客户端的话，是下面这样的。 </p>
<p><strong>服务器端：</strong></p>
<ol>
<li><p>创建 ServerSocket 对象并且绑定地址（ip）和端口号(port)： server.bind(new InetSocketAddress(host, port))</p>
</li>
<li><p>通过 <strong>accept()</strong> 方法监听客户端请求 </p>
<p>ServerSocket 的 <strong>accept（）方法是阻塞方法</strong>，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发 送的连接请求才会继续往下执行代码。</p>
</li>
<li><p>连接建立后，通过输入流读取客户端发送的请求信息 </p>
</li>
<li><p>通过输出流向客户端发送响应信息 </p>
</li>
<li><p>关闭相关资源 </p>
</li>
</ol>
<p><strong>客户端：</strong></p>
<ol>
<li>创建 Socket 对象并且连接指定的服务器的地址（ip）和端口号(port)： socket.connect(inetSocketAddress) </li>
<li>连接建立后，通过输出流向服务器端发送请求信息 </li>
<li>通过输入流获取服务器响应的信息 </li>
<li>关闭相关资源</li>
</ol>
<h1 id="4-静态代理与动态代理-JDK-CGLIB"><a href="#4-静态代理与动态代理-JDK-CGLIB" class="headerlink" title="4.静态代理与动态代理(JDK/CGLIB)"></a>4.静态代理与动态代理(JDK/CGLIB)</h1><h1 id="5-RPC框架的设计"><a href="#5-RPC框架的设计" class="headerlink" title="5.RPC框架的设计"></a>5.RPC框架的设计</h1><h2 id="5-1简单的RPC框架"><a href="#5-1简单的RPC框架" class="headerlink" title="5.1简单的RPC框架"></a>5.1简单的RPC框架</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC2.png" style="zoom:110%;">

<p><strong>一个最简单的RPC框架的实现流程：（消费者client和生产者server）</strong></p>
<p>Server 向注册中心注册服务，Client 能够从注册中心获取服务相关的信息，然后再通过网络请求服务提供端 Server（打 call 的过程）</p>
<h2 id="5-2完整的RPC框架"><a href="#5-2完整的RPC框架" class="headerlink" title="5.2完整的RPC框架"></a>5.2完整的RPC框架</h2><img src="/2021/05/01/%EF%BC%88%E4%B8%80%EF%BC%89RPC%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/GitHub\MyBlogs\source\_posts\2021-05-01-RPC的原理\RPC3.png" style="zoom:90%;">

<p>可以注意到，完成的RPC框架的实现需要以下几部分功能：</p>
<ol>
<li><p><strong>服务注册中心</strong></p>
<p>在分布式架构中，有一个重要的组件，就是服务注册中心，它用于保存多个服务提供者的信息，每个服务提供者在启动时都需要向注册中心注册自己所拥有的服务。这样客户端在发起 RPC 时，就可以直接去向注册中心请求服务提供者的信息，如果拿来的这个挂了，还可以重新请求，并且在这种情况下可以很方便地实现负载均衡。</p>
<p>常见的注册中心有 Eureka、Zookeeper 和 Nacos。</p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务。 服务端启动的时候将服务名称及其对应的**地址(ip+port)**注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之 后，服务消费端就可以通过网络请求服务端了。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>网络传输</strong></p>
<p>我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端</p>
<p>网络传输的具体实现：</p>
<ul>
<li><p>使用 Socket ： Java 中最原始、最基础的网络通信方式。但是，<strong>Socket 是 阻塞 IO、性能低并且功能单一</strong>。</p>
</li>
<li><p>使用同步非阻塞的 I/O 模型 NIO ，但是用它来进行网络编程真的太麻烦了。可以使用基于 NIO 的网络编程框架 <strong>Netty</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>序列化与反序列化</strong></p>
<p>要在网络传输数据就要涉及到序列化。</p>
<p>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够 让 Java 对象在网络中传输我们需要将其序列化为二进制的数据。我们最终需要的还是目标 Java 对 象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次反序 列化。 </p>
<p>另外，不仅网络传输的时候需要用到序列化和反序列化，将对象存储到文件、数据库等场景都需要 用到序列化和反序列化。</p>
<p><strong>实现序列化与反序列化的方式：</strong></p>
<p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code> 接口即可，不过这种方式不推荐，因为不支 持跨语言调用并且性能比较差。 </p>
<p>现在比较常用序列化的有</p>
<ul>
<li><p>hessian</p>
</li>
<li><p><strong>kyro</strong></p>
</li>
<li><p>protostuff</p>
</li>
</ul>
</li>
<li><p><strong>动态代理</strong></p>
<p>RPC 的主要目的就是让我们调用远程方法像调用本地方法一 样简单，我们<strong>不需要关心远程方法调用的细节</strong>比如网络传输。</p>
<p><strong>怎样才能屏蔽程方法调用的底层细节呢？</strong></p>
<p>就是动态代理。简单来说，当你调用远程方法的时候，<strong>实际会通过代理对象来传输网络请求</strong>。</p>
</li>
<li><p><strong>负载均衡</strong></p>
<p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当 客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务 器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就 不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。</p>
</li>
<li><p><strong>传输协议</strong></p>
<p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方） 交流的基础。 </p>
<p>简单来说：<strong>通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二级制数据之后，就可以正确的解析出我们需要的数据。</strong>这有一点像密文传输的感觉。</p>
<p>通常一些标准的 RPC 协议包含下面这些内容：</p>
<ul>
<li><p><strong>魔数 ：</strong> 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后， 服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协 议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </p>
</li>
<li><p><strong>序列化器编号 ：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化 方式。</p>
</li>
<li><p><strong>消息体长度 ：</strong>运行时计算出来。</p>
</li>
</ul>
<p>等…….</p>
</li>
</ol>
<h1 id="6-初步实现RPC"><a href="#6-初步实现RPC" class="headerlink" title="6.初步实现RPC"></a>6.初步实现RPC</h1><h2 id="6-1-rpc-api-包下创建通用接口"><a href="#6-1-rpc-api-包下创建通用接口" class="headerlink" title="6.1 rpc-api 包下创建通用接口"></a>6.1 rpc-api 包下创建通用接口</h2><p>在 rpc-api 包下创建通用接口，也就是<strong>服务端与客户端的公共调用接口</strong></p>
<blockquote>
<p><strong>接口HelloService</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.wangjin.rpc.api;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello方法需要传递一个对象，HelloObject对象，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//这个对象需要实现Serializable接口，因为它需要在调用过程中从客户端传递给服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个对象需要实现<code>Serializable</code>接口，因为它需要在调用过程中从客户端传递给服务端。</p>
<blockquote>
<p>注：</p>
<p>@Data 注解作用是自动生成get和set方法</p>
<p>@AllArgsConstructor 使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数</p>
<p>@NoArgsConstructor 使用后创建一个无参构造函数</p>
</blockquote>
<h2 id="6-2-test-server-包下实现通用接口"><a href="#6-2-test-server-包下实现通用接口" class="headerlink" title="6.2 test-server 包下实现通用接口"></a>6.2 test-server 包下实现通用接口</h2><p>接着我们在服务端对这个接口进行实现，实现的方式也很简单，返回一个字符串就行：</p>
<blockquote>
<p><strong>HelloServiceImpl 实现类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建日志对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到：&#123;&#125;&quot;</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是调用的返回值，id=&quot;</span> + object.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-rpc-common-包下定义传输协议"><a href="#6-3-rpc-common-包下定义传输协议" class="headerlink" title="6.3 rpc-common 包下定义传输协议"></a>6.3 rpc-common 包下定义传输协议</h2><p>当我们想要调用服务端的某个接口的方法时，为了让服务端唯一确定需要调用的接口的方法。我们将请求封装成实体类 <strong>RpcRequest</strong> ，然后到服务端解析，找到对应的接口中的方法，传入相应的参数。</p>
<blockquote>
<p><strong>RpcRequest 实体类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是心跳包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean heartBeat;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>@Builder标签的作用之一是为了解决在某个类有很多构造函数的情况，也省去写很多构造函数的麻烦</p>
<p>在设计模式中的思想是：用一个内部类去实例化一个对象，避免一个类出现过多构造函数</p>
</blockquote>
<p>那么服务器调用完这个方法后，需要给客户端返回哪些信息呢？如果调用成功的话，显然需要返回值，如果调用失败了，就需要失败的信息，这里封装成一个       **RpcResponse **对象：</p>
<blockquote>
<p><strong>RpcResponse 实体类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应对应的请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RpcResponse 实体类中包含两个静态的方法：</p>
<p>一个用于请求成功处理时，返回的 RpcResponse 对象</p>
<p>一个用于请求处理失败时，返回的 RpcResponse 对象</p>
<p>ResponseCode 枚举类，用于初始化 RpcResponse 对象中的 statusCode 和 message 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;调用方法成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">&quot;调用方法失败&quot;</span>),</span><br><span class="line">    METHOD_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定方法&quot;</span>),</span><br><span class="line">    CLASS_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定类&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-rpc-core-包"><a href="#6-4-rpc-core-包" class="headerlink" title="6.4 rpc-core 包"></a>6.4 rpc-core 包</h2><h3 id="6-4-1动态代理实现客户端"><a href="#6-4-1动态代理实现客户端" class="headerlink" title="6.4.1动态代理实现客户端"></a>6.4.1动态代理实现客户端</h3><p>客户端方面，由于在客户端这一侧我们并没有接口的具体实现类，就没有办法直接生成实例对象。这时，我们可以通过动态代理的方式生成实例，并且调用方法时生成需要的RpcRequest对象并且发送给服务端。</p>
<p>采用JDK动态代理，代理类是需要实现<code>InvocationHandler</code>接口的。</p>
<p>需要传递host和port来指明服务端的位置。并且使用getProxy()方法来生成代理对象。</p>
<p><code>InvocationHandler</code>接口需要实现invoke()方法，来指明代理对象的方法被调用时的动作。在这里，我们显然就需要生成一个RpcRequest对象，发送出去，然后返回从服务端接收到的结果即可：</p>
<blockquote>
<p><strong>RpcClientProxy 类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取代理对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">                .interfaceName(method.getDeclaringClass().getName())</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .paramTypes(method.getParameterTypes())</span><br><span class="line">                .build();</span><br><span class="line">        RpcClient rpcClient = <span class="keyword">new</span> RpcClient();</span><br><span class="line">        <span class="keyword">return</span> ((RpcResponse) rpcClient.sendRequest(rpcRequest, host, port)).getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<p>@SuppressWarnings(“unchecked”)<br>告诉编译器<strong>忽略 unchecked 警告信息</strong>，如使用List，ArrayList等未进行参数化产生的警告信息。</p>
</blockquote>
<p>发送的逻辑使用了一个RpcClient对象来实现，这个对象的作用，就是将一个对象发过去，并且接受返回的对象。</p>
<p>代码实现逻辑很简单，直接使用Java的序列化方式，通过Socket传输。创建一个Socket，获取ObjectOutputStream对象，然后把需要发送的对象传进去即可，接收时获取ObjectInputStream对象，readObject()方法就可以获得一个返回的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest, String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            <span class="keyword">return</span> objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-2服务端的实现"><a href="#6-4-2服务端的实现" class="headerlink" title="6.4.2服务端的实现"></a>6.4.2服务端的实现</h3><p>使用一个ServerSocket通过accep() 方法监听客户端请求，如果发来了请求就创建一个线程，在新线程中处理调用（这里创建线程采用线程池）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcServer.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用一个ServerSocket通过accep() 方法监听客户端请求，如果发来了请求就创建一个线程，在新线程中处理调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器正在启动...&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接！Ip为：&quot;</span> + socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> WorkerThread(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程的所进行的处理如下所示：将客户端传入的请求解析，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WorkerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> Object service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket, Object service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">             ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) objectInputStream.readObject();</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            Object returnObject = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            objectOutputStream.writeObject(RpcResponse.success(returnObject));</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-5测试"><a href="#6-5测试" class="headerlink" title="6.5测试"></a>6.5测试</h2><h3 id="6-5-1服务器端"><a href="#6-5-1服务器端" class="headerlink" title="6.5.1服务器端"></a>6.5.1服务器端</h3><p>服务端侧，我们已经在上面实现了一个HelloService的实现类HelloServiceImpl的实现类了，我们只需要创建一个RpcServer并且把这个实现类注册进去就行了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注入HelloServiceImpl实例</span></span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        RpcServer rpcServer = <span class="keyword">new</span> RpcServer();</span><br><span class="line">        rpcServer.register(helloService, <span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-5-2客户端"><a href="#6-5-2客户端" class="headerlink" title="6.5.2客户端"></a>6.5.2客户端</h3><p>客户端方面，我们需要通过动态代理，生成代理对象，并且调用，动态代理会自动帮我们向服务端发送请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>RPC项目</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构相关</title>
    <url>/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-各种树"><a href="#1-各种树" class="headerlink" title="1.各种树"></a>1.各种树</h1><h2 id="1-1完全二叉树"><a href="#1-1完全二叉树" class="headerlink" title="1.1完全二叉树"></a>1.1完全二叉树</h2><p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。</p>
<h2 id="1-2满二叉树"><a href="#1-2满二叉树" class="headerlink" title="1.2满二叉树"></a>1.2满二叉树</h2><p>除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。</p>
<h2 id="1-3堆（实质是由二叉树实现的）"><a href="#1-3堆（实质是由二叉树实现的）" class="headerlink" title="1.3堆（实质是由二叉树实现的）"></a>1.3堆（实质是由二叉树实现的）</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<h2 id="1-4平衡二叉树"><a href="#1-4平衡二叉树" class="headerlink" title="1.4平衡二叉树"></a>1.4平衡二叉树</h2><p>任意节点的子树的高度差都小于等于1。常见的符合平衡树的有，B树（多路平衡搜索树）、AVL树（二叉平衡搜索树）等。</p>
<h2 id="1-5二叉查找树（BST）"><a href="#1-5二叉查找树（BST）" class="headerlink" title="1.5二叉查找树（BST）"></a>1.5二叉查找树（BST）</h2><p>二叉查找树的性质：</p>
<ol>
<li>左子树上所有结点的值均小于或等于它的根结点的值。 </li>
<li>右子树上所有结点的值均大于或等于它的根结点的值。</li>
<li>左、右子树也分别为二叉排序树。</li>
</ol>
<p>二叉查找树的优点：这种方式正是二分查找的思想，查找所需的最大次数等同于二叉查找树的高度</p>
<p>二叉查找树的缺点：当先后插入的关键字有序时，BST退化成单支树结构，查找的性能会打折扣，几乎成为了线性。（因为新插入的节点不需要改变原有树的组织结构）</p>
<h2 id="1-6红黑树"><a href="#1-6红黑树" class="headerlink" title="1.6红黑树"></a>1.6红黑树</h2><p>红黑树为了解决这个缺陷，应运而生。</p>
<p>红黑树是一种自平衡的二叉查找树。除了符合二叉查找树的基本特性外，它还具有下列的附加特性：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节）</li>
<li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ol>
<p>由于这些规则限制，才保证了红黑树的自平衡性，红黑树从根到叶子节点的最长路径不会超过最短路径的2倍。</p>
<p>当插入或者删除节点时，红黑树的规则就有可能被打破，这时候就需要做出一些调整（<strong>变色，左旋、右旋</strong>），来继续维持我们的规则，也就是保证了自平衡性。</p>
<p>下图中这棵树，就是一颗典型的红黑树：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树1.png" style="zoom:110%;">

<p>向原红黑树插入值为21的新节点：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树2.png" style="zoom:110%;">

<p>由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。</p>
<p><strong>变色：</strong>（暂时认为，当两个节点同时为红色节点，或者一条路径上黑色节点的个数与其它路径上的节点个数不同时）</p>
<p>为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。</p>
<p>下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树3.png" style="zoom:110%;">

<p>但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树4.png" style="zoom:110%;">

<p>此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树5.png" style="zoom:110%;">

<p>此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。</p>
<p>变色已无法解决问题——通过<strong>左旋转</strong>进行处理：</p>
<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树6.png" style="zoom:110%;">

<img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/GitHub\MyBlogs\source\_posts\2021-04-26-数据结构\红黑树7.png" style="zoom:110%;">

<p>然后还要进行变色、右旋转、或者再进行左旋转等操作，将该红黑树变回满足要求的红黑树</p>
<p><strong>红黑树的应用：</strong></p>
<p>HashMap为了防止链表过长，查询的效率降低，当链表超过一定的长度后，将链表结构转换为红黑树。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据结构相关</tag>
      </tags>
  </entry>
  <entry>
    <title>其它</title>
    <url>/2021/04/25/%E5%85%B6%E5%AE%83/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">主站-470. 用 Rand7() 实现 Rand10()</a></strong></p>
<p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。</p>
<p>不要使用系统的 Math.random() 方法。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>随机数的产生一定是基于等概率的，也就是说rand7方法产生（1,7）内的随机数一定是等概率的，我们可以利用这点让产生的（1,10）内的每个整数也是等概率的，一般思路如下面这样构建：</p>
<p>$$<br>(rand7()−1)∗7+rand7()<br>$$<br>首先 rand7()−1 得到的数的集合为 {0,1,2,3,4,5,6}</p>
<p>再乘 7 后得到的集合 A 为 {0，7，14，21，28，35，42}</p>
<p>后面 rand7() 得到的集合B为 {1,2,3,4,5,6,7}</p>
<p>我们得到的集合 A 和集合 B，利用这两个集合，得到的数的范围是 1～49，每个数它显然是等概率出现的，因为这两个事件是独立事件<br>$$<br>P(AB)=P(A)∗P(B)=\frac{1}{7}\ *\ \frac{1}{7}<br>$$<br>也就是说（1,49）内产生的每个数字的概率为1/49,那么我们只要范围小于10的，这时，（0,10）中每个整数产生的概率也是相等的。</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首先得到一个数</span></span><br><span class="line">        <span class="keyword">int</span> num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        <span class="comment">// 只要它还大于10，那就给我不断生成，因为我只要范围在1-10的，最后直接返回就可以了</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            num = (rand7() - <span class="number">1</span>) * <span class="number">7</span> + rand7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/palindrome-number/">主站-9. 回文数</a></strong></p>
<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过取整和取余操作获取整数中对应的数字进行比较。</p>
<p>举个例子：1221 这个数字。</p>
<ul>
<li>通过计算 1221 / 1000， 得首位1</li>
<li>通过计算 1221 % 10， 可得末位 1</li>
<li>进行比较</li>
<li>再将 22 取出来继续比较</li>
</ul>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>((x/k)&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">           k*=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> high=x/k;</span><br><span class="line">         <span class="keyword">int</span> low=x%<span class="number">10</span>;</span><br><span class="line">         <span class="keyword">if</span>(high!=low)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         x=x%k;</span><br><span class="line">         x=x/<span class="number">10</span>;</span><br><span class="line">         k/=<span class="number">100</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/reverse-integer/">主站-7. 整数反转</a></strong></p>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
</blockquote>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>每次取整数 x 的最后一位，拼接到 res 上</p>
<p>为了防止溢出，在拼接的过程中，要提前预判拼接的值是否超出了 Integer 的范围，正数最后一位是 7 ，负数最后一位是 -8</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> bound=Integer.MAX_VALUE/<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">int</span> bit=x%<span class="number">10</span>;</span><br><span class="line">          <span class="keyword">if</span>(res&gt;bound||res==-bound&amp;&amp;bit&gt;<span class="number">7</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(res&lt;-bound||res==-bound&amp;&amp;bit&lt;-<span class="number">8</span>)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          res=res*<span class="number">10</span>+bit;</span><br><span class="line">          x/=<span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring相关</title>
    <url>/2021/04/23/Spring%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-Spring-的简介"><a href="#1-Spring-的简介" class="headerlink" title="1. Spring 的简介"></a>1. Spring 的简介</h1><p>Spring是一个<strong>轻量级的IOC和AOP容器</strong>框架。是为Java应用程序提供基础服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</p>
<p>Spring的<strong>核心模块</strong>如下所示：</p>
<ul>
<li><strong>Spring Core：</strong>是核心类库，提供IOC服务； </li>
<li><strong>Spring Context：</strong>提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）； </li>
<li><strong>Spring AOP：</strong>提供AOP服务； </li>
<li><strong>Spring DAO：</strong>对JDBC进行了抽象，简化了数据访问异常等处理； </li>
<li><strong>Spring ORM：</strong>对现有的ORM持久层框架进行了支持； </li>
<li><strong>Spring Web：</strong>提供了基本的面向Web的综合特性； </li>
<li><strong>Spring MVC：</strong>提供面向Web应用的Model-View-Controller实现。 </li>
</ul>
<h1 id="2-Spring-的优点"><a href="#2-Spring-的优点" class="headerlink" title="2. Spring 的优点"></a>2. Spring 的优点</h1><ul>
<li>Spring 将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。比如：在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。</li>
<li><strong>AOP面向切面编程</strong>，可以将通用的任务抽取出来，复用性更高； </li>
<li>Spring对于其余<strong>主流框架都提供了很好的支持</strong>，代码的侵入性很低。 </li>
</ul>
<h1 id="3-SpringIOC-控制反转"><a href="#3-SpringIOC-控制反转" class="headerlink" title="3. SpringIOC(控制反转)"></a>3. SpringIOC(控制反转)</h1><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><strong>Spring IoC的初始化过程：</strong></p>
<img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-23-Spring相关\SpringIOC初始化过程.png" alt="Spring IoC的初始化过程" style="zoom:110%;">

<h1 id="4-SpringAOP-面向切面编程"><a href="#4-SpringAOP-面向切面编程" class="headerlink" title="4. SpringAOP(面向切面编程)"></a>4. SpringAOP(面向切面编程)</h1><p>AOP的核心思想就是：在不改变原来的代码的情况下，实现了对原有功能的增强</p>
<p><strong>AOP(Aspect-Oriented Programming:面向切面编程)：</strong>能够将那些与业务无关，却为<strong>业务模块所共同调用的逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码<strong>，</strong>降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p><strong>重要概念：</strong></p>
<p><strong>切入点：</strong>就是在类里边可以有很多方法被增强，比如实际操作中，只是增强了个别方法，则<strong>定义实际被增强的某个方法为切入点</strong></p>
<p><strong>通知/增强：</strong> 就是指增强的逻辑，<strong>比如扩展日志功能，这个日志功能称为增强</strong></p>
<p><strong>切面：</strong>就是把增强应用到具体方法上面的过程称为切面。</p>
<h2 id="4-1-两种实现-SpringAOP-的方式"><a href="#4-1-两种实现-SpringAOP-的方式" class="headerlink" title="4.1 两种实现 SpringAOP 的方式"></a>4.1 两种实现 SpringAOP 的方式</h2><p>JDK 动态代理</p>
<p>cglib 动态代理</p>
<p>==另开一篇文章，专门写两种代理方式。==</p>
<h2 id="4-2-SpringIOC-初始化的过程"><a href="#4-2-SpringIOC-初始化的过程" class="headerlink" title="4.2 SpringIOC 初始化的过程"></a>4.2 SpringIOC 初始化的过程</h2><p><strong>面试官问题：讲一下 IOC 容器的初始化过程吧。</strong></p>
<p><strong>答：</strong>IOC容器的初始化主要包括 <strong>BeanDefinition 资源定位，BeanDefinition 的载入和 BeanDefinition 的注册：</strong> 三个步骤，接下来我们依次介绍。</p>
<ol>
<li><p><strong>Resource资源定位：</strong></p>
<p>Resouce 定位是指 BeanDefinition 的资源定位，也就是 IOC 容器找数据的过程。Spring 中使用外部资源来描述一个 Bean 对象，IOC 容器第一步就是需要定位 Resource 外部资源。由 ResourceLoader 资源加载器完成资源的定位和读取。</p>
</li>
<li><p><strong>BeanDefinition的载入：</strong></p>
<p>载入过程就是把定义好的Bean表示成IOC容器内部的数据结构，即BeanDefinition。在配置文件中每一个Bean都对应着一个BeanDefinition对象。</p>
<p>通过BeanDefinitionReader读取，解析Resource定位的资源，将用户定义好的Bean表示成IOC容器的内部数据结构BeanDefinition。</p>
<p>在IOC容器内部维护着一个BeanDefinitionMap的数据结构，通过BeanDefinitionMap，IOC容器可以对Bean进行更好的管理。</p>
</li>
<li><p><strong>BeanDefinition的注册：</strong></p>
<p>注册就是将前面的BeanDefition保存到Map中的过程，通过 BeanDefinitionRegistry 接口来实现注册。</p>
</li>
</ol>
<p><strong>解析：</strong></p>
<p><strong>IOC 容器的初始化过程就是对 BeanDefinition 资源的定位、载入和注册</strong>，此时容器对 Bean 的依赖注入并没有发生。接下来，我们看下<strong>依赖注入的发生时刻吧。</strong></p>
<p>ApplicationContext 默认会在容器启动的时候创建我们配置好的各个 Bean ，我们的 Bean 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;oneBean&quot;</span>  <span class="attr">class</span>= <span class="string">&quot;com.nowcoder.oneBean&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里边的隐藏属性是 lazy-init，即上边的配置和下边的是一样的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;oneBean&quot;</span>  <span class="attr">class</span>= <span class="string">&quot;com.nowcoder.oneBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span>//开启懒加载</span><br></pre></td></tr></table></figure>

<p><strong>lazy-init=false</strong> 表示不开启延迟加载，在容器启动的时候即创建该 Bean 。对应的，我们还可以配置 lazy-init=true 表示开启延迟加载，那么该 Bean 的创建发生在应用程序<strong>第一次向容器索取 Bean</strong> 时，通过 getBean() 方法的调用完成。</p>
<h1 id="5-SpringBean"><a href="#5-SpringBean" class="headerlink" title="5. SpringBean"></a>5. SpringBean</h1><h2 id="5-1-Spring-中的-bean-的作用域"><a href="#5-1-Spring-中的-bean-的作用域" class="headerlink" title="5.1 Spring 中的 bean 的作用域"></a>5.1 Spring 中的 bean 的作用域</h2><ul>
<li>singleton : 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值。</li>
<li>prototype : 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean()。</li>
<li>request : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>1.被声明为singleton的bean</strong></p>
<p>如果bean的作用域的属性被声明为<strong>singleton</strong>，那么Spring Ioc容器只会创建一个共享的bean实例。对于所有的bean请求，只要id与该bean定义的相匹配，那么Spring在每次需要时都返回同一个bean实例。</p>
<p>Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，singleton作用域是Spring中的缺省作用域。</p>
<p>可以在 bean 的配置文件中设置作用域的属性为 singleton，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A bean definition with singleton scope --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.被声明为prototype的bean</strong></p>
<p>当一个bean的作用域为prototype，表示一个bean定义对应多个对象实例。声明为prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。<strong>prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。</strong>根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。</p>
<p><strong>3.请求作用域</strong></p>
<p>请求作用域参考如下的Bean定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.LoginAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring容器会在每次用到loginAction来处理每个HTTP请求的时候都会创建一个新的LoginAction实例。也就是说，loginActionBean的作用域是HTTP Request级别的。 </p>
<p>当http请求调用作用域为request的bean的时候，每增加一个HTTP请求，Spring就会创建一个新的bean，在请求处理完成之后便及时销毁这个bean。开发者可以随意改变实例的状态，因为通过loginAction请求来创建的其他实例根本看不到开发者改变的实例状态，所有创建的Bean实例都是根据独立的请求来的。</p>
<p><strong>4.会话作用域</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring容器会在每次调用到userPreferences时，在一个单独的HTTP会话周期来创建一个新的UserPreferences实例。换言之，userPreferencesBean的作用域是HTTP Session级别的。</p>
<p>Session中所有http请求共享同一个请求的bean实例。Session结束后就销毁bean。 在request-scoped作用域的Bean上，开发者可以随意的更改实例的状态。同样，使用从同一个userPreferences bean定义创建的其他HTTP Session实例在看不到不是自己的内部状态的修改，因为他们是单个的HTTP会话。每个Session请求都会创建新的userPreferences实例，所以开发者更改一个Bean的状态，对于其他的Bean仍然是不可见的。</p>
<p>==<strong>5.全局作用域（待定）</strong>==</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.AppPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring容器会在整个web应用范围使用到appPreferences的时候创建一个新的AppPreferences的实例。也就是说，appPreferencesBean是在ServletContext级别的，作为常规的ServletContext属性。这种作用域在一些程度上来说和Spring的单例作用域相似，但是也有如下不同之处：</p>
<ol>
<li><p>application作用域是每个ServletContext中包含一个，而不是每个SpringApplicationContext之中包含一个（某些应用中可能包含不止一个ApplicationContext）。</p>
</li>
<li><p>application作用域仅仅作为ServletContext的属性可见，单例Bean是ApplicationContext可见。</p>
</li>
</ol>
<h2 id="5-2-Spring-中的-bean-的生命周期"><a href="#5-2-Spring-中的-bean-的生命周期" class="headerlink" title="5.2 Spring 中的 bean 的生命周期"></a>5.2 Spring 中的 bean 的生命周期</h2><blockquote>
<p>在IoC容器启动之后，并不会马上就实例化相应的bean，此时容器仅仅拥有所有对象的BeanDefinition(BeanDefinition：是容器依赖某些工具加载的XML配置信息进行解析和分析，并将分析后的信息编组为相应的BeanDefinition)。只有当getBean()调用时才是有可能触发Bean实例化阶段的活动</p>
</blockquote>
<p><strong>先来看以下的图(Bean的一生)：</strong></p>
<p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\Bean的一生.jpg" alt="Spring Bean 生命周期"></p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。（也就是所有对象的BeanDefinition）</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>这里特别说明一下Aware接口，Spring的依赖注入最大亮点就是所有的Bean对Spring容器的存在是没有意识的。但是在实际项目中，我们有时不可避免的要用到Spring容器本身提供的资源，这时候要让 Bean主动意识到Spring容器的存在，才能调用Spring所提供的资源，这就是Spring的Aware接口，Aware接口是个标记接口，标记这一类接口是用来“感知”属性的，Aware的众多子接口则是表征了具体要“感知”什么属性。例如BeanNameAware接口用于“感知”自己的名称，ApplicationContextAware接口用于“感知”自己所处的上下文。其实Spring的Aware接口是Spring设计为框架内部使用的，在大多数情况下，我们不需要使用任何Aware接口，除非我们真的需要它们，实现了这些接口会使应用层代码耦合到Spring框架代码中。 </p>
<p>总之就是：Aware有很多子接口，这些接口拥有一种感知能力，把你想要的对象从spring容器中注入到你的bean中</p>
<p>也就是说如果两个bean的类，一个实现了BeanNameAware接口另一个没有实现时，没有实现的就获取不到自己的name属性</p>
<p><strong>一、先看一个最简单的一生(没有使用Bean的后置处理器)</strong></p>
<blockquote>
<p>Student.java：实现了BeanNameAware接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LinJie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:一个学生类(Bean)，能体现其生命周期的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置对象属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;设置对象属性setName()..&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的初始化方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的销毁方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：销毁&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：使用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 重写toString</span></span><br><span class="line"><span class="comment">	 * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name = &quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用BeanNameAware的setBeanName()</span></span><br><span class="line">	<span class="comment">//传递Bean的ID。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用BeanNameAware的setBeanName()...&quot;</span> ); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">		<span class="comment">//Bean的使用</span></span><br><span class="line">		student.play();</span><br><span class="line">		System.out.println(student);</span><br><span class="line">		<span class="comment">//关闭容器</span></span><br><span class="line">		((AbstractApplicationContext) context).close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>applicationContext.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">&lt;!-- init-method：指定初始化的方法</span></span><br><span class="line"><span class="comment">        destroy-method：指定销毁的方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initStudent&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyStudent&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LINJIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>控制台显示结果：</p>
</blockquote>
<p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\最简单的一生.png"></p>
<p>可以在输出结果看出bean的一生，完全与之前的一生过程图相符(除了bean后置处理器部分)，这里还需要提及的是在xml配置中的两个属性</p>
<ul>
<li>init-method：指定初始化的方法</li>
<li>destroy-method：指定销毁的方法</li>
</ul>
<p>说到init-method和destroy-method，当然也要提及一下在<code>&lt; beans&gt;</code>的属性</p>
<ul>
<li>default-init-method：为应用上下文中所有的Bean设置了共同的初始化方法</li>
<li>default-destroy-method：为应用上下文中所有的Bean设置了共同的销毁方法</li>
</ul>
<p><strong>二、加上Bean的后置处理器</strong></p>
<blockquote>
<p>bean的后置处理器，是为了<strong>对bean的一个增强</strong></p>
</blockquote>
<p><strong>用法：</strong></p>
<blockquote>
<p>分别在Bean的初始化前后对Bean对象提供自己的实例化逻辑</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 实现BeanPostProcessor接口</span><br><span class="line">	- postProcessBeforeInitialization方法</span><br><span class="line">	- postProcessAfterInitialization方法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Student.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 设置对象属性</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name the name to set</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;设置对象属性setName()..&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的初始化方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：初始化&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的销毁方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：销毁&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Bean的使用</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student这个Bean：使用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 重写toString</span></span><br><span class="line"><span class="comment">	 * @see java.lang.Object#toString()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [name = &quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用BeanNameAware的setBeanName()</span></span><br><span class="line">	<span class="comment">//传递Bean的ID。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;调用BeanNameAware的setBeanName()...&quot;</span> ); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MyBeanPostProcessor.java（实现BeanPostProcessor接口）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean的后置处理器</span></span><br><span class="line"><span class="comment"> * 分别在bean的初始化前后对bean对象提供自己的实例化逻辑</span></span><br><span class="line"><span class="comment"> * postProcessAfterInitialization：初始化之后对bean进行增强处理</span></span><br><span class="line"><span class="comment"> * postProcessBeforeInitialization：初始化之前对bean进行增强处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对初始化之后的Bean进行处理</span></span><br><span class="line">	<span class="comment">//参数：bean：即将初始化的bean</span></span><br><span class="line">	<span class="comment">//参数：beanname：bean的名称</span></span><br><span class="line">	<span class="comment">//返回值：返回给用户的那个bean,可以修改bean也可以返回一个新的bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanname)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Student stu = <span class="keyword">null</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;对初始化之后的Bean进行处理,将Bean的成员变量的值修改了&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;name&quot;</span>.equals(beanname) || bean <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">			stu = (Student) bean;</span><br><span class="line">			stu.setName(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对初始化之前的Bean进行处理</span></span><br><span class="line">	<span class="comment">//参数：bean：即将初始化的bean</span></span><br><span class="line">	<span class="comment">//参数：beanname：bean的名称</span></span><br><span class="line">	<span class="comment">//返回值：返回给用户的那个bean,可以修改bean也可以返回一个新的bean</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanname)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;对初始化之前的Bean进行处理,此时我的名字&quot;</span>+bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycleTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		Student student = (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">		<span class="comment">//Bean的使用</span></span><br><span class="line">		student.play();</span><br><span class="line">		System.out.println(student);</span><br><span class="line">		<span class="comment">//关闭容器</span></span><br><span class="line">		((AbstractApplicationContext) context).close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>applicationContext.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- init-method：指定初始化的方法</span></span><br><span class="line"><span class="comment">        destroy-method：指定销毁的方法 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.Student&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initStudent&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyStudent&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LINJIE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">&lt;!-- 配置bean的后置处理器,不需要id，IoC容器自动识别是一个BeanPostProcessor --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.linjie.cycle.MyBeanPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>控制台显示结果</p>
</blockquote>
<p><img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-23-Spring相关\有后置处理器.png"></p>
<p>可以在applicationContext.xml中看到配置Bean后置处理器，不需要ID，只需要其全类名，因为IoC容器自动识别一个BeanPostProcessor</p>
<p>在控制台显示结果可以看出,Bean的后置处理器强大之处，可以对Bean实现自己想要做的事情，比如我这里的Demo就是在postProcessAfterInitialization方法中将成员变量name偷偷修改了，最后输出的就是偷偷修改之后的值</p>
<h2 id="5-3-Spring-中的单例-bean-的线程安全问题"><a href="#5-3-Spring-中的单例-bean-的线程安全问题" class="headerlink" title="5.3 Spring 中的单例 bean 的线程安全问题"></a>5.3 Spring 中的单例 bean 的线程安全问题</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ol>
<li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p>
</li>
<li><p>在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</p>
</li>
</ol>
<h1 id="6-SpringMVC-执行流程"><a href="#6-SpringMVC-执行流程" class="headerlink" title="6. SpringMVC 执行流程"></a>6. SpringMVC 执行流程</h1><h2 id="6-1流程图"><a href="#6-1流程图" class="headerlink" title="6.1流程图"></a>6.1流程图</h2><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p>
<img src="/2021/04/23/Spring%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-08-SpringMVC\SpringMVC执行流程.png" style="zoom:80%;">

<h2 id="6-2组件作用"><a href="#6-2组件作用" class="headerlink" title="6.2组件作用"></a>6.2组件作用</h2><ul>
<li><p><strong>DispatcherServlet：</strong>前端控制器。</p>
<p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p>
</li>
<li><p><strong>HandlerMapping：</strong>处理器映射器</p>
<p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p>
</li>
<li><p><strong>HandlerExecution：</strong>具体的Handler</p>
<p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p>
</li>
<li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p>
</li>
<li><p><strong>HandlAdapter：</strong>处理器适配器</p>
<p><strong>作用1：</strong>按照特定的规则去执行Handler；</p>
<p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p>
<p><strong>注：</strong>Model表示具体的数据，View表示视图</p>
</li>
<li><p><strong>View Resolver：</strong>视图解析器</p>
<p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>View：</strong>视图</p>
<p><strong>作用：</strong>向用户展示结果</p>
</li>
</ul>
<h2 id="6-3执行流程"><a href="#6-3执行流程" class="headerlink" title="6.3执行流程"></a>6.3执行流程</h2><ol>
<li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li>
<li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li>
<li>HandlerExecution就是具体的Controller；</li>
<li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li>
<li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li>
<li>HandlAdapter找到相应的Controller去执行；</li>
<li>Controller将执行结果返回给HandlAdapter；</li>
<li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li>
<li>dispatcherServlet调用View Resolver得到相应的页面地址；</li>
<li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li>
<li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li>
</ol>
<h1 id="7-BeanFactory-和-FactoryBean-的区别"><a href="#7-BeanFactory-和-FactoryBean-的区别" class="headerlink" title="7. BeanFactory 和 FactoryBean 的区别"></a>7. BeanFactory 和 FactoryBean 的区别</h1><p><strong>面试官问题：讲一下 BeanFactory 和 FactoryBean 的区别？</strong></p>
<p><strong>答：</strong>两者的区别简单总结如下。</p>
<p>BeanFactory 是个 bean 工厂，是一个工厂类（接口）， 它负责生产和管理 bean 的一个工厂是 ioc 容器最底层的接口，是个 ioc 容器，是 spring 用来管理和装配普通 bean 的 ioc 容器（这些 bean 成为普通 bean ）。</p>
<p>FactoryBean 是一个接口，当在 IOC 容器中的 Bean 实现了 FactoryBean 后，通过 getBean(String BeanName) 获取到的 Bean 对象并不是 FactoryBean 的实现类对象，而是这个实现类中的 getObject() 方法返回的对象。要想获取 FactoryBean 的实现类，就要 getBean(&amp;BeanName)，在BeanName 之前加上&amp;。</p>
<p><strong>解析：</strong></p>
<p><strong>FactoryBean 源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">    Class&lt;?&gt; getObjectType();  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>下面是一个应用 FactoryBean 的例子，配置文件如下：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.bean.Student&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;school&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.bean.School&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBeanPojo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.spring.bean.FactoryBeanPojo&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span> <span class="attr">value</span>=<span class="string">&quot;student&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>FactoryBean 的实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanPojo</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String type;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;student&quot;</span>.equals(type))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Student();			</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> School();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Class <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> School.class;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>普通的 Bean：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">School</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String schoolName;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> studentNumber;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSchoolName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> schoolName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchoolName</span><span class="params">(String schoolName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.schoolName = schoolName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> address;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStudentNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> studentNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentNumber</span><span class="params">(<span class="keyword">int</span> studentNumber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.studentNumber = studentNumber;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;School [schoolName=&quot;</span> + schoolName + <span class="string">&quot;, address=&quot;</span> + address</span><br><span class="line">				+ <span class="string">&quot;, studentNumber=&quot;</span> + studentNumber + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String url = <span class="string">&quot;com/spring/config/BeanConfig.xml&quot;</span>;</span><br><span class="line">		ClassPathXmlApplicationContext cpxa = <span class="keyword">new</span> ClassPathXmlApplicationContext(url);</span><br><span class="line">		Object school=  cpxa.getBean(<span class="string">&quot;factoryBeanPojo&quot;</span>);</span><br><span class="line">		FactoryBeanPojo factoryBeanPojo= (FactoryBeanPojo) cpxa.getBean(<span class="string">&quot;&amp;factoryBeanPojo&quot;</span>);</span><br><span class="line">		System.out.println(school.getClass().getName());</span><br><span class="line">		System.out.println(factoryBeanPojo.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十一月 16, 2016 10:28:24 上午 org.springframework.context.support.AbstractApplicationContext prepareRefresh</span><br><span class="line">INFO: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1e8ee5c0: startup date [Wed Nov 16 10:28:24 CST 2016]; root of context hierarchy</span><br><span class="line">十一月 16, 2016 10:28:24 上午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</span><br><span class="line">INFO: Loading XML bean definitions from class path resource [com&#x2F;spring&#x2F;config&#x2F;BeanConfig.xml]</span><br><span class="line">十一月 16, 2016 10:28:24 上午 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons</span><br><span class="line">INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@35b793ee: defining beans [student,school,factoryBeanPojo]; root of factory hierarchy</span><br><span class="line">com.spring.bean.Student</span><br><span class="line">com.spring.bean.FactoryBeanPojo</span><br></pre></td></tr></table></figure>

<p>从结果上可以看到当从 IOC 容器中获取 FactoryBeanPojo 对象的时候，用 getBean(String BeanName) 获取的确是 Student 对象，可以看到在 FactoryBeanPojo 中的 type 属性设置为 student 的时候，会在 getObject() 方法中返回 Student 对象。所以说从 IOC 容器获取实现了 FactoryBean 的实现类时，返回的却是实现类中的 getObject 方法返回的对象，要想获取 FactoryBean 的实现类，得在 getBean(String BeanName) 中的 BeanName 之前加上 &amp; ,写成 getBean(String &amp;BeanName) 。</p>
<p><strong>面试官追问：使用 FactoryBean 的优势讲一下?</strong></p>
<p><strong>答：</strong>一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。<strong>FactoryBean 接口让程序员可以通过实现该接口定制实例化 Bean 的逻辑（比如直接 new 一个）。这样就大大简化了 Bean 的配置过程。</strong></bean></bean></p>
<h1 id="8-BeanFactory-和-ApplicationContext-的区别"><a href="#8-BeanFactory-和-ApplicationContext-的区别" class="headerlink" title="8. BeanFactory 和 ApplicationContext 的区别"></a>8. BeanFactory 和 ApplicationContext 的区别</h1><p><strong>面试官问题：讲一下 BeanFactory 和 ApplicationContext 的区别吧。</strong></p>
<p><strong>答：</strong></p>
<p><strong>BeanFactory 接口：</strong> 是 Spring 里面最顶层的接口，包含了各种 Bean 的定义，读取 Bean 配置文档，管理 Bean 的加载、实例化，控制 Bean 的生命周期，维护 Bean 之间的依赖关系。</p>
<p><strong>ApplicationContext 接口：</strong>是BeanFactory的衍生，除了提供 BeanFactory 所具有的功能外，还进行更多的扩展。</p>
<ul>
<li>继承了MessageSource，支持国际化。 </li>
<li>提供了统一的资源文件访问方式。 </li>
<li>提供在Listener中注册Bean的事件。 </li>
<li>提供同时加载多个配置文件的功能。 </li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。 </li>
</ul>
<p><strong>在创建 Bean 和内存占用方面的区别：</strong></p>
<ul>
<li><strong>BeanFactory 采用的是延迟加载形式来注入 Bean 的</strong>，即只有在使用到某个 Bean 时(调用getBean())，才对该 Bean 进行加载实例化。这样，就不能发现一些存在于 <strong>Spring配置</strong> 中的问题。如果 Bean 的某一个属性没有注入，BeanFactory 加载后，直至第一次使用调用 getBean 方法才会抛出异常。 </li>
<li><strong>ApplicationContext，它是在容器启动时，一次性创建了所有的 Bean</strong>。这样，在容器启动时，我们就可以发现 Spring 中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext 启动后预载入所有的单实例 Bean，通过预载入单实例 Bean ,确保当需要的时候，可以直接获取。 </li>
</ul>
<p><strong>面试官追问：说一下 BeanFactory 和 ApplicationContext 的优缺点吧。</strong></p>
<p><strong>答：</strong></p>
<p><strong>BeanFactory的优缺点：</strong></p>
<p><strong>优点</strong>：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势（只是加载用到的Bean）；</p>
<p><strong>缺点</strong>：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。</p>
<p><strong>ApplicationContext的优缺点：</strong> </p>
<p><strong>优点</strong>：所有的Bean在启动的时候都进行了加载，系统运行的速度快；在系统启动的时候，可以发现系统中的配置问题。</p>
<p><strong>缺点</strong>：把费时的操作放到系统启动中完成，所有的对象都可以预加载，缺点就是内存占用较大。</p>
<h1 id="9-循环依赖"><a href="#9-循环依赖" class="headerlink" title="9.循环依赖"></a>9.循环依赖</h1><h2 id="9-1构造器的循环依赖"><a href="#9-1构造器的循环依赖" class="headerlink" title="9.1构造器的循环依赖"></a>9.1构造器的循环依赖</h2><p><strong>面试官问题：</strong>如果A对象创建的过程需要使用到B对象，但是B对象创建的时候也需要A对象，也就是构成了循环依赖的现象，那么Spring会如何解决？</p>
<p><strong>答：</strong>这是一种<strong>构造器循环依赖，通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖。</strong></p>
<h2 id="9-2属性的循环依赖"><a href="#9-2属性的循环依赖" class="headerlink" title="9.2属性的循环依赖"></a>9.2属性的循环依赖</h2><p><strong>面试官问题：属性循环依赖了解吗，怎么解决？</strong></p>
<p><strong>答：</strong>如果对象A中有个属性是对象B，而且对象B中有个属性是对象A，那么对象A和对象B就算是循环依赖</p>
<p><strong>解决思路：</strong></p>
<p>要初始化一个 Bean，必须要注入 Bean 里的依赖，才算初始化成功，但并不要求此时依赖的依赖也都注入成功，只要依赖对象的构造方法执行完了，这个依赖对象就算存在了，注入就算成功了，至于依赖的依赖，以后再初始化也来得及。</p>
<p>因此，我们初始化一个 Bean 时，先调用 Bean 的构造方法，这个对象就在内存中存在了（对象里面的依赖还没有被注入），然后把这个对象保存下来，当循环依赖产生时，直接拿到之前保存的对象，于是循环依赖就被终止了，依赖注入也就顺利完成了。</p>
<p>举个例子：</p>
<p>假设对象 A 中有属性是对象 B ，对象 B 中也有属性是对象 A ，即 A 和 B 循环依赖。</p>
<ol>
<li>创建对象 A，调用 A 的构造，并把 A 保存下来</li>
<li>然后准备注入对象 A 中的依赖，发现对象 A 依赖对象 B ，那么开始创建对象 B</li>
<li>调用 B 的构造，并把 B 保存下来</li>
<li>然后准备注入 B 的构造，发现 B 依赖对象 A ，对象 A 之前已经创建了，直接获取 A 并把 A 注入 B（注意此时的对象 A 还没有完全注入成功，对象 A 中的对象 B 还没有注入），于是 B 创建成功</li>
<li>把创建成功的 B 注入 A ，于是 A 也创建成功了</li>
</ol>
<h1 id="10-Spring-事务"><a href="#10-Spring-事务" class="headerlink" title="10. Spring 事务"></a>10. Spring 事务</h1><h2 id="10-1-事务管理方式"><a href="#10-1-事务管理方式" class="headerlink" title="10.1 事务管理方式"></a>10.1 事务管理方式</h2><p><strong>面试官问题：Spring的事务有了解吗？</strong></p>
<p><strong>答：</strong>Spring 支持编程式事务管理和声明式事务管理两种方式。</p>
<p><strong>编程式事务管理：</strong>Spring 实现编程式事务依赖 TransactionTemplate 类，将事务管理的代码嵌入到业务方法中来控制事务的提交和回滚。</p>
<p>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</p>
<p><strong>声明式事务管理</strong>：建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 </p>
<p>优点：就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（设定事务的隔离级别、传播方式等）或通过@Transactional注解的方式（在注解中设定事务的隔离级别、传播方式等），便可以将事务规则应用到业务逻辑中。</p>
<p>缺点：声明式事务的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别，但是也有解决的方式，就是将代码块分离出来，改写成方法即可。</p>
<p><strong>面试官追问：应该怎么选择事务管理方式呢？</strong></p>
<p><strong>答：</strong>声明式事务管理要优于编程式事务管理，这正是Spring倡导的<strong>非侵入式的开发</strong>方式，使业务代码不受污染，只要<strong>加上注解</strong>就可以获得完全的事务支持。唯一不足之处是声明式事务的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别，但是也有解决的方式，就是将代码块分离出来，改写成方法即可。</p>
<h2 id="10-2-事务的传播行为"><a href="#10-2-事务的传播行为" class="headerlink" title="10.2 事务的传播行为"></a>10.2 事务的传播行为</h2><p><strong>面试官问题：了解 Spring 的事务传播吗？讲一下吧。</strong></p>
<p><strong>答：</strong></p>
<p><strong>事务传播行为（propagation behavior）：</strong>指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 </p>
<p><strong>例如：</strong>methodA 事务方法调用 methodB 事务方法时，methodB 是继续在调用者 methodA 的事务中运行呢，还是为自己开启一个新事务运行，这就是由 methodB 的事务传播行为决定的。</p>
<p><strong>Spring 定义了下边的 7 个传播行为来处理这些事务行为：</strong></p>
<p><strong>1.PROPAGATION_REQUIRED（最常用的设置）</strong></p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> methodB();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独调用 methodB 方法时，因为当前上下文不存在事务，所以会开启一个新的事务。<br>调用 methodA 方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到调用 methodB 时，methodB 发现当前上下文有事务，因此就加入到当前事务中来。</p>
<p><strong>回滚方式：</strong>在 methodA 或者在 methodB 内的任何地方出现异常，事务都会被回滚。即使 methodB 的事务已经被提交，但是 methodA 在接下来要回滚，methodB 也要回滚</p>
<p><strong>2.PROPAGATION_SUPPORTS</strong></p>
<p>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。 </p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> methodB();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事务属性为SUPPORTS</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯的调用 methodB 时，methodB 方法是非事务的执行的。</p>
<p>当调用 methdA 时，methodB 则加入了 methodA 的事务中,事务地执行。</p>
<p><strong>3.PROPAGATION_MANDATORY</strong></p>
<p>如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> methodB();</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事务属性为MANDATORY</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new  IllegalTransactionStateException(“Transaction propagation ‘mandatory’  but no existing transaction  found”)</p>
<p>当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p>
<p><strong>4.PROPAGATION_REQUIRES_NEW</strong></p>
<p>创建新事务，无论当前存不存在事务，都创建新事务。 </p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     methodB();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事务属性为REQUIRES_NEW</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行到 methodB 的时候， methodA 所在的事务就会挂起， methodB 会起一个新的事务，等待 methodB 的事务完成以后，他才继续执行。</p>
<p><strong>回滚方式：</strong>他与 PROPAGATION_REQUIRED 的事务区别在于事务的回滚程度了。因为ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。如果 methodB 已经提交，那么 methodA 失败回滚， methodB 是不会回滚的。如果 methodB 失败回滚，如果他抛出的异常被 methodA 捕获， methodA 事务仍然可能提交。</p>
<p><strong>5.PROPAGATION_NOT_SUPPORTED</strong></p>
<p>当前不支持事务。总是以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     methodB();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事务属性为REQUIRES_NEW</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行到 methodB 时， methodA 的事务挂起，而他以非事务的状态运行完，再继续 methodA 的事务。</p>
<p><strong>6.PROPAGATION_NEVER</strong></p>
<p>以非事务方式执行，如果当前存在事务，则抛出异常。 </p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     methodB();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 事务属性为REQUIRES_NEW</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 methodB 方法时，就要抛出异常。</p>
<p><strong>7.PROPAGATION_NESTED</strong></p>
<p>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED 属性执行。 </p>
<p><strong>有两个方法 Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     methodB();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEWSTED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单独调用methodB方法，此时没有活动事务，就会新开一个事务 B。</p>
<p>如果调用 methodA 时，当 methodB 方法调用之前，调用 setSavepoint 方法，保存当前的状态到 <strong>savepoint</strong> 。如果 methodB 方法调用失败，则恢复到之前保存的状态不会造成父事务的回滚。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码调用失败，则回滚包括 methodB 方法的所有操作。嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<blockquote>
<p>PROPAGATION_NESTED 与 PROPAGATION_REQUIRES_NEW 的区别是，PROPAGATION_REQUIRES_NEW 另起一个事务，将会与他的父事务相互独立，而 Nested 的事务和他的父事务是相依的，他的提交是要等和他的父事务一块提交的。也就是说，如果父事务最后回滚，他也要回滚的。</p>
</blockquote>
<h1 id="11-SpringBoot"><a href="#11-SpringBoot" class="headerlink" title="11. SpringBoot"></a>11. SpringBoot</h1><h1 id="12-面试问题"><a href="#12-面试问题" class="headerlink" title="12.面试问题"></a>12.面试问题</h1><p><strong>1.知道 componentScan 注解吗，讲一下这个注解的作用</strong></p>
<p>与 ComponentScan 注解相对应的 XML 配置就是&lt; context:component-scan/ &gt;， 根据指定的配置自动扫描 package ，将符合条件的组件加入到 IOC 容器中，项目中没有用到这个注解，而是直接在 XML 文件中配置了这个字段，字段值就是扫描包的位置。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan</span><br><span class="line">	base-<span class="keyword">package</span>=<span class="string">&quot;com.yibai.spring.annotation&quot;</span> use-<span class="keyword">default</span>-filters=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line">	&lt;context:include-filter type=<span class="string">&quot;custom&quot;</span></span><br><span class="line">		expression=<span class="string">&quot;com.yibai.spring.annotation.filter.ColorBeanLoadFilter&quot;</span> /&gt;</span><br><span class="line">	&lt;context:exclude-filter type=<span class="string">&quot;annotation&quot;</span></span><br><span class="line">		expression=<span class="string">&quot;org.springframework.stereotype.Component&quot;</span> /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>Spring相关</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2021/04/22/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/add-strings/">主站-415. 字符串相加</a></strong></p>
<p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按位相加，要注意有进位，最后还要补充处理一下进位</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">     StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i=n,j=m;</span><br><span class="line">     <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(carry!=<span class="number">0</span>) res.append(String.valueOf(carry));</span><br><span class="line">     <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/multiply-strings/">主站-43. 字符串相乘</a></strong></p>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用字符串的nums1去乘字符串nums2的每一位，然后每次循环结束调用两个字符串相加的方法去得到新的和</p>
<p>（第一题就是两个字符串求和）</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>)||num2.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">    String res=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;m;j++)&#123;</span><br><span class="line">            temp.append(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> bit2=num2.charAt(i)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">           <span class="keyword">int</span> bit1=(num1.charAt(k)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">           <span class="keyword">int</span> produce=bit1*bit2+carry;</span><br><span class="line">           temp.append(produce%<span class="number">10</span>);</span><br><span class="line">           carry=produce/<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(carry!=<span class="number">0</span>) temp.append(carry);</span><br><span class="line">       res=addStrings(res,temp.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">     StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">     <span class="keyword">int</span> n=num1.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> m=num2.length()-<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i=n,j=m;</span><br><span class="line">     <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num1.charAt(i)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> sum=(num2.charAt(j)-<span class="string">&#x27;0&#x27;</span>)+carry;</span><br><span class="line">             <span class="keyword">int</span> temp=sum%<span class="number">10</span>;</span><br><span class="line">             res.append(String.valueOf(temp));</span><br><span class="line">             carry=sum/<span class="number">10</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         i--;</span><br><span class="line">         j--;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(carry!=<span class="number">0</span>) res.append(String.valueOf(carry));</span><br><span class="line">     <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></strong></p>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>当我们遍历给定的字符串时，当前的字符串有下面几种可能：</p>
<ul>
<li><p><strong>空格</strong>——跳过</p>
</li>
<li><p><strong>其它字符</strong>——循环遍历结束</p>
</li>
<li><p><strong>正负号</strong>——存储到flag变量中，后面再拼接到结果中</p>
</li>
<li><p><strong>数字字符：</strong></p>
<p>对数字字符要进行转换和拼接工作</p>
<p><strong>转换：</strong>将数字字符减去字符’0’，得到数字的值</p>
<p><strong>拼接：</strong>前一位得到的数字应该在高位，所以拼接公式为*<em>res=res</em>10+c**</p>
</li>
</ul>
<p>在对数字进行拼接工作时，要<strong>预判</strong>得到的结果是不是发生了越界，之所以要进行预判是因为得到的结果可能很大，不能确定用什么样类型的变量来接收这个结果。Java中int类型的数值范围为 [−231,  231 − 1]，也就是<strong>2147483647</strong>，要在进行本轮的拼接时，判断结果是否会发生越界，也就是上一轮的结果要小于<strong>214748364</strong>或者等于<strong>214748364</strong>且本轮的数值<strong>c</strong>小于等于7，这样按照公式*<em>res=res</em>10+c**拼接时才不会发生越界，当出现越界时直接返回题目要求的结果。</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bndry = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;<span class="comment">//定位第一个非空格字符</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span>(str.charAt(first)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//去除多余的空格</span></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span>(first==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>) flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>||str.charAt(first)==<span class="string">&#x27;+&#x27;</span>) first++;<span class="comment">//如果第一个非空格字符为正负号时，保存到flag，且first++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;str.length();i++)&#123;<span class="comment">//拼接数字字符</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">&#x27;0&#x27;</span>||str.charAt(i)&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//遇到非数字字符，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;bndry||(res==bndry&amp;&amp;str.charAt(i)&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;<span class="comment">//预判结果是否越界</span></span><br><span class="line">            <span class="keyword">return</span> flag==<span class="number">1</span>? Integer.MAX_VALUE : Integer.MIN_VALUE;&#125;</span><br><span class="line">        res=res*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不越界的情况下，拼接数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">主站-227. 基本计算器 II</a></strong></p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>整体思路：</strong></p>
<p>由于乘除优先于加减计算，所以如果数字之前的符号是加减号时，将数字保存到栈中（减号要保存成负数），如果是乘除，将栈顶的元素弹出与之做乘除运算，然后再将结果保存到栈中。最后一轮循环，将所有结果相加就是最终结果。</p>
<p><strong>具体实现：</strong></p>
<p>用flag位表示前面的字符</p>
<p>用num表示字符串中的每个整数（整数有时不止一位）</p>
<p><strong>遍历字符串</strong></p>
<ul>
<li><strong>如果字符串中是数字：</strong>因为字符串中的数字可能是多位数，如果前面几位也是数字，也就是作为高位加上该位组合成整数</li>
<li><strong>如果字符串中不是数字，也不是空格（过滤空格），或者是倒数第一位（防止最后一个整数不能入栈）：</strong>就要判断之前的符号位是什么情况，将当前的整数相应加到栈中。结束后，因为该位置的整数已经入栈，所以将num置零，重新记录一个整数，当该位不是数字也不是空格，那就只能是符号，将flag赋值，继续作为下一个整数的符号。</li>
</ul>
<h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">char</span> flag=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+(s.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i))&amp;&amp;s.charAt(i)!=<span class="string">&#x27; &#x27;</span>||i==len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">int</span> temp1=stack.pop();</span><br><span class="line">                    num=temp1*num;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">int</span> temp2=stack.pop();</span><br><span class="line">                    num=temp2/num;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                flag=s.charAt(i);</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res+=stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL编程</title>
    <url>/2021/04/20/SQL%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="基本的查询语句"><a href="#基本的查询语句" class="headerlink" title="基本的查询语句"></a>基本的查询语句</h1><ol>
<li><p>查询一列：SELECT cust_id FROM customers;</p>
</li>
<li><p>查询全部列：SELECT cust_id FROM customers；</p>
</li>
<li><p>LIMIT 第一个数为开始的行数，第二个数为要检索的行数</p>
<ul>
<li>从第0行（代表第一行）开始：SELECT cust_name  FROM customers  LIMIT 5;</li>
<li>从第5行（实际表中的第六行）开始，显示5行：SELECT cust_name FROM customers LIMIT 5, 5;</li>
</ul>
</li>
<li><p>排序指令</p>
<ul>
<li>默认ASC降序：SELECT prod_name FROM products ORDER BY prod_price;</li>
<li>DESC升序：SELECT prod_name FROM products ORDER BY prod_price DESC;</li>
<li>按多个列排序 先按价格，再按名称：SELECT prod_name FROM products ORDER BY prod_price, prod_name;</li>
<li>DESC 降序,然后再取第0行：SELECT prod_name FROM products ORDER BY prod_price DESC LIMIT 1;</li>
</ul>
</li>
<li><p>WHERE 的逻辑运算符有AND ,OR, NOT,IN</p>
<ul>
<li>检索出由1003或1002供应商生成的商品：SELECT * FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10;</li>
</ul>
</li>
<li><p>MySQL提供了5种的聚集函数：</p>
<ul>
<li>AVG( ) 返回某列的平均值：SELECT AVG(prod_price) FROM products;</li>
<li>COUNT( ) 返回某列的行数</li>
<li>MAX( ) 返回某列的最大值</li>
<li>MIN( ) 返回某列的最小值</li>
<li>SUM( ) 返回某列值之和</li>
</ul>
</li>
<li><p>内链接inner join on：select * from a_table a inner join b_table bon a.a_id = b.b_id;</p>
</li>
<li><p>左连接left join on / left outer join on：select * from a_table a left join b_table bon a.a_id = b.b_id;</p>
</li>
<li><p>右连接（右外连接）right join on / right outer join on：select * from a_table a right outer join b_table b on a.a_id = b.b_id;</p>
</li>
</ol>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/218ae58dfdcd4af195fff264e062138f?tpId=82&tqId=29753&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找最晚入职员工的所有信息</a></strong></p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>按照hire_date字段降序排列</p>
<p>选取第一条</p>
<p>就是最晚入职员工</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.* </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/ec1ca44c62c14ceb990c3c40def1ec6c?tpId=82&tqId=29754&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey"><strong>牛客-查找入职时间排名倒数第三的员工</strong></a></p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>子查询：</p>
<p>通过DISTINCT指令过滤掉入职时间相同的员工</p>
<p>按照hire_date降序排列</p>
<p>通过LIMIT去掉排名倒数第一第二的时间，取倒数第三</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.*</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> hire_date = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> hire_date</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span>       <span class="comment">-- 倒序</span></span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">2</span>              <span class="comment">-- 去掉排名倒数第一第二的时间，取倒数第三</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c63c5b54d86e4c6d880e4834bfd70c3b?tpId=82&tqId=29755&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找各部门当前领导的当前薪水</a></strong></p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过inner join内连接两个表，连接的字段为两个表中的emp_no</p>
<p>然后按照emp_no字段默认升序排列</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.emp_no,s.salary,s.from_date,s.to_date,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> salaries s <span class="keyword">inner</span> <span class="keyword">join</span> dept_manager d</span><br><span class="line"><span class="keyword">ON</span> s.emp_no=d.emp_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> s.emp_no;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/6d35b1cd593545ab985a68cd86f28671?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有已经分配部门的员工的last_name和first_name</a></strong></p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> employees e,dept_emp d</span><br><span class="line"><span class="keyword">WHERE</span> e.emp_no=d.emp_no</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/dbfafafb2ee2482aa390645abd4463bf?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有员工的last_name和first_name以及对应部门编号dept_no</a></strong></p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为要将没有分配部门的员工也选出来</p>
<p>所以通过左连接，以左边的表格为基准，左边表格中没有的补NULL</p>
<h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.first_name,d.dept_no</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">join</span> dept_emp d</span><br><span class="line"><span class="keyword">ON</span> e.emp_no=d.emp_no</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/6d4a4cff1d58495182f536c548fee1ae?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</a></strong></p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>GROUP BY语句指示MySQL按照emp_no进行分组，这样COUNT函数在进行计算的时候就会对每个emp_no计算一次，而不是对整张表进行计算</p>
<p>HAVING过滤分组，HAVING的功能与WHERE很像，只不过WHERE过滤行，HAVING过滤分组，这里HAVING过滤出分组大于15的分组信息</p>
<h3 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no, <span class="keyword">COUNT</span>(emp_no) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(emp_no)&gt;<span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/ae51e6d057c94f6d891735a48d1c2397?tpId=82&tqId=29760&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-找出所有员工当前薪水salary情况</a></strong></p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码及注释-6"><a href="#代码及注释-6" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/32c53d06443346f4a2f2ca733c19660c?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取所有非manager的员工emp_no</a></strong></p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>非manager员工，也就是员工号不在manager表中选出的工号中，所以子查询中通过not in排除</p>
<h3 id="代码及注释-7"><a href="#代码及注释-7" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line"><span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_manager</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/e50d92b8673a440ebdf3a517b5b37d62?tpId=82&tqId=29763&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取所有员工当前的manager</a></strong></p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>从manager表中选出的emp_no字段作为manager显示</p>
<p>通过内连接两个表，因为要求自己就是manager的员工不显示，所以加&lt;&gt;不等号排除</p>
<h3 id="代码及注释-8"><a href="#代码及注释-8" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> em.emp_no, ma.emp_no <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> dept_emp em <span class="keyword">inner</span> <span class="keyword">join</span> dept_manager ma</span><br><span class="line"><span class="keyword">ON</span> em.dept_no=ma.dept_no</span><br><span class="line"><span class="keyword">WHERE</span> em.emp_no &lt;&gt; ma.emp_no</span><br></pre></td></tr></table></figure>

<h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找employees表所有emp_no为奇数，且last_name不等于Mary的员工信息</a></strong></p>
</blockquote>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>WHERE子查询通过AND连接题目中的两个查询条件</p>
<p>并且按照降序排列</p>
<h3 id="代码及注释-9"><a href="#代码及注释-9" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.* </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> emp_no %<span class="number">2</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> last_name!=<span class="string">&#x27;Mary&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> hire_date <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/8d2c290cc4e24403b98ca82ce45d04db?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-获取当前薪水第二多的员工的emp_no以及其对应的薪水salary</a></strong></p>
</blockquote>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>将薪水降序排序</p>
<p>选出从1开始的第一个数，也就是薪水排名第二的员工（索引从0开始）</p>
<h3 id="代码及注释-10"><a href="#代码及注释-10" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp_no,salary</span><br><span class="line"><span class="keyword">FROM</span> salaries</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c1472daba75d4635b7f8540b837cc719?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找当前薪水排名第二多的员工编号emp_no</a></strong></p>
</blockquote>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为不能使用ORDER BY，所以考虑使用函数MAX</p>
<p>先通过MAX函数选出除去薪水最高的员工，再通过MAX选出的就是薪水第二高的员工信息</p>
<h3 id="代码及注释-11"><a href="#代码及注释-11" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.emp_no,s.salary,e.last_name,e.first_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">inner</span> <span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">ON</span> e.emp_no=s.emp_no</span><br><span class="line"><span class="keyword">WHERE</span> s.salary=(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">    <span class="keyword">FROM</span> salaries</span><br><span class="line">    <span class="keyword">WHERE</span> salary&lt;(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">FROM</span> salaries</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c8652e9e5a354b879e2a244200f1eaae?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-统计出当前各个title类型对应的员工当前薪水对应的平均工资</a></strong></p>
</blockquote>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过emp_no字段连接两张表</p>
<p>通过t.title字段分组，用AVG函数对每个分组求平均值</p>
<p>通过s.salary字段的平均值，升序显示</p>
<h3 id="代码及注释-12"><a href="#代码及注释-12" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t.title, <span class="keyword">AVG</span>(s.salary)</span><br><span class="line"><span class="keyword">FROM</span> titles <span class="keyword">AS</span> t <span class="keyword">join</span> salaries <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">ON</span> t.emp_no = s.emp_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">AVG</span>(s.salary) </span><br></pre></td></tr></table></figure>

<h2 id="题目十四"><a href="#题目十四" class="headerlink" title="题目十四"></a>题目十四</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/5a7975fabe1146329cee4f670c27ad55?tpId=82&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-查找所有员工的last_name和first_name以及对应的dept_name</a></strong></p>
</blockquote>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><p>先通过两个表的连接生成一个子表</p>
<p>再通过员工表与子表的左连接，选出对应的员工和部门信息</p>
<h3 id="代码及注释-13"><a href="#代码及注释-13" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.first_name,t.dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e <span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line"><span class="keyword">SELECT</span>  d.dept_name ,de.emp_no</span><br><span class="line"><span class="keyword">FROM</span> dept_emp <span class="keyword">AS</span> de <span class="keyword">left</span> <span class="keyword">join</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> de.dept_no = d.dept_no</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> e.emp_no= t.emp_no</span><br></pre></td></tr></table></figure>

<h2 id="题目十五"><a href="#题目十五" class="headerlink" title="题目十五"></a>题目十五</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/6a62b6c0a7324350a6d9959fa7c21db3?tpId=82&tqId=29774&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking&tab=answerKey">牛客-统计各个部门的工资记录数</a></strong></p>
</blockquote>
<h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><p>先通过两个表的连接生成一个子表</p>
<p>再按照部门名称分组，然后对每个分组的数据条数求和</p>
<p>输出显示</p>
<h3 id="代码及注释-14"><a href="#代码及注释-14" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.dept_no,d.dept_name,<span class="keyword">COUNT</span>(t.emp_no) <span class="keyword">AS</span> <span class="keyword">sum</span></span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> d <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> de.emp_no,de.dept_no</span><br><span class="line">    <span class="keyword">FROM</span> dept_emp <span class="keyword">As</span> de <span class="keyword">join</span> salaries <span class="keyword">AS</span> s</span><br><span class="line">    <span class="keyword">ON</span> de.emp_no=s.emp_no</span><br><span class="line">) <span class="keyword">AS</span> t</span><br><span class="line"><span class="keyword">ON</span> d.dept_no=t.dept_no</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> d.dept_no</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> d.dept_no </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>SQL编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2021/04/16/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-三大集合接口的引出"><a href="#1-三大集合接口的引出" class="headerlink" title="1.三大集合接口的引出"></a>1.三大集合接口的引出</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="1-1-Collection"><a href="#1-1-Collection" class="headerlink" title="1.1 Collection"></a>1.1 Collection</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合01.png" alt="img"></p>
<p><strong>Set</strong></p>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<p><strong>List</strong></p>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合02.png" alt="img"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable  不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<p><strong>问题：Map，List和Set都是Collection的子接口吗？</strong></p>
<p>Map是和Collection并列的集合上层接口，没有继承关系；List和Set是Collection的子接口。</p>
<p><strong>问题：能说下 List,Set,Map 三者的区别吗？</strong></p>
<ul>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key 可以引用相同的对象，但 Key 不能重复，典型的 Key 是 String 类型，但也可以是任何对象。</li>
</ul>
<h1 id="2-容器中的设计模式"><a href="#2-容器中的设计模式" class="headerlink" title="2. 容器中的设计模式"></a>2. 容器中的设计模式</h1><h2 id="2-1迭代器模式"><a href="#2-1迭代器模式" class="headerlink" title="2.1迭代器模式"></a>2.1迭代器模式</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合03.png" alt="img"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2适配器模式"><a href="#2-2适配器模式" class="headerlink" title="2.2适配器模式"></a>2.2适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-HashMap-集合"><a href="#3-HashMap-集合" class="headerlink" title="3. HashMap 集合"></a>3. HashMap 集合</h1><h2 id="3-1-底层实现"><a href="#3-1-底层实现" class="headerlink" title="3.1 底层实现"></a>3.1 底层实现</h2><p><strong>Java8之前：</strong>数组+链表（数组的查询速度快，链表的增删效率高，因此HashMap结合了两者的优势）</p>
<p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry  是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap  使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合04.png" alt="img"></p>
<ul>
<li>理想情况下，每个键位通过散列运算对应不同的值，这样查询的效率就是O(1)</li>
<li>当不同的键位通过散列运算总是得到相同的值，这时候就会在一个头结点后面拼接为一个很长的链表，性能就会由原来的O(1)降低为O(n)</li>
</ul>
<p>于是，<strong>Java8之后</strong>，就加入了红黑树数据结构，如下图所示：</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片2.png" style="zoom:80%;">

<p>引入一个常量TREEIFY_THRESHOLD，当链表达到一定的长度之后，就会将链表转换成红黑树，这样最坏情况就从O(n)提高到了O(logn)，解决了链表太长导致的查询速度变慢的问题。</p>
<h2 id="3-2-存取原理"><a href="#3-2-存取原理" class="headerlink" title="3.2 存取原理"></a>3.2 存取原理</h2><p><strong>调用 put() 方法传递键和值来存储时：</strong>先对键调用 hashCode() 方法，返回的 hashCode 用于<strong>找到桶位置来储存 Entry 对象</strong>，也就是找到了该元素应该被存储的<strong>桶中（数组）</strong>。当两个键的 hashCode 值相同时，桶位置发生了冲突，也就是<strong>发生了 Hash冲突</strong>，这个时候，会在每一个桶后边接上一个链表（JDK8及以后的版本中还会加上红黑树）来解决，将新存储的键值对放在表头（<strong>头插法</strong>）。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多操作都需要先确定一个键值对所在的桶下标，包含两个步骤：</p>
<ol>
<li>计算 hash 值</li>
<li>取模</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>计算 hash 值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取模</p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用 get() 方法获取存储的值时：</strong>首先根据键的 hashCode 找到对应的桶，然后根据 equals() 方法来在链表和红黑树中找到对应的值。</p>
<p><strong>拉链法工作原理图：</strong></p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合05.png" alt="img"></p>
<h2 id="3-3-扩容问题"><a href="#3-3-扩容问题" class="headerlink" title="3.3 扩容问题"></a>3.3 扩容问题</h2><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<h3 id="3-3-1-初始容量、加载因子、扩容增量"><a href="#3-3-1-初始容量、加载因子、扩容增量" class="headerlink" title="3.3.1 初始容量、加载因子、扩容增量"></a>3.3.1 初始容量、加载因子、扩容增量</h3><p><strong>问题：HashMap的初始容量，加载因子，扩容增量是多少？</strong></p>
<p>HashMap的初始容量16，加载因子为0.75，扩容增量是原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。HashMap扩容是指元素个数<strong>（包括数组和链表+红黑树中）</strong>超过了16*0.75=12之后开始扩容。</p>
<p><strong>问题：HashMap的长度为什么是2的幂次方？</strong></p>
<p>我们先要看下对于一个 Entry 的键值 Key 我们是怎么求得 HashMap 中的 Index 的：index = HashCode（Key） &amp; （Length- 1）</p>
<ol>
<li>length为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与 HashCode 的二进制<strong>与操作效率会非常的快</strong>，这种情况下，index的结果等同于HashCode后几位的值</li>
<li>只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的，也就是<strong>降低了碰撞的可能性</strong></li>
</ol>
<p><strong>问题：加载因子为什么设为 0.75 ？</strong></p>
<p>如果设置太小不利于空间利用，设置太大则会导致碰撞增多，降低了查询效率，所以设置了0.75。</p>
<h3 id="3-3-2扩容步骤"><a href="#3-3-2扩容步骤" class="headerlink" title="3.3.2扩容步骤"></a>3.3.2扩容步骤</h3><p><strong>问题：HashMap 在什么情况下会触发扩容机制？</strong></p>
<p>HashMap 里面默认的负载因子大小为 0.75，也就是说，进行 put 操作时，当发现 Map 中的元素（Entry）个数<strong>（包括数组，链表和红黑树中）</strong>超过了 16*0.75=12 之后开始扩容。将会创建原来 HashMap 大小的两倍的桶数组，来重新调整 Map 的大小，并将原来的对象放入新的桶数组中。</p>
<p><strong>问题：讲一下 HashMap 的扩容过程吧。</strong></p>
<p>HashMap 的扩容过程在 JDK1.8 以前和以后是不同的，下面分别讲解下两个版本下的扩容过程。</p>
<p><strong>JDK1.7 的扩容过程：</strong>JDK1.7 的扩容过程是在 resize() 方法和 transfer() 方法中实现的。</p>
<p>resize() 方法中完成的工作：</p>
<ul>
<li>判断当前数组的大小是否达到了最大值</li>
<li>创建一个新的 Entry 数组 newTable，长度是旧数组的两倍</li>
<li>调用 transfer() 方法，将旧数组中的元素迁移到新数组中</li>
</ul>
<p>transfer() 方法中完成的工作：</p>
<ul>
<li>遍历 oldTable 迁移元素到 newTable</li>
<li>重新计算 Hash 值，找到 Entry 在 newTable 中的位置</li>
</ul>
<p><strong>但是 transfer() 方法这里容易出现问题：</strong>transfer方法的作用是把原table的Node放到新的table中，使用的是<strong>头插法</strong>，也就是说，新table中链表的顺序和旧列表中是相反的，在HashMap线程不安全的情况下，这种头插法可能会导致环状节点，出现环形链表的原因大概是这样的：线程1准备处理节点，然后被挂起，这时线程2把 HashMap 扩容成功，链表已经逆向排序，那么线程1回来继续处理节点时就可能出现环形链表。</p>
<p><strong>JDK1.8 的扩容过程：</strong>整个的扩容过程都在 resize 方法中完成</p>
<ul>
<li>创建一个新的 Entry 数组 newTable，长度是旧数组的两倍</li>
<li>遍历循环原数组，把原数组中的每个链表中的每个元素放入新数组，与 JDK1.7 不同，这里采用的是<strong>尾插法</strong>的方式，新链表中节点顺序和原链表相同，不再是 JDK1.7 的倒序了，这就解决了多线程扩容的线程安全问题（其实还是存在问题）</li>
<li>正常情况下，计算节点在旧数组中的下标的方法是：hash&amp;(oldTable.length-1)，扩容之后，数组长度翻倍，计算新数组中下标的方法是 hash&amp;(newTable.length-1) ，也就是 hash&amp;(oldTable.length*2-1) ，于是我们有了这样的结论：这新旧两次计算下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度。说白了，就是通过新增的 bit 位置上是 0 还是 1 来判断。 如果新增 bit 所在的那一位是 0，那么新 table 按位与的结果和旧 table 的结果就相同，反之如果新增 bit 所在的那一位是1，则新 table 按位与的结果就比旧 table 的结果多了10000（二进制），而这个二进制10000就是旧table的长度16。如下图所示：</li>
</ul>
<p>举个例子，假设table原长度是16，扩容后长度32，那么一个hash值在扩容前后的table下标是这么计算的：</p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\HashMap扩容.png" alt="img"></p>
<p><strong>总结：</strong>JDK1.8 改进之后，通过尾插法的方式避免了多线程扩容时出现的循环链表问题，还通过巧妙利用位运算的特性做了一个扩容时运算效率的提升。</p>
<p><strong>问题：JDK1.8 避免了循环链表后就线程安全了吗？</strong></p>
<p>在 JDK1.8 中，多线程在并发执行 put 操作时会发生数据覆盖的情况</p>
<p>假设两个线程A、B都在进行 put 操作，并且 hash 函数计算出的插入下标是相同的，当线程 A 执行完 hash 碰撞判断通过后，由于时间片耗尽导致被挂起，而线程 B 得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程 A 获得时间片，由于之前已经进行了 hash 碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程 B 插入的数据被线程 A 覆盖了，从而线程不安全。</p>
<h2 id="3-4解决-Hash-冲突的方法"><a href="#3-4解决-Hash-冲突的方法" class="headerlink" title="3.4解决 Hash 冲突的方法"></a>3.4解决 Hash 冲突的方法</h2><p><strong>问题：说一说你了解的解决 Hash 冲突的方法吧</strong></p>
<ul>
<li>拉链法 <strong>（HashMap使用的方法）</strong> </li>
<li>线性探测再散列法 </li>
<li>二次探测再散列法 </li>
<li>伪随机探测再散列法 </li>
</ul>
<p><strong>解析：HashMap 是怎么解决 Hash 冲突的？</strong></p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p>总结来说，就是通过 <strong>扰动函数+拉链法</strong> 来解决Hash冲突的。</p>
<h2 id="3-5-HashMap-实现线程安全"><a href="#3-5-HashMap-实现线程安全" class="headerlink" title="3.5 HashMap 实现线程安全"></a>3.5 HashMap 实现线程安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronizedMap方法中对public方法进行了加锁，相当于把原来的HashMap对象封装在safeHashMap对象中，再通过synchronizedMap中的公共方法对HashMap对象操作时，就是线程安全的了</span></span><br><span class="line">Map hashMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">Map safeHashMap=Collections.synchronizedMap(hashMap);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-HashMap-和-Hashtable-的比较"><a href="#3-5-HashMap-和-Hashtable-的比较" class="headerlink" title="3.5 HashMap 和 Hashtable 的比较"></a>3.5 HashMap 和 Hashtable 的比较</h2><p><strong>HashMap和Hashtable之间的区别可以总结如下：</strong></p>
<ul>
<li><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>对 Null key 和 Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<p>①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p>
<p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</p>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<p><strong>解析：</strong>面试官会根据你的回答，考察线程安全的问题</p>
<p><strong>HashMap 与 Hashtable 的线程安全性：</strong></p>
<ul>
<li>HashMap 的线程不安全主要体现在下面两个方面：<ol>
<li>在 JDK1.7 中，当并发执行扩容操作时会造成环形链和数据丢失的情况。</li>
<li>在 JDK1.8 中，在并发执行 put 操作时会发生数据覆盖的情况。</li>
</ol>
</li>
<li>Hashtable 线程安全是由于其内部实现在 put 和 remove 等方法上使用 synchronized 进行了同步，所以对<strong>单个方法的使用是线程安全</strong>的。但是对多个方法进行<strong>复合操作时，线程安全性无法保证。</strong> 比如一个线程在进行 get 然后 put 更新的操作，这就是两个复合操作，在两个操作之间，可能别的线程已经对这个 key 做了改动，所以，你接下来的 put 操作可能会不符合预期。 </li>
</ul>
<h1 id="4-ConccurentHashMap-集合"><a href="#4-ConccurentHashMap-集合" class="headerlink" title="4. ConccurentHashMap 集合"></a>4. ConccurentHashMap 集合</h1><h2 id="4-1-JDK1-8-之前的底层实现"><a href="#4-1-JDK1-8-之前的底层实现" class="headerlink" title="4.1 JDK1.8 之前的底层实现"></a>4.1 JDK1.8 之前的底层实现</h2><p><strong>多线程的环境下，使用集合时，通常有以下几种方式：</strong></p>
<ol>
<li>使用 synchronizedHashMap 封装的线程安全的 map 集合</li>
<li>使用 Hashtable</li>
<li>使用 ConccurentHashMap</li>
</ol>
<p>由于在多线程环境下，前两种线程安全的 map 集合都是串行执行的，因此效率比较低，并发性也比 HashMap 要好，所以通常选择使用 ConccurentHashMap 集合。</p>
<p><strong>Java8 之前：</strong></p>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap  采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片3.png" style="zoom:80%;">

<p>Segment 继承自 ReentrantLock：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 统计该 Segment 中的键值对个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 记得快速失败（fail—fast）么？</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 大小(size 的临界值，只要大于就得扩容)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p><strong>size 操作</strong></p>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-JDK1-8-之后的底层实现"><a href="#4-2-JDK1-8-之后的底层实现" class="headerlink" title="4.2 JDK1.8 之后的底层实现"></a>4.2 JDK1.8 之后的底层实现</h2><p>通过 CAS+synchronized 使锁更细化，也就是说不再使用分段锁，而是对每一个头结点分别加锁，这样一来效率又有了成倍的提高。而且采用了数组+链表+红黑树的底层结构，查询效率也更高。</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片4.png" style="zoom:80%;">

<h2 id="4-3存取原理"><a href="#4-3存取原理" class="headerlink" title="4.3存取原理"></a>4.3存取原理</h2><p><strong>Jdk1.7：put 操作</strong></p>
<p>首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><strong>JDK1.8：put 操作</strong></p>
<ol>
<li><p>根据 key 计算出 hash 值；</p>
</li>
<li><p>判断是否需要进行初始化；</p>
</li>
<li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p>
<ul>
<li><p>如果为 null ，则通过 CAS 的方式尝试添加；</p>
</li>
<li><p>如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；</p>
</li>
<li><p>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</p>
</li>
</ul>
</li>
<li><p>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</p>
</li>
</ol>
<p><strong>Jdk1.7：get 操作</strong></p>
<p>首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p>
<p>由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p>
<p><strong>JDK1.8：get 操作</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值，判断数组是否为空；</li>
<li>如果是首节点，就直接返回；</li>
<li>如果是红黑树结构，就从红黑树里面查询；</li>
<li>如果是链表结构，循环遍历判断。</li>
</ol>
<h1 id="5-LinkedHashMap-集合"><a href="#5-LinkedHashMap-集合" class="headerlink" title="5. LinkedHashMap 集合"></a>5. LinkedHashMap 集合</h1><h2 id="5-1底层结构"><a href="#5-1底层结构" class="headerlink" title="5.1底层结构"></a>5.1底层结构</h2><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-afterNodeAccess"><a href="#5-2-afterNodeAccess" class="headerlink" title="5.2 afterNodeAccess()"></a>5.2 afterNodeAccess()</h2><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-afterNodeInsertion"><a href="#5-3-afterNodeInsertion" class="headerlink" title="5.3 afterNodeInsertion()"></a>5.3 afterNodeInsertion()</h2><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承  LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU  的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-LRU-缓存的实现"><a href="#5-4-LRU-缓存的实现" class="headerlink" title="5.4 LRU 缓存的实现"></a>5.4 LRU 缓存的实现</h2><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 1, 4]</span><br></pre></td></tr></table></figure>

<h1 id="6-WeakHashMap-集合"><a href="#6-WeakHashMap-集合" class="headerlink" title="6. WeakHashMap 集合"></a>6. WeakHashMap 集合</h1><h2 id="6-1底层结构"><a href="#6-1底层结构" class="headerlink" title="6.1底层结构"></a>6.1底层结构</h2><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-ConcurrentCache-缓存实现"><a href="#6-2-ConcurrentCache-缓存实现" class="headerlink" title="6.2 ConcurrentCache 缓存实现"></a>6.2 ConcurrentCache 缓存实现</h2><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-TreeMap-集合"><a href="#7-TreeMap-集合" class="headerlink" title="7. TreeMap 集合"></a>7. TreeMap 集合</h1><h2 id="7-1底层实现"><a href="#7-1底层实现" class="headerlink" title="7.1底层实现"></a>7.1底层实现</h2><p>TreeMap 底层使用<strong>红黑树</strong>实现，TreeMap中存储的键值对<strong>按照键来排序</strong>。</p>
<ul>
<li>如果Key存入的是字符串等类型，那么会按照字典默认顺序排序 </li>
<li>如果传入的是自定义引用类型，比如说User，那么该对象必须实现Comparable接口，并且覆盖其compareTo方法；或者在创建TreeMap的时候，我们必须指定使用的比较器。如下所示： </li>
</ul>
<p><strong>实现 Comparable 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student,Integer&gt; tm=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        tm.put(s1,<span class="number">1</span>);</span><br><span class="line">        tm.put(s2,<span class="number">2</span>);</span><br><span class="line">        tm.put(s3,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Student&gt; students = tm.keySet();</span><br><span class="line">        Iterator&lt;Student&gt; iterator = students.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wangjin001</span><br><span class="line">wangjin002</span><br><span class="line">wangjin003</span><br></pre></td></tr></table></figure>

<p><strong>指定比较器 Comparator：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student,Integer&gt; tm=<span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        tm.put(s1,<span class="number">1</span>);</span><br><span class="line">        tm.put(s2,<span class="number">2</span>);</span><br><span class="line">        tm.put(s3,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Student&gt; students = tm.keySet();</span><br><span class="line">        Iterator&lt;Student&gt; iterator = students.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wangjin001</span><br><span class="line">wangjin002</span><br><span class="line">wangjin003</span><br></pre></td></tr></table></figure>

<h2 id="7-2-Comparable-和-Comparator-的比较"><a href="#7-2-Comparable-和-Comparator-的比较" class="headerlink" title="7.2 Comparable 和 Comparator 的比较"></a>7.2 Comparable 和 Comparator 的比较</h2><ul>
<li><strong>Comparable 接口</strong>的后缀是able大概表示可以的意思，也就是说一个类如果实现了这个接口，那么这个<strong>类就是可以比较的</strong>。类似的还有cloneable接口表示可以克隆的。</li>
<li><strong>Comparator则是一个比较器</strong>，是创建TreeMap的时候传入，用来指定比较规则。</li>
</ul>
<p><strong>二者的区别：</strong></p>
<ul>
<li>Comparable 实现比较简单，但是当需要重新定义比较规则的时候，<strong>必须修改源代码</strong>，即修改 User 类里边的 compareTo 方法 </li>
<li>Comparator 接口不需要修改源代码，只需要在创建 TreeMap 的时候<strong>重新传入一个具有指定规则的比较器</strong>即可。 </li>
</ul>
<h1 id="8-ArrayList-集合"><a href="#8-ArrayList-集合" class="headerlink" title="8. ArrayList 集合"></a>8. ArrayList 集合</h1><h2 id="8-1底层实现"><a href="#8-1底层实现" class="headerlink" title="8.1底层实现"></a>8.1底层实现</h2><p>因为 ArrayList 是<strong>基于数组实现</strong>的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-2扩容过程"><a href="#8-2扩容过程" class="headerlink" title="8.2扩容过程"></a>8.2扩容过程</h2><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3线程安全的-ArrayList"><a href="#8-3线程安全的-ArrayList" class="headerlink" title="8.3线程安全的 ArrayList"></a>8.3线程安全的 ArrayList</h2><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="9-Vector-集合"><a href="#9-Vector-集合" class="headerlink" title="9. Vector 集合"></a>9. Vector 集合</h1><h2 id="9-1同步"><a href="#9-1同步" class="headerlink" title="9.1同步"></a>9.1同步</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。也就是说它是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2扩容过程"><a href="#9-2扩容过程" class="headerlink" title="9.2扩容过程"></a>9.2扩容过程</h2><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-Vector-和-ArrayList-的比较"><a href="#9-3-Vector-和-ArrayList-的比较" class="headerlink" title="9.3 Vector 和 ArrayList 的比较"></a>9.3 Vector 和 ArrayList 的比较</h2><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h1 id="10-CopyOnWriteArrayList-集合"><a href="#10-CopyOnWriteArrayList-集合" class="headerlink" title="10. CopyOnWriteArrayList 集合"></a>10. CopyOnWriteArrayList 集合</h1><h2 id="10-1读写分离"><a href="#10-1读写分离" class="headerlink" title="10.1读写分离"></a>10.1读写分离</h2><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2适用场景"><a href="#10-2适用场景" class="headerlink" title="10.2适用场景"></a>10.2适用场景</h2><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h1 id="11-LinkedList-集合"><a href="#11-LinkedList-集合" class="headerlink" title="11. LinkedList 集合"></a>11. LinkedList 集合</h1><h2 id="11-1底层实现"><a href="#11-1底层实现" class="headerlink" title="11.1底层实现"></a>11.1底层实现</h2><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><strong>如图所示：</strong></p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合06.png" alt="img"></p>
<h2 id="11-2-LinkedList-和-ArrayList-的比较"><a href="#11-2-LinkedList-和-ArrayList-的比较" class="headerlink" title="11.2 LinkedList 和 ArrayList 的比较"></a>11.2 LinkedList 和 ArrayList 的比较</h2><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h1 id="12-几种常见对比"><a href="#12-几种常见对比" class="headerlink" title="12.几种常见对比"></a>12.几种常见对比</h1><h2 id="12-1-Collection-和-Collections"><a href="#12-1-Collection-和-Collections" class="headerlink" title="12.1 Collection 和 Collections"></a>12.1 Collection 和 Collections</h2><ul>
<li><strong>Collection：</strong> 一个顶层集合接口，其子接口包括 List 和 Set；</li>
<li><strong>Collections：</strong> 一个集合工具类，可以操作集合，比如说排序，二分查找，拷贝集合，寻找最大最小值等。  总而言之：带s的大都是工具类。</li>
</ul>
<h2 id="12-2-HashMap-和-HashSet-的区别"><a href="#12-2-HashMap-和-HashSet-的区别" class="headerlink" title="12.2 HashMap 和 HashSet 的区别"></a>12.2 HashMap 和 HashSet 的区别</h2><p>HashSet 底层就是基于 HashMap 实现的</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put（）</code>向map中添加元素</td>
<td align="center">调用 <code>add（）</code>方法向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使用键（Key）计算Hashcode</td>
<td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td>
</tr>
</tbody></table>
<h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p>
<p><strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<h2 id="12-3-ConcurrentHashMap-和-Hashtable-的区别"><a href="#12-3-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="12.3 ConcurrentHashMap 和 Hashtable 的区别"></a>12.3 ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h1 id="13-Java-集合中的快速失败机制"><a href="#13-Java-集合中的快速失败机制" class="headerlink" title="13. Java 集合中的快速失败机制"></a>13. Java 集合中的快速失败机制</h1><p><strong>面试官问题：快速失败机制（fast-fail）是 HashMap 线程不安全的一种表现吗？说一下你理解的快速失败机制吧。</strong></p>
<p><strong>答：</strong>不是。Hashtable 同样也会在迭代的时候抛出该异常，可能发生快速失败。快速失败是 Java 集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，<strong>有可能</strong>会产生fail-fast。</p>
<p><strong>解析：</strong>假设存在两个线程（线程1、线程2），线程1通过 Iterator 在遍历集合 A 中的元素，在某个时候线程2<strong>修改了集合A的结构</strong>（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就<strong>可能</strong>会抛出 **ConcurrentModificationException **异常，从而产生 fast-fail 快速失败。</p>
<p><strong>底层实现：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount  变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>异常ConcurrentModificationException，JDK中是这么介绍该异常的：当检测到一个并发的修改，就可能会抛出该异常，一些迭代器的实现会抛出该异常，以便可以快速失败。但是你不可以为了便捷而依赖该异常，而应该仅仅作为一个程序的侦测。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1.线程与进程"></a>1.线程与进程</h1><p>同操作系统</p>
<h1 id="2-简述线程与进程的关系"><a href="#2-简述线程与进程的关系" class="headerlink" title="2.简述线程与进程的关系"></a>2.简述线程与进程的关系</h1><h2 id="2-1JVM的角度看线程与进程"><a href="#2-1JVM的角度看线程与进程" class="headerlink" title="2.1JVM的角度看线程与进程"></a>2.1JVM的角度看线程与进程</h2><p>JVM运行时数据区如下图所示：</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM运行时数据区域.png" width="600px">
</div>

<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区(JDK1.8 之后的元空间)</li>
</ul>
<p><strong>总结：</strong> 线程 是 进程 划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反，它的创建和切换的开销都比较大，但是资源是相互之间独立的。</p>
<h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h3 id="Java-虚拟机栈（线程私有）"><a href="#Java-虚拟机栈（线程私有）" class="headerlink" title="Java 虚拟机栈（线程私有）"></a>Java 虚拟机栈（线程私有）</h3><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<h3 id="本地方法栈（线程私有）"><a href="#本地方法栈（线程私有）" class="headerlink" title="本地方法栈（线程私有）"></a>本地方法栈（线程私有）</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p>
<h3 id="堆（线程共享）"><a href="#堆（线程共享）" class="headerlink" title="堆（线程共享）"></a>堆（线程共享）</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>
<h3 id="运行时常量池（属于方法区）"><a href="#运行时常量池（属于方法区）" class="headerlink" title="运行时常量池（属于方法区）"></a>运行时常量池（属于方法区）</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p>
<p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p>
<img src="https://camo.githubusercontent.com/0f899d9813fbf1b8fc74724089a917ff7bdd93d60e8c4f685f0e850b51969154/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067" alt="img" style="zoom:80%;">

<p><strong>为什么虚拟机栈和本地方法栈以及程序计数器是线程私有的？</strong></p>
<ul>
<li>为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</li>
<li>程序计数器私有主要是为了<strong>线程切换后能恢复到正确的执行位置</strong>。</li>
</ul>
<h1 id="3-并发与并行的区别"><a href="#3-并发与并行的区别" class="headerlink" title="3.并发与并行的区别"></a>3.并发与并行的区别</h1><ul>
<li><strong>并发：</strong> 同一<strong>时间段</strong>，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong> <strong>单位时间</strong>内，多个任务同时执行。</li>
</ul>
<h1 id="4-为什么要使用多线程"><a href="#4-为什么要使用多线程" class="headerlink" title="4.为什么要使用多线程"></a>4.为什么要使用多线程</h1><p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h1 id="5-使用多线程可能带来什么问题"><a href="#5-使用多线程可能带来什么问题" class="headerlink" title="5.使用多线程可能带来什么问题"></a>5.使用多线程可能带来什么问题</h1><p>并发编程不一定总是能提高程序的运行效率，并且可能会带来一些问题：</p>
<ul>
<li>内存泄漏</li>
<li>上下文切换（开销增大）</li>
<li>死锁（资源分配）</li>
<li>受限于硬件和软件的资源闲置问题</li>
</ul>
<h1 id="6-线程的生命周期和状态"><a href="#6-线程的生命周期和状态" class="headerlink" title="6.线程的生命周期和状态"></a>6.线程的生命周期和状态</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java 线程的状态 "></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java 线程状态变迁 "></p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="6-1sleep-方法和-wait-方法"><a href="#6-1sleep-方法和-wait-方法" class="headerlink" title="6.1sleep() 方法和 wait() 方法"></a>6.1sleep() 方法和 wait() 方法</h2><p><strong>两者的区别：</strong></p>
<ul>
<li><strong>sleep方法：</strong>是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。<strong>睡眠不释放锁</strong>（如果有的话）。</li>
<li><strong>wait方法：</strong>是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有<strong>重新占用互斥锁</strong>之后才会进入可运行状态。睡眠时，会释放互斥锁。 </li>
</ul>
<p><strong>两者相同点：</strong></p>
<ul>
<li>两者都可以暂停线程的执行</li>
</ul>
<p><strong>解析：</strong>这个题目主要是<strong>考察 sleep 和 wait 方法所处的类</strong>是哪个，并且<strong>考察其在休眠的时候对于互斥锁的处理</strong>。</p>
<h2 id="6-2start-方法和run-方法"><a href="#6-2start-方法和run-方法" class="headerlink" title="6.2start() 方法和run() 方法"></a>6.2start() 方法和run() 方法</h2><p>new 一个 Thread，线程进入了新建状态</p>
<ul>
<li><strong>调用 start() 方法：</strong>会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li>
<li><strong>直接执行 run() 方法：</strong>会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
</ul>
<p>run方法其实就是线程的方法体</p>
<h2 id="6-3-jion-方法"><a href="#6-3-jion-方法" class="headerlink" title="6.3 jion 方法"></a>6.3 jion 方法</h2><p><strong>join 方法：</strong>当前线程调用，则其它线程全部停止，等待当前线程执行完毕，接着执行。</p>
<h2 id="6-4-yield-方法"><a href="#6-4-yield-方法" class="headerlink" title="6.4 yield 方法"></a>6.4 yield 方法</h2><p><strong>yield 方法：</strong>该方法使得线程放弃当前分得的 CPU 时间片。但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。</p>
<blockquote>
<p><strong>注：上下文切换</strong></p>
<p>当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
</blockquote>
<h1 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁"></a>7.死锁</h1><p>见自己整理的《死锁相关》</p>
<h1 id="8-多线程环境下的线程安全"><a href="#8-多线程环境下的线程安全" class="headerlink" title="8.多线程环境下的线程安全"></a>8.多线程环境下的线程安全</h1><p>见《Java高并发程序设计》P18。</p>
<h1 id="9-synchronized-关键字"><a href="#9-synchronized-关键字" class="headerlink" title="9. synchronized 关键字"></a>9. synchronized 关键字</h1><p>见《synchronized 关键字》</p>
<h1 id="10-volatile关键字"><a href="#10-volatile关键字" class="headerlink" title="10.volatile关键字"></a>10.volatile关键字</h1><p>见《volatile关键字》</p>
<h1 id="11-ThreadLocal"><a href="#11-ThreadLocal" class="headerlink" title="11.ThreadLocal"></a>11.ThreadLocal</h1><h2 id="11-1ThreadLocal简介"><a href="#11-1ThreadLocal简介" class="headerlink" title="11.1ThreadLocal简介"></a>11.1ThreadLocal简介</h2><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong>  <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p>如果你<strong>创建了一个<code>ThreadLocal</code>变量</strong>，那么<strong>访问这个变量的每个线程都会有这个变量的本地副本</strong>，这也是<code>ThreadLocal</code>变量名的由来。<strong>他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题</strong>。</p>
<h2 id="11-2ThreadLocal原理"><a href="#11-2ThreadLocal原理" class="headerlink" title="11.2ThreadLocal原理"></a>11.2ThreadLocal原理</h2><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个  <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code>  类型的变量,我们可以把 <code>ThreadLocalMap</code>  理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set() </code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong><code>ThreadLocal</code> 内部维护的是一个类似 <code>Map</code> 的<code>ThreadLocalMap</code> 数据结构，<code>key</code> 为当前对象的 <code>Thread</code> 对象，值为 Object 对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<h2 id="11-3ThreadLocal-内存泄露问题"><a href="#11-3ThreadLocal-内存泄露问题" class="headerlink" title="11.3ThreadLocal 内存泄露问题"></a>11.3ThreadLocal 内存泄露问题</h2><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h1 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12.线程池"></a>12.线程池</h1><h2 id="12-1为什么要用线程池"><a href="#12-1为什么要用线程池" class="headerlink" title="12.1为什么要用线程池"></a>12.1为什么要用线程池</h2><ul>
<li><strong>降低资源消耗：</strong>线程池通常会维护一些线程（数量为 <code>corePoolSize</code>），这些线程被重复使用来执行不同的任务，任务完成后不会销毁。在待处理任务量很大的时候，通过对线程资源的复用，避免了线程的频繁创建与销毁，从而降低了系统资源消耗。</li>
<li><strong>提高响应速度：</strong>由于线程池维护了一批 <code>alive</code> 状态的线程，当任务到达时，不需要再创建线程，而是直接由这些线程去执行任务，从而减少了任务的等待时间。</li>
<li><strong>提高线程的可管理性：</strong>使用线程池可以对线程进行统一的分配，调优和监控。</li>
</ul>
<h2 id="12-2线程池设计思路"><a href="#12-2线程池设计思路" class="headerlink" title="12.2线程池设计思路"></a>12.2线程池设计思路</h2><p>将线程池的实现类比于工厂的生产流程：</p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\工厂.png" style="zoom:110%;">

<p>工厂各部分的映射：</p>
<ul>
<li>工厂——线程池</li>
<li>订单——任务（Runnable）</li>
<li>正式工人——核心线程</li>
<li>临时工——普通线程</li>
<li>仓库（仓库中堆积了生产原料）——任务队列</li>
<li>调度员——getTask()</li>
</ul>
<blockquote>
<p><strong>getTask()是一个方法，将任务队列中的任务调度给空闲线程</strong></p>
</blockquote>
<p>经过映射形成线程池的流程如下：</p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\线程池.png" style="zoom:110%;">

<p>那么线程池的流程可以提炼成：</p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\线程池流程.png" style="zoom:90%;">

<h2 id="12-3-Executor-框架"><a href="#12-3-Executor-框架" class="headerlink" title="12.3 Executor 框架"></a>12.3 Executor 框架</h2><h3 id="12-3-1Executor-框架简介"><a href="#12-3-1Executor-框架简介" class="headerlink" title="12.3.1Executor 框架简介"></a>12.3.1Executor 框架简介</h3><p>Executor 框架是 Java5 之后引进的，在 Java 5 之后，通过 JDK 提供的 Executor 框架来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外。</p>
<p>此外，Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架就是为了更好地控制多线程。</p>
<p>还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p><strong>this 逃逸：</strong>指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<h3 id="12-3-2-Executor-框架结构（三大部分）"><a href="#12-3-2-Executor-框架结构（三大部分）" class="headerlink" title="12.3.2 Executor 框架结构（三大部分）"></a>12.3.2 Executor 框架结构（三大部分）</h3><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\Executor.png" style="zoom:90%;">

<p><strong>1) 任务(<code>Runnable</code> /<code>Callable</code>)</strong></p>
<p>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。**<code>Runnable</code> 接口<strong>或 **<code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</p>
<p><strong>2) 任务的执行(<code>Executor</code>)</strong></p>
<p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <strong><code>ExecutorService</code> 接口。<code>ThreadPoolExecutor</code></strong> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong>ExecutorService 接口</strong>。</p>
<p><strong>3) 异步计算的结果(<code>Future</code>)</strong></p>
<p><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</p>
<p>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</p>
<h3 id="12-3-3-Executor-框架的使用示意图"><a href="#12-3-3-Executor-框架的使用示意图" class="headerlink" title="12.3.3 Executor 框架的使用示意图"></a>12.3.3 Executor 框架的使用示意图</h3><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\Executor框架的使用示意图.png" style="zoom:90%;">

<ol>
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的对象直接交给 <code>ExecutorService</code> 执行</strong>: <code>ExecutorService.execute（Runnable command）</code>）或者也可以把 <code>Runnable</code> 对象或<code>Callable</code> 对象提交给 <code>ExecutorService</code> 执行（<code>ExecutorService.submit（Runnable task）</code>或 <code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行 <code>ExecutorService.submit（…）</code>，<code>ExecutorService</code> 将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行 <code>execute()</code>方法和 <code>submit()</code>方法的区别，<code>submit()</code>会返回一个 <code>FutureTask 对象）。由于 FutureTask</code> 实现了 <code>Runnable</code>，我们也可以创建 <code>FutureTask</code>，然后直接交给 <code>ExecutorService</code> 执行。</li>
<li><strong>最后，主线程可以执行 <code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li>
</ol>
<h3 id="12-3-4ThreadPoolExecutor-类介绍"><a href="#12-3-4ThreadPoolExecutor-类介绍" class="headerlink" title="12.3.4ThreadPoolExecutor 类介绍"></a>12.3.4ThreadPoolExecutor 类介绍</h3><p><strong>1）ThreadPoolExecutor 类构造方法</strong></p>
<p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                              )</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池创建的核心参数：</strong></p>
<p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> : executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> : 拒绝策略。当线程池中线程数达到<code>maximumPoolSize</code>且<code>workQueue</code>打满时，后续提交的任务将被拒绝，<code>handler</code>可以指定用什么方式拒绝任务。</li>
</ol>
<p><strong>ThreadPoolExecutor 拒绝策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li>**<code>ThreadPoolExecutor.AbortPolicy</code>**：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li>**<code>ThreadPoolExecutor.CallerRunsPolicy</code>**：直接运行这个任务的<code>run</code>方法，但并非是由线程池的线程处理，而是交由任务的调用线程处理。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 将当前处于等待队列列头（最先加入的任务）的等待任务强行取出，然后再试图将当前被拒绝的任务提交到线程池执行。</li>
</ul>
<h2 id="12-4线程池的创建方式"><a href="#12-4线程池的创建方式" class="headerlink" title="12.4线程池的创建方式"></a>12.4线程池的创建方式</h2><p><strong>方式一： ThreadPoolExecutor 的构造函数创建（推荐使用）</strong></p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\创建线程池1.png" style="zoom:90%;">

<p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出 java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\创建线程池2.png" style="zoom:90%;">

<p>通过 Executors 工具类我们可以很轻松的创建我们下面将要说的几种线程池。但是实际上我们一般都不是直接使用 Java 提供好的线程池，另外在《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure>

<h2 id="12-5-Java-提供提供的几种线程池"><a href="#12-5-Java-提供提供的几种线程池" class="headerlink" title="12.5 Java 提供提供的几种线程池"></a>12.5 Java 提供提供的几种线程池</h2><ul>
<li><strong>newFixedThreadPool：</strong> 该方法返回一个<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个<strong>可根据实际情况调整线程数量的线程池</strong>。核心线程池大小为0，最大线程池大小不受限，来一个创建一个线程 ，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 主要用来在给定的<strong>延迟后运行任务</strong>，或者<strong>定期执行任务</strong>。ScheduledThreadPoolExecutor 又分为：ScheduledThreadPoolExecutor（包含多个线程）和 SingleThreadScheduledExecutor （只包含一个线程）两种。</li>
</ul>
<p><strong>各种线程池的适用场景介绍</strong></p>
<ul>
<li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li>
<li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务，并且在任意时间点，不会有多个线程是活动的应用场景；</li>
<li><strong>CachedThreadPool：</strong> 适合用来执行大量耗时较短且提交频率较高的任务；</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景；</li>
<li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li>
</ul>
<h2 id="12-6ThreadPoolExecutor-使用示例"><a href="#12-6ThreadPoolExecutor-使用示例" class="headerlink" title="12.6ThreadPoolExecutor 使用示例"></a>12.6ThreadPoolExecutor 使用示例</h2><p><strong>Runnable+ThreadPoolExecutor</strong></p>
<h3 id="12-6-1示例代码"><a href="#12-6-1示例代码" class="headerlink" title="12.6.1示例代码"></a>12.6.1示例代码</h3><p><strong>首先创建一个 <code>Runnable</code> 接口的实现类：</strong><code>MyRunnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写测试程序：</strong><code>ThreadPoolExecutorDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:37 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-5 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-4 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-3 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-2 Start. Time &#x3D; Sun Apr 12 11:14:42 CST 2020</span><br><span class="line">pool-1-thread-1 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-4 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-5 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-3 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br><span class="line">pool-1-thread-2 End. Time &#x3D; Sun Apr 12 11:14:47 CST 2020</span><br></pre></td></tr></table></figure>

<p><strong>代码输出解释：</strong></p>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
<h3 id="12-6-2线程池原理分析"><a href="#12-6-2线程池原理分析" class="headerlink" title="12.6.2线程池原理分析"></a>12.6.2线程池原理分析</h3><p>通过代码输出结果可以看出：<strong>线程首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong></p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong>在 上面的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现原理如下图所示：</p>
<img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source\_posts\2021-04-16-Java多线程\图解线程池实现原理.png" style="zoom:110%;">

<p><strong><code>addWorker</code> 这个方法主要用来创建新的工作线程，如果返回true说明创建和启动工作线程成功，否则的话返回的就是false。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">   <span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line">   <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">   <span class="comment">//获取线程池状态</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="comment">//获取线程池中线程的数量</span></span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">               <span class="comment">// core参数为true的话表明队列也满了，线程池大小变为 maximumPoolSize </span></span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">break</span> retry;</span><br><span class="line">               <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">               c = ctl.get();  </span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                   <span class="keyword">continue</span> retry;</span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">       <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">       <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">       Worker w = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       </span><br><span class="line">           w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">           <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 加锁</span></span><br><span class="line">               <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">               mainLock.lock();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//获取线程池状态</span></span><br><span class="line">                   <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                  <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">                 <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                  <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                   <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       workers.add(w);</span><br><span class="line">                      <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                       <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                       <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                     <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                       workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 释放锁</span></span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">               <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                   t.start();</span><br><span class="line">                 <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                   workerStarted = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">           <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> workerStarted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-7几个常见的对比"><a href="#12-7几个常见的对比" class="headerlink" title="12.7几个常见的对比"></a>12.7几个常见的对比</h2><h3 id="12-7-1Runnable-vs-Callable"><a href="#12-7-1Runnable-vs-Callable" class="headerlink" title="12.7.1Runnable vs Callable"></a>12.7.1Runnable vs Callable</h3><p><strong><code>Runnable</code> 接口</strong>不会返回结果或抛出检查异常，但是**<code>Callable</code> 接口<strong>可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **<code>Runnable</code> 接口</strong>，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现 <code>Runnable</code> 对象和 <code>Callable</code> 对象之间的相互转换。</p>
<h3 id="12-7-2-execute-vs-submit"><a href="#12-7-2-execute-vs-submit" class="headerlink" title="12.7.2 execute() vs submit()"></a>12.7.2 execute() vs submit()</h3><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>我们以**<code>AbstractExecutorService</code>**接口中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再来看看<code>execute()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-7-3-shutdown-VS-shutdownNow"><a href="#12-7-3-shutdown-VS-shutdownNow" class="headerlink" title="12.7.3 shutdown() VS shutdownNow()"></a>12.7.3 shutdown() VS shutdownNow()</h3><ul>
<li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li>
</ul>
<h3 id="12-7-4-isTerminated-VS-isShutdown"><a href="#12-7-4-isTerminated-VS-isShutdown" class="headerlink" title="12.7.4 isTerminated() VS isShutdown()"></a>12.7.4 isTerminated() VS isShutdown()</h3><ul>
<li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
<li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>
<h3 id="12-7-5示例代码"><a href="#12-7-5示例代码" class="headerlink" title="12.7.5示例代码"></a>12.7.5示例代码</h3><p><strong>Callable+ThreadPoolExecutor</strong></p>
<p><strong>首先创建一个 <code>Callable</code> 接口的实现类：</strong><code>MyCallable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//返回执行当前 Callable 的线程名字</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码：</strong><code>CallableDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> Date() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Output:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">41</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">42</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">3</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">4</span></span><br><span class="line">Wed Nov <span class="number">13</span> <span class="number">13</span>:<span class="number">40</span>:<span class="number">43</span> CST <span class="number">2019</span>::pool-<span class="number">1</span>-thread-<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>可以得到任务的执行情况，包括是否成功提交，还有任务的返回结果等信息。</p>
<h1 id="13-J-U-C-AQS"><a href="#13-J-U-C-AQS" class="headerlink" title="13. J.U.C - AQS"></a>13. J.U.C - AQS</h1><h2 id="13-1-J-U-C-类结构"><a href="#13-1-J-U-C-类结构" class="headerlink" title="13.1 J.U.C 类结构"></a>13.1 J.U.C 类结构</h2><p> <strong>J.U.C（java.util.concurrent）包：</strong>提供了很多高性能的并发类，大大提高了并发性能。研究具体的类原理前需要对整个框架有一个大概的认识，整个框架分为五个模块，部分高级模块会依赖其他基础模块，如图所示：</p>
<p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\JUC类体系结构.png" alt="image-20210620113447451"></p>
<h2 id="13-2-AQS-原理分析"><a href="#13-2-AQS-原理分析" class="headerlink" title="13.2 AQS 原理分析"></a>13.2 AQS 原理分析</h2><p><strong>AQS 核心思想</strong></p>
<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</p>
<p>如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<blockquote>
<p><strong>CLH(Craig,Landin,and Hagersten)队列：</strong>是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>AQS 原理如图所示：</p>
<p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\AQS原理图" alt="AQS原理图"></p>
<p><strong>AQS 使用一个 int 成员变量 state 来表示同步状态</strong>，当 state&gt;0 时表示已经获取锁，当 state=0 时表示释放了锁。用 volatile 修饰共享变量 state 保证线程同步，线程通过 CAS 去改变状态符，成功则获取锁成功，失败则被 AQS 封装成 Node 进入等待队列，等待被唤醒。通过内置的 FIFO 队列来完成获取资源线程的排队工作。</p>
<blockquote>
<p><strong>AQS 是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋的方式，不停地尝试获取锁，直到被其他线程获取成功。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p><strong>AQS 提供了三种方法对状态信息修改：</strong>protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-1-AQS-对资源的共享方式"><a href="#13-2-1-AQS-对资源的共享方式" class="headerlink" title="13.2.1 AQS 对资源的共享方式"></a>13.2.1 AQS 对资源的共享方式</h3><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<h3 id="13-2-2-AQS-底层模板方法模式"><a href="#13-2-2-AQS-底层模板方法模式" class="headerlink" title="13.2.2 AQS 底层模板方法模式"></a>13.2.2 AQS 底层模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 </p>
<p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到A线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state 会累加），这就是<strong>可重入</strong>的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 为例，任务分为N个子线程去执行，state 也初始化为 N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown() 一次，state 会 CAS(Compare and Swap) 减1。等到所有子线程都执行完后(即state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p><strong>总结：</strong> </p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>
<p>AQS 解决了实现同步器是涉及到的大量细节问题，如：获取同步状态、FIFO 同步队列等。在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。</p>
<p>AQS 的主要使用方式是继承，子类通过继承 AQS 并实现它的抽象方法来管理同步状态。</p>
<h2 id="13-3-CountDownLatch"><a href="#13-3-CountDownLatch" class="headerlink" title="13.3 CountDownLatch"></a>13.3 CountDownLatch</h2><p><strong>CountDownLatch的内部实现如下：</strong></p>
<p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\countdownlatch.png" alt="img"></p>
<ul>
<li><strong>CountDownLatch</strong>内部维护一个计数器，CountDownLatch.countDown（）每被执行一次都会使计数器值减少1。 </li>
<li><strong>当计数器不为0时</strong>，CountDownLatch.await（）方法的调用将会导致执行线程被暂停，这些线程就叫做该 CountDownLatch 上的等待线程。 </li>
<li>CountDownLatch.countDown（）相当于一个通知方法，<strong>当计数器值达到0时</strong>，唤醒所有等待线程。当然对应还有指定等待时间长度的CountDownLatch.await( long , TimeUnit)方法。 </li>
</ul>
<p><strong>Demo0：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..end..run..</span><br></pre></td></tr></table></figure>

<p><strong>Demo1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.print(<span class="string">&quot;end..&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run..run..run..run..run..run..run..run..run..run..end..</span><br></pre></td></tr></table></figure>

<ul>
<li>由 Demo0 可知，当主线程不等待时，那 end 输出就可能在任意时刻执行，也就是主线程与其它线程是并行的；</li>
<li>由 Demo1可知，当主线程 await 一下，那主线程就会等其它线程执行到 countDownLatch==0 来唤醒主线程，那么输出 end 的操作就会最后执行。</li>
</ul>
<h2 id="13-4-CyclicBarrier"><a href="#13-4-CyclicBarrier" class="headerlink" title="13.4 CyclicBarrier"></a>13.4 CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行，在实际工作中可以用来<strong>模拟高并发请求测试</strong>。</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p>
<p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\CyclicBarrier.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;王进..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">before..before..before..before..before..王进..after..after..after..after..after..</span><br></pre></td></tr></table></figure>

<p><strong>reset 方法的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">5</span>;</span><br><span class="line">        MyRunnable my=<span class="keyword">new</span> MyRunnable();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread,my);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cyclicBarrier.reset();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 reset 方法实现了 “屏障” 的循环使用。</p>
<h2 id="13-5-Semaphore"><a href="#13-5-Semaphore" class="headerlink" title="13.5 Semaphore"></a>13.5 Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p>
<p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    Date satrtTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    String time = sim.format(satrtTime);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;时刻访问了资源&quot;</span>);</span><br><span class="line">                    System.out.println(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-6</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-8</span><br><span class="line">pool-1-thread-7</span><br><span class="line">pool-1-thread-9</span><br><span class="line">pool-1-thread-10</span><br><span class="line">线程pool-1-thread-2在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-5在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-6在2021-06-20 22:11:05时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-1在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-3在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">线程pool-1-thread-4在2021-06-20 22:11:07时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-7在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">线程pool-1-thread-9在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-8在2021-06-20 22:11:09时刻访问了资源</span><br><span class="line">0 </span><br><span class="line">0 </span><br><span class="line">线程pool-1-thread-10在2021-06-20 22:11:11时刻访问了资源</span><br><span class="line">2 </span><br></pre></td></tr></table></figure>

<p>多个线程可以并发执行，一共十个线程对应十个请求访问资源，但是同时最多只能有三个线程访问共享资源。也就是控制并发量。</p>
<h2 id="13-6-AQS-组件总结"><a href="#13-6-AQS-组件总结" class="headerlink" title="13.6 AQS 组件总结"></a>13.6 AQS 组件总结</h2><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h1 id="14-J-U-C-Atomic"><a href="#14-J-U-C-Atomic" class="headerlink" title="14. J.U.C - Atomic"></a>14. J.U.C - Atomic</h1><h2 id="14-1-Atomic-原子类简介"><a href="#14-1-Atomic-原子类简介" class="headerlink" title="14.1 Atomic 原子类简介"></a>14.1 Atomic 原子类简介</h2><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img src="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/GitHub\MyBlogs\source_posts\2021-04-16-Java多线程\JUC原子类概览.png" alt="JUC原子类概览"></p>
<h2 id="14-2-JUC-包中的原子类"><a href="#14-2-JUC-包中的原子类" class="headerlink" title="14.2 JUC 包中的原子类"></a>14.2 JUC 包中的原子类</h2><p><strong>基本类型</strong> </p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整形原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
</ul>
<h2 id="14-3-AtomicInteger-的使用"><a href="#14-3-AtomicInteger-的使用" class="headerlink" title="14.3 AtomicInteger 的使用"></a>14.3 AtomicInteger 的使用</h2><p>通过 i++ 操作来说明 AtomicInteger 的使用。</p>
<p>i++操作并不是线程安全的，它是一个复合操作，包含三个步骤：</p>
<ul>
<li><strong>拷贝i的值到临时变量</strong> </li>
<li><strong>临时变量++操作</strong> </li>
<li><strong>拷贝回原始变量i</strong> </li>
</ul>
<p>这是一个<strong>复合操作，不能保证原子性</strong>，所以这不是线程安全的操作。从运行结果来看，多线程环境下，有可能多个线程的复合操作是穿插的（比如取值是相同的，然后加完还是相同的，最后这次操作只是覆盖了相同的值，并没有+1操作），所以最后的值是每个线程执行了 1000000 的结果，但是由于每个线程的复合操作不满足原子性，最后的结果到不了 2000000。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">1000000</span>; m++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest mt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 休眠一下，让线程执行完毕。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(ThreadTest.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出是不确定的，比如输出1933446，也就是线程不安全，发生了竟态导致计算结果有误。当我们使用了<strong>Atomic等原子类</strong>时，会发现每次输出结果都是2000000，符合我们的程序设计要求。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">1000000</span>; m++) &#123;</span><br><span class="line">            i.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest mt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 休眠一下，让线程执行完毕。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(ThreadTest.i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-4-AtomicInteger-类的原理"><a href="#14-4-AtomicInteger-类的原理" class="headerlink" title="14.4 AtomicInteger 类的原理"></a>14.4 AtomicInteger 类的原理</h2><p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值，如果不相同不进行操作。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset ，通过复杂的计算得到期望值。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2021/04/15/HashMap/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/two-sum/">热题100-1. 两数之和</a></strong></p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>利用HashMap查找时间复杂度为O(1)</strong></p>
<ul>
<li>遍历数组，每遍历到一个元素，用目标值减去该元素，如果前面有对应的元素，在HashMap中应该有对应的键值，将该元素索引和HashMap中的索引返回即可</li>
<li>如果没有，将该元素和其索引存储到HashMap中</li>
<li>遍历结束没有找到，返回空数组</li>
</ul>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    hm.put(nums[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,hm.get(target-nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        hm.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/704c8388a82e42e58b7f5751ec943a11?tpId=190&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-未排序数组中累加和为给定值的最长子数组长度</strong></a></p>
<p>给定一个无序数组arr, 其中元素可正、可负、可0。给定一个整数k，求arr所有子数组中累加和为k的最长子数组长度</p>
<p>与力扣上一道二叉树的题目很像</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>前缀和：</strong>前缀和表示数组中该元素前面的元素累加和 + 该元素的和</p>
<p>同一数组中，如果<strong>两个数的前缀总和是相同的，那么这些元素之间的元素总和为零</strong>。进一步扩展相同的想法，<strong>如果前缀总和currSum，在元素A和元素B处相差target，则位于元素A和元素B之间的元素之和是target</strong>。</p>
<ul>
<li>维护一个最大长度的变量max</li>
<li>遍历数组中的元素，计算该元素的前缀和</li>
<li>当该元素的前缀和-目标值在HashMap中时，表示它们之间的差值满足目标值</li>
<li>如果该前缀和在HashMap中不存在，添加到Hashmap中；如果存在，不用添加，因为要求最长子序列，所以索引越远越好</li>
</ul>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max length of the subarray sum = k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxlenEqualK</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        hm.put(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            preSum+=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(preSum-k))&#123;</span><br><span class="line">                max=Math.max(max,i+<span class="number">1</span>-hm.get(preSum-k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hm.containsKey(preSum))&#123;</span><br><span class="line">                hm.put(preSum,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<p>题目三</p>
<p>解题思路</p>
<p>代码及注释</p>
<p>题目四</p>
<p>解题思路</p>
<p>代码及注释</p>
<p>题目五</p>
<p>解题思路</p>
<p>代码及注释</p>
<p>题目六</p>
<p>解题思路</p>
<p>代码及注释</p>
<p>题目七</p>
<p>解题思路</p>
<p>代码及注释</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis相关</title>
    <url>/2021/04/10/Redis%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1Redis简介"><a href="#1-1Redis简介" class="headerlink" title="1.1Redis简介"></a>1.1Redis简介</h2><p>Redis 是一款高性能的（key/value）基于内存的非关系型数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用集群方案来扩展读性能和写性能。</p>
<h2 id="1-2为什么要用-redis"><a href="#1-2为什么要用-redis" class="headerlink" title="1.2为什么要用 redis"></a>1.2为什么要用 redis</h2><p>主要依据“<strong>高性能</strong>”和“<strong>高并发</strong>”这两点</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg"></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg"></p>
<p><strong>补充一条：</strong>单线程操作，避免了线程上下文切换操作 ，采用的是<strong>多路 I/O 复用的线程模型</strong>，实现了一个线程监控多个 IO 流，及时响应请求 </p>
<h2 id="1-3为什么用redis而不用map-guava-做缓存"><a href="#1-3为什么用redis而不用map-guava-做缓存" class="headerlink" title="1.3为什么用redis而不用map/guava 做缓存?"></a>1.3为什么用redis而不用map/guava 做缓存?</h2><p>以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错。</p>
<p>使用 redis 之类的称为<strong>分布式缓存</strong>，在多实例（进程）的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p>
<h3 id="1-3-1本地缓存map-guava"><a href="#1-3-1本地缓存map-guava" class="headerlink" title="1.3.1本地缓存map/guava"></a>1.3.1本地缓存map/guava</h3><p><strong>优缺点：</strong></p>
<ol>
<li><p>访问速度快，但无法进行大数据存储</p>
<p> 本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。</p>
</li>
<li><p>集群的数据更新问题</p>
<p> 与此同时，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错，如基于 Redis 的发布订阅机制来同步更新各个部署节点。</p>
</li>
<li><p>数据随应用进程的重启而丢失</p>
<p> 由于本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。所以对于需要持久化的数据，需要注意及时保存，否则可能会造成数据丢失。</p>
</li>
</ol>
<p><strong>使用场景：</strong></p>
<p>本地缓存一般适合于缓存只读数据，如统计类数据。或者每个部署节点独立的数据，如长连接服务中，每个部署节点由于都是维护了不同的连接，每个连接的数据都是独立的，并且随着连接的断开而删除。如果数据在集群的不同部署节点需要共享和保持一致，则需要使用分布式缓存来统一存储，实现应用集群的所有应用进程都在该统一的分布式缓存中进行数据存取即可。</p>
<h3 id="13-2分布式缓存redis"><a href="#13-2分布式缓存redis" class="headerlink" title="13.2分布式缓存redis"></a>13.2分布式缓存redis</h3><p><strong>优缺点：</strong></p>
<ol>
<li><p>支持大数据量存储，不受应用进程重启影响</p>
<p> 分布式缓存由于是独立部署的进程，拥有自身独立的内存空间，不会受到应用进程重启的影响，在应用进程重启时，分布式缓存的数据依然存在。同时对于数据量而言，由于不需要占用应用进程的内存空间，并且一般支持以集群的方式拓展，故可以进行大数据量的数据缓存。</p>
</li>
<li><p>数据集中存储，保证数据一致性</p>
<p> 当应用进程采用集群方式部署时，集群的每个部署节点都通过一个统一的分布式缓存进行数据存取操作，故不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题。</p>
</li>
<li><p>数据读写分离，高性能，高可用</p>
<p> 分布式缓存一般支持数据副本机制，可以实现读写分离，故可以解决高并发场景中的数据读写性能问题。并且由于在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。</p>
</li>
<li><p>数据跨网络传输，性能低于本地缓存</p>
<p> 由于分布式缓存是独立部署的进程，并且一般都是与应用进程位于不同的机器，故需要通过网络来进行数据传输，这样相对于本地缓存的进程内部的数据读取操作，性能会较低。</p>
</li>
</ol>
<h1 id="2-数据类型和使用场景分析"><a href="#2-数据类型和使用场景分析" class="headerlink" title="2.数据类型和使用场景分析"></a>2.数据类型和使用场景分析</h1><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><p>String 数据结构是简单的 key-value 类型，value 其实不仅可以是 String，也可以是数字。 </p>
<p><strong>应用场景：</strong></p>
<p>常规 key-value 缓存应用</p>
<p>常规计数：微博上的粉丝数等</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" alt="img" style="zoom: 67%;">

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; <span class="built_in">del</span> hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>String 的数据结构为简单动态字符串。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片01.png" alt="image-20210630202553853"></p>
<p>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>
<h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h2><p>hash 是一个 string 类型的 field 和 value 的映射表（值：包含键值对的无序散列表）</p>
<p><strong>应用场景：</strong></p>
<p>hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\图片06.png" alt="img" style="zoom:67%;">

<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line"><span class="number">1</span>) &quot;sub-key1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;sub-key2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line"><span class="number">1</span>) &quot;sub-key1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>底层就是 Hashtable（哈希表）</p>
<h2 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h2><p>list 就是链表</p>
<p><strong>应用场景：</strong></p>
<p>Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用 Redis 的 list 结构来实现。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片02.png" alt="image-20210630202736517"></p>
<h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p>
<p><strong>应用场景：</strong></p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>Set 数据结构是 dict 字典，字典是用哈希表实现的。</p>
<p>Java 中 HashSet 的内部实现使用的是 HashMap，HashSet 中的元素都存放在 HashMap 的 key 上面，而所有的 value 都指向同一个对象。Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p>
<h2 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h2><p>和 set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</p>
<p><strong>应用场景：</strong></p>
<p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>SortedSet(zset) 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p>
<p><strong>zset 底层使用了两个数据结构</strong></p>
<ul>
<li>hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li>
<li>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li>
</ul>
<p><strong>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表</strong></p>
<ul>
<li><p>有序链表</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片03.png" alt="image-20210630204238166"></p>
</li>
<li><p>跳跃表</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片04.png" alt="image-20210630204325616"></p>
<ol>
<li>从第2层开始，1节点比51节点小，向后比较。</li>
<li>21节点比51节点小，继续向后比较，后面就是 NULL 了，所以从21节点向下到第1层</li>
<li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li>
<li>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li>
</ol>
</li>
</ul>
<p><strong>跳表的优势</strong></p>
<ul>
<li>相对于有序链表来说，查询和插入速率都要高</li>
<li>相对于红黑树来说，实现更简单，维护代价更低，因为不需要旋转等操作来维护平衡性</li>
</ul>
<h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h1><h2 id="3-1持久化策略"><a href="#3-1持久化策略" class="headerlink" title="3.1持久化策略"></a>3.1持久化策略</h2><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis支持持久化支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>将数据在某个节点上的副本写入一个临时文件，持久化结束后，用该临时文件替换上次持久化的文件，达到数据恢复的目的</p>
<p><strong>触发方式：</strong>在配置文件中，可以配置执行了多少次 save 就自动触发自动持久化。 </p>
<ul>
<li><strong>优点：</strong>使用单独的子进程来持久化，主进程不会进行任何的I/O操作，保证了 redis 的高效性能</li>
<li><strong>缺点：</strong>RDB 通常间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据的丢失，所以更适用于对数据要求不是很严谨的情况</li>
</ul>
<p>项目中使用的存储机制：检测到更改的 key 越多，更新越频繁。也就是更改越少，持久化的间隔时间越长。</p>
<table>
<thead>
<tr>
<th>更改key的数目</th>
<th>更新时间间隔</th>
</tr>
</thead>
<tbody><tr>
<td>更改了1个key</td>
<td>间隔900秒更新一次数据</td>
</tr>
<tr>
<td>更改了10个key</td>
<td>间隔300秒更新一次数据</td>
</tr>
<tr>
<td>10000</td>
<td>60秒</td>
</tr>
</tbody></table>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>将执行过的指令记录下来，数据恢复时，按照记录文件中的指令顺序，再将指令执行一遍</p>
<ul>
<li><strong>优点：</strong>可以保持更高的数据完整性，如果设置appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。且日志写入写信不完整，支持检查AOF日志来进行AOF修复，AOF没有被write之前可以删除某些指令</li>
<li><strong>缺点：</strong>AOF文件比RDB文件大，恢复的速度比RDB慢</li>
</ul>
<h2 id="3-2持久化策略的选择"><a href="#3-2持久化策略的选择" class="headerlink" title="3.2持久化策略的选择"></a>3.2持久化策略的选择</h2><ul>
<li>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。 </li>
<li>RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。 </li>
</ul>
<h1 id="4-键的过期时间"><a href="#4-键的过期时间" class="headerlink" title="4.键的过期时间"></a>4.键的过期时间</h1><p>Redis 中有个设置时间过期的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：Redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔 100ms 就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！也就是在获取一个 key 的时候，redis 会检查这个 key 是否已经过期，若过期，则会进行删除操作。</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>Redis 内存淘汰机制。</strong></p>
<h1 id="5-内存淘汰策略"><a href="#5-内存淘汰策略" class="headerlink" title="5.内存淘汰策略"></a>5.内存淘汰策略</h1><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</p>
<p>可以通过设置 Redis 的缓存空间大小为热点数据占用的内存量，然后当内存不足时，Redis 会通过内存淘汰策略将对应的 key 移除内存。Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ol>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ol>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<p>LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6.线程模型"></a>6.线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p><strong>Redis 是单线程的，为什么还那么快？</strong></p>
<ol>
<li>操作完全基于内存，速度快；</li>
<li>数据结构简单，对数据的操作也简单；</li>
<li>采用单线程，避免了不必要的上下文切换开销；</li>
<li>使用非阻塞的<strong>多路IO复用模型。</strong></li>
</ol>
<p>​    I/O 多路复用模型是利用select、poll、epoll可以<strong>同时监察多个流的 I/O 事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，<strong>当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流</strong>（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 <strong>I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且<strong>Redis在内存中操作数据的速度非常快</strong>（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7.事务"></a>7.事务</h1><p><strong>支持事务的隔离性</strong></p>
<ul>
<li>Redis 是单线程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li>
<li>Redis 将多个命令请求打包，然后按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</li>
</ul>
<p><strong>Redis 通过如下一些指令来实现事务功能：</strong></p>
<ul>
<li><strong>MULTI：</strong>标记一个事务块的开始。 </li>
<li><strong>EXEC：</strong>执行所有事务块内的命令。 </li>
<li><strong>DISCARD：</strong>取消事务，放弃执行事务块内的所有命令。 </li>
<li><strong>UNWATCH：</strong>取消 WATCH 命令对所有 key 的监视。 </li>
<li><strong>WATCH key [key …]：</strong>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 </li>
</ul>
<p>需要注意的是 <strong>Redis 的事务不支持回滚操作</strong>，Redis 以 MULTI  开始一个事务，然后将多个命令入队到事务中，最后由 EXEC 命令触发事务，  一并执行事务中的所有命令。只有当被调用的 Redis 命令有语法错误时，这条命令才会执行失败，或者对某个键执行不符合其数据类型的操作，但是应该在将命令入队列的时候就应该并且能够发现这些问题，所以 Redis 的事务不支持进行回滚操作。</p>
<h1 id="8-集群方案"><a href="#8-集群方案" class="headerlink" title="8.集群方案"></a>8.集群方案</h1><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> 、<code>twemproxy</code> 有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p>
<p>现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p>
<p>Redis的官方多机部署方案，Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master  node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p>
<h2 id="8-1Redis-cluster-介绍"><a href="#8-1Redis-cluster-介绍" class="headerlink" title="8.1Redis cluster 介绍"></a>8.1Redis cluster 介绍</h2><ul>
<li>自动将数据进行分片，每个 master 上放一部分数据</li>
<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>
</ul>
<p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h2 id="8-2哨兵模式（sentinel）"><a href="#8-2哨兵模式（sentinel）" class="headerlink" title="8.2哨兵模式（sentinel）"></a>8.2哨兵模式（sentinel）</h2><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/哨兵.png" style="zoom:80%;">

<p><strong>哨兵的介绍</strong></p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，也可以理解为是一个<strong>故障转移系统</strong>，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
</ul>
<h2 id="8-3节点间的内部通信机制"><a href="#8-3节点间的内部通信机制" class="headerlink" title="8.3节点间的内部通信机制"></a>8.3节点间的内部通信机制</h2><p><strong>基本通信原理</strong></p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>集中式：</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\集中式.png" style="zoom:120%;">

<p><strong>Gossip 协议：</strong>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\Gossip.png" style="zoom:120%;">

<p><strong>两种通信方式对比：</strong></p>
<ul>
<li><p><strong>集中式：</strong></p>
<p>优点：元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</p>
<p>缺点：所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p>
</li>
<li><p><strong>Gossip协议：</strong></p>
<p>优点：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p>
<p>缺点：元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p>
</li>
</ul>
<blockquote>
<p><strong>数据元、元数据与数据</strong></p>
<p>数据元是组成实体数据的最小单元，或称原子数据，例如，客户联系方式中的手机号码，手机号为数据元，135****为数据元的值。</p>
<p>元数据是用来描述数据的数据，让数据更容易理解、查找、管理和使用。举个栗子“村里有个姑娘叫小芳，长得好看又善良”这首耳熟能详的歌，我们分析一下，姓名：小芳、性别：姑娘（女）、长相：好看、性格：善良，住址：村里。这里面：小芳是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。当然元数据也会被描述，例如上边我举的例子中姓名的字段长度，字段编码、定义、字段类型、默认值等是用来描述“姓名”这个数据元的。</p>
</blockquote>
<h2 id="8-4分布式寻址算法"><a href="#8-4分布式寻址算法" class="headerlink" title="8.4分布式寻址算法"></a>8.4分布式寻址算法</h2><p>在集群方案中，我们想要获取某个数据存储在哪台服务器中，可以通过顺序遍历的方式来查找。但是这种方式无疑是耗时的，所以我们会想到按某一个字段值进行 Hash 值、取模。所以我们就看看使用 Hash 的方式是怎么进行的。</p>
<h3 id="1-hash-算法"><a href="#1-hash-算法" class="headerlink" title="1. hash 算法"></a>1. hash 算法</h3><p>来了一个 key，首先计算 hash 值，然后<strong>对节点数取模</strong>。然后打在不同的 master 节点上。</p>
<p><strong>问题：</strong></p>
<ul>
<li>Redis服务器变动时，所有缓存的位置都会发生改变；</li>
<li>一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</li>
</ul>
<h3 id="2-一致性-hash-算法"><a href="#2-一致性-hash-算法" class="headerlink" title="2.一致性 hash 算法"></a>2.一致性 hash 算法</h3><blockquote>
<p>简书文章链接：<a href="https://www.jianshu.com/p/528ce5cd7e8f"><strong>点击这里</strong></a></p>
</blockquote>
<p>一致性 Hash 算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的 Hash 算法是对<code>2的32方</code>取模。即，一致性 Hash 算法将整个 Hash 空间组织成一个虚拟的圆环，Hash 函数的值空间为<code>0 ~ 2^32 - 1(一个32位无符号整型)</code>，整个哈希环如下：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片10.png" alt="img" style="zoom:50%;">

<p>整个圆环以<code>顺时针方向组织</code>，圆环正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推。<br> 第二步，我们将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片11.png" alt="img" style="zoom:50%;">

<p>现在，我们使用以下算法定位数据访问到相应的服务器：</p>
<blockquote>
<p>将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。</p>
</blockquote>
<p>例如，现在有ObjectA，ObjectB，ObjectC三个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片12.png" alt="img" style="zoom:50%;">

<p>根据一致性算法，Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</p>
<h4 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h4><p>现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图所示：</p>
<img src="https://upload-images.jianshu.io/upload_images/6555006-cd54d5c30e9cad6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img" style="zoom:50%;">

<p>另外一种情况，现在我们系统增加了一台服务器Node X，如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片13.png" alt="img" style="zoom:50%;">

<p>此时对象ObjectA、ObjectB没有受到影响，只有Object C重新定位到了新的节点X上。<br> 如上所述：</p>
<blockquote>
<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。</p>
</blockquote>
<h4 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h4><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成<code>数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题</code>，如图特例：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片14.png" alt="img" style="zoom:50%;">

<p>这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了<code>虚拟节点机制</code>，即<strong>对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</strong></p>
<p><strong>具体操作可以为服务器IP或主机名后加入编号来实现</strong>，实现如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片15.png" alt="img" style="zoom:50%;">

<p>数据定位算法不变，只需要增加一步：<strong>虚拟节点到实际点的映射。</strong><br>所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h3 id="3-hash-slot-算法"><a href="#3-hash-slot-算法" class="headerlink" title="3. hash slot 算法"></a>3. hash slot 算法</h3><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 校验码值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>
<p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有  5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的  hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>
<p>任何一台机器宕机，另外两个节点，不影响的。因为 <strong>key 找的是 hash slot，不是机器</strong>。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\hash-slot.png" style="zoom:80%;">

<h1 id="9-分布式问题"><a href="#9-分布式问题" class="headerlink" title="9.分布式问题"></a>9.分布式问题</h1><p>见《Redis分布式锁》</p>
<h1 id="11-缓存异常"><a href="#11-缓存异常" class="headerlink" title="11.缓存异常"></a>11.缓存异常</h1><h2 id="11-1缓存雪崩"><a href="#11-1缓存雪崩" class="headerlink" title="11.1缓存雪崩"></a>11.1缓存雪崩</h2><p><strong>什么是缓存雪崩？</strong></p>
<p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>有哪些解决办法？</strong></p>
<ul>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉（通过限流来限制直接访问数据库的请求数量，当限流组件发现剩余的请求未能通过自己，便会调用自定义的降级组件，返回一些默认的友好提示：服务器忙，请稍后重试等，不让客户端继续等待）</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" style="zoom:80%;">



<h2 id="11-2缓存穿透"><a href="#11-2缓存穿透" class="headerlink" title="11.2缓存穿透"></a>11.2缓存穿透</h2><p><strong>什么是缓存穿透？</strong></p>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，造成数据库负载过大。如下图所示：</p>
<p><strong>正常缓存处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png" style="zoom:60%;">

<p><strong>缓存穿透情况处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png" style="zoom:60%;">

<p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;; </code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p>
<p><strong>有哪些解决办法？</strong></p>
<p><strong>1）参数校验</strong></p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。（也就是将一些明显错误的key值，直接将错误信息返回给客户端直接报错）</p>
<p><strong>2）缓存无效 key</strong> </p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险（比如频繁更换key，造成大量的无效key存在于缓存中）</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png" style="zoom:60%;">

<p>也就是在Redis缓存与服务端之间再加一层布隆过滤器</p>
<p><strong>布隆过滤器原理：</strong>点击这里~</p>
<h1 id="12-Redis-支持的客户端"><a href="#12-Redis-支持的客户端" class="headerlink" title="12 Redis 支持的客户端"></a>12 Redis 支持的客户端</h1><p>Redisson、Jedis等</p>
<p><strong>二者的对比</strong></p>
<ul>
<li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；（Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的）</li>
<li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li>
</ul>
<h1 id="13-Redis-和-Memcached-的区别"><a href="#13-Redis-和-Memcached-的区别" class="headerlink" title="13 Redis 和 Memcached 的区别"></a>13 Redis 和 Memcached 的区别</h1><p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型。</li>
<li>Redis 支持五种不同的数据类型，可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
<li>Memcached 不支持持久化。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
</ul>
<h1 id="14如何保证缓存与数据库双写时的数据一致性？"><a href="#14如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="14如何保证缓存与数据库双写时的数据一致性？"></a>14如何保证缓存与数据库双写时的数据一致性？</h1><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p><strong>读请求和写请求串行化</strong></p>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="1-Cache-Aside-Pattern"><a href="#1-Cache-Aside-Pattern" class="headerlink" title="1.Cache Aside Pattern"></a>1.Cache Aside Pattern</h2><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li>
</ul>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ul>
<li><p><strong>因为对于比较复杂的缓存数据计算场景，当被更新的缓存频繁更新、且不常被访问时，更新缓存的代价比较高</strong></p>
<p><strong>例如：</strong>一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>
</li>
</ul>
<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<h2 id="2-最初级的缓存不一致问题"><a href="#2-最初级的缓存不一致问题" class="headerlink" title="2.最初级的缓存不一致问题"></a>2.最初级的缓存不一致问题</h2><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>
<p><strong>解决思路：</strong></p>
<p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p>
<h2 id="3-比较复杂的数据不一致问题"><a href="#3-比较复杂的数据不一致问题" class="headerlink" title="3.比较复杂的数据不一致问题"></a>3.比较复杂的数据不一致问题</h2><p><strong>问题：</strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改，造成数据库和缓存中的数据不一样。</p>
<p><strong>出现场景：</strong>上亿流量高并发场景下，缓存会出现这个问题（大量的“更新”+“读”操作&lt;其实就是时间差&gt;）</p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p>
<p><strong>解决思路：</strong></p>
<p>更新数据的时候，根据<strong>数据的唯一标识（例如店铺ID）</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p>
<p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>
<p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>
<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<h1 id="15-五种IO模型"><a href="#15-五种IO模型" class="headerlink" title="15.五种IO模型"></a>15.五种IO模型</h1><blockquote>
<p><strong>Note：</strong></p>
<p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p>
<p> 我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p>
</blockquote>
<p>一个IO操作其实分成了两个步骤：</p>
<ul>
<li>发起 IO请求</li>
<li>实际的 IO 操作（读/写）。</li>
</ul>
<p><strong>阻塞IO和非阻塞IO的区别：</strong>在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 </p>
<p><strong>同步IO和异步IO的区别：</strong>在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。 </p>
<h2 id="1-阻塞IO模型"><a href="#1-阻塞IO模型" class="headerlink" title="1.阻塞IO模型"></a>1.阻塞IO模型</h2><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<p>执行如下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fd=connect();</span><br><span class="line">write(fd);</span><br><span class="line">read(fd);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\阻塞IO.png" style="zoom:100%;">

<h2 id="2-非阻塞IO模型"><a href="#2-非阻塞IO模型" class="headerlink" title="2.非阻塞IO模型"></a>2.非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\非阻塞IO.png"></p>
<p>这样会造成CPU的占有率特别高</p>
<h2 id="3-多路复用IO模型"><a href="#3-多路复用IO模型" class="headerlink" title="3.多路复用IO模型"></a>3.多路复用IO模型</h2><p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p>
<p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p>
<p>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\多路复用IO.png"></p>
<h2 id="4-信号驱动IO模型"><a href="#4-信号驱动IO模型" class="headerlink" title="4.信号驱动IO模型"></a>4.信号驱动IO模型</h2><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\信号驱动IO.png"></p>
<h2 id="5-异步IO模型"><a href="#5-异步IO模型" class="headerlink" title="5.异步IO模型"></a>5.异步IO模型</h2><p>读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。</p>
<p>读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>
<p><strong>对比信号驱动IO，异步IO的主要区别在于：</strong>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\异步IO.png"></p>
<h1 id="16-常用的IO复用模型"><a href="#16-常用的IO复用模型" class="headerlink" title="16.常用的IO复用模型"></a>16.常用的IO复用模型</h1><p>目前支持I/O多路复用的系统调用有<strong>select，poll，epoll</strong>等函数。I/O多路复用就是通过一种机制<strong>一个线程可以监视多个描述符</strong>，一旦某个描述符读就绪或者写就绪，其能够通知应用程序进行相应的读写操作。</p>
<p><strong>多路I/O复用机制</strong>与多进程和多线程技术相比系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<p>常见的函数特点如下：</p>
<p><strong>三种：select，poll，epoll</strong></p>
<ul>
<li><p><strong>select</strong>==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询所有流</strong>，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll</strong>==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
</li>
<li><p><strong>epoll</strong>==&gt;时间复杂度O(1)</p>
<p>epoll可以理解为event poll，不同于无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p>
</li>
</ul>
<p><strong>三种模型分析：</strong></p>
<p><strong>select缺点：</strong></p>
<ul>
<li>每次调用 select，都需要把 fd_set 集合从用户态拷贝到内核空间中</li>
<li>如果任何一个 sockt(I/O stream) 出现了数据，需要在内核遍历传递进来的所有 fd_set，找出能读出数据，或者写入数据的流，对他们进行操作</li>
<li>有最大监听连接数 1024 个的限制</li>
</ul>
<p><strong>poll缺点：</strong></p>
<ul>
<li><strong>poll 没有最大监听连接数的限制（与 Select 不同）</strong></li>
<li>每次调用 poll，都需要把 fd_set 集合从用户态拷贝到内核空间中</li>
<li>如果任何一个 sock(I/O stream) 出现了数据，需要在内核遍历传递进来的所有 fd_set，找出能读出数据，或者写入数据的流，对他们进行操作</li>
</ul>
<p><strong>epoll：（优势）</strong></p>
<ul>
<li>没有最大并发连接的限制，监听连接数远大于 1024</li>
<li>效率提升，不是轮询的方式，而是信号驱动的方式，这样不会随着 fd_set 集合中元素数目的增加效率下降</li>
<li>红黑树结构使得不需要每次都把 fd_set 集合从用户态拷贝到内核态</li>
<li>减少内存拷贝，利用 mmap() 文件映射内存加速与内核空间的消息传递；即 epoll 使用 mmap 减少复制开销</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>select、poll：连接数少并且连接都十分活跃的情况</p>
<p>epoll：连接多，并且有大量不太活跃的连接</p>
<p><strong>epoll的实现原理：</strong></p>
<p>我们先看一下 epoll 和 select 和 poll 的调用接口上的不同，select 和 poll 都只提供了一个函数—— select 或者 poll 函数。而 epoll 提供了三个函数 epoll_create ，epoll_ctl 和 epoll_wait ，epoll_create 是创建一个 epoll 句柄；epoll_ctl 是注册要监听的事件类型；epoll_wait 则是等待事件的产生。</p>
<ul>
<li><p><strong>epoll_create()系统调用：</strong>通过此调用建立一个epoll对象，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p>
<p><code>红黑树：</code>树中存储着所有添加到epoll中的需要监控的事件</p>
<p><code>双向链表：</code>存放着将要通过epoll_wait()返回给用户的满足条件的事件（所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中）</p>
</li>
<li><p><strong>epoll_ctl()系统调用：</strong>通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来，所以不需要每次调用 epoll_wait 都复制所有的事件结构。并为每个事件指定一个回调函数叫 ep_poll_callback，当设备就绪，就会调用这个回调函数，而这个回调函数会把就绪的事件加入 epoll 对象中的双向链表中。</p>
</li>
<li><p><strong>epoll_wait()系统调用：</strong>通过此调用会直接返回双向链表中的就绪事件，效率高。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>Redis相关</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺项目1.0总结</title>
    <url>/2021/04/10/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE1-0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-开发准备（完成）"><a href="#1-开发准备（完成）" class="headerlink" title="1.开发准备（完成）"></a>1.开发准备（完成）</h1><p>开发环境的准备</p>
<p>开发工具的配置</p>
<p>创建一个Maven项目</p>
<h1 id="2-项目设计和框架搭建（完成）"><a href="#2-项目设计和框架搭建（完成）" class="headerlink" title="2.项目设计和框架搭建（完成）"></a>2.项目设计和框架搭建（完成）</h1><p>对系统的功能模块进行了大致划分</p>
<p>设计并创建实体类的表结构</p>
<p>配置Maven</p>
<p>自底向上方法完成SSM的各项配置</p>
<p>实现一个查询区域的功能</p>
<h1 id="3-Logback配置与使用（完成）"><a href="#3-Logback配置与使用（完成）" class="headerlink" title="3.Logback配置与使用（完成）"></a>3.Logback配置与使用（完成）</h1><p>主要是日志的配置和初步验证配置的可行性</p>
<h1 id="4-店铺注册功能模块（完成）"><a href="#4-店铺注册功能模块（完成）" class="headerlink" title="4.店铺注册功能模块（完成）"></a>4.店铺注册功能模块（完成）</h1><p><strong>店铺注册的流程：</strong>用户进入店铺注册的界面，根据js代码中的逻辑，会通过一个url路由到后端的Controller层的方法，该方法用于获取店铺的区域列表和店铺类别，将结果封装成json对象返回到前端，将该信息填入到对应的控件中，用户选择列表信息，并填入其它需要填入的信息，以及验证码信息，将前端的信息封装成json返回后端，验证码信息会由一个工具类CodeUtil对比用户输入的和图片的能否对应上，然后对店铺信息和店铺的图片信息进行转换处理，对图片信息进行处理时，要用到ImageUtil和PathUtil工具类，最后将返回结果封装成json返回给前端。</p>
<p><strong>验证码的实现：</strong></p>
<ol>
<li>在pom.xml加入kaptcha的jar包</li>
<li>在web.xml中创建验证码的servlet</li>
<li>在html中加入kaptcha控件</li>
<li>在js文件里读取控件内容，将验证码内容读取保存到json中，通过ajax传到后台</li>
<li>后端的CodeUtil工具类用于比较图片中实际的验证码与输入的验证码是否一致（图片中的验证码是从请求会话中得到的）</li>
</ol>
<h1 id="5-主从库同步与读写分离（完成）"><a href="#5-主从库同步与读写分离（完成）" class="headerlink" title="5.主从库同步与读写分离（完成）"></a>5.主从库同步与读写分离（完成）</h1><h2 id="5-1为什么要用主从同步技术？"><a href="#5-1为什么要用主从同步技术？" class="headerlink" title="5.1为什么要用主从同步技术？"></a>5.1为什么要用主从同步技术？</h2><p>这里主要是出于对平台<strong>优化</strong>的目的，为以后的高并发场景做准备。</p>
<p>当网站发生较大的并发访问时，单单靠一台服务器来处理如此多的数据库连接操作，数据库就会崩溃，甚至发生数据的丢失。</p>
<p>这时候我就考虑减少数据库的连接来减轻数据库的压力。</p>
<p>将原主机上的MySQL作为主库，在服务器上部署MySQL作为从库，实现主从同步。其中主数据库负责写的操作，从数据库负责读的操作（slave不能进行写的操作，因为可能造成数据的不一致，但是会进行被动的写操作，也就是在数据同步的时候），这样就可以很大程度上减少数据库的连接，减轻主数据库的负载，实现负载均衡。此外，主从同步技术还有以下优点：</p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败，容错性更高</li>
</ul>
<blockquote>
<p>NOTE：MySQL数据库支持的并发连接的最大数量为16384（还有的说是几百）</p>
</blockquote>
<h2 id="5-2MySQL主从复制的几种方式"><a href="#5-2MySQL主从复制的几种方式" class="headerlink" title="5.2MySQL主从复制的几种方式"></a>5.2MySQL主从复制的几种方式</h2><p>MySQL默认采用<strong>基于语句的复制</strong>，效率比较高。  </p>
<ul>
<li><p>基于语句的复制（statement-based）：在主服务器上执行的SQL语句，在从服务器上执行同样的语句。            </p>
<p>优点：实现简单，二进制日志文件较小</p>
<p>缺点：对于一些特殊的语句，比如包含主库当前时间戳的语句，所以还需要额外记录每条语句在执行时的相关信息，来保证 slave 上执行时，能够得到与主库相同的结果</p>
</li>
<li><p>基于行的复制（row-based）：（会将每一行中发生改变的实际数据记录到日志中）把改变的内容复制过去，而不是把命令在从服务器上执行一遍.，从 mysql5.0 开始支持。</p>
<p>优点：对于任何语句都能正确工作</p>
<p>缺点：二进制日志文件可能会很大</p>
</li>
<li><p>混合类型的复制（mixed-based）: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
</li>
</ul>
<h2 id="5-3MySQL主从复制的模式"><a href="#5-3MySQL主从复制的模式" class="headerlink" title="5.3MySQL主从复制的模式"></a>5.3MySQL主从复制的模式</h2><p><strong>异步复制：</strong>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理；主节点不会主动push bin log到从节点；</p>
<p><strong>半同步模式：</strong>这种模式下<strong>主节点只需要接收到其中一台从节点的返回信息，就会commit</strong>；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。</p>
<p><strong>全同步模式</strong>：全同步模式是指<strong>主节点和从节点全部执行了commit并确认</strong>才会向客户端返回成功。</p>
<h2 id="5-4MySQL中binlog的日志格式"><a href="#5-4MySQL中binlog的日志格式" class="headerlink" title="5.4MySQL中binlog的日志格式"></a>5.4MySQL中binlog的日志格式</h2><p>MySQL中binlog日志支持三种格式类型：</p>
<ul>
<li>STATEMENT：基于SQL语句的复制（statement-based replication, SBR）</li>
<li>ROW：基于行的复制（row-based replication, RBR）</li>
<li>MIXED：混合模式复制（mixed-based replication, MBR）</li>
</ul>
<h2 id="5-5项目中的具体实现"><a href="#5-5项目中的具体实现" class="headerlink" title="5.5项目中的具体实现"></a>5.5项目中的具体实现</h2><ol>
<li>修改主服务器配置文件和从服务器配置文件，实现MySQL主从同步；</li>
<li>在Spring中DataSource有一个抽象类AbstractRoutingDataSource，他能够根据不同的路由找到不同的数据源，类中的determineCurrentLookupKey方法就是决定目标数据源的；</li>
<li>因此创建DynamicDataSource类让它继承抽象类AbstractRoutingDataSource，重写determineCurrentLookupKey方法，调用DynamicDataSourceHolder类中的getDbType()方法，实现不同数据源的选择；</li>
<li>创建DynamicDataSourceHolder类决定返回的数据源是master还是slave（用到了ThreadLocal保证线程安全）；</li>
<li>创建DynamicDataSourceInterceptor类初始化DynamicDataSourceHolder类，拦截所有的数据库操作请求，通过分析sql语句来判断是读还是写操作，读操作就给DynamicDataSourceHolder设置slave源，写操作就给其设置master源，通过DynamicDataSourceHolder类中的setDbType方法；</li>
<li>完成路由后，在Mybatis-config.xml中配置拦截器。我们需要依靠拦截器对传递进来的SQL信息来选择数据源，例如传进来的是insert,update,delete语句，就使用主库的数据源，如果是select就选择从库的数据源；</li>
<li>在SpringDao.xml文件中分别配置主从库数据源；</li>
<li>在jdbc.properties配置文件中，配置主从库数据源的地址；</li>
</ol>
<p><strong>流程：</strong>当我们插入一条数据时，Mybatis会根据SQL语句将DynamicDataSourceHolder初始化，将该线程的数据源设定为主库，Spring通过SpringDao.xml的配置，通过dataSource中的targetDataSource选择数据源，而这个对象就是dynamicDataSource中的targetDataSources该对象的key是master或slave分别对应两个数据库连接池，通过determineCurrentLookupKey方法选择了数据源之后，取出键值key，对应的哪个连接池就是哪个连接池。</p>
<h1 id="6-店铺编辑功能和列表功能（完成）"><a href="#6-店铺编辑功能和列表功能（完成）" class="headerlink" title="6.店铺编辑功能和列表功能（完成）"></a>6.店铺编辑功能和列表功能（完成）</h1><p>实现了两个模块功能：</p>
<ol>
<li><p>店铺编辑功能（类似于店铺注册功能）</p>
</li>
<li><p>店铺列表功能</p>
<p>分页实现：加了一个工具类，将页号转换成行号，也就是将前台的第几页+页面大小转换成从第几行取一个页面大小的数据量</p>
</li>
</ol>
<h1 id="7-商品类别模块"><a href="#7-商品类别模块" class="headerlink" title="7.商品类别模块"></a>7.商品类别模块</h1><h1 id="8-商品模块"><a href="#8-商品模块" class="headerlink" title="8.商品模块"></a>8.商品模块</h1><h1 id="9-前端展示系统"><a href="#9-前端展示系统" class="headerlink" title="9.前端展示系统"></a>9.前端展示系统</h1><h1 id="10-阿里云部署及远程微信开发调试（完成）"><a href="#10-阿里云部署及远程微信开发调试（完成）" class="headerlink" title="10.阿里云部署及远程微信开发调试（完成）"></a>10.阿里云部署及远程微信开发调试（完成）</h1><ul>
<li><p>购买阿里云服务器</p>
</li>
<li><p>在服务器上搭建项目运行环境</p>
</li>
<li><p>将项目部署到远端服务器</p>
</li>
<li><p>解析域名，将服务器的IP地址改成自定义域名</p>
</li>
<li><p><strong>微信登录功能：</strong>微信测试号</p>
<p>1、填写接口配置信息：接口的Url和Token（一经提交，微信便发送GET请求到服务器中）</p>
<p>GET请求携带的参数：signature、timestamp、nonce、echostr，其中signature是微信的加密签名，结合了开发者填写的token参数和timestamp、nonce参数</p>
<p>2、开发者需要通过检验signature确认请求是否来源于微信服务器，并原样返回echostr参数内容，表示接入成功</p>
<p>3、编写两个类：WechatController和SignUtil用于应答连通微信公众号</p>
<p>​      加密校验流程：</p>
<p>​      1）将token、timestamp、nonce三个参数进行字典序排序</p>
<p>​      2）将三个字符串拼接成一个字符串进行sha1加密</p>
<p>​      3）获取加密后的字符串后与signature对比，表示来源于微信服务器</p>
<p>​      4）将echostr参数原样返回</p>
<p>4、接下来需要编写自己的程序以获取关注此公众号的用户信息</p>
<p>​      1） <strong>WechatLoginController</strong> 用来获取已关注此微信号的用户信息，获取用户的openId后，判断当用户不存在创建微信账号并创建用户的信息</p>
<p>​     以下是工具类：</p>
<p>​     2）【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息</p>
<p>​     3）【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息</p>
<p>​     4）【WechatUtil】主要用来提交https请求给微信获取用户信息</p>
<p>​     5）【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器</p>
<p>5、验证登录成功之后，将用户转发到相应的界面，如店铺列表、前端展示系统等</p>
<p>这样，当用户关注我们的公众号时，通过微信浏览器访问我们的服务器，就会自动创建账号，下次该用户再次访问时，通过判断用户的openId，就会实现微信的自动登录。</p>
</li>
</ul>
<h1 id="11-项目升级（完成）"><a href="#11-项目升级（完成）" class="headerlink" title="11.项目升级（完成）"></a>11.项目升级（完成）</h1><p><strong>对项目中的关键信息进行DES加密：</strong></p>
<ol>
<li>创建加密和解密的工具类：DESUtil；</li>
<li>将JDBC.properties文件中的数据库连接的账号、密码信息都改为加密后的密文；</li>
<li>创建类，用于解密关键字段；</li>
<li>更改spring-dao.xml中的配置，将含有加密字段的文件路径放入解密类的bean中。</li>
</ol>
<h1 id="12-引入Redis缓存"><a href="#12-引入Redis缓存" class="headerlink" title="12.引入Redis缓存"></a>12.引入Redis缓存</h1><h2 id="12-1为什么有了Mysq还要用Redis"><a href="#12-1为什么有了Mysq还要用Redis" class="headerlink" title="12.1为什么有了Mysq还要用Redis"></a>12.1为什么有了Mysq还要用Redis</h2><p>MySQL作为持久化存储的数据库，相对薄弱的地方在于每次请求访问数据库时，都存在着I/O操作，反复频繁的访问数据库时，就会因为大量的I/O操作、以及反复的连接数据库导致运行效率过慢。</p>
<p>使用Redis主要有两方面的考虑：</p>
<p><strong>高性能：</strong></p>
<p>Redis将数据保存在内存中，操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<h2 id="12-2Redis与memcached"><a href="#12-2Redis与memcached" class="headerlink" title="12.2Redis与memcached"></a>12.2Redis与memcached</h2><p><strong>为什么项目中使用Redis而不是memcached？</strong></p>
<ol>
<li><strong>Redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong>也就是在数据恢复中更具有优势。</li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
</ol>
<h2 id="12-3项目中的具体实现"><a href="#12-3项目中的具体实现" class="headerlink" title="12.3项目中的具体实现"></a>12.3项目中的具体实现</h2><ol>
<li><p>引入Jedis的jar包：Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的；</p>
</li>
<li><p>创建redis.properties：定义连接redis的账户密码等字段</p>
</li>
<li><p>创建spring-redis.xml对redis进行配置：</p>
<p>创建Redis连接池对象：通过接口JedisPollWriper初始化连接池对象</p>
<p>创建Redis工具类JedisUtil，封装好Redis的连接以进行相关的操作</p>
<p>​     <strong>JedisUtil工具类：</strong>封装好Redis的连接以进行相关的操作，工具类中包含以下几个内部类：</p>
<p>​          1、Keys：主要封装了对redis中的键值对中的键操作的方法，比如：清空所有的Key，删除keys对应的记录等，方法的实现主要还是通过jedis对象中的方法对redis中的内容进行操作</p>
<p>​          2、Strings：主要封装了一些根据string操作对象的值查询value，添加记录等的方法</p>
<p>创建Redis数据类型如string、map、list等的bean用于注入</p>
</li>
<li><p>在对Redis配置完成之后，需要对需要存入Redis缓存中的数据对应的查询、插入、修改的代码逻辑进行更改</p>
</li>
</ol>
<p><strong>本地账号的登录：</strong></p>
<ol>
<li>获取是否需要进行验证码校验的标识符（三次错误就会需要输入验证码）</li>
<li>从request中获取输入的帐号、密码</li>
<li>传入帐号和密码去获取平台帐号信息</li>
<li>同时在session里设置用户信息</li>
</ol>
<p><strong>添加拦截器，以实现登录验证及权限验证：</strong></p>
<p>店家管理系统中的一些敏感信息不能随意被修改，主要是验证用户是否已经登录了系统、有无对数据操作的权限</p>
<p><strong>具体实现：</strong></p>
<p>利用Spring的 AOP功能对相关功能进行织入验证方法，这样不用对每个方法都写一段权限验证的代码</p>
<ul>
<li>在spring-web.xml中配置拦截器：</li>
<li><strong>配置两个拦截器：</strong></li>
<li><strong>校验是否已登录了店家管理系统的拦截器</strong> <ul>
<li>定义拦截的路由：shopadmin下所有的方法（主要是对于店铺和商铺操作的方法）</li>
<li>拦截器具体实现类的bean以及全路径名</li>
</ul>
</li>
<li><strong>校验是否对该店铺有操作权限的拦截器（某一个店铺）</strong><ul>
<li>要对shopadmin下的部分方法进行排除，也就是不拦截，比如：获取店铺列表、注册相关（因为拦截器的具体实现是要获得用户可操作的店铺列表，和需要校验的session中的店铺进行比对的）</li>
</ul>
</li>
</ul>
<p>这样定义了拦截方法的路由之后，就会在方法执行前，执行自定义的拦截器对用户的登录情况和权限情况进行校验</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2021/04/02/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1.面向对象和面向过程的区别"></a>1.面向对象和面向过程的区别</h1><p>两者的思想：</p>
<ul>
<li><strong>面向过程：</strong>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；</li>
<li><strong>面向对象：</strong>是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li>
</ul>
<p>两者间的对比：</p>
<ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是<strong>半编译语言</strong>，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。（还需要执行引擎将字节码文件翻译为机器语言，然后执行）</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h1 id="2-Java-语言有哪些特点"><a href="#2-Java-语言有哪些特点" class="headerlink" title="2.Java 语言有哪些特点"></a>2.Java 语言有哪些特点</h1><ol>
<li>简单易学；</li>
<li><strong>面向对象</strong>（封装，继承，多态）；</li>
<li><strong>平台无关性，可移植性强</strong>（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li><strong>支持多线程</strong>（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li><strong>编译与解释并存</strong>；</li>
</ol>
<h1 id="3-Java-和-C-的区别（重点）"><a href="#3-Java-和-C-的区别（重点）" class="headerlink" title="==3.Java 和 C++的区别（重点）=="></a>==3.Java 和 C++的区别（重点）==</h1><ol>
<li>都是面向对象的语言，支持封装、继承和多态</li>
<li>Java 没有提供指针的方式来访问内存，程序内存更加安全</li>
<li>C++的类支持多继承，Java支持单继承。虽然 Java 的类不支持多继承，但是 Java 的接口支持多继承</li>
<li>Java 支持垃圾回收机制，不需要程序员手动释放内存</li>
</ol>
<h1 id="4-字符型常量和字符串常量的区别"><a href="#4-字符型常量和字符串常量的区别" class="headerlink" title="4.字符型常量和字符串常量的区别"></a>4.字符型常量和字符串常量的区别</h1><ol>
<li>形式上: 字符常量是<strong>单引号</strong>引起的一个字符; 字符串常量是<strong>双引号</strong>引起的若干个字符</li>
<li>含义上: 字符常量相当于一个<strong>整型值</strong>( ASCII 值),可以参加表达式运算; 字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-15/86735519.jpg"></p>
<h1 id="5-构造器-Constructor-是否可被-override"><a href="#5-构造器-Constructor-是否可被-override" class="headerlink" title="5.构造器 Constructor 是否可被 override"></a>5.构造器 Constructor 是否可被 override</h1><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h1 id="6-重载和覆盖的区别（重点）"><a href="#6-重载和覆盖的区别（重点）" class="headerlink" title="==6.重载和覆盖的区别（重点）=="></a>==6.重载和覆盖的区别（重点）==</h1><h2 id="6-1重载"><a href="#6-1重载" class="headerlink" title="6.1重载"></a>6.1重载</h2><p><strong>面试官问题：说一下什么是重载？</strong></p>
<p><strong>答：</strong> <strong>重载是指在一个类中（包括父类）存在多个同名的不同方法</strong>，这些方法的<strong>参数个数，顺序以及类型不同</strong>均可以构成方法的重载。如果仅仅是修饰符、返回值、抛出的异常不同，那么这是2个相同的方法。能够根据不同的数据输入，选择不同的方法执行。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> niuke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverLoadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个方法的参数顺序不同，可以构成方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> age, String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个方法的参数类型不同，可以构成方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个方法的参数个数不同，可以构成方法的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试官追问：如果只有方法返回值不同，可以构成重载吗？</strong></p>
<p><strong>答：</strong>不可以。因为我们调用某个方法，有时候并<strong>不关心其返回值</strong>，这个时候编译器根据方法名和参数无法确定我们调用的是哪个方法。</p>
<p><strong>Demo：</strong>在调用的时候，直接 Test(“XiaoMing”)； 那么就会存在歧义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Test</span><span class="params">(String userName)</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(String userName)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<h2 id="6-2覆盖"><a href="#6-2覆盖" class="headerlink" title="6.2覆盖"></a>6.2覆盖</h2><p><strong>面试官问题：说一下什么是覆盖？</strong></p>
<p><strong>答：</strong> <strong>覆盖也叫重写</strong>，是指<strong>子类和父类</strong>之间方法的一种关系，比如说父类拥有方法A，子类扩展了方法A并且添加了丰富的功能。那么我们就说子类覆盖或者重写了方法A，也就是说子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数以及参数类型。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> niuke;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son().say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是父类中的say方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是子类中的say方法，我覆盖了父类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
</blockquote>
<p><strong>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong> 。</p>
<h1 id="7-Java-面向对象编程三大特性（重点）"><a href="#7-Java-面向对象编程三大特性（重点）" class="headerlink" title="==7.Java 面向对象编程三大特性（重点）=="></a>==7.Java 面向对象编程三大特性（重点）==</h1><h2 id="7-1封装"><a href="#7-1封装" class="headerlink" title="7.1封装"></a>7.1封装</h2><p><strong>面试官问题：说一下你对封装的理解？</strong></p>
<p><strong>答：</strong>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，可以隐藏部分实现细节，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h2 id="7-2继承"><a href="#7-2继承" class="headerlink" title="7.2继承"></a>7.2继承</h2><p><strong>面试官问题：说一下你对继承的理解？</strong></p>
<p><strong>答：</strong>从一个已知的类中<strong>派生出一个新的类</strong>，新类可以拥有已知类的行为和属性，并且可以<strong>通过覆盖/重写来增强</strong>已知类的能力。 </p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。并且父类的构造方法如果被 private 修饰，那么表示该类是不能被其它类继承的，也就是不能有子类。</li>
<li>子类可以拥有自己属性和方法，即子类可以<strong>对父类进行扩展</strong>。</li>
<li>子类可以用自己的方式实现父类的方法（覆盖/重写）。</li>
</ol>
<h2 id="7-3多态"><a href="#7-3多态" class="headerlink" title="7.3多态"></a>7.3多态</h2><p><strong>面试官问题：如何实现多态？</strong></p>
<p><strong>答：</strong>多态的本质就是<strong>一个程序中存在多个同名的不同方法</strong>，主要通过<strong>三种方式</strong>来实现：</p>
<ol>
<li>通过子类对父类的<strong>覆盖</strong>来实现 </li>
<li>通过在一个类中对方法的<strong>重载</strong>来实现 </li>
<li>通过将<strong>子类对象作为父类对象</strong>使用来实现 </li>
</ol>
<p><strong>面试官问题：说一下你对多态的理解？</strong></p>
<p><strong>答：</strong>把不同的子类对象都当作父类对象来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。这样操作之后，父类的对象就可以根据当前赋值给它的子类对象的特性以不同的方式运作。</p>
<p>对象的引用型变量具有多态性，因为<strong>一个引用型变量可以指向不同形式的对象</strong>，即：子类的对象作为父类的对象来使用。在这里涉及到了向上转型和向下转型，我们分别介绍如下：</p>
<p><strong>向上转型：</strong><br>子类对象转为父类，父类可以是接口。<br>公式：Father f = new Son（）; Father是父类或接口，Son是子类。</p>
<p><strong>向下转型：</strong><br>父类对象转为子类。公式：Son s = (Son) f;</p>
<p>在向上转型的时候我们可以直接转，但是在向下转型的时候我们必须强制类型转换。并且，如案例中所述，<strong>该父类必须实际指向了一个子类对象才可强制类型向下转型</strong>，即其是以这种方式Father f = new Son（）创建的父类对象。若以Father f = new Father（）这种方式创建的父类对象，那么不可以转换向下转换为子类的Son对象，运行会报错，因为其本质还是一个Father对象。</p>
<h1 id="8-JDK，JRE和JVM-的区别与联系（重点）"><a href="#8-JDK，JRE和JVM-的区别与联系（重点）" class="headerlink" title="==8. JDK，JRE和JVM 的区别与联系（重点）=="></a>==8. JDK，JRE和JVM 的区别与联系（重点）==</h1><h2 id="8-1基本概念"><a href="#8-1基本概念" class="headerlink" title="8.1基本概念"></a>8.1基本概念</h2><p><strong>面试官问题：说一下三者的基本概念吧？</strong></p>
<p><strong>答：</strong>三者的基本概念如下：</p>
<ul>
<li><strong>JDK（Java Development Kit）</strong>是一个开发工具包，是Java开发环境的核心组件，并且提供编译、调试和运行一个Java程序所需要的所有工具，可执行文件和二进制文件，是一个平台特定的软件 </li>
<li><strong>JRE（Java Runtime Environment）</strong>是指Java运行时环境，是JVM的实现，提供了运行Java程序的平台。JRE包含了JVM，但是不包含Java编译器/调试器之类的开发工具 </li>
<li><strong>JVM（Java Virtual Machine）</strong>是指Java虚拟机，当我们运行一个程序时，JVM负责将字节码转换为特定机器代码，JVM提供了内存管理/垃圾回收和安全机制等 </li>
</ul>
<h2 id="8-2区别与联系"><a href="#8-2区别与联系" class="headerlink" title="8.2区别与联系"></a>8.2区别与联系</h2><p><strong>面试官问题：说一下三者的区别与联系吧</strong></p>
<ul>
<li>JDK是开发工具包，用来开发Java程序，而JRE是Java的运行时环境 </li>
<li>JDK和JRE中都包含了JVM </li>
<li>JVM是Java编程的核心，独立于硬件和操作系统，具有平台无关性，而这也是Java程序可以一次编写，多处执行的原因 </li>
</ul>
<h2 id="8-3跨平台特性"><a href="#8-3跨平台特性" class="headerlink" title="8.3跨平台特性"></a>8.3跨平台特性</h2><p><strong>面试官问题：说一下 Java 语言的跨平台特性是如何实现的</strong></p>
<p><strong>答：</strong>Java 程序都是运行在 Java 虚拟机，即 JVM 之上。JVM 屏蔽了底层操作系统和硬件的差异。我想大多数同学的 Hello  Word 程序都是在文本文件中写的，然后我们通过 javac 来编译 .java 文件，生成了一个 .class 文件，最后再通过 java 命令来运行 .class 文件。其实这就是经历了一个先编译，再解释执行的过程，即先将 java 文件编译成了字节码 .class 文件，然后交给 Java 虚拟机解释成特定平台上的机器码。</p>
<p>另外一个与平台无关性的原因是，Java 的语言规范中规定了基本数据类型的取值范围和行为在各个平台上是保持一致的。</p>
<p><strong>总结起来就是：</strong></p>
<ul>
<li>JVM 屏蔽了操作系统和底层硬件的差异 </li>
<li>Java 面向 JVM 编程，先编译生成字节码文件，然后交给 JVM 解释成机器码执行 </li>
<li>通过规定基本数据类型的取值范围和行为 </li>
</ul>
<p><strong>面试官问题：Java 语言是编译型还是解释型语言？</strong></p>
<p><strong>答：</strong>Java的执行经历了编译和解释的过程，是一种<strong>先编译，后解释</strong>执行的语言，不可以单纯归到编译性或者解释性语言的类别中。也就是编译与解释共存。</p>
<h1 id="9-注解（重点）"><a href="#9-注解（重点）" class="headerlink" title="==9.注解（重点）=="></a>==9.注解（重点）==</h1><h2 id="9-1元注解"><a href="#9-1元注解" class="headerlink" title="9.1元注解"></a>9.1元注解</h2><p><strong>面试官问题：Java 中的元注解有哪些及其作用？</strong></p>
<p><strong>答：</strong>Java中提供了4个元注解，元注解的作用是负责注解其它注解。</p>
<p><strong>@Target：</strong>说明注解所修饰的对象范围</p>
<p>如下的注解使用@Target标注，表明MyAnn注解就只能作用在类/接口和方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Retention：</strong>保留策略定义了该注解被保留的时间长短</p>
<p>如下的注解表示该注解在运行时有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn &#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Documented：</strong>暂未了解</p>
<p><strong>@Inherited：</strong>暂未了解</p>
<h2 id="9-2注解的作用"><a href="#9-2注解的作用" class="headerlink" title="9.2注解的作用"></a>9.2注解的作用</h2><p><strong>面试官追问：说了这么多，说一下你认为注解的作用吧？</strong></p>
<p><strong>答：</strong>使用注解可以代替配置文件，比如 SpringBoot 就是提供了大量的<strong>注解来代替配置文件</strong>，从而极大的方便了Web项目的搭建与开发。</p>
<h2 id="9-3怎么定义注解"><a href="#9-3怎么定义注解" class="headerlink" title="9.3怎么定义注解"></a>9.3怎么定义注解</h2><p><strong>面试官追问：如何自定义一个注解，并且定义注解的属性？</strong></p>
<p><strong>答：</strong>注解定义时，必须使用**@interface**。定义注解的时候 value 就是属性，看着是一个方法，但我们称它为属性。当为注解指定属性后，那么在使用注解时就必须要给属性赋值了，并且我们在获取注解时，能够获取注解的值。具体如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnn &#123;  </span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value1</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用注解MyAnn，可以设置属性</span></span><br><span class="line"><span class="meta">@MyAnn(value1=100,value=&quot;hello&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="10-Java-中的反射机制（重点）"><a href="#10-Java-中的反射机制（重点）" class="headerlink" title="==10. Java 中的反射机制（重点）=="></a>==10. Java 中的反射机制（重点）==</h1><h2 id="10-1基本概念"><a href="#10-1基本概念" class="headerlink" title="10.1基本概念"></a>10.1基本概念</h2><p><strong>面试官问题：说说 Java 中反射机制？</strong></p>
<p><strong>答：</strong> <strong>反射机制</strong>是指在运行中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。即<strong>动态获取信息和动态调用对象方法的功能</strong>称为反射机制。</p>
<h2 id="10-2作用"><a href="#10-2作用" class="headerlink" title="10.2作用"></a>10.2作用</h2><p><strong>面试官追问：说说 Java 中反射机制的作用？</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类 </li>
<li>在运行时构造一个类的对象 </li>
<li>在运行时判断任意一个类所具有的成员变量和方法 </li>
<li>在运行时调用任意一个对象的方法，生成动态代（dai）理 </li>
</ul>
<p>解析：与反射相关的类：</p>
<ul>
<li><strong>Class：表示类</strong>，用于获取类的相关信息 </li>
<li><strong>Field：表示成员变量</strong>，用于获取实例变量和静态变量等 </li>
<li><strong>Method：表示方法</strong>，用于获取类中的方法参数和方法类型等 </li>
<li><strong>Constructor：表示构造器</strong>，用于获取构造器的相关参数和类型等 </li>
</ul>
<h2 id="10-3如何获取-Class-类对象"><a href="#10-3如何获取-Class-类对象" class="headerlink" title="10.3如何获取 Class 类对象"></a>10.3如何获取 Class 类对象</h2><p><strong>面试官追问：说说 Java 中如何获取 Class 类对象吧？</strong></p>
<p><strong>答：</strong>共有三种方式</p>
<ol>
<li><p>通过<strong>类名称.class</strong>来获取 Class 类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = <span class="keyword">int</span>.class；</span><br><span class="line">Class c = <span class="keyword">int</span>[ ].class；</span><br><span class="line">Class c = String.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过**对象.getClass( )**方法来获取 Class 类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = obj.getClass( );</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类名称加载类 **Class.forName( )**，只要有类名称就可以得到 Class：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c = Class.forName(“cn.ywq.Demo”);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>解析：</strong>我们给出一个以反射方式来创建对象的 Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String className = <span class="string">&quot;com.ywq.User&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取Class对象</span></span><br><span class="line">        Class clazz = Class.forName(className);</span><br><span class="line">        <span class="comment">// 创建User对象</span></span><br><span class="line">        User user = (User)clazz.newInstance();</span><br><span class="line">        <span class="comment">// 和普通对象一样，可以设置属性值</span></span><br><span class="line">        user.setUsername(<span class="string">&quot;yangwenqiang&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;19931020&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [username=&quot;</span> + username + <span class="string">&quot;, password=&quot;</span> + password + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过反射机制来成功创建了一个 User 对象，该对象和以 new Object（）方式创建的对象一样，可以设置其属性值。</p>
<h1 id="11-Java-中的值传递和引用传递（重点）"><a href="#11-Java-中的值传递和引用传递（重点）" class="headerlink" title="==11. Java 中的值传递和引用传递（重点）=="></a>==11. Java 中的值传递和引用传递（重点）==</h1><p><strong>面试官问题：Java中的值传递和引用传递可以解释下吗？</strong></p>
<p><strong>答：</strong>值传递和引用传递的解释可以概括如下。</p>
<ul>
<li><strong>值传递，</strong>意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。 </li>
<li><strong>引用传递，</strong>意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象的改变会反映到所有的对象上。 </li>
</ul>
<p><strong>解析：</strong></p>
<p>我们先来看一个值传递的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        change(x);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i=<span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毫无疑问，上边的代码会输出 0 。因为如果参数是基本数据类型，那么是属于值传递的范畴，传递的其实是源对象的一个 copy 副本，不会影响源对象的值。</p>
<p>再来分析一个引用传递的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        StringBuffer x = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        change(x);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer i)</span> </span>&#123;</span><br><span class="line">        i.append(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行程序，<strong>输出为Hello world！</strong>接下来我们通过图片来分析下程序执行过程种的内存变化吧。</p>
<img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\值传递与引用传递.png" alt="图片说明" style="zoom:80%;">

<p>接着，我们修改下change方法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        StringBuffer x = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        change2(x);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change2</span><span class="params">(StringBuffer i)</span> </span>&#123;</span><br><span class="line">        i = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        i.append(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边Demo的输出为Hello，我们依然来画图分析内存变化。</p>
<img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\值传递与引用传递2.png" alt="图片说明" style="zoom:80%;">

<p>由图中我们可以看出来，<strong>在函数change2中将引用变量i重新指向了堆内存中另一块区域</strong>，下边都是对另一块区域进行修改，<strong>所以输出是Hello。</strong></p>
<p>最后，我们继续升级该题目代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Before change, sb = &quot;</span> + sb);</span><br><span class="line">        changeData(sb);</span><br><span class="line">        System.out.println(<span class="string">&quot;After change, sb = &quot;</span> + sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeData</span><span class="params">(StringBuffer strBuf)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hi，I am &quot;</span>);</span><br><span class="line">        strBuf = sb2;</span><br><span class="line">        sb2.append(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为 sb 仍然是 Hello，因为在 changeDate 中将引用变量指向了堆中另一块内存 sb2 ，并且后面也只是对这块内存做的改变。画图分析如下：</p>
<img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\值传递与引用传递3.png" alt="图片说明" style="zoom:80%;">

<h1 id="12-String、StringBuffer-和-StringBuilder（重点）"><a href="#12-String、StringBuffer-和-StringBuilder（重点）" class="headerlink" title="==12.String、StringBuffer 和 StringBuilder（重点）=="></a>==12.String、StringBuffer 和 StringBuilder（重点）==</h1><h2 id="12-1可变性"><a href="#12-1可变性" class="headerlink" title="12.1可变性"></a>12.1可变性</h2><p><strong>面试官问题：说一下三者是否可变的，并从底层解释一下 String 为什么是不可变的？</strong></p>
<p><strong>答：</strong>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<p><code>AbstractStringBuilder.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-2线程安全性"><a href="#12-2线程安全性" class="headerlink" title="12.2线程安全性"></a>12.2线程安全性</h2><p><strong>面试官问题：说一下三者的线程安全性？</strong></p>
<p><strong>答：</strong></p>
<ul>
<li><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
</li>
<li><p>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。S</p>
<p>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
</li>
</ul>
<h2 id="12-3性能"><a href="#12-3性能" class="headerlink" title="12.3性能"></a>12.3性能</h2><p><strong>面试官问题：三者的性能问题？</strong></p>
<p><strong>答：</strong>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<h2 id="12-4应用场景"><a href="#12-4应用场景" class="headerlink" title="12.4应用场景"></a>12.4应用场景</h2><p><strong>面试官问题：说一下三者的使用场景吧？</strong></p>
<p><strong>答：</strong></p>
<ol>
<li>操作<strong>少量的数据</strong>: 适用 String</li>
<li><strong>单线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>: 适用 StringBuilder</li>
<li><strong>多线程</strong>操作字符串缓冲区下操作<strong>大量数据</strong>: 适用 StringBuffer</li>
</ol>
<h1 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13.自动装箱与拆箱"></a>13.自动装箱与拆箱</h1><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h1 id="14-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14.在一个静态方法内调用一个非静态成员为什么是非法的?"></a>14.在一个静态方法内调用一个非静态成员为什么是非法的?</h1><p>根据类的加载过程，JVM先将类中的静态方法的代码加载到方法区，然后有new指令的时候才能在堆内存中创建对象，也就是静态方法会随着类的加载而被加载，但是非静态成员只有在实例化之后才存在，所以不能在静态方法中调用一个非静态成员，这是不合法的，因为那时候可能它还不存在。</p>
<h1 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15.在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>15.在 Java 中定义一个不做事且没有参数的构造方法的作用</h1><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h1 id="16-接口和抽象类（重点）"><a href="#16-接口和抽象类（重点）" class="headerlink" title="==16. 接口和抽象类（重点）=="></a>==16. 接口和抽象类（重点）==</h1><h2 id="16-1抽象类和接口有什么区别"><a href="#16-1抽象类和接口有什么区别" class="headerlink" title="16.1抽象类和接口有什么区别"></a>16.1抽象类和接口有什么区别</h2><p><strong>面试官问题：抽象类和接口有什么区别？</strong></p>
<p><strong>答：</strong>抽象类和接口的主要区别可以总结如下。</p>
<ol>
<li>抽象类中可以没有抽象方法，也可以抽象方法和非抽象方法共存 </li>
<li>接口的方法默认是 public， JDK8 之前所有方法在接口中不能有实现，JDK8 开始接口方法可以有默认实现</li>
<li>接口中除了 static、final 变量，只能有常量不能有其他变量，而抽象类中可以有普通的成员变量</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）</li>
</ol>
<p><strong>解析：</strong></p>
<p>在Java中，我们通过abstract来定义抽象类，通过interface关键字来定义接口。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是一个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-2使用场景"><a href="#16-2使用场景" class="headerlink" title="16.2使用场景"></a>16.2使用场景</h2><p><strong>面试官问题：接口和抽象类应该如何选择，分别在什么情况下使用呢？</strong></p>
<p><strong>答：</strong>根据抽象类和接口的不同之处，当我们仅仅需要定义一些抽象方法而不需要其余额外的具体方法或者变量的时候，我们可以使用接口。反之，则需要使用抽象类，因为抽象类中可以有非抽象方法和变量。</p>
<p><strong>面试官问题：既然说了 JDK8 以后接口中的方法可以有默认实现，简单说一下吧？</strong></p>
<p>我们先给出一个接口中的 default 方法 Demo ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个已经实现的方法，使用default表明</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类实现该接口时，可以继承到该接口中的默认方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass client = <span class="keyword">new</span> MyClass();</span><br><span class="line">        client.test();</span><br><span class="line">        client.say(<span class="string">&quot;World...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，大家就会有疑问，如果两个接口中存在同样的默认方法，实现类继承的是哪一个呢？</p>
<p>实现类会编译出错!! <strong>因为，有两个相同的方法，编译器不知道该如何选择了。</strong></p>
<p>Demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个已经实现的方法，使用default表明</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个已经实现的方法，使用default表明</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[2]-Hello &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处会编译错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>, <span class="title">MyInterface2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有两种处理方式，如下所示：</p>
<ul>
<li>重写多个接口中的相同的默认方法 </li>
<li>在实现类中指定要使用哪个接口中的默认方法 </li>
</ul>
<p><strong>方法一：</strong>重写多个接口中的相同的默认方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>, <span class="title">MyInterface2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Client]-Hello &quot;</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：在实现类中指定要使用哪个接口中的默认方法</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span>, <span class="title">MyInterface2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 手动指定哪个默认方法生效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        MyInterface.<span class="keyword">super</span>.say(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试官又追问：你认为 JDK8 中为什么会出现默认方法呢？</strong></p>
<p><strong>答：</strong>使用接口，使得我们可以面向抽象编程，但是其有一个缺点就是当接口中有改动的时候，需要修改所有的实现类。在JDK8中，<strong>为了给已经存在的接口增加新的方法并且不影响已有的实现</strong>，所以引入了接口中的默认方法实现。</p>
<p>默认方法允许在不打破现有继承体系的基础上改进接口，解决了接口的修改与现有的实现不兼容的问题。</p>
<h1 id="17-成员变量与局部变量的区别有哪些？"><a href="#17-成员变量与局部变量的区别有哪些？" class="headerlink" title="17. 成员变量与局部变量的区别有哪些？"></a>17. 成员变量与局部变量的区别有哪些？</h1><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h1 id="19-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h1><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h1 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h1><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。</p>
<p>返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h1 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21.一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>21.一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h1><p>主要作用是完成对类对象的初始化工作。</p>
<p>可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h1 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h1><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h1 id="23-静态方法和实例方法有何不同？"><a href="#23-静态方法和实例方法有何不同？" class="headerlink" title="23. 静态方法和实例方法有何不同？"></a>23. 静态方法和实例方法有何不同？</h1><ol>
<li><p>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p>
</li>
<li><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</p>
</li>
</ol>
<h1 id="24-equals方法和-的区别？（重点）"><a href="#24-equals方法和-的区别？（重点）" class="headerlink" title="==24. equals方法和 == 的区别？（重点）=="></a>==24. equals方法和 == 的区别？（重点）==</h1><ul>
<li><strong>对象相等：</strong>比的是内存中存放的内容是否相等。</li>
<li><strong>引用相等：</strong>比较的是他们指向的内存地址是否相等。</li>
</ul>
<p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(<strong>基本数据类型</strong>——比较的是值，<strong>引用数据类型</strong>——比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h1 id="27-hashCode-与-equals-重要"><a href="#27-hashCode-与-equals-重要" class="headerlink" title="==27. hashCode 与 equals (重要)=="></a>==27. hashCode 与 equals (重要)==</h1><h2 id="27-1hashCode（）介绍"><a href="#27-1hashCode（）介绍" class="headerlink" title="27.1hashCode（）介绍"></a>27.1hashCode（）介绍</h2><p><code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。**<code>hashCode()</code>在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h2 id="27-2为什么要有-hashCode"><a href="#27-2为什么要有-hashCode" class="headerlink" title="27.2为什么要有 hashCode"></a>27.2为什么要有 hashCode</h2><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<h2 id="27-3hashCode（）与-equals（）的相关规定"><a href="#27-3hashCode（）与-equals（）的相关规定" class="headerlink" title="27.3hashCode（）与 equals（）的相关规定"></a>27.3hashCode（）与 equals（）的相关规定</h2><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong>，hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="30-线程有哪些基本状态-（重点）"><a href="#30-线程有哪些基本状态-（重点）" class="headerlink" title="==30. 线程有哪些基本状态?（重点）=="></a>==30. 线程有哪些基本状态?（重点）==</h1><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/19-1-29/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h1 id="31-关于-final-关键字的一些总结"><a href="#31-关于-final-关键字的一些总结" class="headerlink" title="31.关于 final 关键字的一些总结"></a>31.关于 final 关键字的一些总结</h1><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h1 id="32-Java-中的-Exception-和-Error（重点）"><a href="#32-Java-中的-Exception-和-Error（重点）" class="headerlink" title="==32.Java 中的 Exception 和 Error（重点）=="></a>==32.Java 中的 Exception 和 Error（重点）==</h1><p><strong>Java 异常类层次结构图：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png" alt="Java异常类层次结构图"></p>
<p><strong>面试官问题：说一下 Java 中的 Exception 和 Error 有什么区别？</strong></p>
<p><strong>答：</strong>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。Exception和Error的主要区别可以概括如下：</p>
<ul>
<li><strong>Exception（异常）:是程序本身可以处理的异常</strong>，并且应该被捕获并进行相应的处理，是一种<strong>异常</strong>现象 </li>
<li><strong>Error（错误）:是程序无法处理的错误</strong>，是正常情况下不可能发生的错误，<strong>Error会导致JVM处于一种不可恢复的状态</strong>，不需要捕获处理。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>解析：</strong></p>
<p>Exception又分为了<strong>运行时异常和编译时异常</strong>。</p>
<ul>
<li><strong>编译时异常（受检异常）</strong>表示当前调用的方法体内部抛出了一个异常，所以编译器检测到这段代码在运行时可能会出异常，所以要求我们必须对异常进行相应的处理，可以捕获异常或者抛给上层调用方。</li>
<li><strong>运行时异常（非受检异常）</strong>表示在运行时出现的异常，常见的运行时异常包括：空指针异常，数组越界异常，数字转换异常以及算术异常等。</li>
</ul>
<p>前边说到了异常Exception应该被捕获，我们可以使用try – catch – finally 来处理异常，并且使得程序恢复正常。</p>
<p><strong>面试官追问：那我们捕获异常应该遵循哪些原则呢？</strong></p>
<p><strong>答：</strong></p>
<ul>
<li>尽可能捕获比较详细的异常，而不是使用Exception一起捕获。 </li>
<li>当本模块不知道捕获之后该怎么处理异常时，可以将其抛给上层模块。上层模块拥有更多的业务逻辑，可以进行更好的处理。 </li>
<li>捕获异常后至少应该有日志记录，方便之后的排查。 </li>
<li>不要使用一个很大的try – catch包住整段代码，不利于问题的排查。 </li>
</ul>
<p>**面试官追问：讲一下 try – catch – finally 每部分的作用吧 **</p>
<ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return<br>语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>
<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<p><strong>面试官追问：说一下 NoClassDefFoundError 和 ClassNotFoundException 有什么区别吧？</strong></p>
<p><strong>答：</strong>从名字中，我们可以看出前者是一个错误，后者是一个异常。</p>
<p><strong>ClassNotFoundException：</strong>大概意思就是在说，当我们使用例如 Class.forName 方法来动态的加载该类的时候，传入了一个类名，但是其并没有在类路径中被找到的时候，就会报 ClassNotFoundException 异常。<strong>出现这种情况，一般都是类名字传入有误导致的。</strong></p>
<p><strong>NoClassDefFoundError：</strong>大概意思是这样的，如果 JVM 或者 ClassLoader 实例尝试加载（可以通过正常的方法调用，也可能是使用 new 来创建新的对象）类的时候却找不到类的定义。但是<strong>要查找的类在编译的时候是存在的，运行的时候却找不到了</strong>。这个时候就会导致 NoClassDefFoundError 。出现这种情况，<strong>一般是由于打包的时候漏掉了部分类或者Jar包被篡改已经损坏。</strong></p>
<h1 id="33-序列化与反序列化（重点）"><a href="#33-序列化与反序列化（重点）" class="headerlink" title="==33.序列化与反序列化（重点）=="></a>==33.序列化与反序列化（重点）==</h1><p><strong>面试官：说一下 Java 序列化与反序列化的过程</strong> </p>
<p><strong>答：</strong></p>
<ul>
<li><strong>序列化：</strong>是指将一个 Java 对象变成二进制内容，本质上就是一个 byte 数组，为什么要进行序列化呢？因为序列化之后可以把byte数组保存到文件中，或者把byte通过网络传输到远端，这样就相当于将 Java 对象存储到文件（持久化）或者通过网络传输出去了</li>
<li><strong>反序列化：</strong>就是序列化的一个逆过程，将一个二进制内容（byte数组）变回Java对象</li>
</ul>
<p><strong>面试官追问：对于不想进行序列化的变量，应该怎么办？</strong></p>
<p><strong>答：</strong> <strong>使用 transient 关键字修饰</strong>，transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h1 id="34-深拷贝-vs-浅拷贝"><a href="#34-深拷贝-vs-浅拷贝" class="headerlink" title="34.深拷贝 vs 浅拷贝"></a>34.深拷贝 vs 浅拷贝</h1><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<p><strong>浅拷贝：</strong>仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
<p>即被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p>
<p><strong>深拷贝：</strong>把要复制的对象所引用的对象都复制了一遍。</p>
<p>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h1 id="35-Java-设计模式"><a href="#35-Java-设计模式" class="headerlink" title="35. Java 设计模式"></a>35. Java 设计模式</h1><img src="/2021/04/02/Java%E5%9F%BA%E7%A1%80/GitHub\MyBlogs\source\_posts\2021-04-02-Java基础\设计模式.png" style="zoom:80%;">

<h2 id="35-1单例模式"><a href="#35-1单例模式" class="headerlink" title="35.1单例模式"></a>35.1单例模式</h2><p><strong>单例模式有以下特点：</strong></p>
<ol>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ol>
<p><strong>总结：</strong>单例模式确保某个类只有一个实例，该类提供了一个全局访问点供外部获取该实例。</p>
<p><strong>应用：</strong>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。总之，选择单例模式就是为了避免不一致状态，避免对资源的多重占用。</p>
<p><strong>写法：</strong></p>
<p><strong>饿汉模式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式单例类.在类初始化时，已经自行实例化 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p>
<p><strong>懒汉模式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">             instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在单线程环境下是没有问题的，当该类被调用时，通过调用getInstance方法就可以得到一个实例，但是在多线程环境下，当多个线程同时进入if判断，该例不存在时，就会创建多个实例，所以要对getInstance方法加synchronized关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//通过synchronized加锁来保证线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为<strong>每次调用getInstance()，都要对对象上锁</strong>，事实上，<strong>只有在第一次创建对象的时候需要加锁，之后就不需要了</strong>，所以，这个地方需要改进。我们改成下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                         instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。</p>
<p>但是还是存在问题：</p>
<p>instance=new Singleton()——这段代码其实是分为三步执行：</p>
<ol>
<li>为 instance 分配内存空间</li>
<li>初始化 instance</li>
<li>将 instance 指向分配的内存地址</li>
</ol>
<p>由于 JVM 具有指令重排的特性，所以并不能保证这三个操作的先后顺序，执行顺序有可能变成 1-&gt;3-&gt;2。也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给uniqueInstance成员，然后再去初始化这个Singleton实例。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-2工厂方法模式"><a href="#35-2工厂方法模式" class="headerlink" title="35.2工厂方法模式"></a>35.2工厂方法模式</h2><p><strong>1.普通工厂模式</strong></p>
<p>建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
<p>举例如下：（我们举一个发送邮件和短信的例子）</p>
<p>首先，创建二者的共同接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，创建实现类：（都实现上面的接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;this is mailsender!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is sms sender!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，建工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;mail&quot;</span>.equals(type)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;sms&quot;</span>.equals(type)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入正确的类型!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来测试下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">		Sender sender = factory.produce(<span class="string">&quot;sms&quot;</span>);</span><br><span class="line">		sender.Send();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：this is sms sender!</p>
<p><strong>2.多个工厂方法模式</strong></p>
<p>对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</p>
<p>将上面的代码做下修改，改动下SendFactory类就行，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">		Sender sender = factory.produceMail();</span><br><span class="line">		sender.Send();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：this is mailsender!</p>
<p><strong>3.静态工厂方法模式</strong></p>
<p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		Sender sender = SendFactory.produceMail();</span><br><span class="line">		sender.Send();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：this is mailsender!</p>
<p>工厂模式的应用场景：</p>
<p>凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p>
<h2 id="35-3代理模式"><a href="#35-3代理模式" class="headerlink" title="35.3代理模式"></a>35.3代理模式</h2><p><strong>静态代理：</strong></p>
<p>为某对象提供一种代理以控制对该对象的访问。即<strong>客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性</strong>。比如我们在租房子的时候会去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;the original method!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> Source source;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.source = <span class="keyword">new</span> Source();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		before();</span><br><span class="line">		source.method();</span><br><span class="line">		atfer();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;after proxy!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;before proxy!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Sourceable source = <span class="keyword">new</span> Proxy();</span><br><span class="line">		source.method();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>before proxy!<br> the original method!<br> after proxy!</p>
<p>代理模式的应用场景：</p>
<p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<ol>
<li>修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</li>
<li>就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</li>
</ol>
<p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p>
<p><strong>举个例子：</strong></p>
<p>代理模式一般包括四个部分：（以房屋出租为例）</p>
<p>抽象角色：一般使用接口或者抽象类来实现（出租房屋这个事件本身）</p>
<p>真实角色：被代理的角色（房东）</p>
<p>代理角色：代理真实角色，通常会有一些附属的操作（比如中介，中介类中创建了房东的对象，因为继承自同一个接口，因此它也可以重写方法，并可以在类中创建自己的方法，也就是扩展方法如看房、商谈租金等，并在重写的方法中调用）</p>
<p>客户：通过代理角色去访问被代理角色的资源（比如访客可以通过中介对房东的房子进行看房，讨价还价等操作）</p>
<p><strong>动态代理：</strong></p>
<p>上面的情况是指一个对象A通过持有另一个对象B，可以具有B同样的行为的模式。为了对外开放协议，B往往实现了一个接口，A也会去实现接口。但是B是“真正”实现类，A则比较“虚”，他借用了B的方法去实现接口的方法。A虽然是“伪军”，但它可以增强B，在调用B的方法前后都做些其他的事情。Spring AOP就是使用了动态代理完成了代码的动态“织入”。</p>
<p>也就是说，类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理目前有两种常见的实现，jdk动态代理和cglib动态代理。</p>
<p><strong>JDK动态代理</strong></p>
<p>Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：</p>
<p><strong>1.Interface InvocationHandler：</strong>该接口中仅定义了一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">invoke</span><span class="params">(Object obj,Method method, Object[] args)</span></span></span><br></pre></td></tr></table></figure>

<p>在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。</p>
<p><strong>2.Proxy：</strong>该类即为动态代理类，其中主要包含以下内容：</p>
<p>protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。</p>
<p>static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。</p>
<p>static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法)</p>
<p>所谓DynamicProxy是这样一种class：它是在运行时生成的class，在生成它时你必须提供一组interface给它，然后该class就宣称它实现了这些 interface。你当然可以把该class的实例当作这些interface中的任何一个来用。当然，这个DynamicProxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。</p>
<p>在使用动态代理类时，我们必须实现InvocationHandler接口</p>
<p>通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。</p>
<p><strong>动态代理步骤：</strong></p>
<ol>
<li>创建一个实现接口InvocationHandler的类，它必须实现invoke方法</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li>
<li>通过代理调用方法</li>
</ol>
<p><strong>JDK动态代理的实现</strong></p>
<p>需要动态代理的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要动态代理的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayGoodBye</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要代理的实际对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayGoodBye</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; good bye &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用处理器实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用处理器实现类</span></span><br><span class="line"><span class="comment"> * 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个就是我们要代理的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，给我们要代理的真实对象赋初值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerImpl</span><span class="params">(Object subject)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法负责集中处理动态代理类上的所有方法调用。</span></span><br><span class="line"><span class="comment">     * 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被调用的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   调用参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//在代理真实对象前我们可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在调用之前，我要干点啥呢？&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Method:&quot;</span> + method);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用</span></span><br><span class="line">        Object returnValue = method.invoke(subject, args);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//在代理真实对象后我们也可以添加一些自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;在调用之后，我要干点啥呢？&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemonstration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//代理的真实对象</span></span><br><span class="line">        Subject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">         * 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.</span></span><br><span class="line"><span class="comment">         * 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(realSubject);</span><br><span class="line"> </span><br><span class="line">        ClassLoader loader = realSubject.getClass().getClassLoader();</span><br><span class="line">        Class[] interfaces = realSubject.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理对象的类型：&quot;</span>+subject.getClass().getName());</span><br><span class="line"> </span><br><span class="line">        String hello = subject.SayHello(<span class="string">&quot;jiankunking&quot;</span>);</span><br><span class="line">        System.out.println(hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM相关</title>
    <url>/2021/04/01/JVM%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-JAVA内存区域"><a href="#1-JAVA内存区域" class="headerlink" title="1.JAVA内存区域"></a>1.JAVA内存区域</h1><h2 id="1-1JVM的主要组成部分及作用"><a href="#1-1JVM的主要组成部分及作用" class="headerlink" title="1.1JVM的主要组成部分及作用"></a>1.1JVM的主要组成部分及作用</h2><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>两个子系统：</strong></p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
</ul>
<p><strong>两个组件：</strong></p>
<ul>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码文件，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h2 id="1-2-JVM-运行时数据区"><a href="#1-2-JVM-运行时数据区" class="headerlink" title="1.2 JVM 运行时数据区"></a>1.2 JVM 运行时数据区</h2><p><strong>已经整理，见另一篇文章。</strong></p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片01.png" alt="img" style="zoom: 50%;">

<p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）</strong>：</p>
<ul>
<li><p><strong>程序计数器（Program Counter Register）：</strong>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈（被指令操作的数据）、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片02.png" alt="img" style="zoom:80%;">

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
</li>
<li><p><strong>本地方法栈（Native Method Stack）：</strong>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 堆（Java Heap）：</strong>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例和数组都在这里分配内存；<strong>（线程共享）</strong></p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代（Young Generation）、老年代（Old Generation）。在细致一点的有Eden空间、From Survivor 空间、To Survior 空间等。</p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


</li>
</ul>
<p>​       上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。（年轻代：老年代=8:1）</p>
<ul>
<li><strong>方法区（Methed Area）：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译（ JIT 编译）后的代码等数据。<strong>（线程共享）</strong></li>
</ul>
<h2 id="1-3深拷贝与浅拷贝"><a href="#1-3深拷贝与浅拷贝" class="headerlink" title="1.3深拷贝与浅拷贝"></a>1.3深拷贝与浅拷贝</h2><blockquote>
<p><strong>注：</strong>深拷贝和浅拷贝都是对象拷贝</p>
</blockquote>
<ul>
<li><p><strong>浅拷贝：</strong>对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p>
<p>简而言之，<code>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</code></p>
</li>
<li><p><strong>深拷贝：</strong>当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>简而言之，<code>深拷贝把要复制的对象所引用的对象都复制了一遍。</code></p>
</li>
</ul>
<h2 id="1-4堆栈的区别"><a href="#1-4堆栈的区别" class="headerlink" title="1.4堆栈的区别"></a>1.4堆栈的区别</h2><ul>
<li><p><strong>物理地址</strong></p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
</li>
<li><p><strong>内存分配</strong></p>
<p>堆因为是不连续的，所以分配的内存是在<strong>运行期</strong>确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在<strong>编译期</strong>就确认，大小是固定的。</p>
</li>
<li><p><strong>存放的内容</strong></p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是<strong>数据的存储</strong></p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是<strong>程序方法的执行</strong>。</p>
</li>
<li><p>程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
</li>
</ul>
<h2 id="1-5队列和栈的区别"><a href="#1-5队列和栈的区别" class="headerlink" title="1.5队列和栈的区别"></a>1.5队列和栈的区别</h2><p>队列和栈都是被用来预存储数据的。</p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li>
</ul>
<h1 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h1><h2 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p><strong>对象创建的主要流程：</strong></p>
<p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定</strong>。</p>
<p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="2-2对象分配内存的方式"><a href="#2-2对象分配内存的方式" class="headerlink" title="2.2对象分配内存的方式"></a>2.2对象分配内存的方式</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配<strong>根据Java堆是否规整</strong>，有两种方式：</p>
<ul>
<li>指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<h2 id="2-3对象的访问定位"><a href="#2-3对象的访问定位" class="headerlink" title="2.3对象的访问定位"></a>2.3对象的访问定位</h2><p><code>Java</code>程序需要通过 <code>JVM</code> 栈上的引用访问堆中的具体对象。对象的访问方式取决于 <code>JVM</code> 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p>
<blockquote>
<p><strong>指针：</strong> 指向对象，代表一个对象在内存中的起始地址。</p>
<p><strong>句柄：</strong> 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<h3 id="1-句柄访问"><a href="#1-句柄访问" class="headerlink" title="1.句柄访问"></a>1.句柄访问</h3><p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p>
<p><strong>缺点：</strong>句柄地址方式不直接，访问速度较慢。</p>
<h3 id="2-直接指针"><a href="#2-直接指针" class="headerlink" title="2.直接指针"></a>2.直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么<code>Java</code>堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p>
<img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="2-4堆内存中对象的分配的基本策略"><a href="#2-4堆内存中对象的分配的基本策略" class="headerlink" title="2.4堆内存中对象的分配的基本策略"></a>2.4堆内存中对象的分配的基本策略</h2><p><strong>堆空间的基本结构：</strong></p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


<p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>另外，大对象和长期存活的对象会直接进入老年代。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg" alt="堆内存常见分配策略"></p>
<h1 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3.垃圾收集"></a>3.垃圾收集</h1><h2 id="3-1-Java-垃圾回收机制"><a href="#3-1-Java-垃圾回收机制" class="headerlink" title="3.1 Java 垃圾回收机制"></a>3.1 Java 垃圾回收机制</h2><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="3-2-GC-及作用"><a href="#3-2-GC-及作用" class="headerlink" title="3.2 GC 及作用"></a>3.2 GC 及作用</h2><p><strong>GC</strong> 是垃圾收集的意思</p>
<p><strong>作用一：</strong>Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，避免了编程人员忘记或者错误的内存回收导致程序或系统的不稳定甚至崩溃。</p>
<p><strong>作用二：</strong>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<blockquote>
<p><strong>Note：</strong></p>
<p>Java 语言没有提供释放已分配内存的显示操作方法</p>
<p><strong>内存泄漏：</strong>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
</blockquote>
<h2 id="3-3垃圾回收器的基本原理"><a href="#3-3垃圾回收器的基本原理" class="headerlink" title="3.3垃圾回收器的基本原理"></a>3.3垃圾回收器的基本原理</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>程序员也可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<blockquote>
<p><strong>Note：</strong>释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”。GC将负责回收所有”不可达”对象的内存空间。</p>
<p>比如 ：</p>
<p>class1 aa = new class();  </p>
<p>aa=null; </p>
<p>那在堆上分配的内存上的数据 就无法访问到了，就是不可达对象。</p>
</blockquote>
<h2 id="3-4-Minor-Gc和-Full-GC-有什么不同"><a href="#3-4-Minor-Gc和-Full-GC-有什么不同" class="headerlink" title="3.4 Minor Gc和 Full GC 有什么不同"></a>3.4 Minor Gc和 Full GC 有什么不同</h2><ul>
<li><strong>新生代GC（Minor GC）：</strong>回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li><strong>老年代GC（Major GC/Full GC）：</strong>:回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</li>
</ul>
<h2 id="3-5判断对象是否可以被回收"><a href="#3-5判断对象是否可以被回收" class="headerlink" title="3.5判断对象是否可以被回收"></a>3.5判断对象是否可以被回收</h2><p>等同于判定哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断：</p>
<p><strong>1. 引用计数法</strong></p>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<p><strong>2. 可达性分析算法</strong></p>
<p><strong>可达性分析算法：</strong>基本思路就是通过一系列名为 ”GC Roots” 的对象作为起始点，从这个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。以下对象会被认为是 Roots 对象：</p>
<ul>
<li><strong>栈内存中引用的对象</strong> </li>
<li><strong>方法区中静态引用和常量引用指向的对象</strong> </li>
<li>被启动类（bootstrap加载器）加载的类和创建的对象 </li>
<li>Native 方法中 JNI 引用的对象</li>
</ul>
<img src="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:90%;">

<h2 id="3-6引用类型"><a href="#3-6引用类型" class="headerlink" title="3.6引用类型"></a>3.6引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<ul>
<li><p><strong>强引用(StrongReference)</strong></p>
<p>被强引用关联的对象不会被回收，当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>软引用(SoftReference)</strong></p>
<p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用(WeakReference)</strong></p>
<p>在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，也就是说它只能存活到下一次垃圾回收发生之前。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用（PhantomReference）</strong></p>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<blockquote>
<p><strong>Note：</strong>ReferenceQueue主要是用于监听Reference所指向的对象是否已经被垃圾回收。</p>
</blockquote>
</li>
</ul>
<h2 id="3-7-JVM-中的垃圾回收算法"><a href="#3-7-JVM-中的垃圾回收算法" class="headerlink" title="3.7 JVM 中的垃圾回收算法"></a>3.7 JVM 中的垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h3><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>优点：实现简单，不需要对象进行移动。</p>
<p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。<br><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。</p>
<ul>
<li>它把内存空间划为两个相等的区域，每次只使用其中一个区域</li>
<li>垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中</li>
<li>最后将当前使用的区域的可回收的对象进行回收</li>
</ul>
<p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。<br><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h3><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为<strong>老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低</strong>。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-清除算法不同的是：</p>
<ul>
<li>在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起</li>
<li>然后对端边界以外的内存进行回收</li>
<li>回收后，已用和未用的内存都各自一边</li>
</ul>
<p>优点：解决了标记-清理算法存在的内存碎片问题。</p>
<p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。<br><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h3><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="3-7JVM-垃圾回收器"><a href="#3-7JVM-垃圾回收器" class="headerlink" title="3.7JVM 垃圾回收器"></a>3.7JVM 垃圾回收器</h2><p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片03.jpg" alt="img"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。<strong>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</strong></li>
</ul>
<h3 id="5-CMS-收集器"><a href="#5-CMS-收集器" class="headerlink" title="5. CMS 收集器"></a>5. CMS 收集器</h3><p>CMS 垃圾回收器是第一款并发收集器，第一次实现了让垃圾收集器线程与用户线程同时工作，它的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。延迟越低，越能提高响应速度，进而提升用户的体验。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片04.jpg" alt="img"></p>
<p><strong>CMS收集器：</strong>基于“标记-清除”算法实现，会出现 “Stop The World”。</p>
<p><strong>运作过程如下：</strong></p>
<ul>
<li><strong>初始标记：</strong> 仅仅<strong>只是标记一下 GC Roots 能直接关联到的对象</strong>，需要 “Stop The World”，但是速度很快。</li>
<li><strong>并发标记：</strong> 进行 GC Roots Tracing 的过程，<strong>从 GC Roots 能直接关联到的对象开始遍历整个对象图的过程</strong>，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是<strong>为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清除：</strong> 该阶段<strong>清理掉标记阶段判断已经死亡的对象，释放内存空间</strong>，不需要停顿。</li>
</ul>
<p><strong>优点：</strong></p>
<p>由于在整个过程和中最耗时的并发标记和并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的，所以<strong>停顿时间比较短</strong></p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>CMS 收集器对 CPU 资源非常敏感</strong></p>
<p>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，</p>
</li>
<li><p><strong>CMS 处理器无法处理浮动垃圾</strong> </p>
<p>CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾” ， </p>
</li>
<li><p><strong>CMS 收集器会产生空间碎片</strong></p>
<p>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发 Full GC。</p>
</li>
</ul>
<h3 id="6-G1-垃圾回收器"><a href="#6-G1-垃圾回收器" class="headerlink" title="6. G1 垃圾回收器"></a>6. G1 垃圾回收器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片05.png" alt="img"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片06.png" alt="img"></p>
<p>通过引入 Region  的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>成为可能。通过记录每个 Region  垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，<strong>优先回收价值最大的  Region</strong>。避免了在整个 Java 堆中进行全区域的垃圾收集，而是回收价值最大的区域。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片07.jpg" alt="img"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><strong>初始标记：</strong>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象</li>
<li><strong>并发标记：</strong>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的  Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered  Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收：</strong>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p><strong>并行与并发</strong></p>
<p>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU或者CPU核心）来缩短 stop-The-World 停顿时间</p>
</li>
<li><p><strong>分代收集</strong></p>
<p>G1 不需要其他收集器就能独立管理整个 GC 堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次 GC 的对象。 </p>
</li>
<li><p><strong>减少空间碎片</strong></p>
<p>G1 从整体来看是基于标记-整理算法（将不需要回收的 region 压缩到一起），从局部（两个Region）上看基于复制算法实现，G1 运作期间不会产生内存空间碎片。 </p>
</li>
<li><p><strong>可预测的停顿</strong></p>
<p>这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能<strong>建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对内存和CPU要求高一些</li>
</ul>
<h1 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4.内存分配与回收策略"></a>4.内存分配与回收策略</h1><h2 id="4-1-Minor-GC-和-Full-GC"><a href="#4-1-Minor-GC-和-Full-GC" class="headerlink" title="4.1 Minor GC 和 Full GC"></a>4.1 Minor GC 和 Full GC</h2><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h2 id="4-2内存分配策略"><a href="#4-2内存分配策略" class="headerlink" title="4.2内存分配策略"></a>4.2内存分配策略</h2><p><strong>1. 对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<p><strong>2. 大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p><strong>3. 长期存活的对象进入老年代</strong></p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<p><strong>4. 动态对象年龄判定</strong></p>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor  空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<p><strong>5. 空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure  的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次  Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="4-3-Full-GC-的触发条件"><a href="#4-3-Full-GC-的触发条件" class="headerlink" title="4.3 Full GC 的触发条件"></a>4.3 Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>1. 调用 System.gc()</strong></p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<p><strong>2. 老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn  虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold  调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<p><strong>3. 空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<p><strong>4. JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<p><strong>5. Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 CMS GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="5-虚拟机类加载机制"><a href="#5-虚拟机类加载机制" class="headerlink" title="5.虚拟机类加载机制"></a>5.虚拟机类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="5-1类的生命周期"><a href="#5-1类的生命周期" class="headerlink" title="5.1类的生命周期"></a>5.1类的生命周期</h2><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片08.png" alt="img" style="zoom:67%;">

<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="5-2类装载的过程"><a href="#5-2类装载的过程" class="headerlink" title="5.2类装载的过程"></a>5.2类装载的过程</h2><p><strong>类装载分为以下 5 个步骤：</strong></p>
<p><strong>1.加载</strong></p>
<p>根据查找路径找到相应的 class 文件然后导入 JVM 内存中</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<p><strong>2.验证</strong></p>
<p>检查加载的 class 文件的正确性，确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求。</p>
<p><strong>3.准备</strong></p>
<p>给类中的静态变量分配内存空间；</p>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.解析</strong></p>
<p>虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<p><strong>5.初始化</strong></p>
<p>对静态变量和静态代码块执行初始化工作。</p>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;()  方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;()  是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</clinit></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成  &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的  &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的  &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;()  方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;()  方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;()  方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="5-3类与类加载器"><a href="#5-3类与类加载器" class="headerlink" title="5.3类与类加载器"></a>5.3类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="5-4类加载器的分类"><a href="#5-4类加载器的分类" class="headerlink" title="5.4类加载器的分类"></a>5.4类加载器的分类</h2><p>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如  rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java  程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</JRE_HOME></li>
<li>扩展类加载器（Extension ClassLoader）这个类加载器是由  ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将  <JAVA_HOME>/lib/ext 或者被 java.ext.dir  系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</JAVA_HOME></li>
<li>应用程序类加载器（Application ClassLoader）这个类加载器是由  AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是  ClassLoader 中的 getSystemClassLoader()  方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h2 id="5-5双亲委派模型"><a href="#5-5双亲委派模型" class="headerlink" title="5.5双亲委派模型"></a>5.5双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation  Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片09.png" alt="img" style="zoom:67%;">

<p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p><strong>双亲委派模型的优势：</strong></p>
<ul>
<li><p><strong>避免重复加载</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
</li>
<li><p><strong>避免核心类篡改</strong></p>
<p>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass()  方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出  ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义类加载器的实现</strong></p>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自  java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class  文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打破双亲委派模型的方法</strong></p>
<p>继承 ClassLoader 类，重写 loadClass 和 findClass 方法</p>
<p>默认的 loadClass 方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。为了破坏双亲委派机制必须重写 loadClass 方法，先尝试交由 System 类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。</p>
<blockquote>
<p><strong>findClass方法：</strong>用户自定义类加载逻辑</p>
<p><strong>loadClass方法：</strong>双亲委派的具体逻辑实现，在该方法中，如果父类加载失败，则会调用自己的 findClass（）方法来完成加载</p>
</blockquote>
<h1 id="6-JVM调优"><a href="#6-JVM调优" class="headerlink" title="6. JVM调优"></a>6. JVM调优</h1><p>程序在上线前的测试或运行中有时会出现一些大大小小的JVM问题，比如<strong>cpu  load过高、请求延迟、tps降低</strong>等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对JVM进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。</p>
<h2 id="6-1-JVM-调优目标"><a href="#6-1-JVM-调优目标" class="headerlink" title="6.1 JVM 调优目标"></a>6.1 JVM 调优目标</h2><p>使用较小的内存占用来获得较高的吞吐量或者较低的延迟。</p>
<p>这里有几个比较重要的指标：</p>
<ul>
<li>内存占用：程序正常运行需要的内存大小。</li>
<li>延迟：由于垃圾收集而引起的程序停顿时间。</li>
<li>吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。</li>
</ul>
<p>调优的目的并不是让程序内存占用小、延迟低、高吞吐量同时具有，而是要根据明确的优化目标，找到性能的瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。</p>
<h2 id="6-2-JVM-调优工具"><a href="#6-2-JVM-调优工具" class="headerlink" title="6.2 JVM 调优工具"></a>6.2 JVM 调优工具</h2><p>调优可以依赖参考的数据有</p>
<ol>
<li><strong>系统运行日志：</strong>系统运行日志就是在程序代码中打印出的日志，描述了代码级别的系统运行轨迹（执行的方法、入参、返回值等），一般系统出现问题，系统运行日志是首先要查看的日志。</li>
<li><strong>堆栈错误信息：</strong>当系统出现异常后，可以根据堆栈信息初步定位问题所在，比如根据“java.lang.OutOfMemoryError: Java heap  space”可以判断是堆内存溢出；根据“java.lang.StackOverflowError”可以判断是栈溢出；根据“java.lang.OutOfMemoryError: PermGen space”可以判断是方法区溢出等。</li>
<li><strong>gc日志：</strong>程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:/data/jvm/gc.log  可以在程序运行时把gc的详细过程记录下来，或者直接配置“-verbose:gc”参数把gc日志打印到控制台，通过记录的gc日志可以分析每块内存区域gc的频率、时间等，从而发现问题，进行有针对性的优化。 </li>
<li><strong>线程快照：</strong>根据线程快照可以看到线程在某一时刻的状态，当系统中可能存在请求超时、死循环、死锁等情况时，可以根据线程快照来进一步确定问题。</li>
<li><strong>堆转储快照：</strong>程序启动时可以使用 “-XX:+HeapDumpOnOutOfMemory” 和  “-XX:HeapDumpPath=/data/jvm/dumpfile.hprof”，当程序发生内存溢出时，把当时的内存快照以文件形式进行转储（也可以直接用jmap命令转储程序运行时任意时刻的内存快照），事后对当时的内存使用情况进行分析。</li>
</ol>
<p><strong>JVM调优工具：</strong></p>
<p>用 jps（JVM process Status）可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数（要加上-v参数）等</p>
<p>用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息 </p>
<p>用jmap（Memory Map for Java）查看堆内存信息 </p>
<p>利用jconsole、jvisualvm分析内存信息(各个区如Eden、Survivor、Old等内存变化情况)，如果查看的是远程服务器的JVM，程序启动需要附加参数</p>
<h2 id="6-3常用-JVM-参数参考"><a href="#6-3常用-JVM-参数参考" class="headerlink" title="6.3常用 JVM 参数参考"></a>6.3常用 JVM 参数参考</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms</td>
<td align="center">初始堆大小，默认物理内存的1/64</td>
<td align="center">-Xms512M</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">最大堆大小，默认物理内存的1/4</td>
<td align="center">-Xms2G</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="center">新生代内存大小，官方推荐为整个堆的3/8</td>
<td align="center">-Xmn512M</td>
</tr>
<tr>
<td align="center">-Xss</td>
<td align="center">线程堆栈大小，jdk1.5及之后默认1M，之前默认256k</td>
<td align="center">-Xss512k</td>
</tr>
<tr>
<td align="center">-XX:NewRatio=n</td>
<td align="center">设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</td>
<td align="center">-XX:NewRatio=3</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio=n</td>
<td align="center">年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如:8，表示Eden：Survivor=8:1:1，一个Survivor区占整个年轻代的1/8</td>
<td align="center">-XX:SurvivorRatio=8</td>
</tr>
<tr>
<td align="center">-XX:PermSize=n</td>
<td align="center">永久代初始值，默认为物理内存的1/64</td>
<td align="center">-XX:PermSize=128M</td>
</tr>
<tr>
<td align="center">-XX:MaxPermSize=n</td>
<td align="center">永久代最大值，默认为物理内存的1/4</td>
<td align="center">-XX:MaxPermSize=256M</td>
</tr>
<tr>
<td align="center">-verbose:class</td>
<td align="center">在控制台打印类加载信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-verbose:gc</td>
<td align="center">在控制台打印垃圾回收日志</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGC</td>
<td align="center">打印GC日志，内容简单</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td align="center">打印GC日志，内容详细</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDateStamps</td>
<td align="center">在GC日志中添加时间戳</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-Xloggc:filename</td>
<td align="center">指定gc日志路径</td>
<td align="center">-Xloggc:/data/jvm/gc.log</td>
</tr>
<tr>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">年轻代设置串行收集器Serial</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseParallelGC</td>
<td align="center">年轻代设置并行收集器Parallel Scavenge</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:ParallelGCThreads=n</td>
<td align="center">设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。</td>
<td align="center">-XX:ParallelGCThreads=4</td>
</tr>
<tr>
<td align="center">-XX:MaxGCPauseMillis=n</td>
<td align="center">设置Parallel Scavenge回收的最大时间(毫秒)</td>
<td align="center">-XX:MaxGCPauseMillis=100</td>
</tr>
<tr>
<td align="center">-XX:GCTimeRatio=n</td>
<td align="center">设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</td>
<td align="center">-XX:GCTimeRatio=19</td>
</tr>
<tr>
<td align="center">-XX:+UseParallelOldGC</td>
<td align="center">设置老年代为并行收集器ParallelOld收集器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseConcMarkSweepGC</td>
<td align="center">设置老年代并发收集器CMS</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+CMSIncrementalMode</td>
<td align="center">设置CMS收集器为增量模式，适用于单CPU情况。</td>
<td align="center"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先遍历</title>
    <url>/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p><strong>广度优先遍历（BFS）：</strong>如果说深度优先遍历类似于树的前序遍历，那么广度优先遍历就类似于层序遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>后序补</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">热题100-102. 二叉树的层序遍历</a></strong></p>
<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>创建双端队列</li>
<li>如果根节点不为null，将根节点加入到队列中</li>
<li>为了实现分层打印，在while循环中，每次得到队列的长度也就是该层的节点数，通过for循环将本层的节点打印，每次打印将该节点的左右子树加入到队列中，但是由于长度限制，新加入的节点在本次不会被打印</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        dq.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node=dq.pollFirst();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer-32 - III. 从上到下打印二叉树 III</a></strong></p>
<p>之字形打印二叉树</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>当二叉树的根节点1打印之后，将它的左子节点和右子节点先后保存到一个容器中，当打印二层的节点时，先打印节点3再打印节点2，看起来节点在该容器中是先进后出的，因此可以考虑这个容器用栈来实现。</li>
<li>因为是Z形遍历，所以子节点放入容器的顺序是不同的，对于奇数层，打印顺序是left→right，因为是先进后出所以存储顺序是right→left，偶数层同理。</li>
<li>两个栈可以合并成一个队列，大大节省空间，把队列想象成两个栈底对底拼接在一起，左端存取元素用addFirst（）和pollFirst（），右端存取元素用addLast（）和pollLast（）。</li>
<li>奇偶层用res的元素个数来判断。</li>
</ul>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) dq.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollFirst();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollLast();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/185a87cd29eb42049132aed873273e83?tpId=190&tqId=35580&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-二叉树根节点到叶子节点的所有路径和</a></strong></p>
<p>给定一个仅包含数字 0−9\ 0-9 0−9 的二叉树，每一条从根节点到叶子节点的路径都可以用一个数字表示。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>递归流程：</strong></p>
<ul>
<li>当节点为null时，返回</li>
<li>用路径的和加上该节点的值</li>
<li>当该节点的左右节点都为null时，将该路径和添加到sum中，返回</li>
<li>递归左子树</li>
<li>递归右子树</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> temp,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp+root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            sum+=temp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(temp*<span class="number">10</span>,root.left);</span><br><span class="line">        dfs(temp*<span class="number">10</span>,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>设计</title>
    <url>/2021/03/28/%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/lru-cache/">热题100-146. LRU 缓存机制</a></strong></p>
<p>实现页面置换算法中的最近最久未被使用算法（LRU）中的set和get方法</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>set和get方法的实现需要：</li>
<li>双端链表：存储插入的每一个节点，节点包括四个成员变量：key、value、preNode、nextNode（分别指向前后节点）；</li>
<li>HashMap：键值为节点的key值，值为节点；</li>
<li>两个哑结点：方便头部插入和尾部删除；</li>
<li>addTohead：将节点插入到双端链表的头部，set方法使用；</li>
<li>removeNode：移除一个节点；</li>
<li>removeToHead：当get方法查询一个节点时，先使用removeNode将该节点在双端链表中删除，再使用addToHead方法插入到头部；</li>
<li>removeTail：移除尾部节点；</li>
</ul>
<blockquote>
<p><strong>注意：</strong>当插入节点时，必须同时保存到HashMap中，当删除节点时，将该节点在HashMap中删除</p>
</blockquote>
<h2 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedList pre;</span><br><span class="line">        DLinkedList next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        node.next.pre=node;</span><br><span class="line">        head.next=node;</span><br><span class="line">        node.pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DLinkedList <span class="title">removeToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedList node=tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        hm.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node =<span class="keyword">new</span> DLinkedList(key,value);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            hm.put(key,node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node=hm.get(key);</span><br><span class="line">            <span class="keyword">return</span> removeToHead(node).value; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,DLinkedList&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,DLinkedList&gt;();</span><br><span class="line">    DLinkedList head=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    DLinkedList tail=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LRU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=k;</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span>[] nums:operators)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                 put(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                 res.add(get(nums[<span class="number">1</span>]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">            ans[i]=(<span class="keyword">int</span>)res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>算法思维</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2021/03/25/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>通过两个指针来实现题目要求，大大降低了空间复杂度</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle/">热题100-141. 环形链表</a></strong></p>
<p>给定一个链表，判断链表中是否有环。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置两个指针slow和fast</p>
<p>slow每次移动一个节点，fast每次移动两个节点</p>
<p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p>
</li>
<li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p>
</li>
<li><p>当循环中满足fast==slow时，返回true结束循环，否则链表遍历结束返回false</p>
</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;<span class="comment">//遍历到一个节点时，首先这个节点不能为null，如果该节点不进行判断，就会出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">热题100-142. 环形链表 II</a></strong></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>寻找第一次相遇的点：</strong></p>
<ul>
<li><p>设置两个指针slow和fast</p>
<p>slow每次移动一个节点，fast每次移动两个节点</p>
<p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p>
</li>
<li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p>
</li>
<li><p>当循环中满足fast==slow时，结束循环，判断slow和fast是否相等，不相等返回null，反之，继续执行下面的语句</p>
</li>
</ul>
<p><strong>第二次相遇的点就是环的入口：</strong></p>
<p>分析：设第一次相遇时，指针slow走过s步，fast走的步数比它多n倍的b步，所以fast走过的步数是s+nb；又因为fast一次走两步，所以s+nb=2s,所以s=nb;也就是相遇的这个点是b的倍数，环的入口满足a+xb,所以另一个指针指向头部，另一个指针不动，两个指针一次移动一个节点，第二次相遇时，走过的步数满足a+xb，就是环的入口节点。</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast=head.next;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast=head;</span><br><span class="line">    slow=slow.next;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用HashMap存储数组/字符串中的元素及其对应的下标；</li>
<li>设置左右两个指针，右指针遍历数组，每到一个元素的位置，先在HashMap中查看该元素是否存在，如果元素存在于HashMap中，更新left指针的值，另(left，right]区间内没有重复的元素；</li>
<li>将该元素及其下标存储到HashMap中；</li>
<li>更新最长无重复子串的长度；</li>
<li>返回结果。</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="comment">//HashMap新的键值对会覆盖原有的键值相同的键值对</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>;fast&lt;s.length();fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(ss[fast]))&#123;</span><br><span class="line">           slow=Math.max(hm.get(ss[fast]),slow);<span class="comment">//保证区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">           <span class="comment">//例：s=&quot;abcabcbb&quot;</span></span><br><span class="line">           <span class="comment">//当right指向第三个b时</span></span><br><span class="line">           <span class="comment">//假如left指向第二个c:此时显示有重复值，但是是在left之前，所以left不用变；</span></span><br><span class="line">           <span class="comment">//假如left指向第二个a:此时显示有重复值，是在left右边,所以更新left让其指向第二个b。</span></span><br><span class="line">           <span class="comment">//始终确保区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,fast-slow);</span><br><span class="line">        hm.put(ss[fast],fast);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">热题100-19. 删除链表的倒数第 N 个结点</a></strong></p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>设置快慢指针；</li>
<li>让快指针先走n步的距离，当慢指针开始走时，应该距离快指针有n步的距离；</li>
<li>快慢指针同时移动，当快指针移动到链表尾部时，慢指针正好在倒数第n个节点；</li>
<li>为了方便删除，使用一个哑结点，让慢指针从该节点开始移动，当快指针移动到尾部时，慢指针移动到倒数第n个节点的前一个节点，直接删除倒数第n个节点。</li>
</ul>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>扩展题目：</strong>给定一个链表的头结点和要删除的节点，如何通过O(1)的时间复杂度将该节点删除？（美团IOS）</p>
</blockquote>
<p>解题思路：通常的做法都是我们遍历到要删除节点的前一个节点，然后通过 next 指针的指向来删除给定的节点，如果通过O(1)的时间复杂度，也就是不遍历链表来删除。</p>
<p>考虑到给定了节点，那么我们可以通过该节点找到它的后继节点，将后继节点的内容复制到该节点，那么该节点相当于后一个节点，再通过 next 指针就能够将冗余的后继节点删除了。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=190&tqId=35226&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-反转字符串</a></strong></p>
<p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针一个从前往后，一个从后往前，直接交换就可以</p>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=strs.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=strs[left];</span><br><span class="line">            strs[left]=strs[right];</span><br><span class="line">            strs[right]=ch;</span><br><span class="line">            right--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/3sum/">热题100-15. 三数之和</a></strong></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>将数组排序，排序后的数组顺序为从小到大；</p>
</li>
<li><p>最外层通过for循环，遍历数组中的每一个元素，固定这个元素，再用双指针遍历右边部分的元素，看是否有三个元素和为0；</p>
</li>
<li><p>for循环内部：</p>
<p>1、每遍历到一个元素，判断是否大于0，因为该元素为最小元素，如果它大于0，以后的都大于零，直接结束for循环</p>
<p>2、每遍历到一个元素，判断它是否跟上一个元素相等，为了防止答案重复，如果元素相同向下顺延</p>
<p>3、当该元素不满足上面的两条，固定该元素，设置双指针指向余下部分的首尾元素</p>
<p>4、当left&lt;right时，执行for循环，通过sum与0的大小关系来移动双指针，同时记录满足条件的集合</p>
</li>
</ul>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//牛客上需要自己导包，Java一般导这个就够用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;num.length;k++)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(nums[k]+&quot;+&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(num[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;num.length&amp;&amp;num[k]==num[k-<span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum=num[k]+num[i]+num[j];</span><br><span class="line">         <span class="comment">//System.out.println(sum);</span></span><br><span class="line">          <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">              temp.add(num[k]);</span><br><span class="line">              temp.add(num[i]);</span><br><span class="line">              temp.add(num[j]);</span><br><span class="line">              res.add(temp);</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">              &#125;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/container-with-most-water/">热题100-11. 盛最多水的容器</a></strong></p>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置双指针，分别指向数组的首尾元素；</p>
</li>
<li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p>
<p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p>
<p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p>
</li>
</ul>
<h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max=Math.min(height[left],height[right])*(right-left);</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/trapping-rain-water/">热题100-42. 接雨水</a></strong></p>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置双指针，分别指向数组的首尾元素；</p>
</li>
<li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p>
<p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p>
<p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p>
</li>
</ul>
<h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_max&lt;right_max)&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,left_max-arr[left]);</span><br><span class="line">                left_max=Math.max(left_max,arr[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,right_max-arr[right]);</span><br><span class="line">                right_max=Math.max(right_max,arr[right]);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">热题100-234. 回文链表</a></strong></p>
<p>请判断一个链表是否为回文链表。</p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>找到链表的中间节点midNode：</p>
<p>创建快慢指针</p>
<p>慢指针一次走一步</p>
<p>快指针一次走两步</p>
</li>
<li><p>从中间节点的后面反转链表</p>
</li>
<li><p>这样就得到了两段链表，分别遍历判断即可</p>
</li>
<li><p>最后将链表还原</p>
</li>
</ul>
<h3 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode firstHead=head;</span><br><span class="line">        ListNode midNode=findMidNode(head);</span><br><span class="line">        ListNode secondHead=reverse(midNode.next);</span><br><span class="line">        ListNode temp=secondHead;</span><br><span class="line">        <span class="keyword">while</span>(firstHead!=<span class="keyword">null</span>&amp;&amp;secondHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstHead.val!=secondHead.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHead=firstHead.next;</span><br><span class="line">            secondHead=secondHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        midNode.next=reverse(temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=<span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=fast.next;</span><br><span class="line">            fast.next=slow;</span><br><span class="line">            slow=fast;</span><br><span class="line">            fast=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer-04. 二维数组中的查找</a></strong></p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一次比较都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<blockquote>
<p>解法可以参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/">点击查看</a></p>
</blockquote>
<h3 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//flag作为标志位</span></span><br><span class="line">       <span class="keyword">if</span>((matrix.length)==<span class="number">0</span>||(matrix[<span class="number">0</span>].length)==<span class="number">0</span>) <span class="keyword">return</span> flag;</span><br><span class="line">       <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//（r,c）作为右上角的起始坐标</span></span><br><span class="line">       <span class="keyword">while</span>(r&lt;=(matrix.length-<span class="number">1</span>)&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix[r][c]==target)&#123;<span class="comment">//如果右上角的坐标等于目标值，返回true，结束循环</span></span><br><span class="line">               flag=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c]&gt;target)&#123;<span class="comment">//当右上角的值大于目标值，左移一步，剔除右边的列，小于时，下移一步，剔除顶部一行</span></span><br><span class="line">               c--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/3sum/">热题100-15. 三数之和</a></strong></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>排序 + 双指针</strong></p>
<p><strong>算法流程：</strong></p>
<p>特判，对于数组长度 n，如果数组为 null 或者数组长度小于 3，返回 [][][]。</p>
<p>对数组进行排序。</p>
<p>遍历排序后数组：</p>
<ul>
<li>若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</li>
<li>对于重复元素：跳过，避免出现重复解</li>
<li>令左指针 L=i+1，右指针 R=n−1，当 L&lt;R 时，执行循环：<ul>
<li>当 nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R移到下一位置，寻找新的解</li>
<li>若和大于 0，说明 nums[R]太大，R左移</li>
<li>若和小于 0，说明 nums[L] 太小，L右移</li>
</ul>
</li>
</ul>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(nums[k]+&quot;+&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;nums.length&amp;&amp;nums[k]==nums[k-<span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum=nums[k]+nums[i]+nums[j];</span><br><span class="line">         <span class="comment">//System.out.println(sum);</span></span><br><span class="line">          <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">              temp.add(nums[k]);</span><br><span class="line">              temp.add(nums[i]);</span><br><span class="line">              temp.add(nums[j]);</span><br><span class="line">              res.add(temp);</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">              &#125;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></strong></p>
<p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
</blockquote>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针从后往前遍历</p>
<p>注意字符串方法trim()的使用，去掉首位空格</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">    s&#x3D;s.trim();</span><br><span class="line">    StringBuilder temp&#x3D;new StringBuilder();</span><br><span class="line">    int left&#x3D;s.length()-1;</span><br><span class="line">    int right&#x3D;s.length()-1;</span><br><span class="line">    while(left&gt;&#x3D;0)&#123;</span><br><span class="line">        while(left&gt;&#x3D;0&amp;&amp;s.charAt(left)!&#x3D;&#39; &#39;)&#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.append(s.substring(left+1,right+1)+&quot; &quot;);</span><br><span class="line">        while(left&gt;&#x3D;0&amp;&amp;s.charAt(left)&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        right&#x3D;left;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer-21. 调整数组顺序使奇数位于偶数前面</a></strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
</blockquote>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针指向首位，当头指针为偶数，尾指针为奇数时，交换数组中对应位置元素。</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right )&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                temp=nums[right];</span><br><span class="line">                nums[right]=nums[left];</span><br><span class="line">                nums[left]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>算法思维</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2021/03/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<hr>
<a id="more"></a>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2021/03/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2021/03/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个单调栈来实现获取滑动窗口内的最大值只需要 <strong><em>O(1)</em></strong> 的时间复杂度</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p><strong>动态规划：</strong>是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现(Memorization Search)</p>
<p>动态规划中的最优子结构：大规模问题中包含重复的子问题，并且大规模问题的最优解可以由小规模问题的最优解得到。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>满足两个条件：</strong></p>
<ol>
<li>满足以下条件之一<ul>
<li>求最大/最小值（Maximum/Minimum ）</li>
<li>求是否可行（Yes/No ）</li>
<li>求可行个数（Count(*) ）</li>
</ul>
</li>
<li>满足不能排序或者交换（Can not sort / swap ）</li>
</ol>
<h2 id="四点要素"><a href="#四点要素" class="headerlink" title="四点要素"></a>四点要素</h2><ol>
<li><strong>状态 State</strong><ul>
<li>灵感，创造力，存储小规模问题的结果</li>
</ul>
</li>
<li><strong>方程 Function</strong><ul>
<li><strong>状态之间的联系</strong>，怎么通过小的状态，来算大的状态</li>
</ul>
</li>
<li>初始化 Intialization<ul>
<li>最极限的小状态是什么, 起点</li>
</ul>
</li>
<li>答案 Answer<ul>
<li>最大的那个状态是什么，终点</li>
</ul>
</li>
</ol>
<h2 id="常见四种类型"><a href="#常见四种类型" class="headerlink" title="常见四种类型"></a>常见四种类型</h2><ol>
<li>矩阵类型（Matrix DP ）(10%)</li>
<li>序列类型（Sequence ）(40%)</li>
<li>子序列/子串（Two Sequences DP） (40%)</li>
<li>零钱、背包问题（Backpack） (10%)</li>
</ol>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="类型一：矩阵"><a href="#类型一：矩阵" class="headerlink" title="类型一：矩阵"></a>类型一：矩阵</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer-47. 礼物的最大价值</a></strong></p>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong> 设动态规划矩阵 dp ，dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)时能拿到礼物的最大累计价值。</p>
</li>
<li><p><strong>转移方程：</strong>设 f(i,j)为从棋盘左上角走至单元格 (i,j)的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j−1) 和 f(i−1,j) 中的较大值加上当前单元格礼物价值 grid(i,j)。<br>$$<br>f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)<br>$$</p>
</li>
<li><p><strong>初始状态：</strong> dp[0] [0]=grid[0] [0]，即到达单元格 (0,0)时能拿到礼物的最大累计价值为 grid[0] [0] ；</p>
</li>
<li><p><strong>返回值：</strong> dp[m−1] [n−1]，m,n分别为矩阵的行高和列宽，即返回 dp矩阵右下角元素。</p>
</li>
</ul>
<h4 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.max(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximal-square/">热题100-221. 最大正方形</a></strong></p>
<p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSide=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          maxSide=Math.max(maxSide,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/unique-paths/">热题100-62. 不同路径</a></strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] grid=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;m;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;n;c++)&#123;</span><br><span class="line">            grid[r][c]=grid[r-<span class="number">1</span>][c]+grid[r][c-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/minimum-path-sum/">热题100-64. 最小路径和</a></strong></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.min(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型二：序列"><a href="#类型二：序列" class="headerlink" title="类型二：序列"></a>类型二：序列</h2><p>常见处理方式是给 0 位置占位，这样处理问题时一视同仁，初始化则在原来基础上 length+1，返回结果 f[n]</p>
<ul>
<li>状态可以为前 i 个</li>
<li>初始化 length+1</li>
<li>取值 index=i-1</li>
<li>返回值：f[n]或者 f[m][n]</li>
</ul>
<h3 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/climbing-stairs/">热题100-70. 爬楼梯</a></strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p>状态定义：创建dp数组（长度为n+1），dp[i]表示跳上i阶台阶时的跳法</p>
</li>
<li><p>转移方程：跳上第i阶台阶有两种方式，一个是从i-2阶跳两个台阶，一个是从i-1阶跳一个台阶，这样就有了状态转移方程</p>
</li>
<li><p>$$<br>f(i)=f(i−1)+f(i−2)<br>$$</p>
</li>
<li><p>初始化：因为要从前两个状态得到第i个状态，所以给0,1赋值</p>
</li>
<li><p>返回值：返回dp[n]</p>
</li>
</ul>
<h4 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer-10- I. 斐波那契数列</a></strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 </p>
</blockquote>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意这里的首相为0，不是1</p>
<h4 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximum-subarray/">热题100-53. 最大子序和</a></strong></p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>状态定义：创建dp数组，设dp[i]为以i元素结尾的子数组的最大累加和子数组</li>
<li>转移方程：dp[i]状态可以由dp[i-1]状态转移过来，选取dp[i-1]+arr[i]和arr[i]的较大值，也就是当前面最大值为负数时，直接选取这个元素本身作为最大值</li>
<li>初始化：dp[i]=0</li>
<li>返回值：返回dp[n]</li>
</ul>
<blockquote>
<p><strong>Note：</strong>因为第i个状态只与前一个状态有关，可以只用一个变量preSume来代替dp数组，大大降低空间复杂度</p>
</blockquote>
<h4 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        preSum=Math.max(nums[i],preSum+nums[i]);<span class="comment">//当preSum为负数时，另preSum=nums[i]，也就是index=i结尾的子串最大值为它本身</span></span><br><span class="line">        maxValue=Math.max(preSum,maxValue);<span class="comment">//用maxValue来记录第i个数结尾的连续子数组的最大和的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四-1"><a href="#题目四-1" class="headerlink" title="题目四"></a>题目四</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">热题100-152. 乘积最大子数组</a></strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong>假如我们把dp[i]作为第i个元素结尾的子数组的最大乘积，那么这个状态怎么得到呢，只由i-1状态的最大值是得不到的，该题的关键是：<strong>当nums[i]为负数时，前面的最大值乘完变最小值，最小值乘完变最大值</strong>，所以还要创建一个dp数组，来保存每个元素结尾的子数组的最小乘积。</p>
</li>
<li><p><strong>转移方程：</strong></p>
<p><strong>当nums[i]&gt;=0时：</strong></p>
<ul>
<li><p>dpMax[i]=Math.max(dpMax[i-1]*nums[i],nums[i]);</p>
</li>
<li><p>dpMin[i]=Math.min(dpMin[i-1]*nums[i],nums[i]);</p>
</li>
</ul>
<p><strong>当nums[i]&lt;0时：</strong></p>
<ul>
<li>dpMax[i]=Math.max(dpMin[i-1]*nums[i],nums[i]);</li>
<li>dpMin[i]=Math.min(dpMax[i-1]*nums[i],nums[i]);</li>
</ul>
</li>
<li><p><strong>初始化：</strong>dpMax[0]=dpMin[0]=nums[0]</p>
</li>
<li><p><strong>返回值：</strong>返回最大值</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>因为第i个状态只与前一状态的最大最小值有关，所以可以用preMax和preMin两个变量代替</p>
</blockquote>
<h4 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tempMax=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> tempMin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=tempMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=tempMax;</span><br><span class="line">            tempMax=tempMin;</span><br><span class="line">            tempMin=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        tempMax=Math.max(tempMax*nums[i],nums[i]);</span><br><span class="line">        tempMin=Math.min(tempMin*nums[i],nums[i]);</span><br><span class="line"></span><br><span class="line">        max=Math.max(tempMax,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/word-break/">热题100-139. 单词拆分</a></strong></p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
</blockquote>
<h4 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h4><p>状态定义：dp[i]表示以i结尾的子串，能否被分割</p>
<p>状态转移：dp[i]可以由前面的结果得到，需要遍历i元素前的子串，将子串分为两部分，如果有一部分已经得到&amp;另一部分在字典中能查到，则dp[i]=true</p>
<p>初始化：将dp[0]=true，表示整个子串都能在字典中查到</p>
<p>返回值：返回dp[s.length()]</p>
<h4 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; Dict=<span class="keyword">new</span> HashSet&lt;String&gt;(wordDict);</span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;Dict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目六（打家劫舍）"><a href="#题目六（打家劫舍）" class="headerlink" title="题目六（打家劫舍）"></a>题目六（打家劫舍）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/house-robber/">热题100-198. 打家劫舍</a></strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<h4 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>滚动数组法：</strong></p>
<ul>
<li><p><strong>状态定义：</strong>每个房间都有偷/不偷两种选择，用dp0和dp1分别表示不偷i个房间和偷i个房间能获得的最大价值</p>
</li>
<li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p>
<p>选择偷第i个房间时：dp1=dp[0]+nums[i];</p>
<p>选择不偷第i个房间：dp0=Math.max(dp0，dp1);</p>
<p>这里可以用temp暂存前一天的一个状态</p>
</li>
<li><p><strong>初始化：</strong>dp0=0，dp1=nums[0]</p>
</li>
<li><p><strong>返回值：</strong>返回dp0和dp1的较大值</p>
</li>
</ul>
<h4 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp0=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp1=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=dp0;</span><br><span class="line">        dp0=Math.max(dp0,dp1);</span><br><span class="line">        dp1=Math.max(temp+nums[i],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp0,dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目七（打家劫舍）"><a href="#题目七（打家劫舍）" class="headerlink" title="题目七（打家劫舍）"></a>题目七（打家劫舍）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></strong></p>
<p>二叉树中不能偷取直接相连的节点</p>
</blockquote>
<h4 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong>每个节点都有偷/不偷两种选择，用temp[0]和temp[1]分别表示不偷和偷该节点能获得的最大价值</p>
</li>
<li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p>
<p>当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</p>
<p>当选择偷root节点时，只能是它的值加上左右孩子都不偷时的值</p>
<p>递归中将这两个状态装入数组返回</p>
</li>
<li><p><strong>初始化：</strong>相当于递归终止时返回的数组，也就是都是0</p>
</li>
<li><p><strong>返回值：</strong>返回res[0],res[1]的较大值</p>
</li>
</ul>
<h4 id="代码及注解-10"><a href="#代码及注解-10" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//这个方法举个例子更好理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res=robInternal(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robInternal(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] left=robInternal(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right=robInternal(root.right);</span><br><span class="line">    temp[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);<span class="comment">//当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</span></span><br><span class="line">    temp[<span class="number">1</span>]=root.val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目八（股票）"><a href="#题目八（股票）" class="headerlink" title="题目八（股票）"></a>题目八（股票）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">热题100-121. 买卖股票的最佳时机</a></strong></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
</blockquote>
<h4 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h4><p>较简单，略</p>
<h4 id="代码及注解-11"><a href="#代码及注解-11" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowprice=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        profit=Math.max(profit,prices[i]-lowprice);</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;lowprice)&#123;</span><br><span class="line">            lowprice=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目九（股票）"><a href="#题目九（股票）" class="headerlink" title="题目九（股票）"></a>题目九（股票）</h3><blockquote>
<p><a href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=190&tqId=36950&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-股票交易的最大收益</strong></a></p>
<p>假定你知道某只股票每一天价格的变动。 </p>
<p>你最多可以同时持有一只股票。但你最多只能进行<strong>两次</strong>交易（一次买进和一次卖出记为一次交易。买进和卖出均无手续费）。 </p>
<p> 请设计一个函数，计算你所能获得的最大收益。</p>
</blockquote>
<h4 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong></p>
<p>一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过</p>
<p>所以定义状态转移数组dp[天数] [当前是否持股] [卖出的次数]</p>
</li>
<li><p><strong>转移方程：</strong></p>
<p>第i天的状态由第i-1天的状态得到</p>
<p>具体一天结束时的5种状态：</p>
<p>未持股，未卖出过股票：说明从未进行过买卖，利润为0<br>dp[i] [0] [0]=0<br>未持股，卖出过1次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [1]=max(dp[i-1] [1] [0]+prices[i],dp[i-1] [0] [1])<br>未持股，卖出过2次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [2]=max(dp[i-1] [1] [1]+prices[i],dp[i-1] [0] [2])<br>持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [0]=max(dp[i-1] [0] [0]-prices[i],dp[i-1] [1] [0])<br>持股，卖出过1次股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [1]=max(dp[i-1] [0] [1]-prices[i],dp[i-1] [1] [1])</p>
</li>
<li><p><strong>初始化：</strong></p>
<p> dp[0] [0] [0] = 0;//第一天休息</p>
<p>dp[0] [0] [1] = dp[0] [1] [1] = MIN_VALUE;//不可能</p>
<p>dp[0] [0] [2] = MIN_VALUE;//不可能</p>
<p>dp[0] [1] [0] = -prices[0];//买股票</p>
</li>
<li><p><strong>返回值：</strong>返回最后一天，不持股的两种状态</p>
</li>
</ul>
<h4 id="代码及注解-12"><a href="#代码及注解-12" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> MIN_VALUE = Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十（股票）"><a href="#题目十（股票）" class="headerlink" title="题目十（股票）"></a>题目十（股票）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">热题100-309. 最佳买卖股票时机含冷冻期</a></strong></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
</blockquote>
<h4 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong></p>
<p><strong>一天结束时</strong>，可能有持股、不持股两种状态，并且不持股分为处于冷冻期、不处于冷冻期两种状态</p>
<p>定义状态转移数组dp[i] [0] 、dp[i] [1] 、dp[i] [2] </p>
</li>
<li><p><strong>转移方程：</strong></p>
<p>具体一天的三种状态：</p>
<p>持股的状态，要么前一天持股，要么前一天不持股在i天买入</p>
<p>dp[i] [0] =Math.max(dp[i-1] [0]，dp[i-1] [2]-prices[i])</p>
<p>不持股&amp;处于冷冻期的状态，前一天必须持股而且在第i天卖出</p>
<p>dp[i] [1]=dp[i-1] [0]+prices[i]</p>
<p>不持股&amp;不处于冷冻期，前一天就不持股，对应两种状态</p>
<p>dp[i] [2]=Math.max(dp[i-1] [1],dp[i-1] [2])</p>
</li>
<li><p><strong>初始化：</strong></p>
<p>第一天：</p>
<p>dp[0] [0]=-prices[0];买入</p>
<p>dp[0] [1]=0;不存在的状态</p>
<p>dp[0] [2]=0;什么也不干</p>
</li>
<li><p><strong>返回值：</strong>返回不持股状态的两种较大值</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>这里第i天的状态只与前一天的三种状态有关，所以可以用三个变量代替dp数组</p>
</blockquote>
<h4 id="代码及注解-13"><a href="#代码及注解-13" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;prices.length;x++)&#123;</span><br><span class="line">           <span class="keyword">int</span> ii=Math.max(i,k);</span><br><span class="line">           <span class="keyword">int</span> jj=Math.max(j,i-prices[x]);</span><br><span class="line">           <span class="keyword">int</span> kk=j+prices[x];</span><br><span class="line">           i=ii;</span><br><span class="line">           j=jj;</span><br><span class="line">           k=kk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(i,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十一（回文串）"><a href="#题目十一（回文串）" class="headerlink" title="题目十一（回文串）"></a>题目十一（回文串）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/palindromic-substrings/">热题100-647. 回文子串</a></strong></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
</blockquote>
<h4 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>两层循环，考察所有子串，判断是否是回文串。</li>
<li>时间复杂度 O(n^3)：串的长度为n，每个点的比较次数：0+1+2+……+n=（n+1）*n/2，所以是n^3</li>
<li>空间复杂度：O(n^2)：用到二维数组</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>大问题是一个子串是否是回文串，然后统计有几个回文子串，那规模小一点的子问题呢？</li>
<li>一个子串是回文串，刨去相同的首尾字符，剩下的子串也必须是回文串。</li>
<li>剩下的子串是否为回文串，就是规模小一点的子问题，它影响大问题的结果。</li>
</ul>
<p>用二维 Boolean 数组记录中間子问题的解，从base case出发，递推出每个子问题的解。</p>
<p><strong>s[i:j] 是回文的情况：</strong></p>
<p><strong>首先i和j元素必须相同的前提下，满足下面任意一条</strong></p>
<ul>
<li>当只有单个字符时</li>
<li>由两个字符组成</li>
<li>超过两个字符的情况，<strong>剩余的子串是一个回文串</strong>（这个要用到前面子问题的解）</li>
</ul>
<h4 id="代码及注解-14"><a href="#代码及注解-14" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">      <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录回文串的个数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                  <span class="keyword">if</span>(flag[j][i]=i==j||i-j==<span class="number">1</span>||flag[j+<span class="number">1</span>][i-<span class="number">1</span>])&#123;</span><br><span class="line">                      count++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十二（回文串）"><a href="#题目十二（回文串）" class="headerlink" title="题目十二（回文串）"></a>题目十二（回文串）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">热题100-5. 最长回文子串</a></strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<h4 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h4><p>同上</p>
<h4 id="代码及注解-15"><a href="#代码及注解-15" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||flag[j+<span class="number">1</span>][i-<span class="number">1</span>]||i-j==<span class="number">1</span>)&#123;</span><br><span class="line">                    flag[j][i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&gt;=maxLength)&#123;</span><br><span class="line">                        maxLength=i-j+<span class="number">1</span>;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,start+maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h3><blockquote>
<p><a href="https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-最长递增子序列</strong></a></p>
<p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）</p>
<p><strong>这个题要用贪心+二分法，否则在牛客上不能通过</strong></p>
</blockquote>
<h4 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>动态规划：</strong></p>
<ul>
<li>通过一个maxlens数组，记录每个元素结尾的最长递增子序列的长度，通过一个maxlen来记录最大的长度</li>
<li>对于maxlens[i]，要在区间[0，i]遍历maxlens数组，找到arr[i]&gt;arr[j]时的元素，不断地更新maxlens[i]</li>
<li>这种方式的时间复杂度为n^2，会出现超时的情况</li>
</ul>
<p><strong>贪心+二分：</strong></p>
<ul>
<li>仍然用maxlens数组，记录每个元素结尾的最长递增子序列的长度，maxlen来记录最大的长度</li>
<li>不同的是还要维护一个tails数组，tail[i]表示长度为 i 的最长上升子序列的末尾元素的最小值，比如：数组 [2, 3, 1, 4, 6]中tails最终为[1,4,6]，依次表示长度为1的最长上升子序列末尾的最小元素为1，长度为2的为4，长度为3的为6，这时如果后面再加个10那最长上升子序列的长度为4时，最小的结尾元素为10，如果再多个3，那么长度为2的最长上升子序列的结尾元素就要从4换成3。</li>
<li>这样一来，我们就可以通过二分法在tails数组中查找该元素结尾的最长上升子序列的最大长度</li>
<li>这种方式的时间复杂度变成n*logn</li>
</ul>
<p><strong>最后：（按字典序输出）</strong></p>
<p>假设我们原始数组是arr1，得到的maxLen为<code>[1,2,3,1,3]</code>，最终输出结果为res（字典序最小的最长递增子序列），res的最后一个元素在arr1中位置无庸置疑是<code>maxLen[i]==3</code>对应的下标，那么到底是<code>arr1[2]</code>还是<code>arr1[4]</code>呢？如果是<code>arr1[2]</code>，那么<code>arr1[2]&lt;arr1[4]</code>，则<code>maxLen[4]==4</code>，与已知条件相悖。因此我们应该取<code>arr1[4]</code>放在res的最后一个位置。</p>
<p>因为元素对应同样长度时，后面的元素小于等于前面的元素，否则后面的长度就会大于前面的长度了</p>
<h4 id="代码及注解-16"><a href="#代码及注解-16" class="headerlink" title="代码及注解"></a>代码及注解</h4><p><strong>动态规划代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            maxlens[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                    maxlens[i]=Math.max(maxlens[i],maxlens[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=Math.max(maxlen,maxlens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>贪心+二分代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] tails=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        tails[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        maxlens[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;tails[maxlen-<span class="number">1</span>])&#123;</span><br><span class="line">                tails[maxlen++]=arr[i];</span><br><span class="line">                maxlens[i]=maxlen;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> right=maxlen-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tails[mid]&lt;=arr[i])&#123;</span><br><span class="line">                        left=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right=mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tails[left]=arr[i];</span><br><span class="line">                maxlens[i]=++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十四（股票）"><a href="#题目十四（股票）" class="headerlink" title="题目十四（股票）"></a>题目十四（股票）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣主站-122. 买卖股票的最佳时机 II</a></strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<h4 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(prices.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp0;</span><br><span class="line">            dp0=Math.max(dp1+prices[i],dp0);</span><br><span class="line">            dp1=Math.max(temp-prices[i],dp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十五"><a href="#题目十五" class="headerlink" title="题目十五"></a>题目十五</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/regular-expression-matching/">热题100-10. 正则表达式匹配</a></strong></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<h4 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h4><p>设主串为S，模式串为P</p>
<p>整体上来看就是关注模式串P每加进来一个字符后，能否与主串匹配，而模式串中加进来的字符有三种可能：普通字符、’ . ‘、’ * ‘，然后分情况进行讨论：</p>
<p>进一步来说，因为’ . ‘可以表示任意的字符，所以可以进一步划分，也就是是不是’ * ‘</p>
<ul>
<li><p>如果不是’ * ‘：</p>
<p>如果是普通字符，且与主串中的字符相等</p>
<p>如果是’ . ‘</p>
<p>上面两种情况之一，且模式串 j-1 前的部分可以匹配主串 i-1 前的串，这时，dp[i] [j]=true</p>
<p>其它情况为false</p>
</li>
<li><p>如果是’ * ‘</p>
<p>1、如果 S 的前 i 个字符和 P 的前 j - 2 个字符匹配，这时 P 的第 j 个字符为’*’ ，那么无论p的第j-1个字符是什么，令它出现0次，dp[i] [j]就可以为true</p>
<p>2、如果 s 的前i - 1个字符和p的前j个字符匹配，并且s的第i个字符和p的第j - 1个字符相等，那么<strong>让 p 的第 j - 1个字符多出现一次，s的前i字符和p的前j的字符就可以匹配了</strong>（看到这句话，豁然开朗）</p>
<p>3、如果 S 的前i - 1个字符和 P 的前 j 个字符匹配，因为 P 的第 j - 1个字符为’ . ‘可以匹配任意字符，那么 S 的第 i 个字符可以匹配 P 的第j - 1个字符，令 P 的第 j - 1 个字符多出现一次即可（其实与第二种是同一种情况，就是P的第 j-1 个字符换成’ . ‘，可以匹配任意字符了）</p>
</li>
</ul>
<h4 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">int</span> m=p.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==s.charAt(i-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>)&amp;&amp;(dp[i][j-<span class="number">2</span>]||((s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">&#x27;.&#x27;</span>)&amp;&amp;dp[i-<span class="number">1</span>][j])))&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型三：子序列-子串"><a href="#类型三：子序列-子串" class="headerlink" title="类型三：子序列/子串"></a>类型三：子序列/子串</h2><h3 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></strong></p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<h4 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>A 、B数组各抽出一个子数组，单看它们的末尾项，如果它们俩不一样，则公共子数组肯定不包括它们俩。</li>
<li>如果它们俩一样，则要考虑它们俩前面的子数组<strong>「能为它们俩提供多大的公共长度」</strong>。<ul>
<li>如果它们俩的前缀数组的「末尾项」不相同，由于子数组的连续性，前缀数组不能为它们俩提供公共长度</li>
<li>如果它们俩的前缀数组的「末尾项」相同，则可以为它们俩提供公共长度：<pre><code>至于提供多长的公共长度？这又取决于前缀数组的末尾项是否相同……</code></pre>
</li>
</ul>
</li>
</ul>
<p>所以得出问题的子问题在于：前缀数组的最长重复子数组</p>
<h4 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=nums1.length;</span><br><span class="line">       <span class="keyword">int</span> m=nums2.length;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">       <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(i&lt;n-<span class="number">1</span>&amp;&amp;j&lt;m-<span class="number">1</span>)&#123;</span><br><span class="line">                       dp[i][j]=dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               maxLen=Math.max(maxLen,dp[i][j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">主站-1143. 最长公共子序列</a></strong></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<h4 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li><p><strong>状态定义</strong></p>
<p>可以定义 dp[i] [j]表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。</p>
</li>
<li><p><strong>状态转移方程</strong></p>
<ul>
<li><p><strong>当 text1[i - 1] == text2[j - 1] 时：</strong>说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i] [j] = dp[i - 1] [j - 1] + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。</p>
</li>
<li><p><strong>当 text1[i - 1] != text2[j - 1] 时：</strong>说明两个子字符串的最后一位不相等，那么此时的状态 dp[i] [j] 应该是 dp[i - 1] [j] 和 dp[i] [j - 1] 的最大值。举个例子，比如对于 ace 和 abc 而言，他们的最长公共子序列的长度等于 ① ace 和 ab 的最长公共子序列长度1 与 ② ac 和 abc 的最长公共子序列长度2 的最大值，即 2。（也就是说当最后一位 e != c 时，我们可以认为是 ac 和 ab 的基础上将 e 加进来，也就是 ace 和 ab 这两个子串的最长公共子序列的长度，另一种情况同理）</p>
<p>那为什么不是在dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]中选择最大的呢，因为dp[i-1] [j]和dp[i] [j-1]必定&gt;=dp[i-1] [j-1]。</p>
</li>
</ul>
</li>
<li><p><strong>状态的初始化</strong></p>
<p>初始化就是要看当 i = 0 与 j = 0 时， dp[i] [j] 应该取值为多少。</p>
<ul>
<li>当 i = 0 时，dp[0] [j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0；</li>
<li>当 j = 0 时，dp[i] [0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0；</li>
</ul>
<p>综上，当 i = 0 或者 j = 0 时，dp[i] [j] 初始化为 0.</p>
</li>
<li><p><strong>返回结果</strong></p>
<p><code>dp[i][j]</code> 的含义就是 <code>text1</code> 和 <code>text2</code> 的最长公共子序列</p>
</li>
</ol>
<h4 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=text1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类型四：零钱、背包问题"><a href="#类型四：零钱、背包问题" class="headerlink" title="类型四：零钱、背包问题"></a>类型四：零钱、背包问题</h2><h3 id="题目一（零钱）"><a href="#题目一（零钱）" class="headerlink" title="题目一（零钱）"></a>题目一（零钱）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/coin-change/">热题100-322. 零钱兑换</a></strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<h4 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><strong>状态定义：</strong>dp[i]表示当为i元钱时，需要的硬币最少数目</li>
<li><strong>转移方程：</strong>dp[i]状态要遍历已经得到的dp数组，选择那个硬币最少数目作为dp[i]</li>
<li><strong>初始化：</strong>dp[0]=0，然后每次的dp[i]设为i+1，用于判断该元素是否找到了最少硬币数目的组合</li>
<li><strong>返回值：</strong>根据dp[i]是否有解，确定返回解还是无解</li>
</ul>
<blockquote>
<p><strong>Note：</strong>dp[i-coins[j]] 决策coins[j]是否参与</p>
</blockquote>
<h4 id="代码及注解-17"><a href="#代码及注解-17" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        dp[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;=<span class="number">0</span>&amp;&amp;dp[i-coins[j]]&lt;=i-coins[j])&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]&gt;amount? -<span class="number">1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-3"><a href="#题目二-3" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/perfect-squares/">热题100-279. 完全平方数</a></strong></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
</blockquote>
<h4 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h4><p>同零钱问题</p>
<h4 id="代码及注解-18"><a href="#代码及注解-18" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从下到上地求得每个数的完全平方数的最少个数</span></span><br><span class="line"><span class="comment">    当遍历到i时，从i中减去j的平方(j是递增的)，看当前的dp[i]和从i中减去j的平方后的数+1（因为从i中减去一个平方数j得到dp数组中索引位置index=i-j*j处，因此为dp[i-j*j]+1）哪个小选哪个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j*j&gt;=<span class="number">0</span>;j++)&#123;<span class="comment">//结束条件是大于等于0，等于0也是可以的，比如4-2*2=0,说明正好正好为0，只用一个平方数就可以得到，而当大于0时，这种只用一个平方数的情况就给排除了</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三（01背包）"><a href="#题目三（01背包）" class="headerlink" title="题目三（01背包）"></a>题目三（01背包）</h3><p><strong>总结在先：（两层循环）</strong></p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由大到小）。</li>
</ul>
<blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></strong></p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<h4 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h4><p>作为「0-1 背包问题」，它的特点是：<strong>「每个数只能用一次」</strong>。</p>
<p>解决的基本思路是：<strong>物品一个一个选，容量也一点一点增加去考虑</strong>。</p>
<p>具体做法是：画一个 <strong>len</strong> 行，<strong>target + 1</strong> 列的表格。这里 <strong>len</strong> 是物品的个数，<strong>target</strong> 是背包的容量。<strong>len</strong> 行表示一个一个物品考虑，<strong>target + 1</strong>多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。</p>
<ol>
<li><p><strong>状态的定义：</strong>我们定义dp[i] [j]为当我们选取前 i 个物品时，能否填满容量为 j 的背包</p>
</li>
<li><p><strong>状态的转移：</strong>当我们用前 i 个物品去填满容量为 j 的背包时，看它能否填满，就要分第 i 个物品选还是不选（01）的情况</p>
<p>对于第 i 个物品，还要分能不能选的问题，也就是背包容量 j 是否能够容纳第 i 个物品，于是有：</p>
<p>当 j-nums[i]&lt;0 （不能容纳）：dp[i] [j]=dp[i-1] [j] （等于用前 i-1 个物品能否填满容量为 j 的背包状态）</p>
<p>当 j-nums[i]&gt;=0 （能容纳）：dp[i] [j]=dp[i-1] [j]||dp[i-1] [j-nums[i]]（<strong>不选：</strong>等于用前 i-1 个物品能否填满容量为 j 的背包状态，<strong>选：</strong>此时的背包容量要减去nums[i]，等于用前 i-1 个物品能否填满容量为 j-nums[i] 的背包状态）</p>
</li>
<li><p><strong>初始化：</strong>dp[0] [0] =  true，第一行，也就是背包容量与第一个元素相等时为 true</p>
</li>
<li><p><strong>返回值：</strong>返回dp[nums.length-1] [target]，中间也可以进行剪枝操作，只要发现有一种子集满足就可以返回，也就是表格的最后一列是 true 就可以返回。</p>
</li>
</ol>
<p>表格：如 nums = [1,5,11,5]，target=11时</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0（1）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td align="center"><strong>1（5）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td align="center"><strong>2（11）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T（返回）</strong></td>
</tr>
<tr>
<td align="center"><strong>3（5）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
</tr>
</tbody></table>
<p>举个例子：当nums[1]=5这个元素可以选择时，背包容量增大到 5 时，当不把 5 加到背包中时，发现只用nums[0]=1这个元素填不满，选择把 5 加入到背包中时，就应该等于dp[0] [0]，也就是剩余背包容量正好是 0 ，所以状态为 true ，这也是为什么要将dp[0] [0] 初始化为 true 的原因</p>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><ol>
<li><strong>（重要）</strong>在「填表格」的时候，当前行<strong>只参考了上一行的值</strong>，因此状态数组可以只设置 222 行，使用「滚动数组」的技巧「填表格」即可；</li>
<li><strong>（重要）</strong>实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，<strong>当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值</strong>。因此，我们可以只开一个一维数组，从后向前依次填表即可。</li>
<li>「从后向前」 写的过程中，一旦 nums[i] &lt;= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。</li>
</ol>
<h4 id="代码及注释（二维）"><a href="#代码及注释（二维）" class="headerlink" title="代码及注释（二维）"></a>代码及注释（二维）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target=sum/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=nums[<span class="number">0</span>]==j? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][target]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="代码及注释（一维）"><a href="#代码及注释（一维）" class="headerlink" title="代码及注释（一维）"></a>代码及注释（一维）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target=sum/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;<span class="comment">//只对dp[0]初始化就可以，因为第一次dp[j-nums[i]]，当j-nums[i]=0时，那些位置就会为true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=nums[i];j--)&#123;</span><br><span class="line">            dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四（01背包）"><a href="#题目四（01背包）" class="headerlink" title="题目四（01背包）"></a>题目四（01背包）</h3><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/target-sum/">主站-494. 目标和</a></strong></p>
</blockquote>
<h4 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h4><p>重要的是这道题怎么转换成01背包问题：</p>
<ul>
<li>我们想要的 S = 正数和 - 负数和 = x - y</li>
<li>而已知 x 与 y 的和是数组总和：x + y = sum</li>
<li>可以求出 x = (S + sum) / 2 = target</li>
<li>也就是我们要从 nums 数组里选出几个数，令其和为 target（target 间接给出）。</li>
<li>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 nums，内层循环为 target。</li>
</ul>
<p>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。</p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由大到小）。</li>
</ul>
<p>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。（类似于跳台阶问题）</p>
<p>dp[i] = dp[i] + dp[i - num]</p>
<p>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]</p>
<h4 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S&gt;sum||(sum+S)%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target=(sum+S)/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目五（完全背包）"><a href="#题目五（完全背包）" class="headerlink" title="题目五（完全背包）"></a>题目五（完全背包）</h3><p><strong>总结在先：（两层循环）</strong></p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由小到大）。</li>
</ul>
<blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/coin-change-2/">主站-518. 零钱兑换 II</a></strong></p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
</blockquote>
<h4 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>通过对比01背包和完全背包的循环，可以看到内层遍历背包容量时，一个是从大到小，一个是从小到大</strong></p>
<ul>
<li><p>01背包从大到小：因为01背包中的每个元素<strong>只能用一次</strong>，当从小到大改变每个容量对应的组合数时，后面元素参考的值不再是这个元素选与不选的问题，而是这个元素选了几次的问题。</p>
</li>
<li><p>完全背包从小到大：因为完全背包中的元素是无限的，所以一个元素可以多次使用作为组合来填满背包，需要从小到大地改变每个容量对应的组合数。</p>
<p>举个例子，数组为[2,2,3,5]，要找和为6的组合数</p>
<p>当 i = 0时，dp[4]为 [0] ，</p>
<p>当 i 自增到1，nums[i] =  2，j = 4时，dp[4] = dp[4] + dp[4 -  2]；当 i 不变，j = 6时,dp[6] = dp [6] + dp [6 - 2]，而dp[4]相当于 j = 4 容量时，已经放入了 nums[i] = 2这个物品，这样一来就重复的放入了该物品，所以不满足01背包的要求，但是换成完全背包就可以，它就是要得到一个物品多次放入的组合数</p>
</li>
</ul>
<p><strong>组合数与排列数：</strong></p>
<ul>
<li><p><strong>组合数中的方案不能使用相同元素</strong></p>
<p>当外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设：coins[0] = 1，coins[1] = 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
</li>
<li><p><strong>排列数元素相同但是顺序不同就算一种方案</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
</li>
</ul>
<h4 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">               dp[j]+=dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2021/03/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="二分搜索介绍"><a href="#二分搜索介绍" class="headerlink" title="二分搜索介绍"></a>二分搜索介绍</h2><p>二分查找是一种在每次比较之后<strong>将查找空间一分为二</strong>的算法。二分查找维护查找空间的左、右和中间指示符，并比较查找目标，如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。如果查找以空的一半结束，则无法满足条件，并且无法找到目标。</p>
<p><strong>四个要素：</strong></p>
<ol>
<li>初始化：start=0、end=len-1</li>
<li>循环退出条件：start + 1 &lt; end</li>
<li>比较中点和目标值：A[mid] ==、 &lt;、&gt; target</li>
<li>判断最后两个元素是否符合：A[start]、A[end] ? target</li>
</ol>
<h2 id="识别二分搜索"><a href="#识别二分搜索" class="headerlink" title="识别二分搜索"></a>识别二分搜索</h2><ul>
<li>每次需要查找集合中的索引或元素时，都应该考虑二分查找。</li>
<li>集合有序（如果集合是无序的，我们可以总是在应用二分查找之前先对其进行排序）。</li>
</ul>
<h2 id="实现二分搜索的方法"><a href="#实现二分搜索的方法" class="headerlink" title="实现二分搜索的方法"></a>实现二分搜索的方法</h2><p><strong>详情点击</strong>：<a href="https://leetcode-cn.com/leetbook/read/binary-search/xewjg7/"><strong>二分搜索模板</strong></a></p>
<p><strong>方法一：</strong></p>
<ul>
<li>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。</li>
<li>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target)&#123; <span class="keyword">return</span> mid; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123; left = mid + <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; right = mid - <span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// End Condition: left &gt; right</span></span><br><span class="line">  <span class="comment">// 应该是right略小于target，left略大于target</span></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。</p>
</blockquote>
<p><strong>方法二：</strong></p>
<ul>
<li>搜索条件需要访问元素的直接左右邻居。</li>
<li>使用元素的邻居来确定它是向右还是向左。</li>
<li>保证查找空间在每个步骤中至少有 3 个元素。</li>
<li>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>大部分场景方法二都能解决问题，而且还能找第一次/最后一次出现的位置</li>
<li>如果是最简单的二分搜索，不需要找第一个、最后一个位置、或者是没有重复元素，可以使用方法一</li>
</ul>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">热题100-33. 搜索旋转排序数组</a></strong></p>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用方法二，需要与其相邻的元素比较来确定向左还是向右，最后要对结果进行处理来决定最后的返回值</p>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环的条件</span></span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(nums[left]&lt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&gt;nums[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[right])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/09fbfb16140b40499951f55113f2166c?tpId=190&tqId=35187&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-求平方根</strong></a></p>
<p>实现函数 int sqrt(int x).   </p>
<p>计算并返回x的平方根（向下取整） </p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sqrt</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=x;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;x/mid)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;x/right)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer-11. 旋转数组的最小数字</a></strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;=array[left])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[left]&gt;array[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> array[right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer-53 - I. 在排序数组中查找数字 I</a></strong></p>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法二</p>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            l=left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            l=right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=l;</span><br><span class="line">        right=n-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> right-l+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left-l+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">热题100-34. 在排序数组中查找元素的第一个和最后一个位置</a></strong></p>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>初始化：</strong> 左边界 i=0 ，右边界 j=len(nums)−1 ；代表闭区间 [i,j] 。<br><strong>循环二分：</strong> 当 i≤j 时循环 （即当闭区间 [i,j] 为空时跳出） ；</p>
<ol>
<li>计算中点 m=(i+j)//2，其中 “//“ 为向下取整除法；</li>
<li>若 nums[m]=m ，则 “右子数组的首位元素” 一定在闭区间 [m+1,j]中，因此执行 i=m+1；</li>
<li>若 nums[m]≠m ，则 “左子数组的末位元素” 一定在闭区间 [i,m−1]中，因此执行 j=m−1；</li>
</ol>
<p><strong>返回值：</strong> 跳出时，变量 i 和 j 分别指向 “右子数组的首位元素” 和 “左子数组的末位元素” 。因此返回 i 即可。<strong>（很重要，确定返回值，两个子数组特别关键）</strong></p>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=n-<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            res[<span class="number">1</span>]=right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            res[<span class="number">1</span>]=left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">剑指 Offer-53 - II. 0～n-1中缺失的数字</a></strong></p>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>方法一</p>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;mid)&#123;</span><br><span class="line">        high=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;low=mid+<span class="number">1</span>;&#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出的数据结构，常用于BFS广度优点遍历</p>
<p>创建语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双端队列：</span></span><br><span class="line">Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈的特点是先进后出，常用于二叉树的迭代遍历或者DFS深度优先遍历</p>
<p>创建语句：<strong>常用双端队列来实现栈</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双端队列：</span></span><br><span class="line">Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>双端队列实现队列和栈的常用方法：</strong></p>
<img src="/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/GitHub\MyBlogs\source\_posts\2021-03-25-栈和队列\队列.png" style="zoom:60%;">

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer-59 - I. 滑动窗口的最大值</a></strong></p>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过维护一个单调栈来实现获取滑动窗口内的最大值只需要 <strong><em>O(1)</em></strong> 的时间复杂度</p>
<p>通过for循环遍历数组中的元素</p>
<ul>
<li><p><strong>删除首位元素：</strong>通过当前的下标 i 来判断队列中的首位元素是否超出了滑动窗口区间，是就删除首位</p>
</li>
<li><p><strong>删除尾部元素：</strong>如果新增值大于队列尾部值，删除队列中比新增值小的值，如果新增值大于队列中所有值，删除所有，然后把新增值放到队列首位，保证队列一直是从大到小；如果小于队尾元素，直接插入</p>
<p>（因为经过第一步每次已经将超出窗口区间的元素删除了，如果新加入的元素大于区间内的元素，那么这些小的元素不可能是当前区间的最小值了；如果小于队尾元素，该元素虽然不是当前区间的最小值，但是前面的元素移出窗口区间时，它有可能成为后面某一窗口的最大值）</p>
</li>
<li><p><strong>尾部插入新值：</strong>这个虽然是尾部插入，但是有的已经插入到队首了</p>
</li>
<li><p><strong>将最大值插入到结果集合：</strong>依然是通过当前的下标 i 来判断当前是否形成了窗口区间，如果已经形成，就会取出队首元素，也就是当前窗口的最大值插入到结果集合中</p>
</li>
</ul>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;<span class="comment">//得到给定数组的长度</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  <span class="keyword">return</span> nums;<span class="comment">//如果给定数组长度为0，返回一个空数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[n-k+<span class="number">1</span>];<span class="comment">//通过计算得到返回数组的长度为n-k+1</span></span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; dq=<span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//创建deque双端队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;<span class="comment">//for循环遍历每一个给定数组的元素</span></span><br><span class="line">        <span class="keyword">if</span>(!dq.isEmpty()&amp;&amp;dq.getFirst()&lt;(i-k+<span class="number">1</span>))&#123;<span class="comment">//当滑动窗口的长度达到k时，每次应该先执行删除队头的操作，当dq不为空，且dq中队头元素的下标超出dq长度范围时，执行删除操作</span></span><br><span class="line">            dq.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(!dq.isEmpty()&amp;&amp;nums[i]&gt;=nums[dq.getLast()])&#123;<span class="comment">//执行完删除队头操作之后，执行删除队尾操作，比较添加元素和deque队尾元素的值，当该元素大于deque队列中的值时，也就是它前面的元素不可能是当前和以后的滑动窗口范围内最大值，这时删除所有比它小的元素，当该元素小于队尾元素值时，直接加入，因为它虽然不是当前滑动窗口的最大值，但是有可能是后面的滑动窗口的最大值</span></span><br><span class="line">        dq.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">    dq.addLast(i);<span class="comment">//执行添加操作，因为每次都要执行添加操作，所以不用加条件判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k-<span class="number">1</span>)&#123;<span class="comment">//当滑动窗口的值达到k的长度时，将队头的值（也就是最大值）添加到数组</span></span><br><span class="line">        res[i-k+<span class="number">1</span>]=nums[dq.getFirst()];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指 Offer-41. 数据流中的中位数</a></strong></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为要找数据流的中位数，可以通过排序、二分的方式得到，并且每次插入元素为了保证数组有序，还要将元素插入到合适的位置，时间复杂度为O(n)，可以借助双堆的方式来优化时间复杂度。</p>
<p>通过两个优先队列实现，分别设为q1和q2，用q1保存前半部分数据，用q2保存后半部分数据</p>
<p>插入数据时，有两种情况：</p>
<ul>
<li>当两个堆中的数据一样多时，将数据插入到q2中，再将q2队头的数添加到q1中，也就是总是让多出来的数在q1的队头</li>
<li>当两个堆中的数据不一样多时，q1会多一个数，将该数插入到q1，再将q1的队头插入到q2中，两个堆中的数就一样多了</li>
</ul>
<p>取中位数时，根据两个堆的元素个数，分情况得到中位数</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; pq1;</span><br><span class="line">    Queue&lt;Integer&gt; pq2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pq1=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        pq2=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1,Integer i2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i2-i1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq1.size()==pq2.size())&#123;</span><br><span class="line">            pq2.add(num);</span><br><span class="line">            pq1.add(pq2.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pq1.add(num);</span><br><span class="line">            pq2.add(pq1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq1.size()==pq2.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> (pq1.peek()+pq2.peek())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)pq1.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/daily-temperatures/">热题100-739. 每日温度</a></strong></p>
<p>请根据每日 <code>气温</code> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题我们需要借助<strong>递减栈</strong></p>
<p>当给定数组为： [73, 74, 75, 71, 69, 72, 76, 73]时，我们来模拟函数的运行过程</p>
<p>遍历数组（入栈操作时我们加入栈的是<strong>元素的下标</strong>，这样我们后面能够根据弹出的元素下标填入等待的天数）</p>
<p>元素73对应的下标压入栈中，</p>
<p>元素74，这时栈不为空，要用74跟栈顶的元素来比较，当它大于栈顶的元素时，要将栈顶的元素弹出，并且将此时的元素下标x减去弹出元素的index就是该位置的温度再等几天能够观测到更高温，这里弹出73，将2-1=1加入res数组中下标0的位置，</p>
<p>元素75，同元素74，</p>
<p>元素71，小于栈顶元素75，直接压入栈中，</p>
<p>元素69，同元素71，</p>
<p>元素72，大于69，弹出69，并将5-4=1填入res数组下标4对应的位置，大于71，将71弹出，将5-3=2填入res数组下标3对应位置，小于75，循环结束，将72压入栈中，</p>
<p>然后以此类推……</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">           <span class="keyword">int</span> index=stack.pop();</span><br><span class="line">           res[index]=i-index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/03/25/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="链表相关的核心点"><a href="#链表相关的核心点" class="headerlink" title="链表相关的核心点"></a>链表相关的核心点</h1><ul>
<li>null/nil 异常处理</li>
<li>dummy node 哑节点</li>
<li>快慢指针</li>
<li>插入一个节点到排序链表</li>
<li>从一个链表中移除一个节点</li>
<li>翻转链表</li>
<li>合并两个链表</li>
<li>找到链表的中间节点</li>
</ul>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/"><strong>热题100-21.合并两个有序链表</strong></a></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>设置一个哑结点res，方便返回结果</li>
<li>循环比较两个链表中的节点，循环条件是两个链表指向的节点不为null，head指向数值较小的节点</li>
<li>循环结束的条件实际是有一个链表遍历结束，再让head.next指向没有遍历完的链表即可</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;<span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/">热题100-206. 反转链表</a></strong></p>
<p>输入一个链表，将它反转后返回头结点。</p>
</blockquote>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">    ListNode curNode=head;</span><br><span class="line">    ListNode nextNode=head;</span><br><span class="line">    <span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextNode=curNode.next;</span><br><span class="line">         curNode.next=preNode;</span><br><span class="line">         preNode=curNode;</span><br><span class="line">         curNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=190&tqId=36037&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表的奇偶重排</strong></a></p>
<p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。</p>
<p>注意是节点的编号而非节点的数值。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置两个哑结点</p>
</li>
<li><p>遍历链表：</p>
<p>奇数节点赋给奇数链表</p>
<p>偶数节点赋给偶数链表</p>
</li>
<li><p>如果链表没有遍历完，肯定是奇数个节点的情况，只剩一个节点赋给奇数链表</p>
</li>
<li><p>最后，将奇数链表和偶数链表结合</p>
</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp1=head1;</span><br><span class="line">        ListNode head2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp2=head2;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>&amp;&amp;head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp1.next=head;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">            temp2.next=head.next;</span><br><span class="line">            temp2=temp2.next;</span><br><span class="line">            head=temp2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp1.next=head;</span><br><span class="line">            temp1=temp1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp2.next=<span class="keyword">null</span>;</span><br><span class="line">        temp1.next=head2.next;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer-52. 两个链表的第一个公共节点</a></strong></p>
<p>输入两个链表，找出它们的第一个公共节点。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>头节点 <code>headA</code>  （节点数量a）到 <code>node</code> 前，共有 a−c个节点；</li>
<li>头节点 <code>headB</code>  （节点数量b）到 <code>node</code> 前，共有 b−c个节点；</li>
</ul>
<p>构建两个节点指针 A , B 分别指向两链表头节点 headA , headB ，做如下操作：</p>
<ul>
<li>指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：</li>
</ul>
<p>$$<br>  a+(b−c)<br>$$</p>
<ul>
<li>指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：</li>
</ul>
<p>$$<br>  b+(a−c)<br>$$</p>
<p> 如下式所示，此时指针 A , B 重合，并有两种情况：</p>
<p>$$<br>a+(b−c)=b+(a−c)<br>$$</p>
<ol>
<li>若两链表有公共尾部 (即 c&gt;0 ) ：指针 A , B 同时指向「第一个公共节点」node 。</li>
<li>若两链表无公共尾部 (即 c=0) ：指针 A , B 同时指向 null。</li>
</ol>
<p>因此返回 A 即可。</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode A = headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="keyword">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="keyword">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=190&tqId=35219&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-两个链表生成相加链表</strong></a></p>
<p>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。 </p>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。 </p>
<p>类似题目：<a href="https://leetcode-cn.com/problems/add-two-numbers/"><strong>热题100-2. 两数相加</strong></a></p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>力扣上的题目是<strong>逆序</strong>存储，可以从最低位相加，而这里是<strong>正序</strong>存储的，要对链表进行处理</p>
<ul>
<li>先将两个链表反转，可以从头结点开始遍历链表并对节点相加</li>
<li>循环中要设置进位</li>
<li>循环结束，要判断进位是否为1，如果是要将这个节点拼接到结果链表上</li>
<li>最后将结果链表反转，返回</li>
</ul>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode rhead1=reverseList(head1);</span><br><span class="line">        ListNode rhead2=reverseList(head2);</span><br><span class="line">        <span class="keyword">int</span> carray=<span class="number">0</span>;</span><br><span class="line">        ListNode pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=pre;</span><br><span class="line">        <span class="keyword">while</span>(rhead1!=<span class="keyword">null</span>||rhead2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k1=rhead1==<span class="keyword">null</span>? <span class="number">0</span>:rhead1.val;</span><br><span class="line">            <span class="keyword">int</span> k2=rhead2==<span class="keyword">null</span>? <span class="number">0</span>:rhead2.val;</span><br><span class="line">            <span class="keyword">int</span> sum=k1+k2+carray;</span><br><span class="line">            carray=sum/<span class="number">10</span>;</span><br><span class="line">            sum=sum%<span class="number">10</span>;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            <span class="keyword">if</span>(rhead1!=<span class="keyword">null</span>) rhead1=rhead1.next;</span><br><span class="line">            <span class="keyword">if</span>(rhead2!=<span class="keyword">null</span>) rhead2=rhead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carray!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseList(pre.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer-22. 链表中倒数第k个节点</a></strong></p>
<p> 输入一个链表，输出该链表中倒数第k个结点。 </p>
<p> 如果该链表长度小于k，请返回空。 </p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>快慢指针</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span> <span class="params">(ListNode pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>||k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        node.next=pHead;</span><br><span class="line">        ListNode slow=node;</span><br><span class="line">        ListNode fast=node;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;i&lt;k)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">热题100-19. 删除链表的倒数第 N 个结点</a></strong></p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>删除与返回第n个节点，<strong>fast指针的起始位置是不同的</strong></p>
<h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=190&tqId=35186&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-删除有序链表中重复的元素</strong></a></p>
<p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>设置一个前驱节点，当当前节点与前驱节点的值相同时，跳过</li>
<li>当值不同时，pre.next=head，跳过重复节点，然后该节点作为后面节点的前驱节点，继续循环</li>
<li>循环结束时，前驱节点应该位于链表的最后一个节点，如果不是，说明链表尾部有重复元素没有跳过，如 {1,2,3,4,4,4,4,4}</li>
</ul>
<h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val==pre.val)&#123;</span><br><span class="line">                head=head.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=head;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=190&tqId=35192&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表中的节点每k个一组反转</strong></a></p>
<p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表</p>
<p>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样</p>
<p>你不能更改节点中的值，只能更改节点本身。</p>
<p>要求空间复杂度  O(1)</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>节点 pre：每次指向操作链表的上段链表的结尾</p>
<p>节点 end：指向每段操作链表的尾部</p>
<p>节点 start：指向每段操作链表的头部</p>
<p><strong>reverseKGroup 方法：</strong>以 k 个为一段，<strong>分段处理</strong>链表</p>
<ul>
<li>首先，通过for循环查看剩余长度是否够 k 个，如果不够直接结束循环。外层的循环还要加一个if语句，让它跳出外层循环</li>
<li>当够 k 个，以这k个节点为一段，让 end 指向链表尾部，用一个 nextNode 指向 end.next ,并<strong>让end指向 null</strong> 为了反转该段链表</li>
<li>调用reverse方法，对 start 开头的链表反转</li>
<li>通过 pre 让上段链表与反转后的该段相接</li>
<li>因为<strong>反转后 start 指向了链表尾</strong>，让pre指向start，与下段链表相接</li>
<li>另start指向下段的头部</li>
<li>head也指向下段的头部，下次循环从头部开始遍历</li>
</ul>
<p><strong>reverseList 方法：</strong>反转链表</p>
<h3 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span> <span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        ListNode end=dummy;<span class="comment">//每次指向一节链表的尾部节点</span></span><br><span class="line">        </span><br><span class="line">        ListNode start=head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre.next=start;</span><br><span class="line">                    head=head.next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head=head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end=head;</span><br><span class="line">            ListNode nextNode=end.next;</span><br><span class="line">            end.next=<span class="keyword">null</span>;</span><br><span class="line">            pre.next=reverseList(start);</span><br><span class="line">            pre=start;</span><br><span class="line">            start=nextNode;</span><br><span class="line">            head=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=190&tqId=35184&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-链表内指定区间反转</strong></a></p>
<p>将一个链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。</p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路跟上一题很像，只要处理好反转后的链表的链接细节就行</p>
<h3 id="代码及注释-6"><a href="#代码及注释-6" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span> <span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode slow=dummy;</span><br><span class="line">        ListNode fast=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail=fast.next;</span><br><span class="line">        fast.next=<span class="keyword">null</span>;</span><br><span class="line">        ListNode reTail=slow.next;</span><br><span class="line">        slow.next=reverseList(reTail);</span><br><span class="line">        reTail.next=tail;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode=head;</span><br><span class="line">        <span class="keyword">while</span>(curNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=curNode.next;</span><br><span class="line">            curNode.next=preNode;</span><br><span class="line">            preNode=curNode;</span><br><span class="line">            curNode=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=190&tqId=35342&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-删除有序链表中重复出现的元素</strong></a></p>
<p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。</p>
</blockquote>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>与上面的一题不同，本题最后只保留原来链表中只出现一次的节点</p>
<p>循环遍历链表，对于每个节点有两种可能：</p>
<ul>
<li>后面有重复的元素，要跳过所有重复元素，所以while循环之后还要跳一步才能跳过所有元素，并且让pre（上个元素）的后继指向该节点，防止尾部都是重复元素时，直接来到null，但是pre还是指向后面重复元素的第一个节点</li>
<li>后面没有重复元素，pre（上个元素）的后继指向该节点，并让pre指向该节点，该节点后移一个节点</li>
</ul>
<h3 id="代码及注释-7"><a href="#代码及注释-7" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val==cur.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>&amp;&amp;cur.val==cur.next.val)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">                pre.next=cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next=cur;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></strong></p>
<p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n ，<br>将其重新排列后变为： <em>L</em>0→<em>Ln</em>→<em>L</em>1→<em>Ln</em>-1→<em>L</em>2→<em>Ln</em>-2→…</p>
</blockquote>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。</p>
<p>这样我们的任务即可划分为三步：</p>
<ul>
<li><p>找到原链表的中点</p>
</li>
<li><p>将原链表的右半端反转</p>
</li>
<li><p>将原链表的两端合并</p>
</li>
</ul>
<h3 id="代码及注释-8"><a href="#代码及注释-8" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode firstHead=dummy;</span><br><span class="line">        ListNode secondHead=findMidnode(head);</span><br><span class="line">        ListNode resecondHead=reverseList(secondHead);</span><br><span class="line">        firstHead=firstHead.next;</span><br><span class="line">        <span class="keyword">while</span>(firstHead!=<span class="keyword">null</span>&amp;&amp;resecondHead!=<span class="keyword">null</span>)&#123;<span class="comment">//合并链表</span></span><br><span class="line">            ListNode temp1=firstHead.next;</span><br><span class="line">            ListNode temp2=resecondHead.next;</span><br><span class="line">            firstHead.next=resecondHead;</span><br><span class="line">            resecondHead.next=temp1;</span><br><span class="line">            firstHead=temp1;</span><br><span class="line">            resecondHead=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidnode</span><span class="params">(ListNode head)</span></span>&#123;<span class="comment">//找到每段链表的中间节点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line"></span><br><span class="line">        ListNode slow=dummy;</span><br><span class="line">        ListNode fast=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;<span class="comment">//反转链表</span></span><br><span class="line">        ListNode slow=<span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode temp=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp=fast.next;</span><br><span class="line">            fast.next=slow;</span><br><span class="line">            slow=fast;</span><br><span class="line">            fast=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">主站-24. 两两交换链表中的节点</a></strong></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
</blockquote>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。</p>
<p>如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p>
<h3 id="代码及注释-9"><a href="#代码及注释-9" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummyHead.next = head;</span><br><span class="line">        ListNode temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode node1 = temp.next;</span><br><span class="line">            ListNode node2 = temp.next.next;</span><br><span class="line">            temp.next = node2;</span><br><span class="line">            node1.next = node2.next;</span><br><span class="line">            node2.next = node1;</span><br><span class="line">            temp = node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十四"><a href="#题目十四" class="headerlink" title="题目十四"></a>题目十四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的复制</a></strong></p>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
</blockquote>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li><p>复制各节点，构建拼接链表:<br>设原链表为 node1→node2→⋯ ，构建的拼接链表如下所示：</p>
<p>node1→node1new→node2→node2new→⋯</p>
</li>
<li><p>构建新链表各节点的 random 指向：<br>当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为 cur.random.next 。</p>
</li>
<li><p>拆分原 / 新链表：<br>设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。</p>
</li>
<li><p>返回新链表的头节点 res 即可。</p>
</li>
</ol>
<h3 id="代码及注释-10"><a href="#代码及注释-10" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node nextNode=cur.next;</span><br><span class="line">            Node temp=<span class="keyword">new</span> Node(cur.val);</span><br><span class="line">            cur.next=temp;</span><br><span class="line">            temp.random=<span class="keyword">null</span>;</span><br><span class="line">            temp.next=nextNode;</span><br><span class="line">            cur=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next.random=cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node before=head;</span><br><span class="line">        Node after=head.next;</span><br><span class="line">        Node res=after;</span><br><span class="line">        <span class="keyword">while</span>(before!=<span class="keyword">null</span>&amp;&amp;after.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            before.next=before.next.next;</span><br><span class="line">            after.next=after.next.next;</span><br><span class="line">            before=before.next;</span><br><span class="line">            after=after.next;</span><br><span class="line">        &#125;</span><br><span class="line">        before.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-项目升级</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="11-1-对关键配置信息进行DES加密"><a href="#11-1-对关键配置信息进行DES加密" class="headerlink" title="11.1 对关键配置信息进行DES加密"></a>11.1 对关键配置信息进行DES加密</h1><p>创建加密和解密的工具类：DESUtil</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Key key;</span><br><span class="line">	<span class="comment">// 设置密钥key</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String KEY_STR = <span class="string">&quot;myKey&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String CHARSETNAME = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String ALGORITHM = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 生成DES算法对象</span></span><br><span class="line">			KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);</span><br><span class="line">			<span class="comment">// 运用SHA1安全策略</span></span><br><span class="line">			SecureRandom secureRandom = SecureRandom.getInstance(<span class="string">&quot;SHA1PRNG&quot;</span>);</span><br><span class="line">			<span class="comment">// 设置上密钥种子</span></span><br><span class="line">			secureRandom.setSeed(KEY_STR.getBytes());</span><br><span class="line">			<span class="comment">// 初始化基于SHA1的算法对象</span></span><br><span class="line">			generator.init(secureRandom);</span><br><span class="line">			<span class="comment">// 生成密钥对象</span></span><br><span class="line">			key = generator.generateKey();</span><br><span class="line">			generator = <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取加密后的信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getEncryptString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 基于BASE64编码，接收byte[]并转换成String</span></span><br><span class="line">		BASE64Encoder base64encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 按UTF8编码</span></span><br><span class="line">			<span class="keyword">byte</span>[] bytes = str.getBytes(CHARSETNAME);</span><br><span class="line">			<span class="comment">// 获取加密对象</span></span><br><span class="line">			Cipher cipher = Cipher.getInstance(ALGORITHM);</span><br><span class="line">			<span class="comment">// 初始化密码信息</span></span><br><span class="line">			cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">			<span class="comment">// 加密</span></span><br><span class="line">			<span class="keyword">byte</span>[] doFinal = cipher.doFinal(bytes);</span><br><span class="line">			<span class="comment">// byte[]to encode好的String并返回</span></span><br><span class="line">			<span class="keyword">return</span> base64encoder.encode(doFinal);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取解密之后的信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDecryptString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 基于BASE64编码，接收byte[]并转换成String</span></span><br><span class="line">		BASE64Decoder base64decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将字符串decode成byte[]</span></span><br><span class="line">			<span class="keyword">byte</span>[] bytes = base64decoder.decodeBuffer(str);</span><br><span class="line">			<span class="comment">// 获取解密对象</span></span><br><span class="line">			Cipher cipher = Cipher.getInstance(ALGORITHM);</span><br><span class="line">			<span class="comment">// 初始化解密信息</span></span><br><span class="line">			cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">			<span class="comment">// 解密</span></span><br><span class="line">			<span class="keyword">byte</span>[] doFinal = cipher.doFinal(bytes);</span><br><span class="line">			<span class="comment">// 返回解密之后的信息</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String(doFinal, CHARSETNAME);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将JDBC.properties文件中的数据库连接的账号、密码信息都改为加密后的密文</p>
<p>创建类，用于解密关键字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptPropertyPlaceholderConfigurer</span> <span class="keyword">extends</span> <span class="title">PropertyPlaceholderConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 需要解密的字段数组</span></span><br><span class="line">	<span class="keyword">private</span> String[] encryptPropNames = &#123; <span class="string">&quot;jdbc.username&quot;</span>, <span class="string">&quot;jdbc.password&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 对关键的属性进行转换（上面的字段）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">convertProperty</span><span class="params">(String propertyName, String propertyValue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEncryptProp(propertyName)) &#123;</span><br><span class="line">			<span class="comment">// 对已加密的字段进行解密工作</span></span><br><span class="line">			String decryptValue = DESUtil.getDecryptString(propertyValue);</span><br><span class="line">			<span class="keyword">return</span> decryptValue;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> propertyValue;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 判断该属性是否已加密</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> propertyName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEncryptProp</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 若等于需要加密的field，则进行加密</span></span><br><span class="line">		<span class="keyword">for</span> (String encryptpropertyName : encryptPropNames) &#123;</span><br><span class="line">			<span class="keyword">if</span> (encryptpropertyName.equals(propertyName))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更改spring-dao.xml中的配置，将含有加密字段的文件路径放入工具类的bean中：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里能不能理解为bean中的属性locations的值依次为jdbc.properties中的每一个字段呢</span></span><br><span class="line">&lt;bean</span><br><span class="line">	<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.imooc.o2o.util.EncryptPropertyPlaceholderConfigurer&quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;locations&quot;</span>&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;value&gt;classpath:jdbc.properties&lt;/value&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;fileEncoding&quot;</span> value=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;         </span><br></pre></td></tr></table></figure>

<h1 id="11-2引入Redis缓存技术配置"><a href="#11-2引入Redis缓存技术配置" class="headerlink" title="11.2引入Redis缓存技术配置"></a>11.2引入Redis缓存技术配置</h1><h2 id="11-2-1引入Jedis的jar包"><a href="#11-2-1引入Jedis的jar包" class="headerlink" title="11.2.1引入Jedis的jar包"></a>11.2.1引入Jedis的jar包</h2><p>Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的</p>
<h2 id="11-2-2创建redis-properties"><a href="#11-2-2创建redis-properties" class="headerlink" title="11.2.2创建redis.properties"></a>11.2.2创建redis.properties</h2><p>redis.properties中定义了连接redis的账户密码等字段</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis.hostname</span>=<span class="string">47.93.5.212</span></span><br><span class="line"><span class="meta">redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="meta">redis.pool.maxActive</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">redis.pool.maxIdle</span>=<span class="string">20</span></span><br><span class="line"><span class="meta">redis.pool.maxWait</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">redis.pool.testOnBorrow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h2 id="11-2-3创建spring-redis-xml对redis进行配置"><a href="#11-2-3创建spring-redis-xml对redis进行配置" class="headerlink" title="11.2.3创建spring-redis.xml对redis进行配置"></a>11.2.3创建spring-redis.xml对redis进行配置</h2><p>redis连接池的配置</p>
<p>创建Redis连接池对象：通过接口JedisPollWriper初始化连接池对象</p>
<p>创建Redis工具类JedisUtil，封装好Redis的连接以进行相关的操作</p>
<p>后面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis连接池的设置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisPoolConfig&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;redis.clients.jedis.JedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 控制一个pool可分配多少个jedis实例 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxActive&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 连接池中最多可空闲maxIdle个连接 ，这里取值为20，表示即使没有数据库连接时依然可以保持20空闲的连接，而不被清除，随时处于待命状态。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxIdle&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxWaitMillis&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.maxWait&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 在获取连接的时候检查有效性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testOnBorrow&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;$&#123;redis.pool.testOnBorrow&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 创建Redis连接池，并做相关配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisWritePool&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisPoolWriper&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">depends-on</span>=<span class="string">&quot;jedisPoolConfig&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jedisPoolConfig&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.hostname&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;redis.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 创建Redis工具类，封装好Redis的连接以进行相关的操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisUtil&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jedisPool&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;jedisWritePool&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis的key操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisKeys&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Keys&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis的Strings操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisStrings&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Strings&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis的Lists操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisLists&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Lists&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis的Sets操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisSets&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Sets&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- Redis的HashMap操作 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jedisHash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.cache.JedisUtil$Hash&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;jedisUtil&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-2-4JedisUtil工具类"><a href="#11-2-4JedisUtil工具类" class="headerlink" title="11.2.4JedisUtil工具类"></a>11.2.4JedisUtil工具类</h2><p><strong>JedisUtil工具类：</strong>封装好Redis的连接以进行相关的操作</p>
<p>工具类中包含以下几个内部类：</p>
<p>1、Keys：主要封装了对redis中的键值对中的键操作的方法，比如：清空所有的Key，删除keys对应的记录等，方法的实现主要还是通过jedis对象中的方法对redis中的内容进行操作</p>
<p>2、Strings：主要封装了一些根据string操作对象的值查询value，添加记录等的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 缓存生存时间</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expire = <span class="number">60000</span>;</span><br><span class="line">	<span class="comment">/** 操作Key的方法 */</span></span><br><span class="line">	<span class="keyword">public</span> Keys KEYS;</span><br><span class="line">	<span class="comment">/** 对存储结构为String类型的操作 */</span></span><br><span class="line">	<span class="keyword">public</span> Strings STRINGS;</span><br><span class="line">	<span class="comment">/** 对存储结构为List类型的操作 */</span></span><br><span class="line">	<span class="keyword">public</span> Lists LISTS;</span><br><span class="line">	<span class="comment">/** 对存储结构为Set类型的操作 */</span></span><br><span class="line">	<span class="keyword">public</span> Sets SETS;</span><br><span class="line">	<span class="comment">/** 对存储结构为HashMap类型的操作 */</span></span><br><span class="line">	<span class="keyword">public</span> Hash HASH;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Redis连接池对象 */</span></span><br><span class="line">	<span class="keyword">private</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取redis连接池</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> JedisPool <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jedisPool;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置redis连接池</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJedisPool</span><span class="params">(JedisPoolWriper jedisPoolWriper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.jedisPool = jedisPoolWriper.getJedisPool();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从jedis连接池中获取获取jedis对象</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置过期时间</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> seconds</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Jedis jedis = getJedis();</span><br><span class="line">		jedis.expire(key, seconds);</span><br><span class="line">		jedis.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置默认过期时间</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		expire(key, expire);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *******************************************Keys*******************************************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 清空所有key</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">flushAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String stata = jedis.flushAll();</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> stata;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 更改key</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">rename</span><span class="params">(String oldkey, String newkey)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> rename(SafeEncoder.encode(oldkey), SafeEncoder.encode(newkey));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 更改key,仅当新key不存在时才执行</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">renamenx</span><span class="params">(String oldkey, String newkey)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> status = jedis.renamenx(oldkey, newkey);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 更改key</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String oldkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">rename</span><span class="params">(<span class="keyword">byte</span>[] oldkey, <span class="keyword">byte</span>[] newkey)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String status = jedis.rename(oldkey, newkey);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 设置key的过期时间，以秒为单位</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> 时间     ,已秒为单位</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expired</span><span class="params">(String key, <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.expire(key, seconds);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 设置key的过期时间,它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00，格里高利历）的偏移量。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> 时间     ,已秒为单位</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAt</span><span class="params">(String key, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.expireAt(key, timestamp);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 查询key的过期时间</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 以秒为单位的时间表示</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">ttl</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = sjedis.ttl(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 取消对key过期时间的设置</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 影响的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">persist</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.persist(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 删除keys对应的记录,可以是多个key</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 删除的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">del</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.del(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 删除keys对应的记录,可以是多个key</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 删除的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">del</span><span class="params">(<span class="keyword">byte</span>[]... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.del(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 判断key是否存在</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">boolean</span> exis = sjedis.exists(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> exis;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 对List,Set,SortSet进行排序,如果集合数据较大应避免使用这个方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List&lt;String&gt; 集合的全部记录</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;String&gt; list = sjedis.sort(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 对List,Set,SortSet进行排序或limit</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String        key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> SortingParams parame 定义排序类型或limit的起止位置.</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List&lt;String&gt; 全部或部分记录</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(String key, SortingParams parame)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;String&gt; list = sjedis.sort(key, parame);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回指定key存储的类型</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String string|list|set|zset|hash</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">type</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			String type = sjedis.type(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> type;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 查找所有匹配给定的模式的键</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key的表达式,*表示多个，？表示一个</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">keys</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = jedis.keys(pattern);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *******************************************Strings*******************************************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strings</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 根据key获取记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			String value = sjedis.get(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 根据key获取记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">byte</span>[] get(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">byte</span>[] value = sjedis.get(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> set(SafeEncoder.encode(key), SafeEncoder.encode(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> set(SafeEncoder.encode(key), value);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加记录,如果记录已存在将覆盖原有的value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String status = jedis.set(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加有过期时间的记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    seconds 过期时间，以秒为单位</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String 操作状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">setEx</span><span class="params">(String key, <span class="keyword">int</span> seconds, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String str = jedis.setex(key, seconds, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加有过期时间的记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    seconds 过期时间，以秒为单位</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String 操作状态</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">setEx</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> seconds, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String str = jedis.setex(key, seconds, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加一条记录，仅当给定的key不存在时才插入</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long 状态码，1插入成功且key不存在，0未插入，key存在</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setnx</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> str = jedis.setnx(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 从指定位置开始插入数据，插入的数据会覆盖指定位置以后的数据&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 例:String str1=&quot;123456789&quot;;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 对str1操作后setRange(key,4,0000)，str1=&quot;123400009&quot;;</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   offset</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long value的长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRange</span><span class="params">(String key, <span class="keyword">long</span> offset, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = jedis.setrange(key, offset, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 在指定的key中追加value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long 追加后value的长度</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">append</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = jedis.append(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将key对应的value减去指定的值，只有value可以转为数字时该方法才可用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   number 要减去的值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long 减指定值后的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decrBy</span><span class="params">(String key, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = jedis.decrBy(key, number);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * &lt;b&gt;可以作为获取唯一id的方法&lt;/b&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 将key对应的value加上指定的值，只有value可以转为数字时该方法才可用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   number 要减去的值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long 相加后的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incrBy</span><span class="params">(String key, <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = jedis.incrBy(key, number);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 对指定key对应的value进行截取</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   startOffset 开始位置(包含)</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   endOffset 结束位置(包含)</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String 截取的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getrange</span><span class="params">(String key, <span class="keyword">long</span> startOffset, <span class="keyword">long</span> endOffset)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			String value = sjedis.getrange(key, startOffset, endOffset);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取并设置指定key对应的value&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 如果key存在返回之前的value,否则返回null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String 原始value或null</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getSet</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String str = jedis.getSet(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 批量获取记录,如果指定的key不存在返回List的对应位置将是null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List&lt;String&gt; 值得集合</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">mget</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			List&lt;String&gt; str = jedis.mget(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 批量存储记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String keysvalues 例:keysvalues=&quot;key1&quot;,&quot;value1&quot;,&quot;key2&quot;,&quot;value2&quot;;</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> String 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">mset</span><span class="params">(String... keysvalues)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String str = jedis.mset(keysvalues);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取key对应的值的长度</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> value值得长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">strlen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = jedis.strlen(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *******************************************Sets*******************************************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向Set添加一条记录，如果member已存在返回0,否则返回1</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String member</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 操作码,0或1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sadd</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.sadd(key, member);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sadd</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] member)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.sadd(key, member);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取给定key中元素个数</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 元素个数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">scard</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = sjedis.scard(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回从第一组和所有的给定集合之间的差异的成员</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 差异的成员集合</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sdiff</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = jedis.sdiff(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这个命令等于sdiff,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey 新结果集的key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys 比较的集合</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 新集合中的记录数</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sdiffstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.sdiffstore(newkey, keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回给定集合交集的成员,如果其中一个集合为不存在或为空，则返回空Set</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 交集成员的集合</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sinter</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = jedis.sinter(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这个命令等于sinter,但返回的不是结果集,而是将结果集存储在新的集合中，如果目标已存在，则覆盖。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey 新结果集的key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys 比较的集合</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 新集合中的记录数</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sinterstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.sinterstore(newkey, keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 确定一个给定的值是否存在</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String member 要判断的值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 存在返回1，不存在返回0</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sismember</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">boolean</span> s = sjedis.sismember(key, member);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回集合中的所有成员</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 成员集合</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">smembers</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = sjedis.smembers(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Set&lt;<span class="keyword">byte</span>[]&gt; smembers(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			Set&lt;<span class="keyword">byte</span>[]&gt; set = sjedis.smembers(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将成员从源集合移出放入目标集合 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 如果源集合不存在或不包哈指定成员，不进行任何操作，返回0&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * 否则该成员从源集合上删除，并添加到目标集合，如果目标集合中成员已存在，则只在源集合进行删除</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String srckey 源集合</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String dstkey 目标集合</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String member 源集合中的成员</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码，1成功，0失败</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">smove</span><span class="params">(String srckey, String dstkey, String member)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.smove(srckey, dstkey, member);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 从集合中删除成员</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 被删除的成员</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">spop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String s = jedis.spop(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 从集合中删除指定成员</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String member 要删除的成员</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码，成功返回1，成员不存在返回0</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">srem</span><span class="params">(String key, String member)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.srem(key, member);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并多个集合并返回合并后的结果，合并后的结果集合并不保存&lt;br/&gt;</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 合并后的结果集合</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@see</span> sunionstore</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">sunion</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = jedis.sunion(keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 合并多个集合并将合并后的结果集保存在指定的新集合中，如果新集合已经存在则覆盖</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String newkey 新集合的key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... keys 要合并的集合</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sunionstore</span><span class="params">(String newkey, String... keys)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.sunionstore(newkey, keys);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *******************************************Hash*******************************************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 从hash中删除指定的存储</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码，1成功，0失败</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hdel</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.hdel(key, fieid);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hdel</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.del(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 测试hash中指定的存储是否存在</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 1存在，0不存在</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hexists</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">boolean</span> s = sjedis.hexists(key, fieid);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回hash中指定存储位置的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid 存储的名字</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 存储对应的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">hget</span><span class="params">(String key, String fieid)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			String s = sjedis.hget(key, fieid);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">byte</span>[] hget(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] fieid) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">byte</span>[] s = sjedis.hget(key, fieid);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 以Map的形式返回hash中的存储和值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> Map&lt;Strinig,String&gt;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">hgetAll</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			Map&lt;String, String&gt; map = sjedis.hgetAll(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> map;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加一个对应关系</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码 1成功，0失败，fieid已存在将更新，也返回0</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hset</span><span class="params">(String key, String fieid, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.hset(key, fieid, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hset</span><span class="params">(String key, String fieid, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.hset(key.getBytes(), fieid.getBytes(), value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加对应关系，只有在fieid不存在时才执行</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码 1成功，0失败fieid已存</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hsetnx</span><span class="params">(String key, String fieid, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.hsetnx(key, fieid, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取hash中value的集合</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List&lt;String&gt;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">hvals</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;String&gt; list = sjedis.hvals(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 在指定的存储位置加上指定的数字，存储位置的值必须可转为数字类型</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String fieid 存储位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String long value 要增加的值,可以是负数</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 增加指定数字后，存储位置的值</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hincrby</span><span class="params">(String key, String fieid, <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> s = jedis.hincrBy(key, fieid, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 返回指定hash中的所有存储名字,类似Map中的keySet方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> Set&lt;String&gt; 存储名称的集合</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">hkeys</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			Set&lt;String&gt; set = sjedis.hkeys(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> set;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取hash中存储的个数，类似Map中size方法</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> long 存储的个数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hlen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> len = sjedis.hlen(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 根据多个key，获取对应的value，返回List,如果指定的key不存在,List对应位置为null</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String ... fieids 存储位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List&lt;String&gt;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">hmget</span><span class="params">(String key, String... fieids)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;String&gt; list = sjedis.hmget(key, fieids);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> List&lt;<span class="keyword">byte</span>[]&gt; hmget(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[]... fieids) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;<span class="keyword">byte</span>[]&gt; list = sjedis.hmget(key, fieids);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加对应关系，如果对应关系已存在，则覆盖</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> Strin key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> Map   &lt;String,String&gt; 对应关系</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态，成功返回OK</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">hmset</span><span class="params">(String key, Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String s = jedis.hmset(key, map);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加对应关系，如果对应关系已存在，则覆盖</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> Strin key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> Map   &lt;String,String&gt; 对应关系</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态，成功返回OK</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">hmset</span><span class="params">(<span class="keyword">byte</span>[] key, Map&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; map)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String s = jedis.hmset(key, map);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *******************************************Lists*******************************************//</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lists</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * List长度</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">llen</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> llen(SafeEncoder.encode(key));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * List长度</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 长度</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">llen</span><span class="params">(<span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = sjedis.llen(key);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 覆盖操作,将覆盖List中指定位置的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] value 值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">lset</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> index, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String status = jedis.lset(key, index, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 覆盖操作,将覆盖List中指定位置的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value 值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">lset</span><span class="params">(String key, <span class="keyword">int</span> index, String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> lset(SafeEncoder.encode(key), index, SafeEncoder.encode(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 在value的相对位置插入记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> LIST_POSITION 前面插入或后面插入</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String        pivot 相对位置的内容</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String        value 插入的内容</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">linsert</span><span class="params">(String key, LIST_POSITION where, String pivot, String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> linsert(SafeEncoder.encode(key), where, SafeEncoder.encode(pivot), SafeEncoder.encode(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 在指定位置插入记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String        key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> LIST_POSITION 前面插入或后面插入</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[]        pivot 相对位置的内容</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[]        value 插入的内容</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">linsert</span><span class="params">(<span class="keyword">byte</span>[] key, LIST_POSITION where, <span class="keyword">byte</span>[] pivot, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.linsert(key, where, pivot, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取List中指定位置的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">lindex</span><span class="params">(String key, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> SafeEncoder.encode(lindex(SafeEncoder.encode(key), index));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取List中指定位置的值</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    index 位置</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">		 **/</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">byte</span>[] lindex(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> index) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			<span class="keyword">byte</span>[] value = sjedis.lindex(key, index);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将List中的第一条记录移出List</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">lpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> SafeEncoder.encode(lpop(SafeEncoder.encode(key)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将List中的第一条记录移出List</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">byte</span>[] lpop(<span class="keyword">byte</span>[] key) &#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">byte</span>[] value = jedis.lpop(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 将List中最后第一条记录移出List</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 移出的记录</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">rpop</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String value = jedis.rpop(key);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向List尾部追加记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lpush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> lpush(SafeEncoder.encode(key), SafeEncoder.encode(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向List头部追加记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">rpush</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.rpush(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向List头部追加记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">rpush</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.rpush(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 向List中追加记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] value</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 记录总数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lpush</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.lpush(key, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取指定范围的记录，可以做为分页使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   start</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> long   end</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">lrange</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;String&gt; list = sjedis.lrange(key, start, end);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 获取指定范围的记录，可以做为分页使用</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    start</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    end 如果为负数，则尾部开始计算</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> List</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">public</span> List&lt;<span class="keyword">byte</span>[]&gt; lrange(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">			<span class="comment">// ShardedJedis sjedis = getShardedJedis();</span></span><br><span class="line">			Jedis sjedis = getJedis();</span><br><span class="line">			List&lt;<span class="keyword">byte</span>[]&gt; list = sjedis.lrange(key, start, end);</span><br><span class="line">			sjedis.close();</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 删除List中c条记录，被删除的记录值为value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] value 要匹配的值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 删除后的List中的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lrem</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> c, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			<span class="keyword">long</span> count = jedis.lrem(key, c, value);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 删除List中c条记录，被删除的记录值为value</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    c 要删除的数量，如果为负数则从List的尾部检查并删除符合的记录</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String value 要匹配的值</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 删除后的List中的记录数</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lrem</span><span class="params">(String key, <span class="keyword">int</span> c, String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> lrem(SafeEncoder.encode(key), c, SafeEncoder.encode(value));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 算是删除吧，只保留start与end之间的记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> byte[] key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    start 记录的开始位置(0表示第一条记录)</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推）</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 执行状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">ltrim</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">			Jedis jedis = getJedis();</span><br><span class="line">			String str = jedis.ltrim(key, start, end);</span><br><span class="line">			jedis.close();</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 算是删除吧，只保留start与end之间的记录</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> String key</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    start 记录的开始位置(0表示第一条记录)</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> int    end 记录的结束位置（如果为-1则表示最后一个，-2，-3以此类推）</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@return</span> 执行状态码</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">ltrim</span><span class="params">(String key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> ltrim(SafeEncoder.encode(key), start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-3引入Redis缓存技术编码实现"><a href="#11-3引入Redis缓存技术编码实现" class="headerlink" title="11.3引入Redis缓存技术编码实现"></a>11.3引入Redis缓存技术编码实现</h1><p><strong>在对Redis配置完成之后，需要对需要存入Redis缓存中的数据对应的查询、插入、修改的代码逻辑进行更改</strong></p>
<p>这里我们要将不经常变更的数据：<strong>区域信息、店铺类别、头条信息</strong>等存入Redis缓存中</p>
<p>这里以<strong>AreaServiceImpl</strong>中<strong>getAreaList</strong>方法的逻辑举例：</p>
<ul>
<li>注入JedisUtil.Keys对象：用于对Redis中的键进行操作</li>
<li>注入JedisUtil.Strings对象：用于对Strings类型的对象进行操作（主要是使用其中的方法）</li>
<li>创建redis的key= AREALISTKEY</li>
<li>查询key是否存在，当不存在时，从数据库中取出数据，并且通过jedisStrings.set(key, jsonString)将数据存入到Redis中</li>
<li>当数据存在时，直接从Redis取出数据，因为取出的数据是Strings类型，还要将其转换为Area对象的数组</li>
</ul>
<p>对于其它方法，比如修改店铺的Area时，要将Redis对应的键删除或者修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaServiceImpl</span> <span class="keyword">implements</span> <span class="title">AreaService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AreaDao areaDao;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JedisUtil.Keys jedisKeys;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JedisUtil.Strings jedisStrings;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AreaServiceImpl.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Area&gt; <span class="title">getAreaList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义redis的key</span></span><br><span class="line">		String key = AREALISTKEY;</span><br><span class="line">		<span class="comment">// 定义接收对象</span></span><br><span class="line">		List&lt;Area&gt; areaList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 定义jackson数据转换操作类</span></span><br><span class="line">		ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		<span class="comment">// 判断key是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (!jedisKeys.exists(key)) &#123;</span><br><span class="line">			<span class="comment">// 若不存在，则从数据库里面取出相应数据</span></span><br><span class="line">			areaList = areaDao.queryArea();</span><br><span class="line">			<span class="comment">// 将相关的实体类集合转换成string,存入redis里面对应的key中</span></span><br><span class="line">			String jsonString;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				jsonString = mapper.writeValueAsString(areaList);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				logger.error(e.getMessage());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			jedisStrings.set(key, jsonString);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 若存在，则直接从redis里面取出相应数据</span></span><br><span class="line">			String jsonString = jedisStrings.get(key);</span><br><span class="line">			<span class="comment">// 指定要将string转换成的集合类型</span></span><br><span class="line">			JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, Area.class);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 将相关key对应的value里的的string转换成对象的实体类集合</span></span><br><span class="line">				areaList = mapper.readValue(jsonString, javaType);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (JsonParseException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				logger.error(e.getMessage());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (JsonMappingException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				logger.error(e.getMessage());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				logger.error(e.getMessage());</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> areaList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AreaExecution <span class="title">addArea</span><span class="params">(Area area)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 空值判断，主要是判断areaName不为空</span></span><br><span class="line">		<span class="keyword">if</span> (area.getAreaName() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(area.getAreaName())) &#123;</span><br><span class="line">			<span class="comment">// 设置默认值</span></span><br><span class="line">			area.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">			area.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> effectedNum = areaDao.insertArea(area);</span><br><span class="line">				<span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					deleteRedis4Area();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.SUCCESS, area);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.INNER_ERROR);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(<span class="string">&quot;添加区域信息失败:&quot;</span> + e.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.EMPTY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AreaExecution <span class="title">modifyArea</span><span class="params">(Area area)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 空值判断，主要是areaId不为空</span></span><br><span class="line">		<span class="keyword">if</span> (area.getAreaId() != <span class="keyword">null</span> &amp;&amp; area.getAreaId() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 设置默认值</span></span><br><span class="line">			area.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 更新区域信息</span></span><br><span class="line">				<span class="keyword">int</span> effectedNum = areaDao.updateArea(area);</span><br><span class="line">				<span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					deleteRedis4Area();</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.SUCCESS, area);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.INNER_ERROR);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AreaOperationException(<span class="string">&quot;更新区域信息失败:&quot;</span> + e.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> AreaExecution(AreaStateEnum.EMPTY);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 移除跟实体类相关的redis key-value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteRedis4Area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String key = AREALISTKEY;</span><br><span class="line">		<span class="comment">// 若redis存在对应的key,则将key清除</span></span><br><span class="line">		<span class="keyword">if</span> (jedisKeys.exists(key)) &#123;</span><br><span class="line">			jedisKeys.del(key);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-4添加平台帐号体系"><a href="#11-4添加平台帐号体系" class="headerlink" title="11.4添加平台帐号体系"></a>11.4添加平台帐号体系</h1><h2 id="11-4-1添加平台帐号体系Dao层"><a href="#11-4-1添加平台帐号体系Dao层" class="headerlink" title="11.4.1添加平台帐号体系Dao层"></a>11.4.1添加平台帐号体系Dao层</h2><p>创建LocalAuthDao</p>
<p><strong>方法：</strong></p>
<ul>
<li>通过账号密码查询用户的信息：登录使用</li>
<li>通过userId查询用户的信息</li>
<li>添加本地账号</li>
<li>通过userId，修改账号密码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocalAuthDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过帐号和密码查询对应信息，登录用</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuth <span class="title">queryLocalByUserNameAndPwd</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过用户Id查询对应localauth</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuth <span class="title">queryLocalByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="keyword">long</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 添加平台帐号</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">insertLocalAuth</span><span class="params">(LocalAuth localAuth)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过userId,username,password更改密码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">updateLocalAuth</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;username&quot;)</span> String username,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Param(&quot;password&quot;)</span> String password, <span class="meta">@Param(&quot;newPassword&quot;)</span> String newPassword,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Param(&quot;lastEditTime&quot;)</span> Date lastEditTime)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Mapper中实现LocalAuthDao中的信息：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.imooc.o2o.dao.LocalAuthDao&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;localAuthResultMap&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">type</span>=<span class="string">&quot;com.imooc.o2o.entity.LocalAuth&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;local_auth_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;localAuthId&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;personInfo&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.PersonInfo&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;profile_img&quot;</span> <span class="attr">property</span>=<span class="string">&quot;profileImg&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userType&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enable_status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enableStatus&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryLocalByUserNameAndPwd&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">resultMap</span>=<span class="string">&quot;localAuthResultMap&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">		l.local_auth_id,</span><br><span class="line">		l.username,</span><br><span class="line">		l.password,</span><br><span class="line">		l.create_time,</span><br><span class="line">		l.last_edit_time,</span><br><span class="line">		p.user_id,</span><br><span class="line">		p.name,</span><br><span class="line">		p.gender,</span><br><span class="line">		p.email,</span><br><span class="line">		p.profile_img,</span><br><span class="line">		p.user_type,</span><br><span class="line">		p.create_time,</span><br><span class="line">		p.last_edit_time,</span><br><span class="line">		p.enable_status</span><br><span class="line">		FROM</span><br><span class="line">		tb_local_auth l</span><br><span class="line">		LEFT</span><br><span class="line">		JOIN</span><br><span class="line">		tb_person_info</span><br><span class="line">		p ON l.user_id</span><br><span class="line">		=</span><br><span class="line">		p.user_id</span><br><span class="line">		WHERE</span><br><span class="line">		l.username =</span><br><span class="line">		#&#123;username&#125;</span><br><span class="line">		AND</span><br><span class="line">		l.password = #&#123;password&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryLocalByUserId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;localAuthResultMap&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">		l.local_auth_id,</span><br><span class="line">		l.username,</span><br><span class="line">		l.password,</span><br><span class="line">		l.create_time,</span><br><span class="line">		l.last_edit_time,</span><br><span class="line">		p.user_id,</span><br><span class="line">		p.name,</span><br><span class="line">		p.gender,</span><br><span class="line">		p.email,</span><br><span class="line">		p.profile_img,</span><br><span class="line">		p.user_type,</span><br><span class="line">		p.create_time,</span><br><span class="line">		p.last_edit_time,</span><br><span class="line">		p.enable_status</span><br><span class="line">		FROM</span><br><span class="line">		tb_local_auth l</span><br><span class="line">		LEFT</span><br><span class="line">		JOIN</span><br><span class="line">		tb_person_info</span><br><span class="line">		p ON l.user_id</span><br><span class="line">		=</span><br><span class="line">		p.user_id</span><br><span class="line">		WHERE</span><br><span class="line">		l.user_id =</span><br><span class="line">		#&#123;userId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertLocalAuth&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">parameterType</span>=<span class="string">&quot;com.imooc.o2o.entity.LocalAuth&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">keyProperty</span>=<span class="string">&quot;localAuthId&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;local_auth_id&quot;</span>&gt;</span></span><br><span class="line">		INSERT</span><br><span class="line">		INTO</span><br><span class="line">		tb_local_auth(username,password,user_id,create_time,last_edit_time)</span><br><span class="line">		VALUES</span><br><span class="line">		(#&#123;username&#125;,#&#123;password&#125;,#&#123;personInfo.userId&#125;,#&#123;createTime&#125;,#&#123;lastEditTime&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateLocalAuth&quot;</span>&gt;</span></span><br><span class="line">		update tb_local_auth</span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;newPassword != null&quot;</span>&gt;</span>password=#&#123;newPassword&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastEditTime != null&quot;</span>&gt;</span>last_edit_time=#&#123;lastEditTime&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where user_id=#&#123;userId&#125;</span><br><span class="line">		AND username=#&#123;username&#125;</span><br><span class="line">		AND</span><br><span class="line">		password=#&#123;password&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="11-4-2添加平台帐号体系Service层"><a href="#11-4-2添加平台帐号体系Service层" class="headerlink" title="11.4.2添加平台帐号体系Service层"></a>11.4.2添加平台帐号体系Service层</h2><p><strong>创建LocalAuthService接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LocalAuthService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过帐号和密码获取平台帐号信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuth <span class="title">getLocalAuthByUsernameAndPwd</span><span class="params">(String userName, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 通过userId获取平台帐号信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuth <span class="title">getLocalAuthByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 绑定微信，生成平台专属的帐号</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> localAuth</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> RuntimeException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuthExecution <span class="title">bindLocalAuth</span><span class="params">(LocalAuth localAuth)</span> <span class="keyword">throws</span> LocalAuthOperationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 修改平台帐号的登录密码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> localAuthId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> newPassword</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> lastEditTime</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">LocalAuthExecution <span class="title">modifyLocalAuth</span><span class="params">(Long userId, String username, String password, String newPassword)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> LocalAuthOperationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建LocalAuthServiceImpl实现LocalAuthService接口：</strong></p>
<p><strong>bindLocalAuth方法：</strong></p>
<ul>
<li>对传入的用户信息判断，如果该用户绑定过平台账号直接退出，来保证平台账号的唯一性</li>
<li>如果没有绑定过，创建一个平台账号与该用户绑定</li>
<li>其中对平台账号的密码要进行加密，也就是创建完成之后，数据库中的密码为密文</li>
</ul>
<p><strong>getLocalAuthByUsernameAndPwd方法：</strong></p>
<ul>
<li>当用户登录平台时，要对密码进行加密，去与数据库中的进行比对来实现登录</li>
</ul>
<p><strong>modifyLocalAuth方法：</strong></p>
<ul>
<li>对传入的用户信息、账号、密码进行空值判断；</li>
<li>对旧密码进行验证</li>
<li>对新密码进行加密</li>
<li>成功修改用户的密码</li>
</ul>
<p><strong>getLocalAuthByUserId方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title">LocalAuthService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> LocalAuthDao localAuthDao;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalAuth <span class="title">getLocalAuthByUsernameAndPwd</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> localAuthDao.queryLocalByUserNameAndPwd(username, MD5.getMd5(password));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalAuth <span class="title">getLocalAuthByUserId</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> localAuthDao.queryLocalByUserId(userId);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalAuthExecution <span class="title">bindLocalAuth</span><span class="params">(LocalAuth localAuth)</span> <span class="keyword">throws</span> LocalAuthOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// 空值判断，传入的localAuth 帐号密码，用户信息特别是userId不能为空，否则直接返回错误</span></span><br><span class="line">		<span class="keyword">if</span> (localAuth == <span class="keyword">null</span> || localAuth.getPassword() == <span class="keyword">null</span> || localAuth.getUsername() == <span class="keyword">null</span></span><br><span class="line">				|| localAuth.getPersonInfo() == <span class="keyword">null</span> || localAuth.getPersonInfo().getUserId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.NULL_AUTH_INFO);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 查询此用户是否已绑定过平台帐号</span></span><br><span class="line">		LocalAuth tempAuth = localAuthDao.queryLocalByUserId(localAuth.getPersonInfo().getUserId());</span><br><span class="line">		<span class="keyword">if</span> (tempAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果绑定过则直接退出，以保证平台帐号的唯一性</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.ONLY_ONE_ACCOUNT);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 如果之前没有绑定过平台帐号，则创建一个平台帐号与该用户绑定</span></span><br><span class="line">			localAuth.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">			localAuth.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">			<span class="comment">// 对密码进行MD5加密</span></span><br><span class="line">			localAuth.setPassword(MD5.getMd5(localAuth.getPassword()));</span><br><span class="line">			<span class="keyword">int</span> effectedNum = localAuthDao.insertLocalAuth(localAuth);</span><br><span class="line">			<span class="comment">// 判断创建是否成功</span></span><br><span class="line">			<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;帐号绑定失败&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.SUCCESS, localAuth);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;insertLocalAuth error: &quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalAuthExecution <span class="title">modifyLocalAuth</span><span class="params">(Long userId, String userName, String password, String newPassword)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> LocalAuthOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// 非空判断，判断传入的用户Id,帐号,新旧密码是否为空，新旧密码是否相同，若不满足条件则返回错误信息</span></span><br><span class="line">		<span class="keyword">if</span> (userId != <span class="keyword">null</span> &amp;&amp; userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; newPassword != <span class="keyword">null</span></span><br><span class="line">				&amp;&amp; !password.equals(newPassword)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 更新密码，并对新密码进行MD5加密</span></span><br><span class="line">				<span class="keyword">int</span> effectedNum = localAuthDao.updateLocalAuth(userId, userName, MD5.getMd5(password),</span><br><span class="line">						MD5.getMd5(newPassword), <span class="keyword">new</span> Date());</span><br><span class="line">				<span class="comment">// 判断更新是否成功</span></span><br><span class="line">				<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;更新密码失败&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.SUCCESS);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> LocalAuthOperationException(<span class="string">&quot;更新密码失败:&quot;</span> + e.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LocalAuthExecution(LocalAuthStateEnum.NULL_AUTH_INFO);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-4-3添加平台帐号体系Controller层"><a href="#11-4-3添加平台帐号体系Controller层" class="headerlink" title="11.4.3添加平台帐号体系Controller层"></a>11.4.3添加平台帐号体系Controller层</h2><p>主要实现了：</p>
<p><strong>微信登录后，绑定平台本地账号：</strong></p>
<ul>
<li>验证码校验</li>
<li>从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</li>
<li>要求帐号密码以及当前的用户session非空</li>
<li>创建LocalAuth对象并赋值</li>
<li>绑定帐号</li>
</ul>
<p><strong>修改平台本地账号密码：</strong></p>
<ul>
<li>验证码校验</li>
<li>从request中获取账号、密码、新密码以及从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</li>
<li>要求帐号密码以及当前的用户session非空，且新旧密码不相同</li>
<li>查看原先帐号，看看与输入的帐号是否一致，不一致则认为是非法操作</li>
<li>修改平台帐号的用户密码</li>
</ul>
<p><strong>本地账号登录：</strong></p>
<ul>
<li>获取是否需要进行验证码校验的标识符（三次错误就会需要输入验证码）</li>
<li>从request中获取输入的帐号、密码</li>
<li>传入帐号和密码去获取平台帐号信息</li>
<li>同时在session里设置用户信息</li>
</ul>
<p><strong>注销</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;local&quot;, method = &#123; RequestMethod.GET, RequestMethod.POST &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalAuthController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> LocalAuthService localAuthService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/bindlocalauth&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将用户信息与平台帐号绑定</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">bindLocalAuth</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="comment">// 验证码校验</span></span><br><span class="line">		<span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取输入的帐号</span></span><br><span class="line">		String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取输入的密码</span></span><br><span class="line">		String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">		<span class="comment">// 从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</span></span><br><span class="line">		PersonInfo user = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		<span class="comment">// 非空判断，要求帐号密码以及当前的用户session非空</span></span><br><span class="line">		<span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 创建LocalAuth对象并赋值</span></span><br><span class="line">			LocalAuth localAuth = <span class="keyword">new</span> LocalAuth();</span><br><span class="line">			localAuth.setUsername(userName);</span><br><span class="line">			localAuth.setPassword(password);</span><br><span class="line">			localAuth.setPersonInfo(user);</span><br><span class="line">			<span class="comment">// 绑定帐号</span></span><br><span class="line">			LocalAuthExecution le = localAuthService.bindLocalAuth(localAuth);</span><br><span class="line">			<span class="keyword">if</span> (le.getState() == LocalAuthStateEnum.SUCCESS.getState()) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, le.getStateInfo());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名和密码均不能为空&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/changelocalpwd&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 修改密码</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">changeLocalPwd</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="comment">// 验证码校验</span></span><br><span class="line">		<span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取帐号</span></span><br><span class="line">		String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取原密码</span></span><br><span class="line">		String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取新密码</span></span><br><span class="line">		String newPassword = HttpServletRequestUtil.getString(request, <span class="string">&quot;newPassword&quot;</span>);</span><br><span class="line">		<span class="comment">// 从session中获取当前用户信息(用户一旦通过微信登录之后，便能获取到用户的信息)</span></span><br><span class="line">		PersonInfo user = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		<span class="comment">// 非空判断，要求帐号新旧密码以及当前的用户session非空，且新旧密码不相同</span></span><br><span class="line">		<span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span> &amp;&amp; newPassword != <span class="keyword">null</span> &amp;&amp; user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span></span><br><span class="line">				&amp;&amp; !password.equals(newPassword)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 查看原先帐号，看看与输入的帐号是否一致，不一致则认为是非法操作</span></span><br><span class="line">				LocalAuth localAuth = localAuthService.getLocalAuthByUserId(user.getUserId());</span><br><span class="line">				<span class="keyword">if</span> (localAuth == <span class="keyword">null</span> || !localAuth.getUsername().equals(userName)) &#123;</span><br><span class="line">					<span class="comment">// 不一致则直接退出</span></span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">					modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入的帐号非本次登录的帐号&quot;</span>);</span><br><span class="line">					<span class="keyword">return</span> modelMap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 修改平台帐号的用户密码</span></span><br><span class="line">				LocalAuthExecution le = localAuthService.modifyLocalAuth(user.getUserId(), userName, password,</span><br><span class="line">						newPassword);</span><br><span class="line">				<span class="keyword">if</span> (le.getState() == LocalAuthStateEnum.SUCCESS.getState()) &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">					modelMap.put(<span class="string">&quot;errMsg&quot;</span>, le.getStateInfo());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (LocalAuthOperationException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.toString());</span><br><span class="line">				<span class="keyword">return</span> modelMap;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/logincheck&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">logincheck</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="comment">// 获取是否需要进行验证码校验的标识符</span></span><br><span class="line">		<span class="keyword">boolean</span> needVerify = HttpServletRequestUtil.getBoolean(request, <span class="string">&quot;needVerify&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (needVerify &amp;&amp; !CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取输入的帐号</span></span><br><span class="line">		String userName = HttpServletRequestUtil.getString(request, <span class="string">&quot;userName&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取输入的密码</span></span><br><span class="line">		String password = HttpServletRequestUtil.getString(request, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">		<span class="comment">// 非空校验</span></span><br><span class="line">		<span class="keyword">if</span> (userName != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 传入帐号和密码去获取平台帐号信息</span></span><br><span class="line">			LocalAuth localAuth = localAuthService.getLocalAuthByUsernameAndPwd(userName, password);</span><br><span class="line">			<span class="keyword">if</span> (localAuth != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 若能取到帐号信息则登录成功</span></span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">				<span class="comment">// 同时在session里设置用户信息</span></span><br><span class="line">				request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, localAuth.getPersonInfo());</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;用户名和密码均不能为空&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/logout&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当用户点击登出按钮的时候注销session</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">logout</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="comment">// 将用户session置为空</span></span><br><span class="line">		request.getSession().setAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">		modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-5添加拦截器"><a href="#11-5添加拦截器" class="headerlink" title="11.5添加拦截器"></a>11.5添加拦截器</h1><p>店家管理系统中的一些敏感信息不能随意被修改，主要是验证用户是否已经登录了系统、有无对数据操作的权限</p>
<p>利用Spring的 AOP功能对相关功能进行织入验证方法，这样不用对每个方法都写一段权限验证的代码</p>
<h2 id="11-5-1在spring-web-xml中配置拦截器"><a href="#11-5-1在spring-web-xml中配置拦截器" class="headerlink" title="11.5.1在spring-web.xml中配置拦截器"></a>11.5.1在spring-web.xml中配置拦截器</h2><p><strong>两个拦截器：</strong></p>
<p><strong>校验是否已登录了店家管理系统的拦截器</strong> </p>
<ul>
<li>定义拦截的路由：shopadmin下所有的方法（主要是对于店铺和商铺操作的方法）</li>
<li>拦截器具体实现类的bean以及全路径名</li>
</ul>
<p><strong>校验是否对该店铺有操作权限的拦截器（某一个店铺）</strong></p>
<ul>
<li>要对shopadmin下的部分方法进行排除，也就是不拦截，比如：获取店铺列表、注册相关（因为拦截器的具体实现是要获得用户可操作的店铺列表，和需要校验的session中的店铺进行比对的）</li>
</ul>
<p>不拦截的方法都是session中还没有店铺或者要将某个店铺加入到session中的方法：比如getshopmanagementinfo，点击店铺列表中的某一个店铺来获取店铺信息时才将该店铺添加进session中，所以不拦截</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验是否已登录了店家管理系统的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 校验是否对该店铺有操作权限的拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- shoplist page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shoplist&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshoplist&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- shopregister page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopinitinfo&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/registershop&quot;</span> /&gt;</span></span><br><span class="line">        mvc:exclude-mapping</span><br><span class="line">                             path=&quot;/shopadmin/shopoperation&quot; /&gt;</span><br><span class="line">       <span class="comment">&lt;!-- shopmanage page --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopmanagement&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopmanagementinfo&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopPermissionInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopPermissionInterceptor&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>ShopLoginInterceptor拦截器的具体实现：</strong></p>
<ul>
<li>从session中取出用户信息来</li>
<li>若用户信息不为空则将session里的用户信息转换成PersonInfo实体类对象</li>
<li>做空值判断，确保userId不为空并且该帐号的可用状态为1，并且用户类型为店家</li>
<li>若通过验证则返回true,拦截器返回true之后，用户接下来的操作得以正常执行</li>
<li>若不满足登录验证，则直接跳转到帐号登录页面</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 店家管理系统登录验证拦截器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wangjin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopLoginInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要做事前拦截，即用户操作发生前，改写preHandle里的逻辑，进行拦截</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 从session中取出用户信息来</span></span><br><span class="line">		Object userObj = request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (userObj != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 若用户信息不为空则将session里的用户信息转换成PersonInfo实体类对象</span></span><br><span class="line">			PersonInfo user = (PersonInfo) userObj;</span><br><span class="line">			<span class="comment">// 做空值判断，确保userId不为空并且该帐号的可用状态为1，并且用户类型为店家</span></span><br><span class="line">			<span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; user.getUserId() != <span class="keyword">null</span> &amp;&amp; user.getUserId() &gt; <span class="number">0</span> &amp;&amp; user.getEnableStatus() == <span class="number">1</span>)</span><br><span class="line">				<span class="comment">// 若通过验证则返回true,拦截器返回true之后，用户接下来的操作得以正常执行</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若不满足登录验证，则直接跳转到帐号登录页面</span></span><br><span class="line">		PrintWriter out = response.getWriter();</span><br><span class="line">		out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">		out.println(<span class="string">&quot;&lt;script&gt;&quot;</span>);</span><br><span class="line">		out.println(<span class="string">&quot;window.open (&#x27;&quot;</span> + request.getContextPath() + <span class="string">&quot;/local/login?usertype=2&#x27;,&#x27;_self&#x27;)&quot;</span>);</span><br><span class="line">		out.println(<span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">		out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ShopPermissionInterceptor拦截器的具体实现：</strong></p>
<ul>
<li>从session中获取当前选择的店铺</li>
<li>从session中获取当前用户可操作的店铺列表</li>
<li>遍历可操作的店铺列表</li>
<li>如果当前店铺在可操作的列表里则返回true，进行接下来的用户操作</li>
<li>若不满足拦截器的验证则返回false,终止用户操作的执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopPermissionInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要做事前拦截，即用户操作发生前，改写preHandle里的逻辑，进行用户操作权限的拦截</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> xiangze</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 从session中获取当前选择的店铺</span></span><br><span class="line">		Shop currentShop = (Shop) request.getSession().getAttribute(<span class="string">&quot;currentShop&quot;</span>);</span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">		<span class="comment">// 从session中获取当前用户可操作的店铺列表</span></span><br><span class="line">		List&lt;Shop&gt; shopList = (List&lt;Shop&gt;) request.getSession().getAttribute(<span class="string">&quot;shopList&quot;</span>);</span><br><span class="line">		<span class="comment">// 非空判断</span></span><br><span class="line">		<span class="keyword">if</span> (currentShop != <span class="keyword">null</span> &amp;&amp; shopList != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 遍历可操作的店铺列表</span></span><br><span class="line">			<span class="keyword">for</span> (Shop shop : shopList) &#123;</span><br><span class="line">				<span class="comment">// 如果当前店铺在可操作的列表里则返回true，进行接下来的用户操作</span></span><br><span class="line">				<span class="keyword">if</span> (shop.getShopId() == currentShop.getShopId()) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 若不满足拦截器的验证则返回false,终止用户操作的执行</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-阿里云远程部署及远程微信开发调试</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1阿里云初始化与执行环境安装"><a href="#1-1阿里云初始化与执行环境安装" class="headerlink" title="1.1阿里云初始化与执行环境安装"></a>1.1阿里云初始化与执行环境安装</h1><h2 id="1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）"><a href="#1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）" class="headerlink" title="1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）"></a>1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）</h2><ol>
<li>申请阿里云服务器</li>
<li>搭建出程序的执行环境</li>
<li>在服务器上发布并运行自己的web project</li>
<li>域名解析</li>
<li>微信测试号的申请与连接以获取微信用户信息</li>
</ol>
<h3 id="1-1-1-1申请阿里云服务器"><a href="#1-1-1-1申请阿里云服务器" class="headerlink" title="1.1.1.1申请阿里云服务器"></a><strong>1.1.1.1申请阿里云服务器</strong></h3><p> （1）PC访问阿里云<a href="https://www.aliyun.com/%EF%BC%8C%E7%94%B3%E8%AF%B7%E9%98%BF%E9%87%8C%E4%BA%91%E5%B8%90%E5%8F%B7%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%82%A8%E7%9A%84%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E7%99%BB%E5%BD%95%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E5%B7%B2%E7%BB%8F%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E6%9B%B4%E6%96%B9%E4%BE%BF%EF%BC%89%E5%B9%B6%E7%99%BB%E5%BD%95">https://www.aliyun.com/，申请阿里云帐号（可以用您的支付宝帐号登录，因为支付宝帐号已经进行了实名认证，使用起来更方便）并登录</a><br> （2）找到云服务器ECS购买页面（页面展现随时会变，当前为全部导航-&gt;产品-&gt;弹性计算-&gt;云服务器ECS-&gt;选择自己需要的型号(我选择的是入门级)），购买云服务器，这里主要有三种方式：9块9的学生服务器（大家如果不是学生的话可以用还在读大学的小伙伴的学生证来薅羊毛，购买）、包年包月的服务器（不管你怎么使用，按年按月收费）还有按量付费的服务器（按小时计费，不用可以随时注销掉）<br><img src="http://img1.sycdn.imooc.com/59da2e00000182cc24921486.png" alt="图片描述"><br> 操作系统记得选择centos,这里我用的是最新的7.3版本<br><img src="http://img1.sycdn.imooc.com/59da2e4e0001282423901122.png" alt="图片描述"><br> 上半部分的安全设置里面需要填写上root的登录密码，以后咱们需要用这个root帐号来远程登录服务器去做部署，下半部分主要显示的是您选择的阿里云清单<br><img src="http://img1.sycdn.imooc.com/59da2e7d0001b61723841066.png" alt="图片描述"><br> 开通成功后，服务器会启动并运行，同时会自动分配一个公网IP，咱们外网就可以通过这个公网IP访问服务器，同时也可以将域名解析到这个服务器中。<br><img src="http://img1.sycdn.imooc.com/59da2ea10001283b25420984.png" alt="图片描述"><br> 这里翔仔的公网IP为47.104.1.235</p>
<h3 id="1-1-1-2搭建程序的执行环境"><a href="#1-1-1-2搭建程序的执行环境" class="headerlink" title="1.1.1.2搭建程序的执行环境"></a><strong>1.1.1.2搭建程序的执行环境</strong></h3><p> 搭建程序的执行环境，咱们先列一下常用的执行环境清单：<br> （1）    JDK(这里选择的是JDK1.8)<br> 下载地址为<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br> 选择的是jdk-8u144-linux-x64.rpm<br> （2）    Tomcat 8<br> 下载地址为<br><a href="http://tomcat.apache.org/download-80.cgi#8.0.46">http://tomcat.apache.org/download-80.cgi#8.0.46</a><br> 选择的是apache-tomcat-8.0.46.tar.gz<br> （3）    Mysql(这里选择的是Mysql5.7)repo源，后通过centos自带的yum安装<br> 下载的地址为<br><a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a><br> 这里选择mysql57-community-release-el7-11.noarch.rpm<br> （4）    Redis(可选，最好预先安装上，这里选择的版本为4.0.2)<br> 下载地址为<br><a href="https://redis.io/download">https://redis.io/download</a><br> 这里选择redis-4.0.2.tar.gz<br> 将上面的软件都下载到本地，并上传到服务器(如果您的系统为MAC或LINUX，直接使用SCP命令行上传，具体指令可以查询网上，如果您的系统为WIN，推荐使用filezilla可视化上传工具上传)，或者您也可以直接登录服务器，wget+ftp地址直接下载这些软件；同时需要大家注意的是，我们在服务器上部署了数据库之后，需要往数据库里面去补充数据，我们的线上数据访问的是线上的数据库而非本地的数据库。图片包也需要上传到服务器并通过配置server.xml确保能读取到这些图片（前提是docBase配置上的路径已经在服务器上创建）<br><img src="http://img1.sycdn.imooc.com/59da2edf0001118319361120.png" alt="图片描述"><br> 可以在阿里云控制台进入终端<br><img src="http://img1.sycdn.imooc.com/59da2f3c0001925208650121.png" alt="图片描述"><br> 在服务器的终端，正确的情况下就能看到这些软件了。<br><img src="http://img1.sycdn.imooc.com/59da2f5600011a9419040246.png" alt="图片描述"><br> 接下来开始安装这些软件：</p>
<p><strong>安装JDK</strong><br> Java程序需要运行在JRE里边，因此咱们需要安装JDK，在软件路径里执行<br> //添加可执行权限<br> chmod +x jdk-8u144-linux-x64.rpm<br> //安装RPM软件包<br> rpm -ivh jdk-8u144-linux-x64.rpm<br> //查看<a href="https://coding.imooc.com/?c=java">java</a>的版本信息，若出现版本信息则成功<br> <a href="https://coding.imooc.com/?c=java">java</a> –version<br><img src="http://img1.sycdn.imooc.com/59da2f6c0001f46a19061000.png" alt="图片描述"></p>
<p><strong>安装Mysql</strong><br> 安装用来配置mysql的yum源的rpm包<br> rpm -Uvh mysql57-community-release-el7-11.noarch.rpm<br> 安装Mysql<br> yum install mysql-community-server<br><img src="http://img1.sycdn.imooc.com/59da2fdf0001c0d408650502.png" alt="图片描述"><br> 开启mysql服务<br> service mysqld start<br><img src="http://img1.sycdn.imooc.com/59da2ffa0001edd619340382.png" alt="图片描述"><br> mysql安装成功后创建的超级用户’root’@‘localhost’的密码会被存储在/var/log/mysqld.log，可以使用如下命令查看密码<br> grep ‘temporary password’ /var/log/mysqld.log<br><img src="http://img1.sycdn.imooc.com/59da301d0001785925080182.png" alt="图片描述"><br> 使用mysql生成的’root’@‘localhost’用户和密码登录数据库，并修改 其密码，具体命令<br> mysql -uroot -p<br> ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘Xiangze230!’;<br><img src="http://img1.sycdn.imooc.com/59da30390001bba520861422.png" alt="图片描述"><br> 开启远程连接<br> 通过阿里云控制台开放3306端口<br> 在阿里云控制台咱们的实例页面下面选择安全组-&gt;配置规则<br><img src="http://img1.sycdn.imooc.com/59da30620001aaff25221452.png" alt="图片描述"><br> 进入到规则配置页面之后，咱们可以看到目前只有22端口和3389端口支持远程访问，咱们还需要额外开通80端口（微信公众号用），3306端口(mysql)以及6379端口(redis)<br><img src="http://img1.sycdn.imooc.com/59da30760001f73125541440.png" alt="图片描述"><br> 配置一个支持远程登录的帐号，这里配置一个work帐号<br> mysql -u root -p<br> use mysql;<br> grant SELECT,UPDATE,INSERT,DELETE on <em>.</em> to ‘work’@’%’ identified by ‘Xiangze230!’;//创建work帐号并授权，同时设置密码<br> flush privileges;//生效配置<br> 之后便能在我们本地通过调用mysql指令远程登录阿里云服务器上的mysql server中，<br> mysql -uwork -P3306 -h47.104.1.235 –p //本机远程登录mysql指令<br><img src="http://img1.sycdn.imooc.com/59da309400012e1f19880836.png" alt="图片描述"></p>
<p>安装redis<br> redis安装真的特别简单，首先先解压redis安装包<br> tar -zxvf redis-4.0.2.tar.gz<br> 设置redis以支持远程登录<br> vi redis-4.0.2/redis.conf<br> 将bind 127.0.0.1这句话用井号注释掉，这样就能支持远程连接了<br><img src="http://img1.sycdn.imooc.com/59da30d50001a68521601362.png" alt="图片描述"><br> <strong>此外，还需要给redis.conf添加配置以支持redis作为守护进程一直跑在后台</strong><br> 需要加入『daemonize yes』<br><img src="http://img1.sycdn.imooc.com/59da313000013ead08650187.png" alt="图片描述"><br> 安装redis<br> 去到解压后的目录里<br> cd redis-4.0.2<br> make  //安装redis<br> 启动redis服务<br> src/redis-server redis.conf<br><img src="http://img1.sycdn.imooc.com/59da314a0001d36125400270.png" alt="图片描述"><br> redis连接测试<br> 通过redis-cli连接到redis服务器<br> src/redis-cli<br> 当输入ping 得到pong的回应之后，证明redis配置已经完成<br><img src="http://img1.sycdn.imooc.com/59da316b0001170217480234.png" alt="图片描述"><br> 4．安装tomcat 8<br> tomcat 8的安装更为简单<br> 解压tomcat压缩包<br> tar -zxvf apache-tomcat-8.0.46.tar.gz<br> 启动tomcat<br> ./apache-tomcat-8.0.46/bin/startup.sh<br><img src="http://img1.sycdn.imooc.com/59da31850001020825280504.png" alt="图片描述"></p>
<h3 id="1-1-1-3在服务器上发布并运行自己的web-project"><a href="#1-1-1-3在服务器上发布并运行自己的web-project" class="headerlink" title="1.1.1.3在服务器上发布并运行自己的web project"></a><strong>1.1.1.3在服务器上发布并运行自己的web project</strong></h3><p> 修改tomcat默认启动端口，从8080修改为80端口，便于微信登录<br> vi apache-tomcat-8.0.46/conf/server.xml<br><img src="http://img1.sycdn.imooc.com/59da31960001a44d21681462.png" alt="图片描述"><br> 重启tomcat<br> ./apache-tomcat-8.0.46/bin/shutdown.sh<br> ./apache-tomcat-8.0.46/bin/startup.sh<br> 修改自己本地的网站的配置<br> 这里由于大家自己的<a href="https://coding.imooc.com/?c=java">java</a>网站项目的配置都不相同，只能说大概的，即把项目里的mysql配置(如果有的话)，redis配置(如果有的话)修改为阿里云服务器对应的配置(即ip，端口，密码等配置修改成服务器里安装好的这些软件的对应的配置)<br><img src="http://img1.sycdn.imooc.com/59da31b100014ae324660598.png" alt="图片描述"><br> 打出自己项目的war包<br><img src="http://img1.sycdn.imooc.com/59da31c30001ed4024681500.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31ce0001be2c08650907.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31db0001cb4808650907.png" alt="图片描述"><br> 将export出来的war包上传到服务器tomcat的webapps目录下<br> scp o2o.war <a href="mailto:root@47.104.1.235">root@47.104.1.235</a>:/root/apache-tomcat-8.0.46/webapps<br><img src="http://img1.sycdn.imooc.com/59da32070001e2d708640065.png" alt="图片描述"><br> 上传成功后，没过几秒tomcat便会在webapps目录下自动从项目war包中解析出项目工程目录来<br><img src="http://img1.sycdn.imooc.com/59da32220001dc1008650056.png" alt="图片描述"><br> 之后通过ip+请求路径的形式便能访问到自己的项目(因为已经设置成80端口，这是http默认访问的端口，所以不需要在URL里添加端口信息了)<br><img src="http://img1.sycdn.imooc.com/59da324a000107b108650519.png" alt="图片描述"></p>
<h3 id="1-1-1-4域名解析"><a href="#1-1-1-4域名解析" class="headerlink" title="1.1.1.4域名解析"></a><strong>1.1.1.4域名解析</strong></h3><p> 如果通过ip连接微信号，则总会弹出烦人的警告窗口，因此咱们可以先购买一个域名并对域名进行认证(具体的备案步骤不同服务商有不同要求，大家可以按照他们的要求来，主要分有个人认证和企业认证两种，当然大家如果不嫌烦，可以直接用ip即跳过域名解析这一步)，建议大家看看周围的朋友有谁已经有经过验证的域名了，这样可以直接借他的域名创建一个二级域名来用，方便省事，翔仔购买的是阿里云控制台里面的万网域名，购买并认证成功后，会有如下截图，选择购买好的域名并点击解析创建出二级域名<br><img src="http://img1.sycdn.imooc.com/59da326600014ec708650260.png" alt="图片描述"><br> 进入到解析的页面，选择添加解析，并在A记录里面设置好O2O，IP里面设置咱们的阿里云服务器公网IP。这样就能创建出o2o.yitiaojieinfo.com这样的域名指向该公网IP<br><img src="http://img1.sycdn.imooc.com/59da32830001b76108650508.png" alt="图片描述"><br> 隔一段时间，大概5-10分钟这样子，通过域名访问咱们的站点，就能发现访问是okay的<br><img src="http://img1.sycdn.imooc.com/59da329d0001476708650543.png" alt="图片描述"></p>
<h1 id="1-1-2阿里云部署Java网站和微信开发调试心得技巧-下"><a href="#1-1-2阿里云部署Java网站和微信开发调试心得技巧-下" class="headerlink" title="1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)"></a>1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)</h1><h2 id="1-1-2-5微信测试号的申请与连接以获取微信用户信息"><a href="#1-1-2-5微信测试号的申请与连接以获取微信用户信息" class="headerlink" title="1.1.2.5微信测试号的申请与连接以获取微信用户信息"></a><strong>1.1.2.5微信测试号的申请与连接以获取微信用户信息</strong></h2><p> 在咱们自己的程序里面编写servlet以响应微信号<br> 在接下来的步骤中，我们将在测试号里面设置接口配置信息的URL，一经设置，微信公众号便会发请求到我们设置好的URL去，我们必须编写程序应答才能顺利连通微信公众号，因此咱们需要编写相应的响应程序<br> 需要编写两个类<br> 【SignUtil】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.weixin;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信请求校验工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SignUtil &#123;</span><br><span class="line">    &#x2F;&#x2F; 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token &#x3D; &quot;myo2o&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 验证签名</span><br><span class="line">     * </span><br><span class="line">     * @param signature</span><br><span class="line">     * @param timestamp</span><br><span class="line">     * @param nonce</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp, String nonce) &#123;</span><br><span class="line">        String[] arr &#x3D; new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        &#x2F;&#x2F; 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        StringBuilder content &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md &#x3D; null;</span><br><span class="line">        String tmpStr &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            md &#x3D; MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            &#x2F;&#x2F; 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest &#x3D; md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr &#x3D; byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        content &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr !&#x3D; null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param byteArray</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest +&#x3D; byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param mByte</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;</span><br><span class="line">        char[] tempArr &#x3D; new char[2];</span><br><span class="line">        tempArr[0] &#x3D; Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] &#x3D; Digit[mByte &amp; 0X0F];</span><br><span class="line"></span><br><span class="line">        String s &#x3D; new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatController】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.util.wechat.SignUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">&#x2F;&#x2F;一会在设置的URL里面就设置上这个路由</span><br><span class="line">@RequestMapping(&quot;wechat&quot;)</span><br><span class="line">public class WechatController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">        String signature &#x3D; request.getParameter(&quot;signature&quot;);</span><br><span class="line">        &#x2F;&#x2F; 时间戳</span><br><span class="line">        String timestamp &#x3D; request.getParameter(&quot;timestamp&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机数</span><br><span class="line">        String nonce &#x3D; request.getParameter(&quot;nonce&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机字符串</span><br><span class="line">        String echostr &#x3D; request.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">        PrintWriter out &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            out &#x3D; response.getWriter();</span><br><span class="line">            if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">                log.debug(&quot;weixin get success....&quot;);</span><br><span class="line">                out.print(echostr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (out !&#x3D; null)</span><br><span class="line">                out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重新部署一版最新的程序</p>
<p>访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录<br><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a><br><img src="https://img1.sycdn.imooc.com/59da332500011d0308650391.png" alt="图片描述"><br> 进入到测试号页面后，分别看到如下信息<br> 【测试号信息】<br> appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等<br> appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里<br><img src="https://img1.sycdn.imooc.com/59da33380001aa6608650121.png" alt="图片描述"><br> 【接口配置信息】<br> URL: 是开发者用来接收微信消息和事件的接口URL<br> Token:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）<br><img src="https://img1.sycdn.imooc.com/59da334f000153d408650159.png" alt="图片描述"><br> 【JS接口安全域名】<br> 域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL，这里直接填写o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da336d0001ccc608650117.png" alt="图片描述"><br> 【测试号二维码】<br> 里面包含了测试号二维码以及已经关注了的用户信息<br><img src="https://img1.sycdn.imooc.com/59da33840001e2f508650283.png" alt="图片描述"><br> 【体验接口权限表】<br> 这里主要介绍【网页服务】里面的【网页帐号】<br> 网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。这里直接设置为o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da33e400010e7d08650549.png" alt="图片描述"><br><img src="https://img1.sycdn.imooc.com/59da340100017e1308650619.png" alt="图片描述"><br> 有不清楚的地方可以直接参考微信官方文档<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</a><br> 接下来需要编写自己的程序以获取关注此公众号的用户信息<br> 需要编写5个类 WechatLoginController.<a href="https://coding.imooc.com/?c=java">java</a>，UserAccessToken.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUser.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUtil.<a href="https://coding.imooc.com/?c=java">java</a>以及MyX509TrustManager.<a href="https://coding.imooc.com/?c=java">java</a><br> 【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line">import com.imooc.o2o.util.wechat.WeiXinUserUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;wechatlogin&quot;)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问</span><br><span class="line"> * https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;您的appId&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;o2o.yitiaojieinfo.com&#x2F;o2o&#x2F;wechatlogin&#x2F;logincheck&amp;role_type&#x3D;1&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;1#wechat_redirect</span><br><span class="line"> * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatLoginController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatLoginController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;logincheck&quot;, method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public String doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin login get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息</span><br><span class="line">        String code &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">        &#x2F;&#x2F; 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用</span><br><span class="line">        &#x2F;&#x2F; String roleType &#x3D; request.getParameter(&quot;state&quot;);</span><br><span class="line">        log.debug(&quot;weixin login code:&quot; + code);</span><br><span class="line">        WechatUser user &#x3D; null;</span><br><span class="line">        String openId &#x3D; null;</span><br><span class="line">        if (null !&#x3D; code) &#123;</span><br><span class="line">            UserAccessToken token;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过code获取access_token</span><br><span class="line">                token &#x3D; WeiXinUserUtil.getUserAccessToken(code);</span><br><span class="line">                log.debug(&quot;weixin login token:&quot; + token.toString());</span><br><span class="line">                &#x2F;&#x2F; 通过token获取accessToken</span><br><span class="line">                String accessToken &#x3D; token.getAccessToken();</span><br><span class="line">                &#x2F;&#x2F; 通过token获取openId</span><br><span class="line">                openId &#x3D; token.getOpenId();</span><br><span class="line">                &#x2F;&#x2F; 通过access_token和openId获取用户昵称等信息</span><br><span class="line">                user &#x3D; WeiXinUserUtil.getUserInfo(accessToken, openId);</span><br><span class="line">                log.debug(&quot;weixin login user:&quot; + user.toString());</span><br><span class="line">                request.getSession().setAttribute(&quot;openId&quot;, openId);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(&quot;error in getUserAccessToken or getUserInfo or findByOpenId: &quot; + e.toString());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F; 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了，</span><br><span class="line">        &#x2F;&#x2F; 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取到微信验证的信息后返回到指定的路由（需要自己设定）</span><br><span class="line">            return &quot;frontend&#x2F;index&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户授权token</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UserAccessToken &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到的凭证</span><br><span class="line">    @JsonProperty(&quot;access_token&quot;)</span><br><span class="line">    private String accessToken;</span><br><span class="line">    &#x2F;&#x2F; 凭证有效时间，单位：秒</span><br><span class="line">    @JsonProperty(&quot;expires_in&quot;)</span><br><span class="line">    private String expiresIn;</span><br><span class="line">    &#x2F;&#x2F; 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处</span><br><span class="line">    @JsonProperty(&quot;refresh_token&quot;)</span><br><span class="line">    private String refreshToken;</span><br><span class="line">    &#x2F;&#x2F; 该用户在此公众号下的身份标识，对于此微信号具有唯一性</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 表示权限范围，这里可省略</span><br><span class="line">    @JsonProperty(&quot;scope&quot;)</span><br><span class="line">    private String scope;</span><br><span class="line"></span><br><span class="line">    public String getAccessToken() &#123;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccessToken(String accessToken) &#123;</span><br><span class="line">        this.accessToken &#x3D; accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getExpiresIn() &#123;</span><br><span class="line">        return expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpiresIn(String expiresIn) &#123;</span><br><span class="line">        this.expiresIn &#x3D; expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRefreshToken() &#123;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRefreshToken(String refreshToken) &#123;</span><br><span class="line">        this.refreshToken &#x3D; refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getScope() &#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScope(String scope) &#123;</span><br><span class="line">        this.scope &#x3D; scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;accessToken:&quot; + this.getAccessToken() + &quot;,openId:&quot; + this.getOpenId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信用户实体类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUser implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -4684067645282292327L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; openId,标识该公众号下面的该用户的唯一Id</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 用户昵称</span><br><span class="line">    @JsonProperty(&quot;nickname&quot;)</span><br><span class="line">    private String nickName;</span><br><span class="line">    &#x2F;&#x2F; 性别</span><br><span class="line">    @JsonProperty(&quot;sex&quot;)</span><br><span class="line">    private int sex;</span><br><span class="line">    &#x2F;&#x2F; 省份</span><br><span class="line">    @JsonProperty(&quot;province&quot;)</span><br><span class="line">    private String province;</span><br><span class="line">    &#x2F;&#x2F; 城市</span><br><span class="line">    @JsonProperty(&quot;city&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">    &#x2F;&#x2F; 区</span><br><span class="line">    @JsonProperty(&quot;country&quot;)</span><br><span class="line">    private String country;</span><br><span class="line">    &#x2F;&#x2F; 头像图片地址</span><br><span class="line">    @JsonProperty(&quot;headimgurl&quot;)</span><br><span class="line">    private String headimgurl;</span><br><span class="line">    &#x2F;&#x2F; 语言</span><br><span class="line">    @JsonProperty(&quot;language&quot;)</span><br><span class="line">    private String language;</span><br><span class="line">    &#x2F;&#x2F; 用户权限，这里没什么作用</span><br><span class="line">    @JsonProperty(&quot;privilege&quot;)</span><br><span class="line">    private String[] privilege;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNickName() &#123;</span><br><span class="line">        return nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNickName(String nickName) &#123;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(int sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProvince() &#123;</span><br><span class="line">        return province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProvince(String province) &#123;</span><br><span class="line">        this.province &#x3D; province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCity() &#123;</span><br><span class="line">        return city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCity(String city) &#123;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCountry() &#123;</span><br><span class="line">        return country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCountry(String country) &#123;</span><br><span class="line">        this.country &#x3D; country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHeadimgurl() &#123;</span><br><span class="line">        return headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeadimgurl(String headimgurl) &#123;</span><br><span class="line">        this.headimgurl &#x3D; headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLanguage() &#123;</span><br><span class="line">        return language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLanguage(String language) &#123;</span><br><span class="line">        this.language &#x3D; language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getPrivilege() &#123;</span><br><span class="line">        return privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrivilege(String[] privilege) &#123;</span><br><span class="line">        this.privilege &#x3D; privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;openId:&quot; + this.getOpenId() + &quot;,nikename:&quot; + this.getNickName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatUtil】主要用来提交https请求给微信获取用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ConnectException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.HttpsURLConnection;</span><br><span class="line">import javax.net.ssl.SSLContext;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import javax.net.ssl.TrustManager;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信工具类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatUtil.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取UserAccessToken实体类</span><br><span class="line">     * </span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static UserAccessToken getUserAccessToken(String code) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appId</span><br><span class="line">        String appId &#x3D; &quot;您的appId&quot;;</span><br><span class="line">        log.debug(&quot;appId:&quot; + appId);</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appsecret</span><br><span class="line">        String appsecret &#x3D; &quot;您的appsecret&quot;;</span><br><span class="line">        log.debug(&quot;secret:&quot; + appsecret);</span><br><span class="line">        &#x2F;&#x2F; 根据传入的code,拼接出访问微信定义好的接口的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;&quot; + appId + &quot;&amp;secret&#x3D;&quot; + appsecret</span><br><span class="line">                + &quot;&amp;code&#x3D;&quot; + code + &quot;&amp;grant_type&#x3D;authorization_code&quot;;</span><br><span class="line">        &#x2F;&#x2F; 向相应URL发送请求获取token json字符串</span><br><span class="line">        String tokenStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;userAccessToken:&quot; + tokenStr);</span><br><span class="line">        UserAccessToken token &#x3D; new UserAccessToken();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            token &#x3D; objectMapper.readValue(tokenStr, UserAccessToken.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (token &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取WechatUser实体类</span><br><span class="line">     * </span><br><span class="line">     * @param accessToken</span><br><span class="line">     * @param openId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static WechatUser getUserInfo(String accessToken, String openId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;&quot; + accessToken + &quot;&amp;openid&#x3D;&quot; + openId</span><br><span class="line">                + &quot;&amp;lang&#x3D;zh_CN&quot;;</span><br><span class="line">        &#x2F;&#x2F; 访问该URL获取用户信息json 字符串</span><br><span class="line">        String userStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;user info :&quot; + userStr);</span><br><span class="line">        WechatUser user &#x3D; new WechatUser();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            user &#x3D; objectMapper.readValue(userStr, WechatUser.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发起https请求并获取结果</span><br><span class="line">     * </span><br><span class="line">     * @param requestUrl</span><br><span class="line">     *            请求地址</span><br><span class="line">     * @param requestMethod</span><br><span class="line">     *            请求方式（GET、POST）</span><br><span class="line">     * @param outputStr</span><br><span class="line">     *            提交的数据</span><br><span class="line">     * @return json字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建SSLContext对象，并使用我们指定的信任管理器初始化</span><br><span class="line">            TrustManager[] tm &#x3D; &#123; new MyX509TrustManager() &#125;;</span><br><span class="line">            SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</span><br><span class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</span><br><span class="line">            &#x2F;&#x2F; 从上述SSLContext对象中得到SSLSocketFactory对象</span><br><span class="line">            SSLSocketFactory ssf &#x3D; sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">            URL url &#x3D; new URL(requestUrl);</span><br><span class="line">            HttpsURLConnection httpUrlConn &#x3D; (HttpsURLConnection) url.openConnection();</span><br><span class="line">            httpUrlConn.setSSLSocketFactory(ssf);</span><br><span class="line"></span><br><span class="line">            httpUrlConn.setDoOutput(true);</span><br><span class="line">            httpUrlConn.setDoInput(true);</span><br><span class="line">            httpUrlConn.setUseCaches(false);</span><br><span class="line">            &#x2F;&#x2F; 设置请求方式（GET&#x2F;POST）</span><br><span class="line">            httpUrlConn.setRequestMethod(requestMethod);</span><br><span class="line"></span><br><span class="line">            if (&quot;GET&quot;.equalsIgnoreCase(requestMethod))</span><br><span class="line">                httpUrlConn.connect();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当有数据需要提交时</span><br><span class="line">            if (null !&#x3D; outputStr) &#123;</span><br><span class="line">                OutputStream outputStream &#x3D; httpUrlConn.getOutputStream();</span><br><span class="line">                &#x2F;&#x2F; 注意编码格式，防止中文乱码</span><br><span class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将返回的输入流转换成字符串</span><br><span class="line">            InputStream inputStream &#x3D; httpUrlConn.getInputStream();</span><br><span class="line">            InputStreamReader inputStreamReader &#x3D; new InputStreamReader(inputStream, &quot;utf-8&quot;);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">            String str &#x3D; null;</span><br><span class="line">            while ((str &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                buffer.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            &#x2F;&#x2F; 释放资源</span><br><span class="line">            inputStream.close();</span><br><span class="line">            inputStream &#x3D; null;</span><br><span class="line">            httpUrlConn.disconnect();</span><br><span class="line">            log.debug(&quot;https buffer:&quot; + buffer.toString());</span><br><span class="line">        &#125; catch (ConnectException ce) &#123;</span><br><span class="line">            log.error(&quot;Weixin server connection timed out.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;https request error:&#123;&#125;&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.security.cert.CertificateException;</span><br><span class="line">import java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.X509TrustManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 证书信任管理器（用于https请求）</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyX509TrustManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重新打包一个新的war包并发布到服务器tomcat webapps目录下<br> 发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=%E6%82%A8%E7%9A%84appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect</a><br><img src="https://img1.sycdn.imooc.com/59da34c500012aa908650494.png" alt="图片描述"><br> 之后查看日志信息，便能发现确实能够获取到用户的信息了<br><img src="https://img1.sycdn.imooc.com/59da34de0001a64308650182.png" alt="图片描述"></p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-前端展示系统</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-商品模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-商品类别模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E7%B1%BB%E5%88%AB%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-店铺编辑和列表功能</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E7%BC%96%E8%BE%91%E5%92%8C%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="6-1店铺信息编辑之Dao层开发"><a href="#6-1店铺信息编辑之Dao层开发" class="headerlink" title="6.1店铺信息编辑之Dao层开发"></a>6.1店铺信息编辑之Dao层开发</h1><h2 id="6-1-1ShopDao接口"><a href="#6-1-1ShopDao接口" class="headerlink" title="6.1.1ShopDao接口"></a>6.1.1ShopDao接口</h2><p><strong>新建queryByShopId方法：</strong>因为对店铺进行编辑之前，要先将店铺的信息查询出来</p>
<h2 id="6-1-2Mapper中实现queryByShopId方法"><a href="#6-1-2Mapper中实现queryByShopId方法" class="headerlink" title="6.1.2Mapper中实现queryByShopId方法"></a>6.1.2Mapper中实现queryByShopId方法</h2><p><strong>在Mapper中自定义返回类型：</strong></p>
<p>主要是<strong>复合类型的定义</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//resultMap type：自定义的Shop实体类</span><br><span class="line">//id：返回类型的名称</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.imooc.o2o.entity.Shop&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shopMap&quot;</span>&gt;</span></span><br><span class="line">        //id column：主键为shop_id，与数据库中列名一致</span><br><span class="line">        //property：与实体类中的成员变量名称一致</span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;shop_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopId&quot;</span> /&gt;</span></span><br><span class="line">		//result column：与数据库中列名一致</span><br><span class="line">        //property：与实体类中的成员变量名称一致</span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopDesc&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_addr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopAddr&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">property</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_img&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopImg&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;priority&quot;</span> <span class="attr">property</span>=<span class="string">&quot;priority&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enable_status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enableStatus&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">property</span>=<span class="string">&quot;advice&quot;</span> /&gt;</span></span><br><span class="line">		//复合类型，property：与实体类中的成员变量名称一致</span><br><span class="line">		//通过area_id连接</span><br><span class="line">		//javaType：该复合类型所对应的Java实体类</span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;area&quot;</span> <span class="attr">column</span>=<span class="string">&quot;area_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.Area&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;area_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;areaId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;area_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;areaName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;shopCategory&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">column</span>=<span class="string">&quot;shop_category_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.ShopCategory&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;shop_category_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopCategoryId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_category_name&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">property</span>=<span class="string">&quot;shopCategoryName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;owner&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.PersonInfo&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>对应的SQL语句：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByShopId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;shopMap&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">        //要选出的店铺信息</span><br><span class="line">		s.shop_id,</span><br><span class="line">		s.shop_name,</span><br><span class="line">		s.shop_desc,</span><br><span class="line">		s.shop_addr,</span><br><span class="line">		s.phone,</span><br><span class="line">		s.shop_img,</span><br><span class="line">		s.priority,</span><br><span class="line">		s.create_time,</span><br><span class="line">		s.last_edit_time,</span><br><span class="line">		s.enable_status,</span><br><span class="line">		s.advice,</span><br><span class="line">        //要选出的区域信息</span><br><span class="line">		a.area_id,</span><br><span class="line">		a.area_name,</span><br><span class="line">        //要选出的店铺类别信息</span><br><span class="line">		sc.shop_category_id,</span><br><span class="line">		sc.shop_category_name</span><br><span class="line">		FROM</span><br><span class="line">		tb_shop s,</span><br><span class="line">		tb_area a,</span><br><span class="line">		tb_shop_category sc</span><br><span class="line">		WHERE</span><br><span class="line">        //where子查询定义查询的条件，也就是与店铺中area_id和shop_category_id中相等的区域和类别信息</span><br><span class="line">		s.area_id=a.area_id</span><br><span class="line">		AND</span><br><span class="line">		s.shop_category_id = sc.shop_category_id</span><br><span class="line">		AND</span><br><span class="line">        //传入的参数也就是店铺Id</span><br><span class="line">		s.shop_id=#&#123;shopId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-2店铺信息编辑之Service层的实现"><a href="#6-2店铺信息编辑之Service层的实现" class="headerlink" title="6.2店铺信息编辑之Service层的实现"></a>6.2店铺信息编辑之Service层的实现</h1><h2 id="6-2-1ShopService接口"><a href="#6-2-1ShopService接口" class="headerlink" title="6.2.1ShopService接口"></a>6.2.1ShopService接口</h2><p><strong>getByShopId方法：</strong></p>
<ul>
<li>返回shop实体类对象</li>
</ul>
<p><strong>modifyShop方法：</strong></p>
<ul>
<li>传入店铺和图片</li>
<li>更新店铺信息，包括对图片的处理</li>
<li>返回ShopExecution对象</li>
</ul>
<h2 id="6-2-2ShopServiceImpl实现方法"><a href="#6-2-2ShopServiceImpl实现方法" class="headerlink" title="6.2.2ShopServiceImpl实现方法"></a>6.2.2ShopServiceImpl实现方法</h2><p><strong>modifyShop方法：</strong></p>
<ol>
<li><p>判断是否需要处理图片</p>
<p>当有图片时，先调用工具类中的方法，将图片删除</p>
<p>调用添加图片的方法，将图片更新到数据库中</p>
</li>
<li><p>更新店铺信息</p>
<p>这里要用已经修改后的店铺（有最新的图片信息），而不是刚开始通过shopID查询的tempShop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ShopExecution <span class="title">modifyShop</span><span class="params">(Shop shop, ImageHolder thumbnail)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ShopOperationException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (shop == <span class="keyword">null</span> || shop.getShopId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.NULL_SHOP);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 1、判断是否需要处理图片</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;shopImgInputStream&quot;</span> + thumbnail.getImage());</span><br><span class="line">				<span class="keyword">if</span> (thumbnail.getImage() != <span class="keyword">null</span> &amp;&amp; thumbnail.getImageName() != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(thumbnail.getImageName())) &#123;</span><br><span class="line">					Shop tempShop = shopDao.queryByShopId(shop.getShopId());</span><br><span class="line">					<span class="keyword">if</span> (tempShop.getShopImg() != <span class="keyword">null</span>) &#123;</span><br><span class="line">						ImageUtil.deleteFileOrPath(tempShop.getShopImg());</span><br><span class="line">					&#125;</span><br><span class="line">					addShopImg(shop, thumbnail);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 2、更新店铺信息</span></span><br><span class="line">				shop.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">				<span class="keyword">int</span> effectedNum = shopDao.updateShop(shop);</span><br><span class="line">				<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.INNER_ERROR);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					shop = shopDao.queryByShopId(shop.getShopId());</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.SUCCESS, shop);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;modifyShop error:&quot;</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中对于图片的处理需要工具类中加入方法deleteFileOrPath：</p>
<ul>
<li>先判断storePath是文件的路径还是目录的路径 如果storePath是文件的路径，直接删除该文件</li>
<li>如果storePath是目录的路径则删除该目录下的所有文件</li>
</ul>
<h1 id="6-3店铺信息编辑之Controller层实现"><a href="#6-3店铺信息编辑之Controller层实现" class="headerlink" title="6.3店铺信息编辑之Controller层实现"></a>6.3店铺信息编辑之Controller层实现</h1><h2 id="6-3-1getShopById方法的实现"><a href="#6-3-1getShopById方法的实现" class="headerlink" title="6.3.1getShopById方法的实现"></a>6.3.1getShopById方法的实现</h2><ul>
<li>创建modelMap用来接收返回结果</li>
<li>从request中获取shopId</li>
<li>通过调用Service层的getByShopId和getAreaList方法获取店铺信息及区域列表，将这些信息放入modelMap</li>
<li>操作成功：将成功信息放入modelMap</li>
<li>操作失败：将失败信息放入modelMap</li>
<li>操作异常：将异常信息放入modelMap</li>
<li>返回modelMap</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/getshopbyid&quot;, method = RequestMethod.GET)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getShopById</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		Long shopId = HttpServletRequestUtil.getLong(request, <span class="string">&quot;shopId&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (shopId &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Shop shop = shopService.getByShopId(shopId);</span><br><span class="line">				List&lt;Area&gt; areaList = areaService.getAreaList();</span><br><span class="line">				modelMap.put(<span class="string">&quot;shop&quot;</span>, shop);</span><br><span class="line">				modelMap.put(<span class="string">&quot;areaList&quot;</span>, areaList);</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;empty shopId&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-2modifyShop方法的实现"><a href="#6-3-2modifyShop方法的实现" class="headerlink" title="6.3.2modifyShop方法的实现"></a>6.3.2modifyShop方法的实现</h2><ul>
<li>创建modelMap用于将结果返回到前端</li>
<li>判断验证码信息</li>
</ul>
<p><strong>下面与注册店铺的逻辑基本相同</strong></p>
<ul>
<li><p>接收并转化相应的参数，包括店铺信息以及图片信息</p>
</li>
<li><p>修改店铺信息</p>
<p>店铺注册时图片信息不能为空</p>
<p>这里的图片信息是可以为空的，只对店铺内容更新即可</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/modifyshop&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">modifyShop</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.接收并转化相应的参数，包括店铺信息以及图片信息</span></span><br><span class="line">		String shopStr = HttpServletRequestUtil.getString(request, <span class="string">&quot;shopStr&quot;</span>);</span><br><span class="line">		ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		Shop shop = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			shop = mapper.readValue(shopStr, Shop.class);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		CommonsMultipartFile shopImg = <span class="keyword">null</span>;</span><br><span class="line">		CommonsMultipartResolver commonsMultipartResolver = <span class="keyword">new</span> CommonsMultipartResolver(</span><br><span class="line">				request.getSession().getServletContext());</span><br><span class="line">		<span class="keyword">if</span> (commonsMultipartResolver.isMultipart(request)) &#123;</span><br><span class="line">			MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request;</span><br><span class="line">			shopImg = (CommonsMultipartFile) multipartHttpServletRequest.getFile(<span class="string">&quot;shopImg&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.修改店铺信息</span></span><br><span class="line">		<span class="keyword">if</span> (shop != <span class="keyword">null</span> &amp;&amp; shop.getShopId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ShopExecution se;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (shopImg == <span class="keyword">null</span>) &#123;</span><br><span class="line">					se = shopService.modifyShop(shop, <span class="keyword">null</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					ImageHolder imageHolder = <span class="keyword">new</span> ImageHolder(shopImg.getOriginalFilename(), shopImg.getInputStream());</span><br><span class="line">					se = shopService.modifyShop(shop, imageHolder);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (se.getState() == ShopStateEnum.SUCCESS.getState()) &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">					modelMap.put(<span class="string">&quot;errMsg&quot;</span>, se.getStateInfo());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ShopOperationException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;请输入店铺Id&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-4店铺信息编辑之前端实现"><a href="#6-4店铺信息编辑之前端实现" class="headerlink" title="6.4店铺信息编辑之前端实现"></a>6.4店铺信息编辑之前端实现</h1><h2 id="6-4-1shopoperation-js文件修改"><a href="#6-4-1shopoperation-js文件修改" class="headerlink" title="6.4.1shopoperation.js文件修改"></a>6.4.1shopoperation.js文件修改</h2><ul>
<li><p>在common.js中添加getQueryString方法来获取ShopId</p>
</li>
<li><p>通过判断shopId是否为空来决定使用哪个功能</p>
<p>shopId=null：店铺注册</p>
<p>shopId！=null：修改店铺</p>
</li>
<li><p>创建两个Url：</p>
<p>shopInfoUrl：获取店铺信息（上面获取的shopId要拼接到这个Url中）</p>
<p>editShopUrl：修改店铺</p>
</li>
<li><p>这里的逻辑就是当shopId为空时，通过initUrl来获取店铺注册所需要的信息（区域列表、店铺类别等）</p>
<p>当shopId不为空时，通过shopInfoUrl来获取店铺信息，后面进行修改</p>
<p>同时，在ajax中也要判断shopId是否为空来决定将数据传送给后端的哪个controller方法</p>
</li>
</ul>
<h1 id="6-5店铺列表展示之Dao层的实现"><a href="#6-5店铺列表展示之Dao层的实现" class="headerlink" title="6.5店铺列表展示之Dao层的实现"></a>6.5店铺列表展示之Dao层的实现</h1><h2 id="6-5-1ShopDao接口"><a href="#6-5-1ShopDao接口" class="headerlink" title="6.5.1ShopDao接口"></a>6.5.1ShopDao接口</h2><p><strong>新建queryShopList方法：</strong>分页查询店铺，可输入的条件有：店铺名（模糊查询），店铺状态，店铺类别，区域Id，owner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分页查询店铺，可输入的条件有：店铺名（模糊查询），店铺类别，区域Id，owner</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shopCondition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rowIndex      从第几行开始取数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pageSize      返回的数据条数（从起始行算起）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Shop&gt; <span class="title">queryShopList</span><span class="params">(<span class="meta">@Param(&quot;shopCondition&quot;)</span> Shop shopCondition, <span class="meta">@Param(&quot;rowIndex&quot;)</span> <span class="keyword">int</span> rowIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Param(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@Param标签：</strong>当方法中有多个参数时，需要用标签将不同的参数区分开</p>
</blockquote>
<p><strong>新建queryShopCount方法：</strong>返回查询的店铺总数，<strong>用来支持分页查询</strong></p>
<h2 id="6-5-2Mapper中实现queryShopList方法"><a href="#6-5-2Mapper中实现queryShopList方法" class="headerlink" title="6.5.2Mapper中实现queryShopList方法"></a>6.5.2Mapper中实现queryShopList方法</h2><p><strong>代码的逻辑就是在where子句中加入动态SQL，只要参数有值就会将多个参数组合起来查询</strong></p>
<p><strong>注意：</strong>对于商铺名称我们使用模糊查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模糊查询用like ‘%xxx%’</span><br><span class="line">where s.shop_name like &#39;%要匹配的字符串%&#39;</span><br></pre></td></tr></table></figure>

<p>这里加入了分页查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;按照权重从高到低排序后，按照传入的参数确定返回的数据条数</span><br><span class="line">ORDER BY</span><br><span class="line">s.priority DESC</span><br><span class="line">LIMIT #&#123;rowIndex&#125;,#&#123;pageSize&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryShopList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;shopMap&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">		s.shop_id,</span><br><span class="line">		s.shop_name,</span><br><span class="line">		s.shop_desc,</span><br><span class="line">		s.shop_addr,</span><br><span class="line">		s.phone,</span><br><span class="line">		s.shop_img,</span><br><span class="line">		s.priority,</span><br><span class="line">		s.create_time,</span><br><span class="line">		s.last_edit_time,</span><br><span class="line">		s.enable_status,</span><br><span class="line">		s.advice,</span><br><span class="line">		a.area_id,</span><br><span class="line">		a.area_name,</span><br><span class="line">		sc.shop_category_id,</span><br><span class="line">		sc.shop_category_name</span><br><span class="line">		FROM</span><br><span class="line">		tb_shop s,</span><br><span class="line">		tb_area a,</span><br><span class="line">		tb_shop_category sc</span><br><span class="line">		<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.shopCategory != null and </span></span></span><br><span class="line"><span class="tag"><span class="string">			shopCondition.shopCategory.shopCategoryId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_category_id =</span><br><span class="line">				#&#123;shopCondition.shopCategory.shopCategoryId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.shopCategory != null </span></span></span><br><span class="line"><span class="tag"><span class="string">			and shopCondition.shopCategory.parent!=null </span></span></span><br><span class="line"><span class="tag"><span class="string">			and shopCondition.shopCategory.parent.shopCategoryId !=null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_category_id in (select shop_category_id from</span><br><span class="line">				tb_shop_category</span><br><span class="line">				WHERE parent_id =</span><br><span class="line">				#&#123;shopCondition.shopCategory.parent.shopCategoryId&#125;)</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.area != null and </span></span></span><br><span class="line"><span class="tag"><span class="string">			shopCondition.area.areaId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.area_id =</span><br><span class="line">				#&#123;shopCondition.area.areaId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopCondition.shopName != null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_name like &#x27;%$&#123;shopCondition.shopName&#125;%&#x27;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopCondition.enableStatus != null&quot;</span>&gt;</span></span><br><span class="line">				and s.enable_status = #&#123;shopCondition.enableStatus&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.owner != null and shopCondition.owner.userId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.owner_id = #&#123;shopCondition.owner.userId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			AND</span><br><span class="line">			s.area_id=a.area_id</span><br><span class="line">			AND</span><br><span class="line">			s.shop_category_id = sc.shop_category_id</span><br><span class="line">		<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">		ORDER BY</span><br><span class="line">		s.priority DESC</span><br><span class="line">		LIMIT #&#123;rowIndex&#125;,#&#123;pageSize&#125;;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-6店铺列表展示之Service层的实现"><a href="#6-6店铺列表展示之Service层的实现" class="headerlink" title="6.6店铺列表展示之Service层的实现"></a>6.6店铺列表展示之Service层的实现</h1><h2 id="6-6-1ShopService接口"><a href="#6-6-1ShopService接口" class="headerlink" title="6.6.1ShopService接口"></a>6.6.1ShopService接口</h2><p><strong>getShopList方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据shopCondition分页返回相应店铺列表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shopCondition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pageIndex</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pageSize</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ShopExecution <span class="title">getShopList</span><span class="params">(Shop shopCondition,<span class="keyword">int</span> pageIndex,<span class="keyword">int</span> pageSize)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-6-2ShopServiceImpl实现方法"><a href="#6-6-2ShopServiceImpl实现方法" class="headerlink" title="6.6.2ShopServiceImpl实现方法"></a>6.6.2ShopServiceImpl实现方法</h2><p>这里获取店铺列表时，由于在数据库中我们只认行数，而在前端要转换成页数，因此要添加工具类，将行数转换成页码</p>
<p>表示第几页开始取一页的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageCalculator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateRowIndex</span><span class="params">(<span class="keyword">int</span> pageIndex, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pageIndex &gt; <span class="number">0</span>) ? (pageIndex - <span class="number">1</span>) * pageSize : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>getShopList方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ShopExecution <span class="title">getShopList</span><span class="params">(Shop shopCondition, <span class="keyword">int</span> pageIndex, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 将pageIndex转换成rowIndex</span></span><br><span class="line">		<span class="keyword">int</span> rowIndex = PageCalculator.calculateRowIndex(pageIndex, pageSize);</span><br><span class="line">        List&lt;Shop&gt; shopList=shopDao.queryShopList(shopCondition, rowIndex, pageSize);</span><br><span class="line">        <span class="keyword">int</span> count=shopDao.queryShopCount(shopCondition);</span><br><span class="line">        ShopExecution se=<span class="keyword">new</span> ShopExecution();</span><br><span class="line">        <span class="keyword">if</span>(shopList!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        	se.setShopList(shopList);</span><br><span class="line">        	se.setCount(count);</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        	se.setState(ShopStateEnum.INNER_ERROR.getState());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> se;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-6店铺列表展示之Controller层的实现"><a href="#6-6店铺列表展示之Controller层的实现" class="headerlink" title="6.6店铺列表展示之Controller层的实现"></a>6.6店铺列表展示之Controller层的实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/getshoplist&quot;, method = RequestMethod.GET)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getShopList</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		PersonInfo user = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Shop shopCondition = <span class="keyword">new</span> Shop();</span><br><span class="line">			shopCondition.setOwner(user);</span><br><span class="line">			ShopExecution se = shopService.getShopList(shopCondition, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;shopList&quot;</span>, se.getShopList());</span><br><span class="line">			<span class="comment">// 列出店铺成功之后，将店铺放入session中作为权限验证依据，即该帐号只能操作它自己的店铺</span></span><br><span class="line">			request.getSession().setAttribute(<span class="string">&quot;shopList&quot;</span>, se.getShopList());</span><br><span class="line">			modelMap.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelMap;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-主从库同步与读写分离</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="5-1为什么要用主从同步，及其原理"><a href="#5-1为什么要用主从同步，及其原理" class="headerlink" title="5.1为什么要用主从同步，及其原理"></a>5.1为什么要用主从同步，及其原理</h1><p>在MySQL相关的文章里</p>
<h1 id="5-2主从同步数据库配置"><a href="#5-2主从同步数据库配置" class="headerlink" title="5.2主从同步数据库配置"></a>5.2主从同步数据库配置</h1><h2 id="5-2-1主服务器配置文件"><a href="#5-2-1主服务器配置文件" class="headerlink" title="5.2.1主服务器配置文件"></a>5.2.1主服务器配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//服务器id，必须唯一</span><br><span class="line">server-id=1</span><br><span class="line">//开启log-bin二进制日志</span><br><span class="line">log-bin=master-bin</span><br><span class="line">//开启索引</span><br><span class="line">log-bin-index=master-bin.index</span><br></pre></td></tr></table></figure>

<p><strong>重启主服务器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p><strong>查看主服务器状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status</span><br></pre></td></tr></table></figure>

<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片1.png" style="zoom:67%;">

<p><strong>创建repl账号：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user repl</span><br></pre></td></tr></table></figure>

<p><strong>给与使用repl账号登录的服务器的权限：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* TO &#39;repl&#39;@&#39;服务器IP&#39; IDENTIFIED BY &#39;mysql&#39;</span><br></pre></td></tr></table></figure>

<p><strong>刷新：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges</span><br></pre></td></tr></table></figure>

<h2 id="5-2-2从服务器配置文件"><a href="#5-2-2从服务器配置文件" class="headerlink" title="5.2.2从服务器配置文件"></a>5.2.2从服务器配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//服务器id，必须唯一</span><br><span class="line">server-id=2</span><br><span class="line">//开启relay-log二进制日志</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">//开启索引</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">//由于在同一台机器上，要修改端口号</span><br><span class="line">port=3305</span><br></pre></td></tr></table></figure>

<p><strong>重启从服务器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p><strong>将master与slave联系起来：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用repl账号从主库的日志文件的位置开启同步</span><br><span class="line">change master to master_host&#x3D;&#39;主库IP&#39;,master_port&#x3D;3306,master_user&#x3D;&#39;repl&#39;,master_password&#x3D;&#39;mysql&#39;,master_log_file&#x3D;&#39;master-bin.000001&#39;,master_log_pos&#x3D;0;</span><br></pre></td></tr></table></figure>

<p><strong>开启从库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start slave</span><br></pre></td></tr></table></figure>

<p><strong>查看从服务器状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片2.png" style="zoom:67%;">

<h2 id="5-2-3数据库备份与导入"><a href="#5-2-3数据库备份与导入" class="headerlink" title="5.2.3数据库备份与导入"></a>5.2.3数据库备份与导入</h2><p><strong>备份数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将指定的数据库输出到指定的文件</span><br><span class="line">mysqldump -uroot -p o2o &gt; o2o.sql</span><br></pre></td></tr></table></figure>

<p><strong>引入备份的数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;xx路径下的xx.sql文件</span><br><span class="line">source ~&#x2F;o2o.sql;</span><br></pre></td></tr></table></figure>

<h1 id="5-3代码层面读写分离的实现"><a href="#5-3代码层面读写分离的实现" class="headerlink" title="5.3代码层面读写分离的实现"></a>5.3代码层面读写分离的实现</h1><h2 id="5-3-1创建DynamicDataSource类"><a href="#5-3-1创建DynamicDataSource类" class="headerlink" title="5.3.1创建DynamicDataSource类"></a>5.3.1创建DynamicDataSource类</h2><p>创建DynamicDataSource类让它继承抽象类AbstractRoutingDataSource，重写determineCurrentLookupKey方法，实现不同数据源的选择：</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片3.png" style="zoom:67%;">

<h2 id="5-3-2创建DynamicDataSourceHolder类"><a href="#5-3-2创建DynamicDataSourceHolder类" class="headerlink" title="5.3.2创建DynamicDataSourceHolder类"></a>5.3.2创建DynamicDataSourceHolder类</h2><p><strong>引入ThreadLocal保证线程安全：</strong>维持线程封闭性的一种规范方法是使用ThreadLocal。它提供了set和get等访问方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get方法总是返回由当前执行线程在调用set时设置的最新值。一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的，每个线程都只能看到自己线程的值，这也就是<strong>ThreadLocal的核心作用：实现线程范围的局部变量。</strong><br><strong>getDbType方法：</strong>获取数据源类型</p>
<p><strong>setDbType方法：</strong>设置数据源类型</p>
<p>clearDBType方法：略</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片4.png" style="zoom:67%;">

<h2 id="5-3-3创建DynamicDataSourceInterceptor类"><a href="#5-3-3创建DynamicDataSourceInterceptor类" class="headerlink" title="5.3.3创建DynamicDataSourceInterceptor类"></a>5.3.3创建DynamicDataSourceInterceptor类</h2><p>DynamicDataSourceHolder这个类决定返回的数据源是master还是slave，这个类的初始化我们就需要借助DateSourceSelectInterceptor了，我们拦截所有的数据库操作请求，通过分析sql语句来判断是读还是写操作，读操作就给DynamicDataSourceHolder设置slave源，写操作就给其设置master源，代码如下：</p>
<ul>
<li><p>添加@Intercepts注解：说明要拦截的类型，其中update涵盖了增删改的操作</p>
</li>
<li><p>创建日志对象来输出显示使用数据源的类型</p>
</li>
<li><p>编写正则表达式：能够匹配的要用主库</p>
</li>
<li><p>intercept方法：</p>
<p>synchronizationActive：判断是不是事务</p>
<p>objects：获取传入对象的SQL语句参数</p>
<p>ms：接收参数的第一个值objects[0]，第一个值往往就是操作名称</p>
<p>lookupKey：保存数据源的类型</p>
<p><strong>判断不是事务管理：</strong></p>
<p>如果是SELECT方法，再去判断Mybatis是否调用了获取自增主键的方法，比如我们注册店铺根据<strong>选择的</strong>shopID生成图片地址，再将图片的地址插入到数据库，这个我们应该选择<strong>主库</strong>；</p>
<p>如果没有调用获取自增主键的方法，再将ms的第二个内容也就是SQL语句统一格式去匹配写好的正则表达式，如果能匹配上也要用<strong>主库</strong>，反之，匹配不上用从库。</p>
<p><strong>判断是事务管理：</strong></p>
<p>一般使用事务管理的都是写操作，我们使用主库</p>
<p>通过DynamicDataSourceHolder中的setDbType()方法最终决定使用哪个数据源</p>
<p>invocation.proceed()：程序继续执行</p>
</li>
<li><p>plugin方法：</p>
</li>
<li><p>setProperties方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过拦截器，根据不同的SQL请求选择对应的数据源 select、query--选择读的数据源（slave）</span></span><br><span class="line"><span class="comment"> * updata、insert--选择写的数据源（master）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 王进</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(&#123; @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class &#125;),</span></span><br><span class="line"><span class="meta">		@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span></span><br><span class="line"><span class="meta">				RowBounds.class, ResultHandler.class &#125;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建日志对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceInterceptor.class);</span><br><span class="line">	<span class="comment">// 正则表达式</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">&quot;.*insert\\u0020.*.*delete\\u0020.*.*updata\\u0020.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要的拦截方法，根据不同的情况去做拦截</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是不是事务</span></span><br><span class="line">		<span class="keyword">boolean</span> synchronizationActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">		<span class="comment">// 获取传入对象的SQL参数</span></span><br><span class="line">		Object[] objects = invocation.getArgs();</span><br><span class="line">		MappedStatement ms = (MappedStatement) objects[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 保存dataSourceType</span></span><br><span class="line">		String lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">		<span class="keyword">if</span> (synchronizationActive != <span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 读方法</span></span><br><span class="line">			<span class="keyword">if</span> (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) &#123;</span><br><span class="line">				<span class="comment">// selectKey 为自增id查询主键（SELECT LAST_INSERT_ID()）方法，使用主库</span></span><br><span class="line">				<span class="keyword">if</span> (ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) &#123;</span><br><span class="line">					lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line">					<span class="comment">// 替换SQL中所有的制表符、换行符为空格</span></span><br><span class="line">					String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll(<span class="string">&quot;[\\t\\n\\r]&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">					<span class="comment">// 用sql去匹配正则表达式，如果是insert、delete、updata使用主库</span></span><br><span class="line">					<span class="keyword">if</span> (sql.matches(REGEX)) &#123;</span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_SLAVE;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 使用事务管理的都是写操作，使用主库</span></span><br><span class="line">			lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">		&#125;</span><br><span class="line">		logger.debug(<span class="string">&quot;设置方法[&#123;&#125;] use [&#123;&#125;] Strategy,SqlCommandType [&#123;&#125;]..&quot;</span>, ms.getId(), lookupKey,</span><br><span class="line">				ms.getSqlCommandType().name());</span><br><span class="line">		<span class="comment">// 通过DynamicDataSourceHolder中的setDbType()方法最终决定使用哪个数据源</span></span><br><span class="line">		DynamicDataSourceHolder.setDbType(lookupKey);</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回代理对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (target <span class="keyword">instanceof</span> Executor) &#123;<span class="comment">// Mybatis中的Executor支持增删改查操作，发现对象中有这个对象，</span></span><br><span class="line">											<span class="comment">// 要去调用intercept方法来决定使用哪个数据源</span></span><br><span class="line">			<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> target;<span class="comment">// 返回本体，不做拦截</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化时所做的相关配置（不必要）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-4Mybatis-config-xml中配置拦截器"><a href="#5-3-4Mybatis-config-xml中配置拦截器" class="headerlink" title="5.3.4Mybatis-config.xml中配置拦截器"></a>5.3.4Mybatis-config.xml中配置拦截器</h2><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片5.png" style="zoom:67%;">

<h2 id="5-3-5Spring-dao中重新配置datesource"><a href="#5-3-5Spring-dao中重新配置datesource" class="headerlink" title="5.3.5Spring-dao中重新配置datesource"></a>5.3.5Spring-dao中重新配置datesource</h2><p>将原来配置的连接池属性的bean设为抽象的并保留原先配置的属性，让id为master和slave的bean继承这些私有属性，而master和slave连接数据库的属性是不同的（url、密码等）：</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片6.png" style="zoom:67%;">

<p>这里已经更改了jdbc.properties文件，多了一个连接主库的变量：jdbc.master.url</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-主从库同步与读写分离\图片7.png" style="zoom:67%;">

<p>配置动态数据源，创建DynamicDataSource类的对象dynamicDataSource，因为它继承了AbstractRoutingDataSource，所以它有一个成员变量targetDataSources是Map类型的，将定义好的两个bean加到这个成员变量中去；</p>
<p>因为数据源的选择只有在SQL语句执行时才会触发，所以引入一个类实现懒加载，将对象dynamicDataSource放到里面：</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-店铺注册功能模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1Dao层之新增店铺"><a href="#1-1Dao层之新增店铺" class="headerlink" title="1.1Dao层之新增店铺"></a>1.1Dao层之新增店铺</h1><h2 id="1-1-1创建ShopDao接口"><a href="#1-1-1创建ShopDao接口" class="headerlink" title="1.1.1创建ShopDao接口"></a>1.1.1创建ShopDao接口</h2><p><strong>接口中仅包含一个方法：插入店铺</strong></p>
<h2 id="1-1-2创建ShopDao-xml文件"><a href="#1-1-2创建ShopDao-xml文件" class="headerlink" title="1.1.2创建ShopDao.xml文件"></a>1.1.2创建ShopDao.xml文件</h2><p><strong>useGeneratedKeys=”true”：</strong>使用自增主键，表示店铺插入成功之后，将该店铺的主键值返回，为了<strong>后续图片插入能与店铺对应</strong>起来</p>
<p>INSERT INTO中的参数名是与数据库o2o表中的<strong>列名</strong>一一对应的；VALUES中是与实体类中的<strong>成员变量</strong>对应的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertShop&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">keyColumn</span>=<span class="string">&quot;shop_id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;shopId&quot;</span>&gt;</span></span><br><span class="line">		INSERT INTO</span><br><span class="line">		tb_shop(owner_id,area_id,shop_category_id,shop_name,shop_desc,shop_addr,</span><br><span class="line">		phone,shop_img,priority,create_time,last_edit_time,enable_status,advice)</span><br><span class="line">		VALUES</span><br><span class="line">		(#&#123;owner.userId&#125;,#&#123;area.areaId&#125;,#&#123;shopCategory.shopCategoryId&#125;,#&#123;shopName&#125;,</span><br><span class="line">		#&#123;shopDesc&#125;,#&#123;shopAddr&#125;,#&#123;phone&#125;,#&#123;shopImg&#125;,#&#123;priority&#125;,#&#123;createTime&#125;,#&#123;lastEditTime&#125;,</span><br><span class="line">		#&#123;enableStatus&#125;,#&#123;advice&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-3ShopDao接口测试"><a href="#1-1-3ShopDao接口测试" class="headerlink" title="1.1.3ShopDao接口测试"></a>1.1.3ShopDao接口测试</h2><p>同区域查询测试方法差不多</p>
<h1 id="1-2Dao层之更新店铺"><a href="#1-2Dao层之更新店铺" class="headerlink" title="1.2Dao层之更新店铺"></a>1.2Dao层之更新店铺</h1><h2 id="1-2-1在ShopDao中加入更新方法"><a href="#1-2-1在ShopDao中加入更新方法" class="headerlink" title="1.2.1在ShopDao中加入更新方法"></a>1.2.1在ShopDao中加入更新方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertShop</span><span class="params">(Shop shop)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 更新店铺信息</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shop</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">updateShop</span><span class="params">(Shop shop)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-2在ShopDao-xml中实现更新方法"><a href="#1-2-2在ShopDao-xml中实现更新方法" class="headerlink" title="1.2.2在ShopDao.xml中实现更新方法"></a>1.2.2在ShopDao.xml中实现更新方法</h2><p><strong>这里使用了动态SQL：</strong></p>
<p>当需要更新不同内容的值时，如果不使用动态SQL就需要多个更新方法实现，所以这里使用动态SQL只更新传入的不为NULL的列值</p>
<p><strong>格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;xxx是实体类中对应的字段名，xxx_xxx是数据库中对应的字段名</span><br><span class="line">&lt;if test&#x3D;&quot;xxx !&#x3D;null&quot;&gt;xxx_xxx&#x3D;#&#123;xxx&#125;,&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateShop&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">parameterType</span>=<span class="string">&quot;com.imooc.o2o.entity.Shop&quot;</span>&gt;</span></span><br><span class="line">		update tb_shop</span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopName !=null&quot;</span>&gt;</span>shop_name=#&#123;shopName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopDesc != null&quot;</span>&gt;</span>shop_desc=#&#123;shopDesc&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopAddr != null&quot;</span>&gt;</span>shop_addr=#&#123;shopAddr&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;phone != null&quot;</span>&gt;</span>phone=#&#123;phone&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopImg != null&quot;</span>&gt;</span>shop_img=#&#123;shopImg&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;priority != null&quot;</span>&gt;</span>priority=#&#123;priority&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;lastEditTime != null&quot;</span>&gt;</span>last_edit_time=#&#123;lastEditTime&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;enableStatus != null&quot;</span>&gt;</span>enable_status=#&#123;enableStatus&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;advice != null&quot;</span>&gt;</span>advice=#&#123;advice&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;area != null&quot;</span>&gt;</span>area_id=#&#123;area.areaId&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopCategory != null&quot;</span>&gt;</span>shop_category_id=#&#123;shopCategory.shopCategoryId&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where shop_Id=#&#123;shopId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-3ShopDao接口测试"><a href="#1-2-3ShopDao接口测试" class="headerlink" title="1.2.3ShopDao接口测试"></a>1.2.3ShopDao接口测试</h2><h1 id="1-3Thumbnailator图片处理和封装Util"><a href="#1-3Thumbnailator图片处理和封装Util" class="headerlink" title="1.3Thumbnailator图片处理和封装Util"></a>1.3Thumbnailator图片处理和封装Util</h1><h2 id="1-3-1导入Thumbnailator相关的-jar包"><a href="#1-3-1导入Thumbnailator相关的-jar包" class="headerlink" title="1.3.1导入Thumbnailator相关的.jar包"></a>1.3.1导入Thumbnailator相关的.jar包</h2><p>通过pom.xml导入Thumbnailator相关的.jar包</p>
<h2 id="1-3-2创建PathUtil工具类"><a href="#1-3-2创建PathUtil工具类" class="headerlink" title="1.3.2创建PathUtil工具类"></a>1.3.2创建PathUtil工具类</h2><p><strong>方法getImgBasePath：获取图片根路径</strong></p>
<ul>
<li>因为图片或者文件的处理要获取文件路径，所以创建一个工具类能够<strong>根据不同的系统获取文件的路径</strong></li>
<li>用Seperator变量获取系统文件的分隔符</li>
<li>获取系统名称</li>
<li>根据不同的系统名称获取变量</li>
</ul>
<p><strong>方法getShopImagePath：获取店铺图片相对子路径：</strong></p>
<ul>
<li>获取相对子路径并返回</li>
</ul>
<p><strong>后面的方法分别是获取头条和店铺类别图片的相对子路径</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String seperator = System.getProperty(<span class="string">&quot;file.separator&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getImgBasePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String os = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">		String basePath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (os.toLowerCase().startsWith(<span class="string">&quot;win&quot;</span>)) &#123;</span><br><span class="line">			basePath = <span class="string">&quot;D:/projectdev/image&quot;</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			basePath = <span class="string">&quot;/Users/baidu/work/image&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		basePath = basePath.replace(<span class="string">&quot;/&quot;</span>, seperator);</span><br><span class="line">		<span class="keyword">return</span> basePath;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShopImagePath</span><span class="params">(<span class="keyword">long</span> shopId)</span> </span>&#123;</span><br><span class="line">		String imagePath = <span class="string">&quot;/upload/images/item/shop/&quot;</span> + shopId + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> imagePath.replace(<span class="string">&quot;/&quot;</span>, seperator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHeadLineImagePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String imagePath = <span class="string">&quot;/upload/images/item/headtitle/&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> imagePath.replace(<span class="string">&quot;/&quot;</span>, seperator);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShopCategoryPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String imagePath = <span class="string">&quot;/upload/images/item/shopcategory/&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> imagePath.replace(<span class="string">&quot;/&quot;</span>, seperator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-3创建ImageUtil工具类"><a href="#1-3-3创建ImageUtil工具类" class="headerlink" title="1.3.3创建ImageUtil工具类"></a>1.3.3创建ImageUtil工具类</h2><p><strong>transferCommonsMultipartFileToFile方法：</strong>因为CommonsMultipartFile实现类只能通过前端的文件上传控件来初始化，而CommonsMultipartFile的构造方法中也不是用的File类的实例对象，因此将File类转换成CommonsMultipartFile是不现实的，InputStream类在我们对Service层进行junit测试时更便于初始化，因此要将CommonsMultipartFile转化成File类型</p>
<p>**==改进：==**如果图片类型为File类型，虽然方便我们做UT测试，但是controller调用时，每次都要讲InputStream转换成File类型，因此我们这里直接将类型从File类型装换成InputStream类型</p>
<p><strong>generateThumbnail方法：</strong></p>
<ul>
<li><p>先调用getRandomFileName方法得到一个随机的图片名称</p>
</li>
<li><p>再调用getFileExtension方法得到插入图片的扩展名称</p>
</li>
<li><p>调用makeDirPath方法创建目标路径</p>
</li>
<li><p>由targetAddr + realFileName + extension得到图片的<strong>相对路径</strong>地址</p>
<p>存为相对路径更有利于项目的移植，根路径可以通过getBasePath来获取</p>
</li>
</ul>
<p><strong>getRandomFileName方法：</strong>由随机生成的五位数还有当前的日期<strong>为插入的图片生成随机的文件名称</strong></p>
<p><strong>getFileExtension方法：</strong>由传入图片名称的最后一个点为分隔，<strong>获取图片的扩展名</strong></p>
<p><strong>makeDirPath方法：</strong>判断目标文件是否存在，如果不存在递归地生成该路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String basePath = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ImageUtil.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将CommonsMultipartFile转换成File类</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cFile</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">transferCommonsMultipartFileToFile</span><span class="params">(CommonsMultipartFile cFile)</span> </span>&#123;</span><br><span class="line">		File newFile = <span class="keyword">new</span> File(cFile.getOriginalFilename());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			cFile.transferTo(newFile);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newFile;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理缩略图，并返回新生成图片的相对值路径</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thumbnail</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetAddr</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateThumbnail</span><span class="params">(ImageHolder thumbnail, String targetAddr)</span> </span>&#123;</span><br><span class="line">		String realFileName = getRandomFileName();</span><br><span class="line">		String extension = getFileExtension(thumbnail.getImageName());</span><br><span class="line">		makeDirPath(targetAddr);</span><br><span class="line">		String relativeAddr = targetAddr + realFileName + extension;</span><br><span class="line">		logger.debug(<span class="string">&quot;current relativeAddr is:&quot;</span> + relativeAddr);</span><br><span class="line">		File dest = <span class="keyword">new</span> File(PathUtil.getImgBasePath() + relativeAddr);</span><br><span class="line">		logger.debug(<span class="string">&quot;current complete addr is:&quot;</span> + PathUtil.getImgBasePath() + relativeAddr);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thumbnails.of(thumbnail.getImage()).size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">					.watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\index.jpg&quot;</span>)), <span class="number">0.25f</span>)</span><br><span class="line">					.outputQuality(<span class="number">0.8f</span>).toFile(dest);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> relativeAddr;<span class="comment">// 存为相对路径更有利于项目的移植，根路径可以通过getBasePath来获取</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建目标路径所涉及到的目录，即/home/work/wangjin/xxx.jpg,那么home work wangjin 这三个文件夹都得自动创建出来</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetAddr</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeDirPath</span><span class="params">(String targetAddr)</span> </span>&#123;</span><br><span class="line">		String realFileParentPath = PathUtil.getImgBasePath() + targetAddr;</span><br><span class="line">		File dirPath = <span class="keyword">new</span> File(realFileParentPath);</span><br><span class="line">		<span class="keyword">if</span> (!dirPath.exists()) &#123;</span><br><span class="line">			dirPath.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取输入文件流的扩展名（jpg、pnm）</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thumbnail</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFileExtension</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成随机文件名，用当前的年月日小时分钟秒钟+五位随机数来保证随机文件名不一样</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRandomFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取随机的五位数</span></span><br><span class="line">		<span class="keyword">int</span> rannum = r.nextInt(<span class="number">89999</span>) + <span class="number">10000</span>;</span><br><span class="line">		String nowTimeStr = sDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">return</span> nowTimeStr + rannum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Thumbnails.of(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\xiaohuangren.jpg&quot;</span>)).size(<span class="number">1200</span>, <span class="number">1200</span>)</span><br><span class="line">				.watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\index.jpg&quot;</span>)), <span class="number">0.25f</span>)</span><br><span class="line">				.outputQuality(<span class="number">0.8f</span>).toFile(<span class="string">&quot;D:\\GitHub\\xintupian3.jpg&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-4Dto之ShopExecution的实现"><a href="#1-4Dto之ShopExecution的实现" class="headerlink" title="1.4Dto之ShopExecution的实现"></a>1.4Dto之ShopExecution的实现</h1><h2 id="1-4-1创建枚举类型来存储店铺的对应状态"><a href="#1-4-1创建枚举类型来存储店铺的对应状态" class="headerlink" title="1.4.1创建枚举类型来存储店铺的对应状态"></a>1.4.1创建枚举类型来存储店铺的对应状态</h2><ul>
<li><p>枚举实例：包括CHECK(0, “审核中”), OFFLINE(-1, “非法店铺”)类似的，需要什么状态就在这里添加，最后要用分号结束</p>
</li>
<li><p>定义两个私有的成员变量：状态和状态信息</p>
</li>
<li><p>定义构造方法：分别对应构造失败时使用的构造方法和构造成功时使用的构造方法</p>
<p><strong>stateOf方法：</strong>根据传入的状态值返回相应的状态信息到前端</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopExecution</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 结果状态</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态标识(以文字的形式来解释state的状态)</span></span><br><span class="line">	<span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 操作的shop（增删改店铺的时候用到）</span></span><br><span class="line">	<span class="keyword">private</span> Shop shop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shop列表（查询店铺列表的时候使用）</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Shop&gt; shopList;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个枚举类型中存储的是状态值，针对失败的时候去生成的ShopExecution对象，</span></span><br><span class="line">	<span class="comment">//因此是店铺操作失败的时候使用的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回Shop对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回ShopList对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateInfo</span><span class="params">(String stateInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Shop <span class="title">getShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShop</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Shop&gt; <span class="title">getShopList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShopList</span><span class="params">(List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-4-2创建ShopExecution类"><a href="#1-4-2创建ShopExecution类" class="headerlink" title="1.4.2创建ShopExecution类"></a>1.4.2创建ShopExecution类</h2><p><strong>成员变量：</strong></p>
<ul>
<li>状态值和状态信息：店铺插入成功或失败的返回信息</li>
<li>店铺数量</li>
<li>操作的店铺：存储当前操作的店铺</li>
<li>店铺列表：当查询店铺时，将查询结果存储到店铺列表中</li>
</ul>
<p><strong>构造方法：</strong></p>
<ul>
<li>店铺操作失败的时候使用的构造器：当操作失败时，仅将失败的信息赋值给ShopExecution对象的状态值和状态信息</li>
<li>店铺操作成功时候使用的构造器：当操作成功，除了返回状态信息外，还要将店铺赋值给ShopExecution对象的shop变量中</li>
<li>店铺操作成功时候使用的构造器：当操作成功时，将店铺的列表赋值给ShopExecution对象的shoplist变量中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopExecution</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 结果状态</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态标识(以文字的形式来解释state的状态)</span></span><br><span class="line">	<span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 操作的shop（增删改店铺的时候用到）</span></span><br><span class="line">	<span class="keyword">private</span> Shop shop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shop列表（查询店铺列表的时候使用）</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Shop&gt; shopList;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个枚举类型中存储的是状态值，针对失败的时候去生成的ShopExecution对象，</span></span><br><span class="line">	<span class="comment">//因此是店铺操作失败的时候使用的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回Shop对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回ShopList对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateInfo</span><span class="params">(String stateInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Shop <span class="title">getShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShop</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Shop&gt; <span class="title">getShopList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShopList</span><span class="params">(List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-5店铺注册之Service层的实现"><a href="#1-5店铺注册之Service层的实现" class="headerlink" title="1.5店铺注册之Service层的实现"></a>1.5店铺注册之Service层的实现</h1><h2 id="1-5-1创建ShopService接口"><a href="#1-5-1创建ShopService接口" class="headerlink" title="1.5.1创建ShopService接口"></a>1.5.1创建ShopService接口</h2><p><strong>只有一个addShop方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注册店铺信息，包括图片处理</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shop</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shopImgInputStream</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ShopOperationException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">ShopExecution <span class="title">addShop</span><span class="params">(Shop shop, ImageHolder thumbnail)</span> <span class="keyword">throws</span> ShopOperationException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-2创建ShopServiceImpl实现ShopService接口"><a href="#1-5-2创建ShopServiceImpl实现ShopService接口" class="headerlink" title="1.5.2创建ShopServiceImpl实现ShopService接口"></a>1.5.2创建ShopServiceImpl实现ShopService接口</h2><p><strong>addShop方法的实现：将店铺的信息和店铺的图片信息插入到数据库中</strong></p>
<ul>
<li><p>通过@Transactional引入事务管理：因为该方法包括在数据库中存入店铺信息、插入图片等多个操作，其中一个操作不成功就要回滚</p>
</li>
<li><p>注入ShopDao实例</p>
</li>
<li><p>首先判断店铺是否为空</p>
<p>如果为空调用ShopExecution类中操作失败的构造器，将对应的状态赋值给ShopExecution对象</p>
<p>如果不为空，设置店铺的状态、创建时间和最近修改时间</p>
</li>
<li><p>调用ShopDao的insertShop方法：插入传入的对象</p>
<p>如果返回的影响行数小于等于0，说明店铺插入失败，通过ShopOperationException抛出异常信息</p>
<p><strong>注：</strong>ShopOperationException要继承RuntimeException类，只有这个类抛出异常信息时，才会回滚，普通的抛出异常信息不会</p>
</li>
<li><p>存储图片信息：</p>
<p>先判断图片的信息是否为空，空则抛出异常，不为空就调用addShopImg方法将图片信息插入</p>
</li>
<li><p>店铺和图片都插入成功之后，通过ShopExecution操作成功的构造方法，将店铺的状态和相应的店铺对象赋值给ShopExecution创建ShopExecution对象并返回该对象</p>
</li>
</ul>
<p><strong>addShopImg方法的实现：</strong></p>
<ul>
<li>通过shopId获取图片存储的相对值路径</li>
<li>调用ImageUtil工具类的generateThumbnail方法，得到图片的相对值路径，并赋值给相应的店铺ShopImg成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopServiceImpl</span> <span class="keyword">implements</span> <span class="title">ShopService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ShopServiceImpl.class);</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopDao shopDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ShopExecution <span class="title">addShop</span><span class="params">(Shop shop, ImageHolder thumbnail)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ShopOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// 空值判断，判断shop中是否包含必须的值</span></span><br><span class="line">		<span class="keyword">if</span> (shop == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.NULL_SHOP);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 给店铺信息赋初始值（状态为0，审核中；以及创建时间和最近修改时间）</span></span><br><span class="line">			shop.setEnableStatus(<span class="number">0</span>);</span><br><span class="line">			shop.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">			shop.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">			<span class="comment">// 添加店铺信息：成功→else；失败→进入店铺创建失败</span></span><br><span class="line">			<span class="keyword">int</span> effectedNum = shopDao.insertShop(shop);</span><br><span class="line">			<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;店铺创建失败&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (thumbnail.getImage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 存储图片(参数shop:根据shopId得到图片的地址，参数shopImg:保存到相应的地址中)</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						addShopImg(shop, thumbnail);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;addShopImg error:&quot;</span> + e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 更新店铺的图片地址</span></span><br><span class="line">					effectedNum = shopDao.updateShop(shop);</span><br><span class="line">					<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;更新图片地址失败&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;addShop error:&quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.CHECK, shop);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addShopImg</span><span class="params">(Shop shop, ImageHolder thumbnail)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取shop图片目录的相对值路径</span></span><br><span class="line">		String dest = PathUtil.getShopImagePath(shop.getShopId());</span><br><span class="line">		String shopImgAddr = ImageUtil.generateThumbnail(thumbnail, dest);</span><br><span class="line">		shop.setShopImg(shopImgAddr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-3创建ShopOperationException类"><a href="#1-5-3创建ShopOperationException类" class="headerlink" title="1.5.3创建ShopOperationException类"></a>1.5.3创建ShopOperationException类</h2><p><strong>该类对于RuntimeException做了一个简单的封装，用于更好地看出是程序的哪个类或者操作抛出的异常信息</strong></p>
<ul>
<li>该类继承了RuntimeException类（<strong>当该类抛出异常时，用事务管理的方法就会回滚</strong>）</li>
<li>只有一个构造方法</li>
<li>有一个序列化的ID</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopOperationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2361446884822298905L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopOperationException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-4Service层的测试"><a href="#1-5-4Service层的测试" class="headerlink" title="1.5.4Service层的测试"></a>1.5.4Service层的测试</h2><h1 id="1-6店铺注册功能之Controller层的实现"><a href="#1-6店铺注册功能之Controller层的实现" class="headerlink" title="1.6店铺注册功能之Controller层的实现"></a>1.6店铺注册功能之Controller层的实现</h1><ul>
<li><p>通过@Controller标签告诉spring该类为Controller类型</p>
</li>
<li><p>设置根路由为：/shopadmin</p>
</li>
<li><p>注入所需要的的实例对象</p>
</li>
<li><p>设置方法的路由为：/registershop</p>
</li>
<li><p>设置访问的方法为POST：向指定资源提交数据进行处理请求</p>
</li>
<li><p><strong>registerShop方法的实现：</strong>（三部分）</p>
<p>方法传入的参数为：HttpServletRequest类型，url的请求头都会封装到该类的对象中，通过调用相关的方法就能获取传入的店铺相关的所有参数</p>
<p>返回类型为：Map类型，@ResponseBody标签将Map转换成json类型</p>
<p>创建modelMap用于保存方法的执行结果</p>
<p><strong>1.接收并转化相应的参数，包括店铺信息以及图片信息</strong></p>
<p>通过HttpServletRequestUtil中的getString方法，将request中key为shopStr对应的值转换成String，并用shopStr接收；</p>
<p>创建ObjectMapper对象，将json串转换成实体类shop</p>
<p>转换图片文件，创建文件上传解析器CommonsMultipartResolver，在request会话的上下文中获取文件信息，当CommonsMultipartResolver中的内容不为空，将request转换成MultipartHttpServletRequest类型的对象，再从multipartHttpServletRequest对象中取出shopImg变量的信息转换成CommonsMultipartFile，也就是spring能够处理的类型</p>
<p><strong>2.注册店铺</strong></p>
<p><strong>通过session获取店家信息：</strong>在登陆时，我们将user信息写入到session中，key设为user，这里从session中取出即可</p>
<p>当店铺和图片信息都不为空时，程序开始执行</p>
<p>从当前请求的request中取出user对应的owner信息</p>
<p>将CommonsMultipartFile类型的shopImg转换成InputStream，满足addShop方法参数要求</p>
<p>调用shopService中的addShop方法，将店铺和店铺图片封装成ShopExecution对象</p>
<p>将注册好的店铺插入到用户可操作的店铺列表中：在会话中取出用户可操作的店铺列表，没有就创建，有就取出，添加新店铺后，再将列表填入到session中</p>
<p><strong>3.返回结果</strong></p>
<p>将每步操作的执行结果放入modelMap，转换成json返回给前端</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shopadmin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopManagementController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopService shopService;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopCategoryService shopCategoryService;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AreaService areaService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/registershop&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">registerShop</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.接收并转化相应的参数，包括店铺信息以及图片信息</span></span><br><span class="line">		String shopStr = HttpServletRequestUtil.getString(request, <span class="string">&quot;shopStr&quot;</span>);</span><br><span class="line">		ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		Shop shop = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			shop = mapper.readValue(shopStr, Shop.class);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		CommonsMultipartFile shopImg = <span class="keyword">null</span>;</span><br><span class="line">		CommonsMultipartResolver commonsMultipartResolver = <span class="keyword">new</span> CommonsMultipartResolver(</span><br><span class="line">				request.getSession().getServletContext());</span><br><span class="line">		<span class="keyword">if</span> (commonsMultipartResolver.isMultipart(request)) &#123;</span><br><span class="line">			MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request;</span><br><span class="line">			shopImg = (CommonsMultipartFile) multipartHttpServletRequest.getFile(<span class="string">&quot;shopImg&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;上传图片不能为空&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.注册店铺</span></span><br><span class="line">		<span class="keyword">if</span> (shop != <span class="keyword">null</span> &amp;&amp; shopImg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			PersonInfo owner = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			shop.setOwner(owner);</span><br><span class="line">			ShopExecution se;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ImageHolder imageHolder = <span class="keyword">new</span> ImageHolder(shopImg.getOriginalFilename(), shopImg.getInputStream());</span><br><span class="line">				se = shopService.addShop(shop, imageHolder);</span><br><span class="line">				<span class="keyword">if</span> (se.getState() == ShopStateEnum.CHECK.getState()) &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">					<span class="comment">// 该用户可以操作的店铺列表</span></span><br><span class="line">					<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">					List&lt;Shop&gt; shopList = (List&lt;Shop&gt;) request.getSession().getAttribute(<span class="string">&quot;shopList&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span> (shopList == <span class="keyword">null</span> || shopList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">						shopList = <span class="keyword">new</span> ArrayList&lt;Shop&gt;();</span><br><span class="line">					&#125;</span><br><span class="line">					shopList.add(se.getShop());</span><br><span class="line">					request.getSession().setAttribute(<span class="string">&quot;shopList&quot;</span>, shopList);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">					modelMap.put(<span class="string">&quot;errMsg&quot;</span>, se.getStateInfo());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ShopOperationException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;请输入店铺信息&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-1创建工具类HttpServletRequestUtil"><a href="#1-6-1创建工具类HttpServletRequestUtil" class="headerlink" title="1.6.1创建工具类HttpServletRequestUtil"></a>1.6.1创建工具类HttpServletRequestUtil</h2><p><strong>HttpServletRequestUtil用于转换HttpServletRequest中的数据，传入一个key，将这个key对应的值转换成相应的数据类型的值。</strong></p>
<h1 id="1-9店铺注册之前端设计"><a href="#1-9店铺注册之前端设计" class="headerlink" title="1.9店铺注册之前端设计"></a>1.9店铺注册之前端设计</h1><h2 id="1-9-1SUI-Mobile介绍"><a href="#1-9-1SUI-Mobile介绍" class="headerlink" title="1.9.1SUI Mobile介绍"></a>1.9.1SUI Mobile介绍</h2><p>SUI Mobile 是一套基于 <a href="http://framework7.taobao.org/">Framework7</a> 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。</p>
<h2 id="1-9-2创建shopoperation-html页面"><a href="#1-9-2创建shopoperation-html页面" class="headerlink" title="1.9.2创建shopoperation.html页面"></a>1.9.2创建shopoperation.html页面</h2><p><strong>分段介绍shopoperation.html的作用：</strong></p>
<p><strong>1.表头提供设备方面的信息，能根据设备的属性来调整页面到适合设备的尺寸</strong></p>
<p><strong>2.表头之下引入css文件</strong></p>
<p>这里的css文件要在js静态资源之前，是因为在加载html页面时，我们要先生成页面的轮廓或者布局，再将静态资源填到页面中</p>
<p><strong>3.主体</strong></p>
<ul>
<li><strong>li标签：</strong>页面显示中的一些控件等，</li>
<li><strong>id：</strong>通过给这些控件加<strong>id</strong>命名，可以方便在js代码中对这些控件进行选中、响应或其他操作</li>
<li><strong>input type：</strong>控件的类型</li>
</ul>
<p><strong>4.结尾</strong></p>
<ul>
<li><strong>给出静态资源的位置，导入必要的.css文件和.js文件</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>SUI Mobile Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">content</span>=<span class="string">&quot;MSUI: Build mobile apps with simple HTML, CSS, and JS components.&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;阿里巴巴国际UED前端&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Google Web Fonts --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">href</span>=<span class="string">&quot; //g.alicdn.com/msui/sm/0.6.2/css/sm.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">href</span>=<span class="string">&quot; //g.alicdn.com/msui/sm/0.6.2/css/sm-extend.min.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">href</span>=<span class="string">&quot;/assets/img/apple-touch-icon-114x114.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">//ga</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-group&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;page-label-input&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;bar bar-nav&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;button button-link button-nav pull-left back&quot;</span></span></span><br><span class="line"><span class="tag">					<span class="attr">href</span>=<span class="string">&quot;/demos/form&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon icon-left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 返回</span><br><span class="line">				<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>商店信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list-block&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- Text inputs --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>商铺名称<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shop-name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;商铺名称&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				</span><br><span class="line">						<span class="comment">&lt;!-- 商铺分类 下拉列表 --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>商铺分类<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;shop-category&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 区域分类 下拉列表 --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>所属区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;area&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 详细地址 text --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>详细地址<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shop-addr&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;详细地址&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 联系电话 text --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>联系电话<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shop-phone&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;联系电话&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 缩略图 上传控件 --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>缩略图<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shop-img&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 店铺简介 textarea --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;align-top&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>店铺简介<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;shop-desc&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;店铺简介&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="comment">&lt;!-- 验证码 kaptcha --&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;j_captcha&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;验证码&quot;</span>&gt;</span></span><br><span class="line">									<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">										<span class="tag">&lt;<span class="name">img</span> <span class="attr">type</span>=<span class="string">&quot;captcha_img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;点击更换&quot;</span> <span class="attr">title</span>=<span class="string">&quot;点击更换&quot;</span></span></span><br><span class="line"><span class="tag">										<span class="attr">onclick</span>=<span class="string">&quot;changeVerifyCode(this)&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../Kaptcha&quot;</span>/&gt;</span></span><br><span class="line">									<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-block&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-50&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button button-big button-fill button-danger&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-50&quot;</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button button-big button-fill button-success&quot;</span></span></span><br><span class="line"><span class="tag">								<span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">src</span>=<span class="string">&#x27;//g.alicdn.com/sj/lib/zepto/zepto.min.js&#x27;</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">src</span>=<span class="string">&#x27;//g.alicdn.com/msui/sm/0.6.2/js/sm.min.js&#x27;</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">src</span>=<span class="string">&#x27;//g.alicdn.com/msui/sm/0.6.2/js/sm-extend.min.js&#x27;</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">src</span>=<span class="string">&#x27;../resources/js/common/common.js&#x27;</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">src</span>=<span class="string">&#x27;../resources/js/shop/shopoperation.js&#x27;</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-9-3创建ShopAdminController"><a href="#1-9-3创建ShopAdminController" class="headerlink" title="1.9.3创建ShopAdminController"></a>1.9.3创建ShopAdminController</h2><p>我们为了隐藏我们的项目结构，不能直接在url中体现我们shopoperation.html页面的位置，但是放在WEB-INF下外部是访问不到的，因此创建ShopAdminController根据url进行页面的转发：</p>
<p>这个返回的字符串再与spring-web中配置的前后缀拼接，得到页面的全路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.web.shopadmin;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;shopadmin&quot;, method = &#123; RequestMethod.GET &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopAdminController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/shopoperation&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">shopOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//转发至店铺操作页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/shopoperation&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/shoplist&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">shopList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//转发至店铺列表页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/shoplist&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/shopmanagement&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">shopManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//转发至店铺管理页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/shopmanagement&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/productcategorymanagement&quot;, method = RequestMethod.GET)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">productCategoryManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//转发至商品类别管理页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/productcategorymanagement&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/productoperation&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">productOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//转发至商品添加/编辑页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/productoperation&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@RequestMapping(value = &quot;/productmanagement&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">productManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 转发至商品管理页面</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;shop/productmanagement&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-4店铺注册之js实现"><a href="#1-9-4店铺注册之js实现" class="headerlink" title="1.9.4店铺注册之js实现"></a>1.9.4店铺注册之js实现</h2><p> 创建<strong>shopoperation.js文件</strong>，这个文件的功能为<strong>操作html页面</strong>：</p>
<ul>
<li>获取初始的信息，将一些信息填充到控件中</li>
<li>当我们点击提交时，获取表单的信息，并通过ajax将这个json对象传递到后端</li>
</ul>
<p>所有动作都是<strong>异步</strong>的，不影响用户的前端体验</p>
<p><strong>功能一的实现：</strong></p>
<ul>
<li><p>定义两个url：一个是获取店铺信息的url，另一个是注册店铺的url</p>
</li>
<li><p>方法getShopInitInfo：</p>
<p>通过获取店铺信息的url从后端获取区域和店铺列表数据data</p>
<p>如果json中key=success为true，开始遍历json中的区域和店铺信息，并将它们填充到html页面的相应控件中</p>
</li>
</ul>
<p><strong>功能二的实现：</strong></p>
<ul>
<li><p>从html页面的各个控件中选择其中的内容放到shop集合中，特殊的像区域和店铺类型要将用户的选择放到集合中</p>
</li>
<li><p>ajax将shop集合转换成json对象，通过注册店铺的url将这些数据返回到后端的方法中</p>
</li>
</ul>
<h1 id="1-10引入kaptcha实现验证码"><a href="#1-10引入kaptcha实现验证码" class="headerlink" title="1.10引入kaptcha实现验证码"></a>1.10引入kaptcha实现验证码</h1><h2 id="1-10-1引入kaptcha的jar包"><a href="#1-10-1引入kaptcha的jar包" class="headerlink" title="1.10.1引入kaptcha的jar包"></a>1.10.1引入kaptcha的jar包</h2><p>在pom.xml加入kaptcha的jar包</p>
<h2 id="1-10-2在web-xml中创建验证码的servlet"><a href="#1-10-2在web-xml中创建验证码的servlet" class="headerlink" title="1.10.2在web.xml中创建验证码的servlet"></a>1.10.2在web.xml中创建验证码的servlet</h2><p>servlet是运行在服务器上的一个小程序，用来处理服务器请求的（或者理解为与用户交互的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt;</span><br><span class="line">		&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">google</span>.<span class="title">code</span>.<span class="title">kaptcha</span>.<span class="title">servlet</span>.<span class="title">KaptchaServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 接下来定义<span class="title">servlet</span>的样式 --&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 是否有边框 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">border</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">no</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 字体颜色 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">font</span>.<span class="title">color</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">red</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 图片宽度 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">image</span>.<span class="title">width</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;135&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 使用哪些字符来生成验证码 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">char</span>.<span class="title">string</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">ACDEFHKPRSTWX345679</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 图片高度 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">image</span>.<span class="title">height</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;50&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 字体大小 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">font</span>.<span class="title">size</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;43&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 干扰线的颜色 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">noise</span>.<span class="title">color</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">black</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 字符个数 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">char</span>.<span class="title">length</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;4&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;!-- 字体 --&gt;</span></span><br><span class="line"><span class="class">		&lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">kaptcha</span>.<span class="title">textproducer</span>.<span class="title">font</span>.<span class="title">names</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">			&lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">Arial</span>&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">		&lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;!-- <span class="title">servlet</span>-<span class="title">mapping</span>响应/<span class="title">Kaptcha</span>的请求 --&gt;</span></span><br><span class="line"><span class="class">	&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">	   &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">Kaptcha</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">	   &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">Kaptcha</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">	&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>每个servlet都要有映射！：</strong>如果不加映射，会找不到对应的servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet-name指向servlet的注册名称 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- url-pattern 设置servlet对外访问的路径（一定要加斜杠） --&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：这里对验证码这个servlet的请求为<a href="http://localhost:8080/o2o/Kaptcha%EF%BC%8C%E6%98%A0%E5%B0%84%E4%BC%9A%E7%94%B1/Kaptcha%E6%98%A0%E5%B0%84%E5%88%B0servlet%E7%9A%84%E6%B3%A8%E5%86%8C%E5%90%8D%E7%A7%B0Kaptcha%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81servlet">http://localhost:8080/o2o/Kaptcha，映射会由/Kaptcha映射到servlet的注册名称Kaptcha，找到对应的验证码servlet</a></p>
<h2 id="1-10-3在html中加入kaptcha控件"><a href="#1-10-3在html中加入kaptcha控件" class="headerlink" title="1.10.3在html中加入kaptcha控件"></a>1.10.3在html中加入kaptcha控件</h2><ul>
<li><strong>id：</strong>验证码控件的名称</li>
<li><strong>changeVerifyCode：</strong>自定义的一个方法，即点击本身更换验证码</li>
<li><strong>src：</strong>指定验证码的servlet</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">                   <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-content&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-inner&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-title label&quot;</span>&gt;</span>验证码<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;j_captcha&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;验证码&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item-input&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">img</span> <span class="attr">type</span>=<span class="string">&quot;captcha_img&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;点击更换&quot;</span> <span class="attr">title</span>=<span class="string">&quot;点击更换&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">onclick</span>=<span class="string">&quot;changeVerifyCode(this)&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../Kaptcha&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-10-4创建js文件，实现kaptcha控件中changeVerifyCode方法"><a href="#1-10-4创建js文件，实现kaptcha控件中changeVerifyCode方法" class="headerlink" title="1.10.4创建js文件，实现kaptcha控件中changeVerifyCode方法"></a>1.10.4创建js文件，实现kaptcha控件中changeVerifyCode方法</h2><h2 id="1-10-5将kaptcha控件中的内容传入后台"><a href="#1-10-5将kaptcha控件中的内容传入后台" class="headerlink" title="1.10.5将kaptcha控件中的内容传入后台"></a>1.10.5将kaptcha控件中的内容传入后台</h2><p>将kaptcha控件中的内容读取到js文件中，在js文件里读取控件内容，将验证码内容读取保存到json中，通过ajax传到后台</p>
<h2 id="1-10-6创建CodeUtil工具类"><a href="#1-10-6创建CodeUtil工具类" class="headerlink" title="1.10.6创建CodeUtil工具类"></a>1.10.6创建CodeUtil工具类</h2><ul>
<li>CodeUtil工具类用于比较图片中实际的验证码与输入的验证码是否一致</li>
<li>图片中的验证码是从请求会话中得到的</li>
<li>在店铺注册中调用工具类来比较验证码是否一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用于判断验证码是否符合预期的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeUtil</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkVerifyCode</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	   <span class="comment">//获取会话中实际的验证码</span></span><br><span class="line">	   String verifyCodeExpected=(String)request.getSession().getAttribute(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY);</span><br><span class="line">		   </span><br><span class="line"><span class="comment">//	   String verifyCodeExpected=(String) request.getSession()</span></span><br><span class="line"><span class="comment">//			   .getAttribute(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_CONFIG_KEY);</span></span><br><span class="line">	   <span class="comment">//获取实际输入的验证码</span></span><br><span class="line">	   String verifyCodeActual=HttpServletRequestUtil.getString(request, <span class="string">&quot;verifyCodeActual&quot;</span>);</span><br><span class="line">	   <span class="comment">//对比实际的验证码和输入的验证码是否一致</span></span><br><span class="line">	   <span class="keyword">if</span>(verifyCodeActual==<span class="keyword">null</span>||!verifyCodeActual.equals(verifyCodeExpected)) &#123;</span><br><span class="line">		   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-11前后端联合调试"><a href="#1-11前后端联合调试" class="headerlink" title="1.11前后端联合调试"></a>1.11前后端联合调试</h1><ol>
<li><p>以Debug方式启动Tomcat</p>
</li>
<li><p>在前端打断点，<strong>建议设置在明确执行的方法的入口处</strong>，这里我们选择设置在<code>点击提交按钮</code>后的代码处</p>
</li>
<li><p>后端打断点，在店铺注册的Controller方法的入口处</p>
</li>
<li><p>在前端打断点，在ajax中的弹出结果信息方法入口处</p>
</li>
<li><p>输入店铺的注册信息，输入验证码，点击提交，执行到前端js中的断点位置</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-店铺注册功能模块\图片1.png" style="zoom:80%;">
</li>
<li><p>在js代码逻辑中获取表单的各项信息，并将验证码也填入集合对象中</p>
</li>
<li><p>ajax通过注册店铺的url进入后端店铺注册的Controller方法中的断点处</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-店铺注册功能模块\图片2.png" style="zoom:80%;">
</li>
<li><p>方法执行结束，返回前端，弹出执行的结果信息</p>
</li>
</ol>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-店铺注册功能模块\图片3.png" style="zoom:80%;">]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-Logback配置与使用</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-Logback%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="3-1Logback介绍"><a href="#3-1Logback介绍" class="headerlink" title="3.1Logback介绍"></a>3.1Logback介绍</h1><h2 id="3-1-1使用日志的目的"><a href="#3-1-1使用日志的目的" class="headerlink" title="3.1.1使用日志的目的"></a>3.1.1使用日志的目的</h2><ul>
<li>做故障定位 </li>
<li>显示程序运行状态</li>
</ul>
<h2 id="3-1-2日志的三个主要模块"><a href="#3-1-2日志的三个主要模块" class="headerlink" title="3.1.2日志的三个主要模块"></a>3.1.2日志的三个主要模块</h2><ul>
<li><p><strong>logback-access</strong></p>
<p><strong>第三方的软件</strong>可以通过logback-access访问我们日志记录的内容</p>
</li>
<li><p><strong>logback-classic</strong></p>
<p>方便更换成其它的日志系统</p>
</li>
<li><p><strong>logback-core</strong></p>
<p>为以上的两个模块提供基础</p>
</li>
</ul>
<h2 id="3-1-3日志的三个标签"><a href="#3-1-3日志的三个标签" class="headerlink" title="3.1.3日志的三个标签"></a>3.1.3日志的三个标签</h2><ul>
<li><p><strong>logger</strong></p>
<p>存放日志的对象，定义日志的类型还有级别等信息</p>
</li>
<li><p><strong>appender</strong></p>
<p>指定日志输出的媒介，比如：控制台，文件，远程套接字服务器等</p>
</li>
<li><p><strong>layout</strong></p>
<p>格式化日志信息的输出</p>
</li>
</ul>
<h1 id="3-2Logback的配置"><a href="#3-2Logback的配置" class="headerlink" title="3.2Logback的配置"></a>3.2Logback的配置</h1><p><strong>总结：</strong></p>
<ul>
<li>定义扫描属性</li>
<li>设置默认级别</li>
<li>日志的最大保留时间</li>
<li>日志的存储路径</li>
<li>日志的输出格式</li>
<li>日志的输出媒介</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">//1.定义扫描属性，间隔60秒更新一次看是否变化了</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义参数常量 --&gt;</span> </span><br><span class="line">    //2.也就是定义全局变量</span><br><span class="line">	<span class="comment">&lt;!-- 日志的级别：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- logger.trace(&quot;msg&quot;) logger.debug... --&gt;</span></span><br><span class="line">    //3.设置级别，默认级别为debug</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.level&quot;</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    //4.最大的保留历史的时间为30</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.maxHistory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">    //5.设置日志存储的根路径</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.filePath&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&quot;$&#123;catalina.base&#125;/logs/webapps&quot;</span> /&gt;</span></span><br><span class="line">    //6.定义日志展现的格式：时间格式||哪个线程执行的||哪个级别的日志||哪个包下的哪个类||日志信息</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%thread]%-5level %logger&#123;50&#125;-%msg%n&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 控制台设置 --&gt;</span></span><br><span class="line">    //7.设置输出媒介——控制台</span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            //8.定义log的输出格式（encoder既将输出转换成字符串，又将字符串保存到文件中）</span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- DEBUG --&gt;</span></span><br><span class="line">    //8.设置输出媒介——文件（该文件随着滚动，它的size不断增大）</span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;debugAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">        //9.输出媒介的文件路径</span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">            //10.输出媒介的文件名称</span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            //11.输出媒介的文件最大保存历史数量</span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            //12.设置输出格式</span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        //13.设置过滤器，只保留DEBUG相关的日志</span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- INFO --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;infoAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ERROR --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;errorAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    //14.将logger与appender绑定，表示logger对象会往绑定的三个文件中输出日志信息</span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.imooc.o2o&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;log.level&#125;&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;debugAppender&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;infoAppender&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;errorAppender&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleAppender&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-3验证配置"><a href="#3-3验证配置" class="headerlink" title="3.3验证配置"></a>3.3验证配置</h1><p><strong>1.调用方法生成logger对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger=LoggerFactory.getLogger(AreaController.class);</span><br></pre></td></tr></table></figure>

<p><strong>2.打印日志信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;===start===&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.error(<span class="string">&quot;test error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;constTime:[&#123;&#125;ms]&quot;</span>,endTime-startTime);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-项目设计和框架搭建</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="2-1系统功能模块划分"><a href="#2-1系统功能模块划分" class="headerlink" title="2.1系统功能模块划分"></a>2.1系统功能模块划分</h1><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片1.png" style="zoom:80%;">



<p>2.1.1前端展示系统</p>
<ul>
<li><p>头条展示：通过轮播图的形式，将数据库中的头条图片展示出来</p>
</li>
<li><p>店铺类别展示：将一级类别展示出来</p>
</li>
<li><p>区域展示</p>
</li>
<li><p>店铺：</p>
<p>列表展示（点击全部商店）</p>
<p>查询店铺（搜索框）</p>
<p>查看店铺详情</p>
</li>
<li><p>商品（同上）</p>
</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片2.png" style="zoom:80%;">

<p>2.1.2店家系统</p>
<ul>
<li>Local账号维护（注册账户、与微信账号绑定）</li>
<li>微信账号维护（支持微信登录）</li>
<li>店铺信息维护</li>
<li>权限验证（检测账号是否具有相关的权限去修改商品信息）</li>
<li>商品类别维护</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片3.png" style="zoom:80%;">

<p>2.1.3 超级管理员系统</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片4.png" style="zoom:80%;">

<h1 id="2-2实体类与表创建A"><a href="#2-2实体类与表创建A" class="headerlink" title="2.2实体类与表创建A"></a>2.2实体类与表创建A</h1><h2 id="2-2-1实体类的框架"><a href="#2-2-1实体类的框架" class="headerlink" title="2.2.1实体类的框架"></a>2.2.1实体类的框架</h2><h3 id="2-2-1-1项目1-0实体类框架："><a href="#2-2-1-1项目1-0实体类框架：" class="headerlink" title="2.2.1.1项目1.0实体类框架："></a>2.2.1.1项目1.0实体类框架：</h3><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片5.png" style="zoom:80%;">

<h3 id="2-2-1-2区域"><a href="#2-2-1-2区域" class="headerlink" title="2.2.1.2区域"></a>2.2.1.2区域</h3><ul>
<li><strong>区域ID：</strong>主键（自增+1）</li>
<li><strong>名称：</strong>唯一键，区域名称不能重复</li>
<li>权重：权重越大，排序越靠前</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
<li>更新时间</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片6.png" style="zoom:80%;">

<h3 id="2-2-1-3用户"><a href="#2-2-1-3用户" class="headerlink" title="2.2.1.3用户"></a>2.2.1.3用户</h3><ul>
<li><p><strong>用户ID：</strong>主键（自增+1）</p>
</li>
<li><p>姓名：</p>
</li>
<li><p>性别：</p>
</li>
<li><p><strong>状态：</strong>标志用户是否有资格进入商城对商铺和商品信息做操作</p>
<p>能操作：1</p>
<p>不能操作：0</p>
</li>
<li><p><strong>身份标识：</strong></p>
<p>顾客：1</p>
<p>店家：2</p>
<p>超级管理员：3</p>
</li>
<li><p>头像：存储头像的地址</p>
</li>
<li><p>邮箱</p>
</li>
<li><p>创建时间</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<h3 id="2-2-1-4微信账号与本地账号"><a href="#2-2-1-4微信账号与本地账号" class="headerlink" title="2.2.1.4微信账号与本地账号"></a>2.2.1.4微信账号与本地账号</h3><p><strong>微信账号：</strong></p>
<ul>
<li><p>ID：主键（自增+1）</p>
</li>
<li><p><strong>用户ID：</strong>作为<strong>外键</strong>与<strong>用户信息</strong>关联</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//创建外键：</span><br><span class="line">constraint `外键名称` foreign key(`要指定为外键的列`) references `与哪个表关联`(`关联表的主键`)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>openID：</strong>设置为<strong>唯一索引</strong>，来<strong>提升查询的性能</strong>，微信账号与微信公众号绑定的标识</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
</ul>
<p><strong>本地账号：</strong></p>
<ul>
<li>ID：主键（自增+1） </li>
<li><strong>用户ID：</strong>作为<strong>外键</strong>与<strong>用户信息</strong>关联</li>
<li><strong>用户名：</strong>唯一键，用户名不能重复</li>
<li>密码</li>
<li>创建时间</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片7.png" style="zoom:80%;">

<h3 id="2-2-1-5头条"><a href="#2-2-1-5头条" class="headerlink" title="2.2.1.5头条"></a>2.2.1.5头条</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p>名称：唯一键，区域名称不能重复</p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>状态：表示头条是否可用</p>
<p>可用：0</p>
<p>不可用：1</p>
</li>
<li><p>链接：点击首页的头条会链接到相应的url</p>
</li>
<li><p>图片</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片8.png" style="zoom:80%;">

<h3 id="2-2-1-6店铺类别"><a href="#2-2-1-6店铺类别" class="headerlink" title="2.2.1.6店铺类别"></a>2.2.1.6店铺类别</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>上级ID：</strong>上级ID为null时就是我们的根类，往下就是子类 </p>
<p>作为外键使用，与表本身的tb_shop_category链接起来，也就是它的父类是哪个类</p>
</li>
<li><p>名称</p>
</li>
<li><p>描述</p>
</li>
<li><p>图片  </p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>更新时间</p>
</li>
</ul>
<h3 id="2-2-1-7店铺"><a href="#2-2-1-7店铺" class="headerlink" title="2.2.1.7店铺"></a>2.2.1.7店铺</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>店名：</strong>唯一键，区域名称不能重复</p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>描述</p>
</li>
<li><p>联系方式</p>
</li>
<li><p>门面照</p>
</li>
<li><p>地址</p>
</li>
<li><p>状态：店铺是否可用</p>
<p>不可用：-1 表示前端看不到店铺，店家无法修改店铺信息，发布商品等</p>
<p>审核中：0 表示前端看不到店铺，但是店家能够对店铺操作</p>
<p> 可用：通过了审核，正常状态</p>
</li>
<li><p>建议：超级管理员对店铺的建议</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>更新时间</p>
</li>
<li><p><strong>区域ID：外键，</strong>与区域ID关联，表示属于校园的哪个区域</p>
</li>
<li><p><strong>类别ID：外键，</strong>表示店铺属于哪个类</p>
</li>
<li><p><strong>用户ID：外键，</strong>表示店铺的创建者 </p>
</li>
</ul>
<h3 id="2-2-1-8商品类别"><a href="#2-2-1-8商品类别" class="headerlink" title="2.2.1.8商品类别"></a>2.2.1.8商品类别</h3><ul>
<li><strong>ID：</strong>主键（自增+1）</li>
<li><strong>店铺ID：</strong>所属于哪个店铺</li>
<li>权重</li>
<li>名称</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
</ul>
<h3 id="2-2-1-9详情图片"><a href="#2-2-1-9详情图片" class="headerlink" title="2.2.1.9详情图片"></a>2.2.1.9详情图片</h3><ul>
<li><strong>ID：</strong>主键（自增+1）</li>
<li><strong>商品ID：外键，</strong>属于哪个商品的详情图片</li>
<li>图片的地址</li>
<li>描述</li>
<li>权重</li>
<li>名称</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
</ul>
<h3 id="2-2-1-10商品"><a href="#2-2-1-10商品" class="headerlink" title="2.2.1.10商品"></a>2.2.1.10商品</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>店铺ID：外键，</strong>属于哪个店铺的商品</p>
</li>
<li><p><strong>类别ID：外键</strong>该商品属于哪个类别</p>
</li>
<li><p>描述</p>
</li>
<li><p>权重</p>
</li>
<li><p>商品名</p>
</li>
<li><p>原价</p>
</li>
<li><p>折扣价</p>
</li>
<li><p>状态</p>
<p>下架：0</p>
<p>在前端展示系统显示：1</p>
</li>
<li><p>缩略图：缩略图的地址</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片9.png" style="zoom:80%;">

<h2 id="2-2-2实体类之间的关联"><a href="#2-2-2实体类之间的关联" class="headerlink" title="2.2.2实体类之间的关联"></a>2.2.2实体类之间的关联</h2><h3 id="2-2-2-1用户信息关联"><a href="#2-2-2-1用户信息关联" class="headerlink" title="2.2.2.1用户信息关联"></a>2.2.2.1用户信息关联</h3><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片10.png" style="zoom:80%;">

<h3 id="2-2-2-2店铺信息关联"><a href="#2-2-2-2店铺信息关联" class="headerlink" title="2.2.2.2店铺信息关联"></a>2.2.2.2店铺信息关联</h3><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片11.png" style="zoom:80%;">

<h3 id="2-2-2-3商品信息关联"><a href="#2-2-2-3商品信息关联" class="headerlink" title="2.2.2.3商品信息关联"></a>2.2.2.3商品信息关联</h3><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片12.png" style="zoom:80%;">

<h2 id="2-2-3可视化软件SQLYog"><a href="#2-2-3可视化软件SQLYog" class="headerlink" title="2.2.3可视化软件SQLYog"></a>2.2.3可视化软件SQLYog</h2><p><strong>使用可视化软件SQLYog对数据库进行表的创建和修改</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片13.png" style="zoom:80%;">

<h2 id="2-2-4配置Maven"><a href="#2-2-4配置Maven" class="headerlink" title="2.2.4配置Maven"></a>2.2.4配置Maven</h2><h3 id="2-2-4-1项目1-0的整体架构"><a href="#2-2-4-1项目1-0的整体架构" class="headerlink" title="2.2.4.1项目1.0的整体架构"></a>2.2.4.1项目1.0的整体架构</h3><img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-项目设计和框架搭建\图片14.png" style="zoom:80%;">

<ul>
<li><p><strong>1.src/main/java：</strong>存放业务的Java代码；</p>
</li>
<li><p><strong>2.src/main/resources：</strong>存放项目用到的资源文件，如spring、mybatis、日志的配置文件；</p>
<p>​     src/main/resources/spring：存放spring相关的配置信息；</p>
<p>​     src/main/resources/mapper：存放Dao中每个方法对应的SQL，<strong>Mybatis让我们不用去写Dao的实现类</strong></p>
</li>
<li><p><strong>3.src/test/java：</strong>存放单元测试所涉及到的Java代码；</p>
</li>
<li><p><strong>4.src/test/resources：</strong>存放单元测试所涉及到的配置文件；</p>
</li>
<li><p><strong>5.Maven Dependencies：</strong>存储项目中通过Maven管理的.jar包，通常通过<strong>pom.xml</strong>指定下载；</p>
</li>
<li><p><strong>6.Apache Tomcat：</strong>存放的是Tomcat所依赖的.jar包；</p>
</li>
<li><p><strong>7.JRE System Library：</strong>存放Java运行时所需要的.jar包；</p>
</li>
<li><p><strong>8.src文件夹下的webapp下的resources：</strong>存放项目的静态资源，如js文件，css文件，图片；</p>
<p>​     src文件夹下的webapp下的WEB-INF：外界不能通过URL对web-inf下的文件直接进行访问，而通过内部程序可以；</p>
<p>​     src文件夹下的webapp下的WEB-INF下的web.xml：初始化配置信息，比如设置默认访问页面等；</p>
</li>
<li><p><strong>9.target：</strong>存放项目构建后的文件和目录，.jar 包等，编译后的文件等</p>
</li>
<li><p><strong>10.com.imooc.o2o：</strong></p>
<p>​     com.imooc.o2o下的web：**相当于controlor层，存放controlor控制器；</p>
<p>​     com.imooc.o2o下的service：业务逻辑层；</p>
<p>​     com.imooc.o2o下的impl：实现service接口；</p>
<p>​     com.imooc.o2o下的dao：与数据库打交道，存放与数据相关的操作，不需要impl，因为我们用的是mybatis，可以<strong>直接在配置文件中实现接口的每一个方法</strong>，也就是在src/main/resources/mapper中实现dao接口的逻辑；</p>
<p>​     com.imooc.o2o下的dto：弥补entity的不足，比如要返回一个商品列表，还要返回是否成功、状态等信息只通过实体类的product不能满足，就要用到dto；</p>
<p>​     com.imooc.o2o下的enums：存放枚举类型；</p>
<p>​     com.imooc.o2o下的interceptor：拦截器的代码；</p>
<p>​     com.imooc.o2o下的util：通用的工具类；</p>
<p>​     com.imooc.o2o下的exceptions：保存异常处理类；</p>
<p>​     com.imooc.o2o下的cache：redis缓存相关的工具类等。</p>
</li>
</ul>
<h3 id="2-2-4-2项目1-0引入-jar包（pom-xml）"><a href="#2-2-4-2项目1-0引入-jar包（pom-xml）" class="headerlink" title="2.2.4.2项目1.0引入.jar包（pom.xml）"></a>2.2.4.2项目1.0引入.jar包（pom.xml）</h3><ul>
<li>groupId</li>
<li>artifactId：.jar包的名称</li>
<li>version：.jar包的版本</li>
<li>scope：.jar包的使用范围</li>
</ul>
<blockquote>
<p><strong>NOTE：</strong>设置了一个全局变量${spring.version}，下面的与spring相关的都用这个全局变量为版本，方便后续对spring框架的升级</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>o2o<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>o2o Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 1)包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2)这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control </span></span><br><span class="line"><span class="comment">			/ Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar </span></span><br><span class="line"><span class="comment">			及spring-beans.jar 文件就可以了。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 3)这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI </span></span><br><span class="line"><span class="comment">			所需的全部类，instrumentation组件以及校验Validation 方面的相关类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 4) 这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 5) 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 6)Spring web 包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 7)包含SpringMVC框架相关的所有类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 8)Spring test 对JUNIT等测试框架的简单封装 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Servlet web --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- json解析 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Map工具类 对标准java Collection的扩展 spring-core.jar需commons-collections.jar --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- DAO: MyBatis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 图片处理 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 实现验证码 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- redis客户端：Jedis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>o2o<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-compiler-plugin --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-5逐层（自底向上）完成SSM的各项配置"><a href="#2-2-5逐层（自底向上）完成SSM的各项配置" class="headerlink" title="2.2.5逐层（自底向上）完成SSM的各项配置"></a>2.2.5逐层（自底向上）完成SSM的各项配置</h2><h3 id="2-2-5-1数据库连接配置"><a href="#2-2-5-1数据库连接配置" class="headerlink" title="2.2.5.1数据库连接配置"></a>2.2.5.1数据库连接配置</h3><ul>
<li>定义MySQL相关的驱动器</li>
<li>设置jdbc的URL， 也就是MySQL所在主机的端口号和要连接的数据库</li>
<li>设置登录账号</li>
<li>设置登录密码</li>
</ul>
<h3 id="2-2-5-2Mybatis配置"><a href="#2-2-5-2Mybatis配置" class="headerlink" title="2.2.5.2Mybatis配置"></a>2.2.5.2Mybatis配置</h3><h3 id="2-2-5-3Spring-dao的配置"><a href="#2-2-5-3Spring-dao的配置" class="headerlink" title="2.2.5.3Spring-dao的配置"></a>2.2.5.3Spring-dao的配置</h3><p>这里的Spring-dao.xml文件是最终版，涉及到redis配置、动态数据源的选择将在后面介绍  </p>
<ol>
<li>找到需要读取变量的文件——jdbc.properties</li>
<li>定义数据库连接池的属性</li>
<li>创建一个负责创建数据库连接池的对象 </li>
<li> 给定路径，需要到什么路径下去扫描Dao层，并将3中创建的对象传入 </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置整合mybatis过程 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.util.EncryptPropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:redis.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;abstractDataSource&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;master&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;abstractDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.master.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;slave&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;abstractDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.slave.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置动态数据源，这儿targetDataSources就是路由数据源所对应的名称 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dynamicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.dao.split.DynamicDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;master&quot;</span> <span class="attr">key</span>=<span class="string">&quot;master&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;slave&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSource&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dynamicDataSource&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 扫描entity包 使用别名 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.imooc.entity&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.imooc.o2o.dao&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-3Spring-service的配置"><a href="#2-2-5-3Spring-service的配置" class="headerlink" title="2.2.5.3Spring-service的配置"></a>2.2.5.3Spring-service的配置</h3><p>这里的Spring-service.xml文件是最终版</p>
<ol>
<li><p>扫描service包下所有使用注解的类型</p>
</li>
<li><p>配置事务管理，因为可能涉及多个Dao操作，当其中一个执行出错时进行回滚，要用事务进行管理</p>
<p>并且注入spring-dao.xml中定义的连接池</p>
</li>
<li><p>支持事务注解——transaction-manager</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">		<span class="attr">base-package</span>=<span class="string">&quot;com.imooc.o2o.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置基于注解的声明式事务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span><br><span class="line"><span class="tag">		<span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-4Spring-web的配置"><a href="#2-2-5-4Spring-web的配置" class="headerlink" title="2.2.5.4Spring-web的配置"></a>2.2.5.4Spring-web的配置</h3><p>这里的Spring-web.xml文件是最终版</p>
<ol>
<li>开启注解模式，能够识别Controller层的注解</li>
<li>告诉SpringMVC的核心类DispatcherServlet，不要去拦截以resources文件夹下的.js 、图片等，而是将这些静态资源统一 交给&lt;mvc:default-servlet-handler /&gt;来处理</li>
<li>视图解析器能够根据url请求解析出相应的.html页面 </li>
<li>指定相关的扫描路径</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用&quot;/&quot;做整体映射 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">location</span>=<span class="string">&quot;/resources/&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3.定义视图解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/html/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 文件上传解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 1024 * 1024 * 20 = 20M --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20971520&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20971520&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 4.扫描web相关的bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">		<span class="attr">base-package</span>=<span class="string">&quot;com.imooc.o2o.web&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 5.权限拦截器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 校验是否已登录了店家管理系统的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 校验是否对该店铺有操作权限的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shoplist page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shoplist&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshoplist&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shopregister page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopinitinfo&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/registershop&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopoperation&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shopmanage page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopmanagement&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopmanagementinfo&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopPermissionInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopPermissionInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 超级管理员系统拦截部分 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/login&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/logincheck&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/main&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/top&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4area&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4headline&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4shopcategory&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;SuperAdminLoginInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.superadmin.SuperAdminLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-5整合spring的相关配置"><a href="#2-2-5-5整合spring的相关配置" class="headerlink" title="2.2.5.5整合spring的相关配置"></a>2.2.5.5整合spring的相关配置</h3><p>在web.xml中完成以下配置：</p>
<ul>
<li><p>配置DispatcherServlet</p>
<p>定义Servlet-name</p>
<p>定义Servlet-class</p>
<p>初始化参数，定义参数名称，还有param-value也就是spring相关配置的路径</p>
</li>
<li><p>配置servelet-mapping，让它与spring-dispatcher映射在一起 ，默认将所有的url请求都转入到spring-dispatcher来处理</p>
</li>
</ul>
<h2 id="2-2-6逐层验证"><a href="#2-2-6逐层验证" class="headerlink" title="2.2.6逐层验证"></a>2.2.6逐层验证</h2><p>这里以获取区域信息为例，演示从Dao层到Controller层的实现</p>
<h3 id="2-2-6-1Dao层"><a href="#2-2-6-1Dao层" class="headerlink" title="2.2.6.1Dao层"></a>2.2.6.1Dao层</h3><p><strong>创建AreaDao接口：</strong>只包含一个queryArea()方法</p>
<p><strong>在Mapper下创建AreaDao.xml配置文件来实现AreaDao接口中的方法：</strong></p>
<ul>
<li>定义AreaDao.xml文件中的编写规范</li>
<li>namespace：AreaDao的绝对路径</li>
<li>id：AreaDao接口中的方法名</li>
<li>resultType：定义查询数据库后的返回值类型，也就是每条记录都会转换成Area对象</li>
<li>在SELECT中编写SQL语句</li>
</ul>
<h3 id="2-2-6-2Dao层测试"><a href="#2-2-6-2Dao层测试" class="headerlink" title="2.2.6.2Dao层测试"></a>2.2.6.2Dao层测试</h3><p>先在src/test/java下创建一个BaseTest类，该类的作用是告诉junit：<strong>spring要用哪个类来跑这个单元测试以及spring的配置文件在哪里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 配置spring和junit整合，junit启动时加载springIOC容器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//告诉junit spring配置文件在哪里</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123; &quot;classpath:spring-dao.xml&quot;, &quot;classpath:spring/spring-service.xml&quot;,</span></span><br><span class="line"><span class="meta">		&quot;classpath:spring/spring-redis.xml&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>让测试类继承BaseTest，这样每次启动这个测试单元时都会去加载BaseTest中的方法以及spring的配置文件。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.o2o.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreaDaoTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AreaDao areaDao;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		List&lt;Area&gt; areaList = areaDao.queryArea();</span><br><span class="line">		assertEquals(<span class="number">2</span>, areaList.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE：</strong>@Autowired标签能自动注入所需要的bean</p>
</blockquote>
<h3 id="2-2-6-3Service层"><a href="#2-2-6-3Service层" class="headerlink" title="2.2.6.3Service层"></a>2.2.6.3Service层</h3><p><strong>创建AreaService接口：</strong>只包含一个getAreaList()方法</p>
<p><strong>创建实现类AreaServiceImpl去实现AreaService中的getAreaList()方法：</strong></p>
<p>自动注入一个AreaDao实例对象，调用AreaDao接口中的方法</p>
<blockquote>
<p><strong>NOTE：</strong>@Service标签告诉spring这是service层的类<strong>需要托管在spring容器中</strong>，当其它类中用到这个AreaService时SpringIOC会将这个AreaServiceImpl注入到所需要的类中去</p>
</blockquote>
<h3 id="2-2-6-4Controller层"><a href="#2-2-6-4Controller层" class="headerlink" title="2.2.6.4Controller层"></a>2.2.6.4Controller层</h3><ul>
<li><p>@Controller标签：告诉spring容器这是Controller ，作用等同于@service</p>
</li>
<li><p>@RequestMapping(“/superadmin”)： 指定路由为o2o下面的shopadmin</p>
</li>
<li><p>@Autowired：自动注入AreaService实例</p>
</li>
<li><p>@RequestMapping(value = “/listarea”, method = RequestMethod.GET)：定义路由，指定访问shopadmin下的listarea方法，使用的方法为GET方法</p>
</li>
<li><p>@ResponseBody：将返回对象转换为json对象返回给前台</p>
</li>
<li><p>程序中的逻辑：</p>
<p>创建一个HashMap类型的对象来保存返回结果</p>
<p>创建一个ArrayList集合来保存areaService中getAreaList方法返回的结果</p>
<p>方法执行成功：将返回结果和返回结果的元素数put进modelmap中</p>
<p>方法执行失败：返回false并返回异常信息</p>
</li>
</ul>
<h3 id="2-2-6-5Controller层测试"><a href="#2-2-6-5Controller层测试" class="headerlink" title="2.2.6.5Controller层测试"></a>2.2.6.5Controller层测试</h3><p>启动Tomcat，从Chrome中输入：</p>
<p>Localhost：8080/o2o/superadmin/shoplist</p>
<p>就会根据路由执行Controller中的方法，调用数据库中的数据返回给前台</p>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-开发准备</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1环境准备"><a href="#1-1环境准备" class="headerlink" title="1.1环境准备"></a>1.1环境准备</h1><ul>
<li>  JDK 1.8：提供Java基础类库的支持；</li>
<li>  Maven 3.3.9：对项目用到的jar包进行管理；</li>
<li>  MySQL 5.5+：存储数据；</li>
<li>  Chrome：展示与前端调试；</li>
<li>  Tomcat 8：运行Java项目；</li>
<li>  Eclipse：开发工具</li>
</ul>
<h1 id="1-2开发准备"><a href="#1-2开发准备" class="headerlink" title="1.2开发准备"></a>1.2开发准备</h1><h2 id="1-2-1JDK1-8"><a href="#1-2-1JDK1-8" class="headerlink" title="1.2.1JDK1.8"></a>1.2.1JDK1.8</h2><h3 id="1-2-1-1下载安装"><a href="#1-2-1-1下载安装" class="headerlink" title="1.2.1.1下载安装"></a>1.2.1.1下载安装</h3><h3 id="1-2-1-1配置到eclipse中"><a href="#1-2-1-1配置到eclipse中" class="headerlink" title="1.2.1.1配置到eclipse中"></a>1.2.1.1配置到eclipse中</h3><p><strong>如下图所示：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片01.png" style="zoom:80%;">

<h2 id="1-2-2Tomcat"><a href="#1-2-2Tomcat" class="headerlink" title="1.2.2Tomcat"></a>1.2.2Tomcat</h2><h3 id="1-2-2-1下载安装"><a href="#1-2-2-1下载安装" class="headerlink" title="1.2.2.1下载安装"></a>1.2.2.1下载安装</h3><p><strong>详细的Tomcat服务器下载、安装、配置环境变量教程请点击：<a href="https://blog.csdn.net/qq_40881680/article/details/83582484?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161694559516780264078493%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161694559516780264078493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-83582484.nonecase&utm_term=Tomcat">点击这里</a></strong></p>
<h3 id="1-2-2-1配置到eclipse中"><a href="#1-2-2-1配置到eclipse中" class="headerlink" title="1.2.2.1配置到eclipse中"></a>1.2.2.1配置到eclipse中</h3><p><strong>按下图将Tomcat配置到eclipse中：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片02.png" style="zoom:80%;">

<h2 id="1-2-3Maven"><a href="#1-2-3Maven" class="headerlink" title="1.2.3Maven"></a>1.2.3Maven</h2><h3 id="1-2-3-1下载安装"><a href="#1-2-3-1下载安装" class="headerlink" title="1.2.3.1下载安装"></a>1.2.3.1下载安装</h3><h3 id="1-2-3-1配置到eclipse中"><a href="#1-2-3-1配置到eclipse中" class="headerlink" title="1.2.3.1配置到eclipse中"></a>1.2.3.1配置到eclipse中</h3><p><strong>将eclipse自带的Maven插件与我们本地的Maven对应起来：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片03.png" style="zoom:80%;">

<p><strong>配置eclipse让它读取我们本地的Maven配置文件，以及告诉eclipse读取我们本地的jar包：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片04.png" style="zoom:80%;">

<h2 id="1-2-3下载安装Mysql5-7"><a href="#1-2-3下载安装Mysql5-7" class="headerlink" title="1.2.3下载安装Mysql5.7"></a>1.2.3下载安装Mysql5.7</h2><h2 id="1-2-4创建Maven项目"><a href="#1-2-4创建Maven项目" class="headerlink" title="1.2.4创建Maven项目"></a>1.2.4创建Maven项目</h2><p><strong>选择Maven Project&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片05.png" style="zoom:80%;">

<p><strong>点击Next&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片06.png" style="zoom:80%;">

<p><strong>选择Java动态项目工程如下图&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片07.png" style="zoom:80%;">

<p><strong>给创建的Maven项目命名为：o2o&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片08.png" style="zoom:80%;">

<p><strong>创建完成！</strong> </p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片09.png" style="zoom:80%;">

<p><strong>配置输出文件的位置，如下图所示：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片10.png" style="zoom:80%;">

<h2 id="1-2-5动态Javaweb项目与静态的Javaweb项目"><a href="#1-2-5动态Javaweb项目与静态的Javaweb项目" class="headerlink" title="1.2.5动态Javaweb项目与静态的Javaweb项目"></a>1.2.5动态Javaweb项目与静态的Javaweb项目</h2><p><strong>动态的Javaweb项目：</strong>包含一些Java代码，像JavaScript，它可以向后台传入数据，还可以响应请求从后端取出数据；</p>
<p><strong>静态的Javaweb项目：</strong>不能包含动态信息，在编写代码时直接写死，点击就可以看到效果。</p>
<p>这里使用的是动态的Javaweb项目，要及时修改Dynamic Web Module实现更好的网页性能，并要确保与jdk版本兼容</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片11.png" style="zoom:80%;">

<p>修改版本之后，要修改web.xml中的规范，这里使用的是version=3.1</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片12.png" style="zoom:80%;">]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>校园商铺平台</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL相关</title>
    <url>/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-索引"><a href="#1-索引" class="headerlink" title="1.索引"></a>1.索引</h1><h2 id="1-1什么是索引"><a href="#1-1什么是索引" class="headerlink" title="1.1什么是索引"></a>1.1什么是索引</h2><p><strong>索引（index）是一种用于 MySQL 快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和 Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢<strong>（顺序查找）</strong>。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了<strong>（使用索引）</strong>。</p>
<h2 id="1-2索引的优缺点"><a href="#1-2索引的优缺点" class="headerlink" title="1.2索引的优缺点"></a>1.2索引的优缺点</h2><ul>
<li><p><strong>优点：</strong></p>
<p><strong>可以大大加快数据的检索速度（大大减少的检索的数据量）, ** 这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。 另外，通过创建</strong>唯一性索引，可以保证数据库表中每一行数据的唯一性。**</p>
</li>
<li><p><strong>缺点：</strong></p>
<p><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</p>
<p><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</p>
<p><strong>不是所有的情况都适用：</strong>少量数据、频繁更新的字段、很少使用的字段</p>
</li>
</ul>
<h2 id="1-3索引类型（数据结构角度）"><a href="#1-3索引类型（数据结构角度）" class="headerlink" title="1.3索引类型（数据结构角度）"></a>1.3索引类型（数据结构角度）</h2><h3 id="1-哈希索引"><a href="#1-哈希索引" class="headerlink" title="1.哈希索引"></a>1.哈希索引</h3><p><strong>数据结构：</strong>Hash 表</p>
<p><strong>优点：</strong></p>
<ul>
<li>最大的优点就是能够在很短的时间内，根据 Hash 函数定位到数据所在的位置，这是B+树所不能比的。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>存在 Hash 冲突问题</p>
</li>
<li><p><strong>不支持顺序和范围查询</strong>是它最大的缺点</p>
<p>试想一种情况:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br></pre></td></tr></table></figure>

<p><strong>B+ 树</strong>是有序的，在这种<strong>范围查询中，优势非常大</strong>，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 Hash 算法来定位的，难不成还要把 1-499 的数据，每个都进行一次 Hash 计算来定位吗？这就是 Hash 索引最大的缺点了。 </p>
</li>
</ul>
<h3 id="2-B-树索引"><a href="#2-B-树索引" class="headerlink" title="2.B+树索引"></a>2.B+树索引</h3><p><strong>1.数据结构</strong></p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片05.png" alt="img"></p>
<p><strong>2.操作</strong></p>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>
<p><strong>3.与B树的比较</strong></p>
<ul>
<li><p>B树的所有节点既存放键(key) 也存放数据(data)；而 B+ 树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p>
<p>因为中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，I/O 次数更少。</p>
</li>
<li><p>B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
<p>这种特性便于范围查询。B树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。</p>
</li>
<li><p>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程。</p>
<p>查询的效率更稳定，但查询的速度并不慢。</p>
</li>
</ul>
<p><strong>4.与红黑树的比较</strong></p>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p>
<p>（1）B+ 树有更低的树高</p>
<p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>
<p>（2）磁盘访问原理</p>
<p><strong>获取磁盘上数据的过程：</strong></p>
<p>要获取磁盘上数据，必须先将磁头移动到数据所在的<strong>柱面</strong>，然后找到指定<strong>盘面</strong>，接着旋转盘面找到数据所在的<strong>磁道</strong>，最后对数据进行读写。磁盘本身存取就比主存慢很多，再加上查找过程中的机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O，树的深度过大会造成磁盘 I/O 频繁读写。根据<strong>磁盘查找存取的 I/O 次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构尽量减少树的高度。</p>
<p>B+ 树相对于红黑树有更低的树高，进行柱面寻找的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
<blockquote>
<p><strong>磁盘结构：</strong>磁盘由一层一层的盘片组成，每个盘片区分<strong>上下面</strong>，每个盘面由<strong>磁道</strong>组成，同时，各盘面相同半径的磁道组成<strong>柱面</strong>。</p>
</blockquote>
<p>（3）磁盘预读特性</p>
<p><strong>磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存（预读取的长度一般是磁盘页的整数倍）</strong>。这样做的理论依据是计算机科学中著名的局部性原理（该数据附近的数据有可能被经常读取）。</p>
<p>红黑树底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，所以没能充分利用磁盘预读功能。</p>
<p>B+树的每个节点可以存储多个关键字，<strong>它创建节点时，将其大小设置为磁盘页的大小，一次就能够获取更多的元素，充分利用了磁盘预读的功能。</strong>要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p>
<h3 id="3-全文本索引"><a href="#3-全文本索引" class="headerlink" title="3.全文本索引"></a>3.全文本索引</h3><p>前面我们通常使用 LIKE 关键字来查找包含特殊值或者部分值的行，但是这种方式存在问题：</p>
<ol>
<li><strong>性能：</strong>通配符和正则表达式匹配通常要求尝试匹配表中所有行，试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。</li>
<li><strong>明确控制：</strong>通配符和正则表达式很难明确控制匹配什么不匹配什么</li>
<li><strong>智能化结果：</strong>通配符和正则表达式的搜索不能提供智能化的将结果按照匹配的相关度进行一个排序</li>
</ol>
<p>所以，在这样的矛盾下出现了全文索引技术。</p>
<p><strong>实现原理：</strong>是先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳，这样就相当于对文件建立了一个以词库为目录的索引，这样查找某个词的时候就能很快的定位到该词出现的位置。这样 MySQL 不需要分别查看每一行，不需要分别处理和分析每个词。</p>
<p><img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-03-16-MySQL相关\图片01.png" alt="img"></p>
<p><strong>创建表时创建全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> fulltext_test (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">content</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    tag <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    FULLTEXT <span class="keyword">KEY</span> content_tag_fulltext(<span class="keyword">content</span>)  // 创建联合全文索引列</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p><strong>使用全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> fulltext_test </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">match</span>(<span class="keyword">content</span>) against(<span class="string">&#x27;aaa&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用 LIKE 子句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> fulltext_test </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">content</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%aaa%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述两条 SELECT 语句检索出的结果应该都是相同的，但是返回的顺序不一定相同，全文本索引能够按照搜索关键词在文本中出现的位置和频率对搜索结果进行排序。</p>
<h2 id="1-4索引类型（功能分类）"><a href="#1-4索引类型（功能分类）" class="headerlink" title="1.4索引类型（功能分类）"></a>1.4索引类型（功能分类）</h2><h3 id="1-主键索引"><a href="#1-主键索引" class="headerlink" title="1.主键索引"></a>1.主键索引</h3><p>数据表的主键列使用的就是主键索引。</p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</strong></p>
<p>在 mysql 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<h3 id="2-二级索引-辅助索引"><a href="#2-二级索引-辅助索引" class="headerlink" title="2.二级索引(辅助索引)"></a>2.二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>二级索引又包括以下索引：</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引<strong>只适用于字符串类型的数据</strong>。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是<strong>为了检索大文本数据中的关键字的信息</strong>，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 </li>
</ol>
<p>为了更好的理解主键索引与普通索引的区别，给出一个具体的案例如下：</p>
<p>我们先来创建一张表 User，主键为 id，并且拥有字段 uid 和字段 name，uid 字段上有索引，建表语句如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">User</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">uid <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>, </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line"><span class="keyword">index</span> (uid))<span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>接着我们插入如下几条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">User</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">21</span>,<span class="string">&#x27;zhangsan&#x27;</span>),(<span class="number">2</span>,<span class="number">22</span>,lisi),(<span class="number">3</span>,<span class="number">23</span>,<span class="string">&#x27;wangwu&#x27;</span>),(<span class="number">5</span>,<span class="number">25</span>,<span class="string">&#x27;ywq&#x27;</span>),(<span class="number">6</span>,<span class="number">26</span>,<span class="string">&#x27;dym&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们知道，主键上自动创建了主键索引，并且我们手动在 uid 字段上创建的普通索引。接下来，我们一起看下主键索引树和普通索引树的形状吧：</p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\图片02.png" alt="图片说明" style="zoom:80%;">

<p>由上图可以看出，左边<strong>主键索引树的叶子节点存储的是完整的记录</strong>，而<strong>普通索引树上存储的是其对应的主键的值</strong>。那么主键索引和普通索引在查询方面的差距也就显而易见了。</p>
<h2 id="1-5索引类型（列数分类）"><a href="#1-5索引类型（列数分类）" class="headerlink" title="1.5索引类型（列数分类）"></a>1.5索引类型（列数分类）</h2><h3 id="1-单列索引"><a href="#1-单列索引" class="headerlink" title="1.单列索引"></a>1.单列索引</h3><p>一个索引只包含一个列，一个表可以有多个单例索引。</p>
<h3 id="2-复合索引（联合索引）"><a href="#2-复合索引（联合索引）" class="headerlink" title="2.复合索引（联合索引）"></a>2.复合索引（联合索引）</h3><p>一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。</p>
<p><strong>为什么要用联合索引？</strong></p>
<ul>
<li><strong>减少开销。</strong>建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</li>
<li><strong>覆盖索引。</strong>对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</li>
<li><strong>效率高</strong>。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！</li>
</ul>
<h2 id="1-6索引类型（物理分类）"><a href="#1-6索引类型（物理分类）" class="headerlink" title="1.6索引类型（物理分类）"></a>1.6索引类型（物理分类）</h2><h3 id="1-聚集索引"><a href="#1-聚集索引" class="headerlink" title="1.聚集索引"></a>1.聚集索引</h3><p><strong>1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>2.聚集索引的优点</strong></p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p><strong>3.聚集索引的缺点</strong></p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+ 树是多路平衡树（有序），如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="2-非聚集索引"><a href="#2-非聚集索引" class="headerlink" title="2.非聚集索引"></a>2.非聚集索引</h3><p><strong>1.非聚集索引即索引结构和数据分开存放的索引。</strong> <strong>二级索引属于非聚集索引。</strong></p>
<p>MYISAM 引擎的表的<code>.MYI</code>文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向<code>.MYD</code>文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
<p><strong>2.非聚集索引的优点</strong></p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p><strong>3.非聚集索引的缺点</strong></p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据。</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h2 id="1-7覆盖索引和回表查询"><a href="#1-7覆盖索引和回表查询" class="headerlink" title="1.7覆盖索引和回表查询"></a>1.7覆盖索引和回表查询</h2><h3 id="1-7-1回表查询"><a href="#1-7-1回表查询" class="headerlink" title="1.7.1回表查询"></a>1.7.1回表查询</h3><ul>
<li>如果语句是 select * from User where id=3，即主键查询方式，则只需要搜索 主键索引树。 </li>
<li>如果语句是 select * from User where uid=23，即普通索引查询方式，则需要先搜索 普通索引树，得到其对应的主键值为 3，再到主键索引树搜索一次。这个过程称为<strong>回表。</strong> </li>
</ul>
<h3 id="1-7-2覆盖索引"><a href="#1-7-2覆盖索引" class="headerlink" title="1.7.2覆盖索引"></a>1.7.2覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询 name，name 字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><strong>覆盖索引:</strong></p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\2.7.01.png" style="zoom:80%;">

<p>如以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;guang19&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个要查询的字段建立了索引，所以不用回表查询。</p>
<p>如果，还有一个字段是 sex ，下面的 SQL 语句，就没有用到覆盖索引，还是需要回表查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> ， sex <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;guang19&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是如果将单列索引（name）优化为联合索引（name，sex），也可以避免回表查询。</p>
<h2 id="1-8最左前缀原则"><a href="#1-8最左前缀原则" class="headerlink" title="1.8最左前缀原则"></a>1.8最左前缀原则</h2><p>假设创建的联合索引由三个字段组成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">table</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">num</span>,<span class="keyword">name</span>,age)</span><br></pre></td></tr></table></figure>

<p>那么当查询的条件有为：num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<h3 id="1-8-1深入理解最左匹配原则"><a href="#1-8-1深入理解最左匹配原则" class="headerlink" title="1.8.1深入理解最左匹配原则"></a>1.8.1深入理解最左匹配原则</h3><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">a <span class="built_in">int</span> ,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line">c <span class="built_in">int</span>,</span><br><span class="line">d <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">key</span> index_abc(a,b,c)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>插入1000条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> proc_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_initData()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i&lt;=10000 DO</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(a,b,c,d) <span class="keyword">VALUES</span>(i,i,i,i);</span><br><span class="line">    <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CALL</span> proc_initData();</span><br></pre></td></tr></table></figure>

<p>建立了联合索引（a，b，c）</p>
<p>验证：</p>
<ul>
<li><p>explain select * from test where a&lt;10 ;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>能不能将 a，b出现顺序换一下，a，b，c出现顺序换一下：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and a &lt;10;</p>
</li>
<li><p>explain select * from test where b&lt;10 and a &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>不是最左匹配原则吗？</p>
<p>查了下资料发现：mysql 查询优化器会判断纠正这条 sql 语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以 mysql 查询优化器会最终以这种顺序进行查询执行。<strong>也就是说 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，不过建议 where 后的字段顺序和联合索引保持一致。</strong></p>
<p><strong>（重点）</strong>输入下面两条 SQL 语句：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and c &lt;10;、</p>
</li>
<li><p>explain select * from test where a&lt;10 and c &lt;10;</p>
</li>
</ul>
<p>为什么 b&lt;10 and c &lt;10,没有用到索引？而 a&lt;10 and c &lt;10用到了？</p>
<p>当 b+ 树的数据项是复合的数据结构，比如创建联合索引（name,age,sex）的时候，b+ 树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当(20,F)这样的没有 name 的数据来的时候，b+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h3 id="1-8-2联合索引中索引失效的情况"><a href="#1-8-2联合索引中索引失效的情况" class="headerlink" title="1.8.2联合索引中索引失效的情况"></a>1.8.2联合索引中索引失效的情况</h3><p>如：建立 姓名、年龄、性别的复合索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTest（</span><br><span class="line"></span><br><span class="line">        a <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        b <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        c <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">KEY</span> a（a,b,c）</span><br><span class="line"></span><br><span class="line">   ）；</span><br></pre></td></tr></table></figure>

<p><strong>索引的使用和失效情况：</strong></p>
<ul>
<li>select * from myTest  where a=3 and b=5 and c=4;   —-  abc顺序<br>abc 三个索引都在where条件里面用到了，而且都发挥了作用</li>
<li>select * from myTest  where  c=4 and b=6 and a=3;<br>where 里面的条件顺序在查询之前会被 mysql 自动优化，效果跟上一句一样</li>
<li>select * from myTest  where a=3 and c=7;<br>a 用到索引，b 没有用，所以 c 是没有用到索引效果的（因为<strong>索引不能跨列使用</strong>）</li>
<li>select * from myTest  where a=3 and b&gt;7 and c=3;     —- b 范围值，断点，阻塞了 c 的索引<br>a 用到了，b 也用到了，c 没有用到，这个地方 b 是范围值，也算断点，只不过自身用到了索引</li>
<li>select * from myTest  where b=3 and c=4;   — 联合索引必须按照顺序使用，并且需要全部使用<br>因为 a 索引没有使用，所以这里 bc 都没有用上索引效果</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li>如果复合索引（a,b,c,d）和使用的顺序全部一致（且不跨列使用），则复合索引全部使用</li>
<li>并且有 order by 时，where 和 order by 拼起来，满足不跨列使用的索引能够使用到</li>
</ol>
<h2 id="1-9索引创建原则"><a href="#1-9索引创建原则" class="headerlink" title="1.9索引创建原则"></a>1.9索引创建原则</h2><h3 id="1-9-1选择合适的字段"><a href="#1-9-1选择合适的字段" class="headerlink" title="1.9.1选择合适的字段"></a>1.9.1选择合适的字段</h3><p><strong>1.不为NULL的字段</strong></p>
<p>索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p>
<p><strong>2.被频繁查询的字段</strong></p>
<p>我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p><strong>3.被作为条件查询的字段</strong> </p>
<p>被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
<p><strong>4.被经常频繁用于连接的字段</strong></p>
<p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<p><strong>5.查询中排序的字段，排序字段如果通过索引访问将大大提高排序速度</strong></p>
<h3 id="1-9-2不合适创建索引的字段"><a href="#1-9-2不合适创建索引的字段" class="headerlink" title="1.9.2不合适创建索引的字段"></a>1.9.2不合适创建索引的字段</h3><p><strong>1.被频繁更新的字段应该慎重建立索引</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。<br>如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>2.不被经常查询的字段没有必要建立索引</strong></p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一棵B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong></p>
<p>冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。（也就是功能相同的索引）</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3 id="1-9-3使用索引一定能提高查询性能吗"><a href="#1-9-3使用索引一定能提高查询性能吗" class="headerlink" title="1.9.3使用索引一定能提高查询性能吗?"></a>1.9.3使用索引一定能提高查询性能吗?</h3><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2 id="1-10创建索引的三种方式"><a href="#1-10创建索引的三种方式" class="headerlink" title="1.10创建索引的三种方式"></a>1.10创建索引的三种方式</h2><p>第一种方式：在执行CREATE TABLE时创建索引（直接指定一列或几列为什么类型索引）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">	id INT auto_increment PRIMARY KEY,</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>

<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用 CREATE INDEX 命令创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure>

<p>CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。（但是，不能创建PRIMARY KEY索引）</p>
<h2 id="1-11删除索引的方式"><a href="#1-11删除索引的方式" class="headerlink" title="1.11删除索引的方式"></a>1.11删除索引的方式</h2><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure>

<h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2.存储引擎"></a>2.存储引擎</h1><h2 id="2-1-InnoDB"><a href="#2-1-InnoDB" class="headerlink" title="2.1 InnoDB"></a>2.1 InnoDB</h2><ul>
<li>MySQL 默认的事务型存储引擎，适合高并发操作；</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读；</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免回表查询，因此对查询性能有很大的提升。</li>
</ul>
<h2 id="2-2-MyISAM"><a href="#2-2-MyISAM" class="headerlink" title="2.2 MyISAM"></a>2.2 MyISAM</h2><ul>
<li>不支持事务，但是性能高；</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）；</li>
<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</li>
<li>主索引是非聚簇索引，数据与索引分离，</li>
</ul>
<h2 id="2-3-MyISAM-与-InnoDB-区别"><a href="#2-3-MyISAM-与-InnoDB-区别" class="headerlink" title="2.3 MyISAM 与 InnoDB 区别"></a>2.3 MyISAM 与 InnoDB 区别</h2><ul>
<li><strong>MyISAM引擎：</strong>不提供事务的支持，也不支持行级锁和外键，MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li><strong>InnoDB引擎：</strong>提供了对数据库事务的支持，并且还提供了行级锁和外键的支持。 InnoDB 支持 MVCC，应对高并发事务, MVCC比单纯的加锁更高效，并可通过多版本并发控制（MVCC）+ Next-Key Locking 实现可串行化防止幻影读。</li>
</ul>
<h2 id="2-2-MyISAM-索引与-InnoDB-索引的区别？"><a href="#2-2-MyISAM-索引与-InnoDB-索引的区别？" class="headerlink" title="2.2 MyISAM 索引与 InnoDB 索引的区别？"></a>2.2 MyISAM 索引与 InnoDB 索引的区别？</h2><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM:</strong> B+Tree叶节点的<strong>data域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后<strong>以 data 域的值为地址读取相应的数据记录</strong>。这被称为<strong>“非聚簇索引”</strong>。</li>
<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，其表数据文件本身就是按B+Tree组织的一个索引结构，树的<strong>叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong></li>
</ul>
<h2 id="2-3存储引擎的应用"><a href="#2-3存储引擎的应用" class="headerlink" title="2.3存储引擎的应用"></a>2.3存储引擎的应用</h2><ul>
<li>MyISAM：以读为主的应用程序，比如博客系统、新闻门户网站。</li>
<li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li>
</ul>
<h1 id="3-MySQL中一条SQL语句的执行过程"><a href="#3-MySQL中一条SQL语句的执行过程" class="headerlink" title="3.MySQL中一条SQL语句的执行过程"></a>3.MySQL中一条SQL语句的执行过程</h1><h2 id="3-1MySQL-基础架构分析"><a href="#3-1MySQL-基础架构分析" class="headerlink" title="3.1MySQL 基础架构分析"></a>3.1MySQL 基础架构分析</h2><h3 id="3-1-1-MySQL-基本架构概览"><a href="#3-1-1-MySQL-基本架构概览" class="headerlink" title="3.1.1 MySQL 基本架构概览"></a>3.1.1 MySQL 基本架构概览</h3><p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存:</strong>  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。（因为缓存失效的问题比较多，又因为它不像是Redis能够存储不常更新的数据，所以不是很实用）</li>
<li><strong>分析器:</strong>  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>  按照 MySQL 认为最优的方案去执行（优化 SQL 语句）。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\mysql执行.png" style="zoom:80%;">

<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="3-1-2-Server-层基本组件介绍"><a href="#3-1-2-Server-层基本组件介绍" class="headerlink" title="3.1.2 Server 层基本组件介绍"></a>3.1.2 Server 层基本组件介绍</h3><p><strong>1) 连接器</strong></p>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<p><strong>2) 查询缓存(MySQL 8.0 版本后移除)</strong></p>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<p><strong>3) 分析器</strong></p>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<p><strong>4) 优化器</strong> </p>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<p><strong>5) 执行器</strong></p>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="3-2语句分析"><a href="#3-2语句分析" class="headerlink" title="3.2语句分析"></a>3.2语句分析</h2><h3 id="3-2-1-查询语句"><a href="#3-2-1-查询语句" class="headerlink" title="3.2.1 查询语句"></a>3.2.1 查询语句</h3><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age=<span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>
<li>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>
<li>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="3-2-2-更新语句"><a href="#3-2-2-更新语句" class="headerlink" title="3.2.2 更新语句"></a>3.2.2 更新语句</h3><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age=<span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失，也就是支持事务的回滚)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时<strong>主从同步</strong>也会丢失这一条数据。<strong>（主从同步是MySQL的binlog关联的）</strong></li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？<br>这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2 id="3-3总结"><a href="#3-3总结" class="headerlink" title="3.3总结"></a>3.3总结</h2><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）→查询缓存→分析器→优化器→权限校验→执行器→引擎</li>
<li>更新语句执行流程如下：分析器→权限校验→执行器→引擎—redo log(prepare 状态→binlog→redo log(commit状态)</li>
</ul>
<h1 id="4-常见的SQL语句"><a href="#4-常见的SQL语句" class="headerlink" title="4.常见的SQL语句"></a>4.常见的SQL语句</h1><h2 id="4-1基本查询关键字的使用"><a href="#4-1基本查询关键字的使用" class="headerlink" title="4.1基本查询关键字的使用"></a>4.1基本查询关键字的使用</h2><h3 id="1-where"><a href="#1-where" class="headerlink" title="1. where"></a>1. where</h3><p>where 子句用来筛选 from 子句中指定的操作所产生的的行 </p>
<h3 id="2-group-by"><a href="#2-group-by" class="headerlink" title="2. group by"></a>2. group by</h3><p>group by 子句用来分组 where 子句筛选后的数据</p>
<h3 id="3-having"><a href="#3-having" class="headerlink" title="3. having"></a>3. having</h3><p>having 子句用来从分组的结果中筛选行 </p>
<h3 id="4-having-与-where-的区别"><a href="#4-having-与-where-的区别" class="headerlink" title="4. having 与 where 的区别"></a>4. having 与 where 的区别</h3><p>where 搜索条件在进行分组操作之前应用；having 搜索条件在进行分组操作之后应用。这是一个重要区别，where 筛选掉的数据有可能会影响 having 基于这些值过滤掉的分组。</p>
<h3 id="5-执行顺序"><a href="#5-执行顺序" class="headerlink" title="5.执行顺序"></a>5.执行顺序</h3><p><strong>Demo：</strong>找到具有 2 个以上、价格在 10 以上的产品的供应商</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vent_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>WHERE 子句筛选所有价格在 10 以上的数据行</li>
<li>GROUP BY 子句按照 vent_id 对筛选的数据进行分组</li>
<li>HAVING 子句过滤计数为 2 以上的分组。</li>
</ol>
<h2 id="4-2六种关联查询"><a href="#4-2六种关联查询" class="headerlink" title="4.2六种关联查询"></a>4.2六种关联查询</h2><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
</ul>
<p><strong>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录：</strong></p>
<p><code>R表</code></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p><code>S表</code></p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="1-交叉连接（CROSS-JOIN）"><a href="#1-交叉连接（CROSS-JOIN）" class="headerlink" title="1.交叉连接（CROSS JOIN）"></a>1.交叉连接（CROSS JOIN）</h3><p>交叉连接(笛卡尔积):</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r,s</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="2-内连接（INNER-JOIN）（交集）"><a href="#2-内连接（INNER-JOIN）（交集）" class="headerlink" title="2.内连接（INNER JOIN）（交集）"></a>2.内连接（INNER JOIN）（交集）</h3><ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>内连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">inner</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<h3 id="3-连接（LEFT-JOIN-RIGHT-JOIN）"><a href="#3-连接（LEFT-JOIN-RIGHT-JOIN）" class="headerlink" title="3.连接（LEFT JOIN/RIGHT JOIN）"></a>3.连接（LEFT JOIN/RIGHT JOIN）</h3><ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>左连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">left</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>右连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">right</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="4-联合查询（UNION与UNION-ALL）"><a href="#4-联合查询（UNION与UNION-ALL）" class="headerlink" title="4.联合查询（UNION与UNION ALL）"></a>4.联合查询（UNION与UNION ALL）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，<code>UNION</code>前的结果为基准，需要注意的是<strong>联合查询的列数要相等</strong>，<strong>相同的记录行会合并</strong></li>
<li>如果使用<code>UNION ALL</code>，<strong>不会合并重复的记录行</strong></li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h3 id="5-全连接（FULL-JOIN）"><a href="#5-全连接（FULL-JOIN）" class="headerlink" title="5.全连接（FULL JOIN）"></a>5.全连接（FULL JOIN）</h3><ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<p>全表连接的结果（MySql不支持，Oracle支持）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">full</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h1 id="5-SQL-优化"><a href="#5-SQL-优化" class="headerlink" title="5. SQL 优化"></a>5. SQL 优化</h1><h2 id="5-1-Explain-语句（问题定位）"><a href="#5-1-Explain-语句（问题定位）" class="headerlink" title="5.1 Explain 语句（问题定位）"></a>5.1 Explain 语句（问题定位）</h2><p><strong>常见问题：</strong></p>
<ul>
<li>如何定位及优化 SQL 语句的性能问题？</li>
<li>创建的索引有没有被使用到?</li>
<li>或者说怎么才可以知道这条语句运行很慢的原因？</li>
</ul>
<h3 id="1-Explain-语句的作用"><a href="#1-Explain-语句的作用" class="headerlink" title="1. Explain 语句的作用"></a>1. Explain 语句的作用</h3><p>对于低性能的 SQL 语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL 提供了 explain 命令来<strong>查看语句的执行计划</strong>。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条 SQL 语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于 SQL 语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</strong></p>
<p>（因为 MySQL 优化之后，实际的执行过程并不一定是按照我们编写的 SQL 语句执行的）</p>
<h3 id="2-Explain-语句的字段含义"><a href="#2-Explain-语句的字段含义" class="headerlink" title="2. Explain 语句的字段含义"></a>2. Explain 语句的字段含义</h3><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>id</strong> 由一组数字组成。表示一个查询中<strong>各个子查询的执行顺序</strong>：（本质：在嵌套子查询时，先内层后外层）</p>
<ul>
<li>id 相同执行顺序由上至下。</li>
<li>id 不同，id 值越大优先级越高，越先被执行。</li>
<li>id 为 null 时表示一个结果集，不需要使用它查询，常出现在包含 union 等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">简单查询，<strong>不包含任何子查询或 union 等查询</strong></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PRIMARY</td>
<td align="center">包含子查询<strong>最外层查询</strong>就显示为 PRIMARY</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SUBQUERY</td>
<td align="center">包含子查询SQL中的子查询（<strong>非最外层</strong>）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DERIVED</td>
<td align="center">衍生查询，from子句中包含的查询，衍生查询的结果可以用于外层的查询</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">UNION</td>
<td align="center">出现在union后的查询语句中</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">UNION RESULT</td>
<td align="center">从UNION中获取结果集，主要是告知开发人员，哪些表发生了UNION</td>
</tr>
</tbody></table>
<p><strong>table</strong> 查询的数据表</p>
<p><strong>type</strong> 访问类型（非常重要，<strong>可以看到有没有走索引</strong>) </p>
<ul>
<li>system：只有一条数据的系统表，或衍生表只有一条的主查询；（几乎不可能达到）</li>
<li>const：仅仅能查到一条数据的 SQL，并且索引走的是 Primary 或者 unique key；（几乎不可能达到）</li>
<li>==eq_ref ：唯一性索引，根据索引查询到的<strong>每条数据都是唯一的</strong>；（常见于唯一索引和主键索引）==</li>
<li>ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0个、多个）；</li>
<li>range：范围查询，检索指定范围的行，where 后面是一个范围查询（between，in ，&gt; &lt; 等）（in 有时候会失效，走全表扫描）；</li>
<li>index：查询全部索引中的数据，还是会走索引；</li>
<li>All：查询全部表中的数据，全表扫描，没有用到索引；</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL 时就要考虑当前的 SQL 是否需要优化了。</p>
<p><strong>key</strong> 显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>key_len</strong> 实际使用索引的长度，可以用于查看复合索引是否全被使用。</p>
<p><strong>ref</strong> 它的作用是指明当前表所参照的（另一张表的）字段（与 Type 中的 ref 要区分），引用的字段可以是 const</p>
<p><strong>rows</strong> 显示 MYSQL 执行查询的行数，简单且重要，数值越大越不好，说明没有用好索引</p>
<p><strong>extra</strong> 含MySQL解决查询的<strong>详细信息</strong>，常见的有：</p>
<ul>
<li><p>Using filesort：当 Query 中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件内排序”；（情况比较严重）</p>
</li>
<li><p>Using index：表示相应的 select 操作用使用覆盖索引，避免访问了表的数据行；</p>
</li>
<li><p>Using where：使用了用 where 子句来过滤结果集；</p>
</li>
<li><p>Using temporary：使用了临时表保存中间结果，mysql 在查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</p>
</li>
</ul>
<h3 id="3-实例分析"><a href="#3-实例分析" class="headerlink" title="3.实例分析"></a>3.实例分析</h3><img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\9.1.05.png" style="zoom: 80%;">

<ul>
<li>执行顺序1：select_type 为 UNION，说明第四个 select 是 UNION 里的第二个 select，最先执行【select name,id from t2】</li>
<li>执行顺序2：id 为 3，是整个查询中第三个 select 的一部分。因查询包含在 from 中，所以为 DERIVED【select id,name from t1 where other_column=’’】</li>
<li>执行顺序3：select 列表中的子查询 select_type 为 subquery，为整个查询中的第二个 select【select id from t3】</li>
<li>执行顺序4：id 列为 1，表示是 UNION 里的第一个 select，select_type 列的 primary 表示该查询为外层查询，table 列被标记为<code>&lt;derived3&gt;</code>，表示查询结果来自一个衍生表，其中 derived3 中的 3 代表该查询衍生自第三个 select 查询，即 id 为 3 的 select。【select d1.name …】</li>
<li>执行顺序5：代表从 UNION 的临时表中读取行的阶段，table 列的&lt; union1,4 &gt;表示用第一个和第四个 select 的结果进行 UNION 操作。【两个结果 union 操作】</li>
</ul>
<h2 id="5-2如何使用索引避免全表扫描"><a href="#5-2如何使用索引避免全表扫描" class="headerlink" title="5.2如何使用索引避免全表扫描"></a>5.2如何使用索引避免全表扫描</h2><ul>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引：</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h1 id="6-数据库优化"><a href="#6-数据库优化" class="headerlink" title="6.数据库优化"></a>6.数据库优化</h1><h2 id="6-1大表优化"><a href="#6-1大表优化" class="headerlink" title="6.1大表优化"></a>6.1大表优化</h2><p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用 MySQL 的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<h3 id="1-垂直分区"><a href="#1-垂直分区" class="headerlink" title="1.垂直分区"></a>1.垂直分区</h3><p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指<strong>数据表列</strong>的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\9.1.01.png" style="zoom:67%;">

<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，垂直分区会让事务变得更加复杂；</p>
<p><strong>例：</strong>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\9.1.02.png" style="zoom:67%;">

<p><strong>适用场景:</strong></p>
<p>1、如果一个表中某些列常用，另外一些列不常用</p>
<p>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少 I/O 次数</p>
<p><strong>缺点:</strong></p>
<p>1、有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p>
<p>2、对于应用层来说，逻辑算法增加开发成本</p>
<p>3、管理冗余列，查询所有数据需要 join 操作</p>
<h3 id="2-水平分区"><a href="#2-水平分区" class="headerlink" title="2.水平分区"></a>2.水平分区</h3><p><strong>保持数据表结构不变，通过某种策略存储数据分片。它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\9.1.03.png" style="zoom:67%;">

<p>水平拆分是指数据表行的拆分，表的行数超过 200 万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以<strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够<strong>支持非常大的数据量存储</strong>，<strong>应用端改造也少</strong>，但<strong>分片事务难以解决</strong> ，跨节点 Join 性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络 I/O 。</p>
<p><strong>水平分表</strong></p>
<p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\9.1.04.png" style="zoom:80%;">

<p><strong>适用场景</strong></p>
<ol>
<li>表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>需要把数据存放在多个介质上。（分布式）</li>
</ol>
<p><strong>水平切分的缺点</strong></p>
<ol>
<li>给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需 UNION 操作</li>
<li>在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ol>
<h2 id="6-2主从复制"><a href="#6-2主从复制" class="headerlink" title="6.2主从复制"></a>6.2主从复制</h2><h3 id="1-主从复制的概念及作用"><a href="#1-主从复制的概念及作用" class="headerlink" title="1.主从复制的概念及作用"></a>1.主从复制的概念及作用</h3><p><strong>主从复制：</strong></p>
<ul>
<li>将主数据库中的 DDL 和 DML 操作通过二进制日志（BIN LOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li>
</ul>
<p><strong>MySQL主从复制解决的问题：</strong></p>
<ul>
<li>数据分布：实现在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：主数据库出现问题，可以切换到从数据库。</li>
<li>升级测试：可以用更高版本的 MySQL 作为从库（MySQL 的向后兼容性）</li>
</ul>
<h3 id="2-主从复制的几种方式"><a href="#2-主从复制的几种方式" class="headerlink" title="2.主从复制的几种方式"></a>2.主从复制的几种方式</h3><p>这里的复制方式也就是 Binlog 日志的几种格式。</p>
<p>MySQL默认采用<strong>基于语句的复制</strong>，效率比较高。</p>
<ul>
<li><p>基于语句的复制（statement-based）：在主服务器上执行的SQL语句，在从服务器上执行同样的语句。            </p>
<p>优点：实现简单，二进制日志文件较小</p>
<p>缺点：对于一些特殊的语句，比如包含主库当前时间戳的语句，所以还需要额外记录每条语句在执行时的相关信息，来保证 slave 上执行时，能够得到与主库相同的结果</p>
</li>
<li><p>基于行的复制（row-based）：（会将每一行中发生改变的实际数据记录到日志中）把改变的内容复制过去，而不是把命令在从服务器上执行一遍.，从 mysql5.0 开始支持。</p>
<p>优点：对于任何语句都能正确工作</p>
<p>缺点：二进制日志文件可能会很大</p>
</li>
<li><p>混合类型的复制（mixed-based）: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
</li>
</ul>
<h3 id="3-主从复制的模式"><a href="#3-主从复制的模式" class="headerlink" title="3.主从复制的模式"></a>3.主从复制的模式</h3><p>MySQL <strong>主从复制默认是异步的模式：</strong></p>
<p><strong>异步复制：</strong>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理；主节点不会主动 push bin log 到从节点；</p>
<p><strong>半同步模式：</strong>这种模式下**主节点只需要接收到其中一台从节点的返回信息，就会 commit **；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。</p>
<p><strong>全同步模式</strong>：全同步模式是指<strong>主节点和从节点全部执行了 commit 并确认</strong>才会向客户端返回成功。</p>
<h3 id="4-主从复制流程"><a href="#4-主从复制流程" class="headerlink" title="4.主从复制流程"></a>4.主从复制流程</h3><img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL相关\4.1.01.png" style="zoom: 67%;">

<blockquote>
<p><strong>Binary log：</strong>主数据库的二进制日志</p>
<p><strong>Relay log：</strong>从服务器的中继日志</p>
</blockquote>
<ul>
<li><p>第一步：master 在每个事务更新数据完成之前，将该操作记录串行地写入到 binlog 文件中。</p>
</li>
<li><p>第二步：salve 开启一个 I/O Thread，该线程在 master 打开一个普通连接，主要工作是 binlog dump process。如果读取的进度已经跟上了 master，就进入睡眠状态并等待 master 产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
</li>
<li><p>第三步：SQL Thread 会读取中继日志，并顺序执行该日志中的 SQL 事件，从而与主数据库中的数据保持一致。</p>
</li>
</ul>
<h3 id="5-读写分离的实现方案"><a href="#5-读写分离的实现方案" class="headerlink" title="5.读写分离的实现方案"></a>5.读写分离的实现方案</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读。</p>
<p><strong>方案一</strong></p>
<p>使用代理方式来实现：代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master 和 slave 用一样的帐号，mysql 官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><img src="/2021/03/16/MySQL%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-06-27-数据库系统原理\图片09.png" alt="img"></p>
<p><strong>方案二（项目中使用的方法）</strong></p>
<p>使用 AbstractRoutingDataSource+aop+annotation 在 dao 层决定数据源。<br>如果采用了 mybatis， 可以将读写分离放在ORM层，比如 mybatis 可以通过 mybatis plugin 拦截 sql 语句，所有的 insert/update/delete 都访问 master 库，所有的 select 都访问 salve 库，这样对于 dao 层都是透明。plugin 实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下 DataSourceTransactionManager， 将 read-only 的事务扔进读库（slave）， 其余的有读有写的扔进写库（master）。</p>
<h3 id="6-主从复制数据不一致性问题及解决方法"><a href="#6-主从复制数据不一致性问题及解决方法" class="headerlink" title="6.主从复制数据不一致性问题及解决方法"></a>6.主从复制数据不一致性问题及解决方法</h3><p>因为主从复制要求<code>slave</code>不能写只能读，如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>。</p>
<p><strong>问题：</strong>数据同步延迟很多，且希望重新做主从，使得主从在数据上保持完全同步。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>查看master的运行情况:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">File: mysql-bin.000014     //这个信息点要记住，下面用</span><br><span class="line">Position: 170017372        //这个信息点要记住，下面用</span><br></pre></td></tr></table></figure>
</li>
<li><p>先进入主库，进行锁表，防止数据写入</p>
</li>
<li><p>进行master数据备份（mysqldump）</p>
</li>
<li><p>打包数据(可选)</p>
</li>
<li><p>把mysql备份文件传到从库机器，进行数据恢复</p>
</li>
<li><p>更新/设置同步进度点</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@slave] <span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">&#x27;master.mysql.ipharmacare.org&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_port=<span class="number">3306</span>, master_password=<span class="string">&#x27;************&#x27;</span>, master_log_file=<span class="string">&#x27;mysql-bin.000014&#x27;</span>, master_log_pos=<span class="number">170017372</span>;//这里就用前面的，使从库与主库的进度点保持一致</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE：</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//(1)做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：</span><br><span class="line">[root@master] mysqldump –master-data –single-transaction –user=username –password=password dbname&gt; dumpfilename</span><br><span class="line">//这样就可以保留file和position的信息，在新搭建一个slave的时候，还原完数据库，file和position的信息也随之更新，接着再<span class="keyword">start</span> <span class="keyword">slave</span> 就可以很迅速的完成增量同步。</span><br><span class="line">//(<span class="number">2</span>) 忘记主从复制时,对从库用户密码时,可以这样去重置:</span><br><span class="line">[root@<span class="keyword">master</span>] <span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;slave.mysql.ipharmacare.org&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;slave&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="7-Binlog、Redolog-和-Undolog"><a href="#7-Binlog、Redolog-和-Undolog" class="headerlink" title="7.Binlog、Redolog 和 Undolog"></a>7.Binlog、Redolog 和 Undolog</h1><h2 id="1-Binlog"><a href="#1-Binlog" class="headerlink" title="1.Binlog"></a>1.Binlog</h2><p>Binlog 是 <strong>Server 层自带</strong>的日志模块，Binlog 是逻辑日志，记录本次修改的原始逻辑，说白了就是 SQL 语句。Binlog 是追加写的形式，可以写多个文件，不会覆盖之前的日志。通过 mysqlbinlog 可以解析查看 Binlog 日志。Binlog 日志文件的格式：statement，row，mixed。</p>
<ul>
<li><strong>statement 格式：</strong>Binlog 记录的是完整的 SQL 语句，优点是日志文件小，性能较好，缺点也很明显，那就是准确性差，遇到 SQL 语句中有 now() 等函数会导致不准确 </li>
<li><strong>row 格式：</strong> Binlog 中记录的是数据行的实际数据的变更，优点就是数据记录准确，缺点就是日志文件较大。 </li>
<li><strong>mixed 格式：</strong>Binlog 中记录的是前面两者的混合模式 </li>
</ul>
<p>业界目前推荐使用的是 row 模式，因为很多情况下对准确性的要求是排在第一位的。</p>
<h2 id="2-Redolog"><a href="#2-Redolog" class="headerlink" title="2.Redolog"></a>2.Redolog</h2><p>Redo log 是 InnoDB 存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，Redo log 文件就能派上用场，如数据库掉电，InnoDB 存储引擎会使用 Redo  log 恢复到掉电前的时刻，以此来保证数据的完整性，这个能力称为 crash-safe 。</p>
<p>InnoDB 的 Redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么 Redo log 总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。</p>
<blockquote>
<p><strong>看上面的两阶段提交方式来实现崩溃恢复</strong></p>
</blockquote>
<h2 id="3-Undolog"><a href="#3-Undolog" class="headerlink" title="3.Undolog"></a>3.Undolog</h2><p>Undolog 日志用于存放数据修改被修改前的值，假设修改 tba 表中 id=2的行数据，把Name=’B’ 修改为Name = ‘B2’  ，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。</p>
<p>举例说明 Redolog 和 Undolog 存储内容的区别：</p>
<p>假设有 A、B 两个数据，值分别为 1,2，开始一个事务，事务的操作内容为：把1修改为3，2修改为4，那么实际的记录如下（简化）： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.事务开始. </span><br><span class="line">B.记录A&#x3D;1到undo log. </span><br><span class="line">C.修改A&#x3D;3. </span><br><span class="line">D.记录A&#x3D;3到redo log. </span><br><span class="line">E.记录B&#x3D;2到undo log. </span><br><span class="line">F.修改B&#x3D;4. </span><br><span class="line">G.记录B&#x3D;4到redo log. </span><br><span class="line">H.将redo log写入磁盘。 </span><br><span class="line">I.事务提交</span><br></pre></td></tr></table></figure>

<h1 id="8-SQL-语句的分类"><a href="#8-SQL-语句的分类" class="headerlink" title="8. SQL 语句的分类"></a>8. SQL 语句的分类</h1><p>SQL 语言共分为四大类：数据查询语言 DQL，数据操纵语言 DML，数据定义语言 DDL，数据控制语言 DCL。</p>
<h2 id="1-数据查询语言-DQL"><a href="#1-数据查询语言-DQL" class="headerlink" title="1.数据查询语言 DQL"></a>1.数据查询语言 DQL</h2><p>数据查询语言 DQL 基本结构是由 SELECT 子句，FROM 子句，WHERE 子句组成的查询块：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;字段名表&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;表或视图名&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;查询条件&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-数据操纵语言-DML"><a href="#2-数据操纵语言-DML" class="headerlink" title="2.数据操纵语言 DML"></a>2.数据操纵语言 DML</h2><p>对数据库中的数据进行一些简单操作，如 insert，delete，update，select 等.</p>
<p>DML 主要有三种形式：</p>
<ol>
<li>插入：INSERT</li>
<li>更新：UPDATE</li>
<li>删除：DELETE</li>
</ol>
<h2 id="3-数据定义语言-DDL"><a href="#3-数据定义语言-DDL" class="headerlink" title="3.数据定义语言 DDL"></a>3.数据定义语言 DDL</h2><p>对数据库中的某些对象（例如，database,table）进行管理，如：</p>
<ol>
<li>Create：创建</li>
<li>Alter：修改</li>
<li>Drop：删除</li>
</ol>
<h2 id="4-数据控制语言-DCL"><a href="#4-数据控制语言-DCL" class="headerlink" title="4.数据控制语言 DCL"></a>4.数据控制语言 DCL</h2><p>数据控制语言 DCL 用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p>
<ol>
<li><p>GRANT：授权</p>
</li>
<li><p>ROLLBACK：回滚（可以通过回滚命令使数据库回到上次提交的状态）</p>
</li>
<li><p>COMMIT：提交</p>
<p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型：</p>
<p>(1) 显式提交</p>
<p>用 COMMIT 命令直接完成的提交为显式提交。其格式为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt;COMMIT；</span><br></pre></td></tr></table></figure>

<p>(2) 隐式提交</p>
<p>用 SQL 命令间接完成的提交为隐式提交。这些命令是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span>，<span class="keyword">AUDIT</span>，<span class="keyword">COMMENT</span>，<span class="keyword">CONNECT</span>，<span class="keyword">CREATE</span>，<span class="keyword">DISCONNECT</span>，<span class="keyword">DROP</span>，<span class="keyword">EXIT</span>，<span class="keyword">GRANT</span>，<span class="keyword">NOAUDIT</span>，QUIT，<span class="keyword">REVOKE</span>，<span class="keyword">RENAME</span></span><br></pre></td></tr></table></figure>

<p>(3) 自动提交</p>
<p>若把 AUTOCOMMIT 设置为 ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt;SET AUTOCOMMIT ON；</span><br></pre></td></tr></table></figure>





</li>
</ol>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>MySQL相关</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统相关</title>
    <url>/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1.操作系统概述"></a>1.操作系统概述</h1><h2 id="1-1操作系统的定义"><a href="#1-1操作系统的定义" class="headerlink" title="1.1操作系统的定义"></a>1.1操作系统的定义</h2><ol>
<li><p>操作系统本质上是<strong>运行在计算机上的软件程序，用于管理计算机硬件与软件资源</strong> ；</p>
</li>
<li><p>操作系统<strong>为用户提供一个与系统交互的操作界面</strong> ；</p>
</li>
<li><p>操作系统分<strong>内核</strong>与<strong>外壳</strong>（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</p>
</li>
</ol>
<h2 id="1-2系统调用"><a href="#1-2系统调用" class="headerlink" title="1.2系统调用"></a>1.2系统调用</h2><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode) :</strong> 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)：</strong>可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>我们运行的程序基本都是运行在用户态，如果<strong>我们调用操作系统提供的系统态级别的子功能</strong>时就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h1 id="2-进程、线程与协程"><a href="#2-进程、线程与协程" class="headerlink" title="2.进程、线程与协程"></a><strong>2.进程、线程与协程</strong></h1><h2 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h2><ul>
<li><strong>进程：</strong>进程是一个“执行中的程序”，是系统进行<strong>资源分配和调度</strong>的一个独立单位 </li>
<li><strong>线程：</strong>线程是进程的一个实体，一个进程中可以包含多个线程。与进程不同的是同类的多个线程共享同一块内存空间和系统资源，所以系统在产生一个线程，或者在各个线程之间进行切换时，开销比进程小很多，因此线程也被称为轻量级进程。</li>
<li><strong>协程：</strong>它就是一个函数，一个特殊的函数，可以在某个地方挂起，并且可以重新在挂起处继续运行。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。进程线程都是同步机制，而协程则是异步。协程不需要多线程的锁机制。</li>
</ul>
<h2 id="2-2进程与线程的区别与联系"><a href="#2-2进程与线程的区别与联系" class="headerlink" title="2.2进程与线程的区别与联系"></a>2.2进程与线程的区别与联系</h2><p><strong>面试官问题：进程与线程的区别总结如下。</strong></p>
<p><strong>答：</strong></p>
<ul>
<li>进程是资源分配最小单位，线程是程序执行的最小单位；</li>
<li>进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间。线程是进程的一个实体，一个进程至少有一个线程,同一个进程的所有线程，共享所属进程的资源；</li>
<li>线程占用的资源比进程少很多，所以创建线程和切换线程的开销相对来说很小。但多进程程序更安全，生命力更强。一个进程的死亡不会对其他进程造成影响。而一个线程死掉，（可能会锁住资源）造成整个进程都死掉了。</li>
</ul>
<p><strong>面试官问题：进程的切换与线程有什么不同？</strong></p>
<p><strong>答：</strong>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<p><strong>面试官问题：那么为什么进程的切换比线程大呢？</strong></p>
<p><strong>答：</strong>我们已经知道了进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 Cache 来缓存常用的地址映射，这样可以加速页表查找，这个 Cache 就是 TLB，我们不需要关心这个名字只需要知道TLB本质上就是一个 Cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 TLB 就失效了，Cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<p><strong>面试官问题：我们说线程之间共享一个进程的资源和地址空间，那么线程可以拥有独属于自己的资源吗？</strong></p>
<p><strong>答：</strong>可以的，通过ThreadLocal可以存储线程的特有对象，也就是属于当前线程的资源。</p>
<h2 id="2-3进程空间（看JVM）"><a href="#2-3进程空间（看JVM）" class="headerlink" title="2.3进程空间（看JVM）"></a>2.3进程空间（看JVM）</h2><p>（可以<strong>结合JVM运行时数据区的角度来看进程共享的区域与线程私有的区域</strong>）</p>
<p><strong>进程空间：</strong>内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段。</p>
<p><strong>线程共享的有：</strong>进程代码段、进程公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号处理器、进程当前目录、进程用户ID、进程组ID。</p>
<p><strong>线程私有的：</strong>线程ID、寄存器的值、线程的栈、线程优先级、错误返回码、线程信号屏蔽码。</p>
<ol>
<li>线程ID<br>同一进程中每个线程拥有唯一的线程ID。</li>
<li>寄存器组的值<br>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。</li>
<li>线程堆栈<br>线程可以进行函数调用，必然会使用函数堆栈。</li>
<li>错误返回码<br>线程执行出错时，必须明确是哪个线程出现何种错误，因此不同的线程应该拥有自己的错误返回码变量。</li>
<li>信号屏蔽码<br>由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。</li>
<li>线程的优先级<br>由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。</li>
</ol>
<h2 id="2-4进程的状态"><a href="#2-4进程的状态" class="headerlink" title="2.4进程的状态"></a>2.4进程的状态</h2><p>我们一般把进程大致分为 5 种状态：</p>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器分配的时间片之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<h2 id="2-5进程间的通信方式IPC"><a href="#2-5进程间的通信方式IPC" class="headerlink" title="2.5进程间的通信方式IPC"></a>2.5进程间的通信方式IPC</h2><h3 id="2-5-1用户进程缓存区和内核缓存区"><a href="#2-5-1用户进程缓存区和内核缓存区" class="headerlink" title="2.5.1用户进程缓存区和内核缓存区"></a>2.5.1用户进程缓存区和内核缓存区</h3><p>缓冲区的目的，<strong>主要就是为了减少频繁的与物理设备之间进行数据交换</strong>。比如：外部设备的读写等。</p>
<img src="https://img-blog.csdnimg.cn/20201203232556861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pfX01heA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:80%;">

<ul>
<li><p>有了内存缓冲区，用户进程使用read系统调用时，仅仅将数据从内核缓冲区复制到应用的进程缓冲区（进程缓冲区）；相应的，write系统调用也仅仅是将数据从进程缓冲区复制到内核缓冲区。系统底层会对内核缓冲区进行监控，等待缓冲区中的数据达到一定数量后再进行IO设备的中断处理，其实就是将物理设备的IO操作进行了集中化，减少了对物理设备的直接读写操作，从而提升了系统的整体性能。</p>
</li>
<li><p>从数量的角度来看，操作系统内核中只有一个内核缓冲区，而每个用户进程都会有自己独立的缓冲区（其实就是内存的一个子集），即进程缓冲区。所以，用户在程序中实现的IO读写逻辑，并没有进行实际的IO操作，而是在进程缓冲区和内核缓冲区之间进行数据的交换。</p>
</li>
</ul>
<h3 id="2-5-2七种通信方式"><a href="#2-5-2七种通信方式" class="headerlink" title="2.5.2七种通信方式"></a>2.5.2七种通信方式</h3><ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="2-5-3详细解释"><a href="#2-5-3详细解释" class="headerlink" title="2.5.3详细解释"></a>2.5.3详细解释</h3><p><strong>1.无名管道与命名管道：</strong></p>
<p>管道分为pipe（无名管道）和fifo（命名管道）两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。他们都是通过内核缓冲区实现数据传输。</p>
<ul>
<li>无名管道pipe：用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。</li>
<li>命名管道FIFO：在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。</li>
</ul>
<p><strong>管道的实质是一个内核缓冲区</strong>，进程以<strong>先进先出</strong>的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后在缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或满的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。</p>
<img src="https://img-blog.csdnimg.cn/20190426140549553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW9ob25nX2Jv,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:80%;">

<p><strong>2.消息队列：</strong></p>
<p>消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</p>
<p>消息队列与管道通信相比，其优势是<strong>对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</strong></p>
<p>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
<p><strong>3.共享内存：</strong></p>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取操做读出，从而实现了进程间的通信。</p>
<p>采用共享内存进行通信的一个主要好处是<strong>效率高</strong>，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队列等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而<strong>共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<img src="https://img-blog.csdnimg.cn/2019042614103483.png" alt="在这里插入图片描述" style="zoom:150%;">

<p><strong>4.信号量：</strong></p>
<p><strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问</strong>。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>5.信号：</strong></p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><strong>6.套接字：</strong></p>
<p><strong>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。</strong>也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</p>
<h2 id="2-6线程间的通信方式"><a href="#2-6线程间的通信方式" class="headerlink" title="2.6线程间的通信方式"></a>2.6线程间的通信方式</h2><ul>
<li><p><strong>锁机制：</strong>包括互斥锁、条件变量、读写锁等。</p>
<p>互斥锁：确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</p>
<p>读写锁：当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。</p>
<p>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。（见CSDN博客）</p>
</li>
<li><p><strong>信号量机制(Semaphore)：</strong>包括无名线程信号量和命名线程信号量</p>
</li>
<li><p><strong>信号机制(Signal)：</strong>类似进程间的信号处理</p>
</li>
</ul>
<p><strong>线程间通信的主要目的是用于线程同步</strong>，所以线程没有像进程通信中用于数据交换的通信机制。</p>
<h2 id="2-7多进程和多线程的对比"><a href="#2-7多进程和多线程的对比" class="headerlink" title="2.7多进程和多线程的对比"></a>2.7多进程和多线程的对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据</th>
<th align="center">共享</th>
<th align="center">同步</th>
<th align="center">内存占用</th>
<th align="center">CPU利用率</th>
<th align="center">创建、销毁、切换</th>
<th align="center">相互间影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>多线程</strong></td>
<td align="center">多个线程共享所属进程的数据</td>
<td align="center">共享复杂</td>
<td align="center">困难</td>
<td align="center">少</td>
<td align="center">高</td>
<td align="center">简单且速度快</td>
<td align="center">一个线程挂掉将导致整个进程挂掉（可能会锁住资源）</td>
</tr>
<tr>
<td align="center"><strong>多进程</strong></td>
<td align="center">每个进程都有自己的数据，且互不干涉</td>
<td align="center">共享简单，通过IPC来共享</td>
<td align="center">简单</td>
<td align="center">大</td>
<td align="center">低</td>
<td align="center">复杂且速度慢</td>
<td align="center">进程之间不会相互影响</td>
</tr>
</tbody></table>
<h2 id="2-8单线程与多线程的关系"><a href="#2-8单线程与多线程的关系" class="headerlink" title="2.8单线程与多线程的关系"></a>2.8单线程与多线程的关系</h2><p><strong>先说下 CPU 中时间片的概念：</strong></p>
<p>时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p><strong>面试官问题：说一下多线程与单线程之间的关系吧。</strong></p>
<ul>
<li>多线程是指在<strong>一个进程中，并发执行了多个线程</strong>，每个线程都实现了不同的功能 </li>
<li>在单核CPU中，将CPU分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用CPU的机制。由于<strong>CPU轮询</strong>的速度非常快，所以看起来像是“同时”在执行一样 </li>
<li>多线程会存在<strong>线程上下文切换</strong>，会导致程序执行速度变慢 </li>
<li>多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以<strong>减少用户的等待响应时间，提高了资源的利用效率</strong> </li>
</ul>
<p><strong>面试官问题：为什么要用多线程呢？</strong></p>
<p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<p><strong>面试官问题：多线程会带来哪些问题呢？</strong></p>
<p><strong>答：</strong>多线程并发编程也会带来<strong>数据的安全问题</strong>，线程之间的竞争也会导致<strong>线程死锁</strong>等故障。<strong>线程之间的上下文切换</strong>也会带来<strong>额外的开销</strong>等问题。</p>
<h2 id="2-8竞态"><a href="#2-8竞态" class="headerlink" title="2.8竞态"></a>2.8竞态</h2><p><strong>竞态：</strong>多线程编程中的一个问题，对于同样的输入，程序的输出有时是正确的，有时是错误的，这种计算结果的正确性与时间有关的现象被成为竞态。</p>
<h2 id="2-9线程安全和非线程安全"><a href="#2-9线程安全和非线程安全" class="headerlink" title="2.9线程安全和非线程安全"></a>2.9线程安全和非线程安全</h2><p><strong>线程安全和非线程安全：</strong> 一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能运行正常，我们就称其是线程安全的。反之，一个类在单线程环境下运行正常，而在多线程环境下无法正常运行，这个类就是非线程安全的。</p>
<h1 id="3-用户态与核心态"><a href="#3-用户态与核心态" class="headerlink" title="3.用户态与核心态"></a>3.用户态与核心态</h1><h2 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h2><p>为防止用户进程访问对操作系统的稳定运行造成破坏。对一些资源的访问进行了等级划分。<strong>内核态和用户态是操作系统的两种运行级别，内核态权限高，用户态权限低。</strong></p>
<h2 id="3-2为什么要划分用户态与核心态"><a href="#3-2为什么要划分用户态与核心态" class="headerlink" title="3.2为什么要划分用户态与核心态"></a>3.2为什么要划分用户态与核心态</h2><p><strong>操作系统的很多操作会消耗系统的物理资源，</strong>例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能随便让任何程序都可以做，<strong>于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这样可以做到集中管理，减少有限资源的访问和使用冲突。</strong></p>
<p><strong>当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，</strong>大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的<strong>内核地址空间，</strong>包括代码和数据；<strong>当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。</strong>执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。</p>
<h2 id="3-3用户态和内核态的切换："><a href="#3-3用户态和内核态的切换：" class="headerlink" title="3.3用户态和内核态的切换："></a>3.3用户态和内核态的切换：</h2><p><strong>进程大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。</strong></p>
<p><strong>切换到内核的方式有：</strong>系统调用、发生异常、外围设备的中断。</p>
<h1 id="4-死锁的条件及解决方法"><a href="#4-死锁的条件及解决方法" class="headerlink" title="4.死锁的条件及解决方法"></a>4.死锁的条件及解决方法</h1><h2 id="4-1死锁的产生条件"><a href="#4-1死锁的产生条件" class="headerlink" title="4.1死锁的产生条件"></a>4.1死锁的产生条件</h2><ol>
<li>死锁问题的情景</li>
</ol>
<p>例如：系统中只有一台扫描仪R1和一台刻录机R2.有两个进程P1和P2，他们都准备将扫描的文档刻录到光盘上，进程P1先请求扫描仪并获得成功，进程P2先请求刻录机并获得成功。后来P1又请求刻录机，因为刻录机被分配给了了P2而导致阻塞；P2又请求扫描仪，因为扫描仪被分配给了P1而导致阻塞。双方都希望对方能释放资源而成全自己，但是双方都不让步，然后就一直僵持下去。</p>
<p>再例如哲学家进餐问题也是死锁的问题场景。</p>
<ol start="2">
<li><strong>死锁产生的四个必要条件</strong></li>
</ol>
<p>只要其中任意一个不成立，则死锁就不会发生。</p>
<p>（1）互斥条件：即在一段时间内，一个资源只能被一个进程占用。</p>
<p>（2）请求和保持条件：进程已经获得了某种资源，但又提出了新的资源的要求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己保持的资源不放。</p>
<p>（3）不可抢占资源条件：进程已获得的资源在未使用完成之前不能被其他进程抢占。</p>
<p>（4）循环等待条件：在发生死锁时，必然存在一个循环链。</p>
<h2 id="4-2解决死锁的方法"><a href="#4-2解决死锁的方法" class="headerlink" title="4.2解决死锁的方法"></a>4.2解决死锁的方法</h2><p><strong>1.预防死锁</strong></p>
<p>去破坏产生死锁的四个必要条件中的一个或几个来预防死锁的产生。</p>
<p>由于互斥条件是保护临界资源的一种措施，所以不仅不能改变，还要加以保证。所以只能破坏其他三个条件。</p>
<p>（1）破坏“请求和保持条件”</p>
<p>第一种协议：进程必须一次性的申请所需的所有资源，并且系统有足够的资源分配给他，否则就不分配。</p>
<p>这种协议的优点是简单，易行且安全，但存在很大的问题，比如资源严重浪费和使进程发生饥饿现象。</p>
<p>第二种协议：允许一个进程只获得运行初期的所需资源，在进程运行过程中，将运行完成的资源释放，然后再请求其他所需资源。</p>
<p>（2）破坏“不可抢占条件”</p>
<p>将不可抢占变成可抢占的资源，实现起来较为复杂，且需要付出很大的代价。</p>
<p>（3）破坏“循环条件”</p>
<p>将循环条件改为层次分配策略</p>
<p><strong>2.避免死锁</strong></p>
<p>在资源的动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p>
<p>安全状态：只要存在一种可以顺利完成任务的顺序就属于安全状态。</p>
<p>不安全状态：没有任意一种顺序使任务顺利完成。</p>
<p><strong>3.检测死锁</strong></p>
<p>通过检测机构检测出死锁的发生，然后采取适当的措施。</p>
<p><strong>4.解除死锁</strong></p>
<p>当检测到死锁已经发生时，撤销一些进程，回收他们的资源，将他们分配给其他需要的进程，使其继续运行。解除死锁的方法：</p>
<p>（1）抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程。</p>
<p>（2）终止进程：终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。</p>
<h1 id="5-操作系统内存管理基础"><a href="#5-操作系统内存管理基础" class="headerlink" title="5.操作系统内存管理基础"></a>5.操作系统内存管理基础</h1><h2 id="5-1内存管理介绍"><a href="#5-1内存管理介绍" class="headerlink" title="5.1内存管理介绍"></a>5.1内存管理介绍</h2><ul>
<li>操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存）；</li>
<li>另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</li>
</ul>
<h2 id="5-2常见的内存管理机制"><a href="#5-2常见的内存管理机制" class="headerlink" title="5.2常见的内存管理机制"></a>5.2常见的内存管理机制</h2><ul>
<li><p><strong>连续分配管理方式：</strong>连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如<strong>块式管理</strong>。</p>
<p><strong>块式管理：</strong>将内存分为几个<code>固定大小</code>的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部碎片。</p>
</li>
<li><p><strong>非连续分配管理方式：</strong>因为连续分配管理方式容易产生大量的内部碎片，如果将一个进程离散地装配到内存中，就可以有效地利用内存空间。非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 、 <strong>段式管理</strong>以及<strong>段页式管理机制</strong> 。</p>
<p><strong>页式管理</strong> ：把主存分为<code>大小相等</code>且固定的一页一页的形式，<code>页较小</code>，相对相比于块式管理的划分力度更大，<code>提高了内存利用率</code>，<code>减少了碎片</code>。页式管理通过页表对应逻辑地址和物理地址。</p>
<p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</p>
<p><strong>段页式管理机制</strong> ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>内部碎片&amp;外部碎片</p>
<ul>
<li><strong>内部碎片：</strong>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</li>
<li><strong>外部碎片：</strong>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</li>
</ul>
</blockquote>
<h2 id="5-3分页存储"><a href="#5-3分页存储" class="headerlink" title="5.3分页存储"></a>5.3分页存储</h2><h3 id="5-3-1分页存储的思想"><a href="#5-3-1分页存储的思想" class="headerlink" title="5.3.1分页存储的思想"></a>5.3.1分页存储的思想</h3><p>把主存分为<code>大小相等</code>且固定的一页一页的形式，<code>页较小</code>，相对相比于块式管理的划分力度更大，<code>提高了内存利用率</code>，<code>减少了碎片</code>。页式管理通过页表对应逻辑地址和物理地址。</p>
<h3 id="5-3-2分页存储地址的转换"><a href="#5-3-2分页存储地址的转换" class="headerlink" title="5.3.2分页存储地址的转换"></a>5.3.2分页存储地址的转换</h3><ul>
<li><p>因为内存分页后，页面的大小是确定的，比如是50B；</p>
</li>
<li><p>假如需要访问逻辑地址为80的内存单元；</p>
</li>
<li><p>用80/50=1，也就是在1号页；</p>
</li>
<li><p>用80%50=30，也就是页内偏移量为30；</p>
</li>
<li><p>再加上该页面在内存中的起始地址，就能得到逻辑地址到物理地址的映射。</p>
</li>
</ul>
<h3 id="5-3-2分页存储的逻辑结构"><a href="#5-3-2分页存储的逻辑结构" class="headerlink" title="5.3.2分页存储的逻辑结构"></a>5.3.2分页存储的逻辑结构</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.05.png" style="zoom:80%;">

<h3 id="5-3-3页式存储-页表"><a href="#5-3-3页式存储-页表" class="headerlink" title="5.3.3页式存储-页表"></a>5.3.3页式存储-页表</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.06.png" style="zoom:80%;">

<h3 id="5-3-4分页存储管理的基本地址变换结构"><a href="#5-3-4分页存储管理的基本地址变换结构" class="headerlink" title="5.3.4分页存储管理的基本地址变换结构"></a>5.3.4分页存储管理的基本地址变换结构</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.07.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.08.png" style="zoom:80%;">

<h2 id="5-4快表机制与多级页表"><a href="#5-4快表机制与多级页表" class="headerlink" title="5.4快表机制与多级页表"></a>5.4快表机制与多级页表</h2><p><strong>在分页存储中，很重要的两个问题：</strong></p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大、占用内存空间较大的问题。</li>
</ol>
<h3 id="5-4-1快表机制"><a href="#5-4-1快表机制" class="headerlink" title="5.4.1快表机制"></a>5.4.1快表机制</h3><p><strong>思想：</strong>图片中</p>
<p><strong>优点：</strong>采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p><strong>使用快表之后的地址转换流程：</strong></p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.01.png" style="zoom:80%;">

<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.02.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.3.01.png"></p>
<h3 id="5-4-2多级页表"><a href="#5-4-2多级页表" class="headerlink" title="5.4.2多级页表"></a>5.4.2多级页表</h3><p><strong>思想：</strong>为了解决页表必须连续存储的问题，可以考虑用分页的方式将页表离散地存储到内存中，为离散的页表再建立一张页表，成为页表目录</p>
<p><strong>优点：</strong>避免把全部页表一直放在内存中占用过多空间</p>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.02.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.3.01.png"></p>
<h3 id="5-4-3总结"><a href="#5-4-3总结" class="headerlink" title="5.4.3总结"></a>5.4.3总结</h3><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理。</p>
<h2 id="5-5分段存储"><a href="#5-5分段存储" class="headerlink" title="5.5分段存储"></a>5.5分段存储</h2><h3 id="5-5-1分段存储的思想"><a href="#5-5-1分段存储的思想" class="headerlink" title="5.5.1分段存储的思想"></a>5.5.1分段存储的思想</h3><p>按照<strong>程序自身的逻辑关系</strong>划分为若干个段，每个段都有一个段名，每段从0开始编址。</p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.03.png" style="zoom:80%;">

<h3 id="5-5-2分段存储的逻辑结构"><a href="#5-5-2分段存储的逻辑结构" class="headerlink" title="5.5.2分段存储的逻辑结构"></a>5.5.2分段存储的逻辑结构</h3><p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.4.04.png"></p>
<p>因为页面大小是一定的，所以页号可以是隐含的，但是段的大小不固定，所以断号是必须的，所以是二维的</p>
<h3 id="5-5-3分段存储地址变换"><a href="#5-5-3分段存储地址变换" class="headerlink" title="5.5.3分段存储地址变换"></a>5.5.3分段存储地址变换</h3><p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.05.png" style="zoom:80%;">!</p>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片01.png" alt="在这里插入图片描述"></p>
<h2 id="5-6分段、分页管理的对比"><a href="#5-6分段、分页管理的对比" class="headerlink" title="5.6分段、分页管理的对比"></a>5.6分段、分页管理的对比</h2><ol>
<li><strong>共同点</strong> ：<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><strong>区别</strong> ：<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.07.png" style="zoom:80%;">



<p><strong>分段实现信息共享共享</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.08.png" style="zoom:80%;">

<p><strong>分页不方便实现信息共享和保护</strong></p>
<p>因为有的页中包含多段程序，有的程序逻辑是不允许被多个进程访问的</p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.09.png" style="zoom:80%;">

<h2 id="5-7段页式存储管理"><a href="#5-7段页式存储管理" class="headerlink" title="5.7段页式存储管理"></a>5.7段页式存储管理</h2><h3 id="5-7-1分页、分段的优缺点分析"><a href="#5-7-1分页、分段的优缺点分析" class="headerlink" title="5.7.1分页、分段的优缺点分析"></a>5.7.1分页、分段的优缺点分析</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.01.png" style="zoom:80%;">

<h3 id="5-7-2段页式管理思想"><a href="#5-7-2段页式管理思想" class="headerlink" title="5.7.2段页式管理思想"></a>5.7.2段页式管理思想</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.02.png" style="zoom:80%;">

<h3 id="5-7-3段页式管理的逻辑地址结构"><a href="#5-7-3段页式管理的逻辑地址结构" class="headerlink" title="5.7.3段页式管理的逻辑地址结构"></a>5.7.3段页式管理的逻辑地址结构</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.03.png" style="zoom:80%;">

<h3 id="5-7-4段页式存储的段表、页表"><a href="#5-7-4段页式存储的段表、页表" class="headerlink" title="5.7.4段页式存储的段表、页表"></a>5.7.4段页式存储的段表、页表</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.04.png" style="zoom:80%;">

<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片02.png" alt="在这里插入图片描述"></p>
<h2 id="5-8逻辑（虚拟）地址和物理地址"><a href="#5-8逻辑（虚拟）地址和物理地址" class="headerlink" title="5.8逻辑（虚拟）地址和物理地址"></a>5.8逻辑（虚拟）地址和物理地址</h2><p>比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h2 id="5-9CPU-寻址与为什么需要虚拟地址空间"><a href="#5-9CPU-寻址与为什么需要虚拟地址空间" class="headerlink" title="5.9CPU 寻址与为什么需要虚拟地址空间"></a>5.9CPU 寻址与为什么需要虚拟地址空间</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要通过内存管理单元（Memory Management Unit, MMU） 的硬件将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated"></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。会出现的问题：</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区；</li>
<li>方便实现各个进程空间之间的隔离，互不干扰，因为每个进程都对应自己的虚拟地址空间；</li>
<li>实现虚拟存储，从逻辑上扩大了内存。</li>
</ul>
<h2 id="5-10虚拟内存的概念"><a href="#5-10虚拟内存的概念" class="headerlink" title="5.10虚拟内存的概念"></a>5.10虚拟内存的概念</h2><h3 id="5-10-1内存、磁盘与虚拟内存的关系"><a href="#5-10-1内存、磁盘与虚拟内存的关系" class="headerlink" title="5.10.1内存、磁盘与虚拟内存的关系"></a>5.10.1内存、磁盘与虚拟内存的关系</h3><p>计算机在运行程序时，必须将磁盘中的内容加载到内存中，不加载是不能运行程序的。在内存中有一部分数据存的是磁盘的缓存，这样做可以加速磁盘访问速度。就跟我们开发程序中使用的缓存作用一样。</p>
<p><strong>虚拟内存：</strong>虚拟内存，是指把磁盘中的一部分作为假想的内存使用，windows通过分页式虚拟内存机制：即在不考虑程序构造的情况下将程序按照一定大小的页进行划分，并以页为单位在内存和磁盘间进行置换。一般来说自己计算机的实际内存大小即为当前页文件的大小。这个是可以在电脑中进行设定的。</p>
<h3 id="5-10-2传统存储管理的特征、缺点"><a href="#5-10-2传统存储管理的特征、缺点" class="headerlink" title="5.10.2传统存储管理的特征、缺点"></a>5.10.2传统存储管理的特征、缺点</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.01.png" style="zoom:80%;">

<h3 id="5-10-3局部性原理"><a href="#5-10-3局部性原理" class="headerlink" title="5.10.3局部性原理"></a>5.10.3局部性原理</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.02.png" style="zoom:80%;">

<h3 id="5-10-4虚拟内存的定义和特征"><a href="#5-10-4虚拟内存的定义和特征" class="headerlink" title="5.10.4虚拟内存的定义和特征"></a>5.10.4虚拟内存的定义和特征</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.03.png" style="zoom:80%;">

<p><strong>虚拟存储器：</strong>（暂时认为与虚拟内存的概念差不多）</p>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>虚拟内存是一种<strong>时间换空间</strong>的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</p>
<h3 id="5-10-5如何实现虚拟内存技术"><a href="#5-10-5如何实现虚拟内存技术" class="headerlink" title="5.10.5如何实现虚拟内存技术"></a>5.10.5如何实现虚拟内存技术</h3><ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分页面即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，如果发现程序段不在内存中，可以通过置换算法将对应的程序段从磁盘中装入内存；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.04.png" style="zoom:80%;">

<h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><p><strong>1.知识总览</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.01.png" style="zoom:80%;">

<p><strong>2.请求页表与基本页表的区别</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.02.png" style="zoom:80%;">

<p><strong>3.缺页中断机构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.03.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.04.png" style="zoom:80%;">

<p><strong>只看这个图也可以，对上面的总结</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.05.png" style="zoom:80%;">

<p><strong>4.地址变换机构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.07.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.08.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.09.png" style="zoom:80%;">

<h3 id="5-10-6页面置换算法"><a href="#5-10-6页面置换算法" class="headerlink" title="5.10.6页面置换算法"></a><strong>5.10.6页面置换算法</strong></h3><p>当发生缺页中断时，如果当前内存中并没有空闲的空间，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们<strong>可以把页面置换算法看成是淘汰页面的规则</strong>。</p>
<p>页面的换入换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法<strong>追求更低的缺页率</strong>。（也就是尽可能少的进行页面置换）</p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.02.png" style="zoom:80%;">

<p><strong>1.最佳置换算法—OPT</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.03.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.04.png" style="zoom:80%;">

<p><strong>2.先进先出置换算法—FIFO</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.05.png" style="zoom:80%;">

<p><strong>FIFO的改进策略：</strong>即给每个页面增加一个R位，表示最近访问过，每次先从链表头开始查找，如果R置1位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。</p>
<p><strong>3.最近最久未使用置换算法—LRU</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.06.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.07.png" style="zoom:80%;">

<p><strong>4.时钟置换算法—CLOCK</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.08.png" style="zoom:80%;">

<p><strong>5.改造型时钟置换算法</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.09.png" style="zoom:80%;">

<p><strong>例：</strong>开始都是（1,1）</p>
<p>第一轮没找到未访问&amp;未修改的页面</p>
<p>第二轮也没找到未访问&amp;修改过的页面，但是将访问位置零（0,1）</p>
<p>第三轮看看将访问位置零后，有没有（0,0）。因为第二轮之前不排除有（1,0）的情况。</p>
<p>第四轮肯定有（0,1）了</p>
<h1 id="6-进程调度算法"><a href="#6-进程调度算法" class="headerlink" title="6.进程调度算法"></a>6.进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="1-批处理系统"><a href="#1-批处理系统" class="headerlink" title="1.批处理系统"></a>1.批处理系统</h2><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2 id="2-交互式系统"><a href="#2-交互式系统" class="headerlink" title="2.交互式系统"></a>2.交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片07.png" alt="img"></p>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source_posts\2021-03-15-操作系统\图片08.png" alt="img"></p>
<h2 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3.实时系统"></a>3.实时系统</h2><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统相关</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1主机之间的通信方式"><a href="#1-1主机之间的通信方式" class="headerlink" title="1.1主机之间的通信方式"></a>1.1主机之间的通信方式</h2><ul>
<li><strong>客户-服务器（C/S）：</strong>客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片01.png" alt="img" style="zoom:80%;">



<ul>
<li><strong>对等（P2P）：</strong>不区分客户和服务器。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片02.png" alt="img" style="zoom:80%;">

<h2 id="1-2电路交换与分组交换"><a href="#1-2电路交换与分组交换" class="headerlink" title="1.2电路交换与分组交换"></a>1.2电路交换与分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要<strong>建立一条专用的物理链路</strong>，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对<strong>线路的利用率很低</strong>，往往不到 10%。</p>
<h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此<strong>在同一条传输线路上允许同时传输多个分组</strong>，也就是说分组交换不需要占用传输线路，并且根据不同的目的地址交付给不同的应用进程，实现线路的复用，提高了线路的利用率。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h2 id="1-3计算机网络体系结构"><a href="#1-3计算机网络体系结构" class="headerlink" title="1.3计算机网络体系结构"></a>1.3计算机网络体系结构</h2><p>OSI：是一种开放式系统互联通信的抽象参考模型。</p>
<ul>
<li>OSI七层模型：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层；</li>
<li>TCP/IP4层模型：网络接口层，网络层，运输层，应用层；（将会话层、表示层、应用层合并为应用层，将物理层和数据链路层合并为网络接口层）</li>
<li>5层模型：物理层，数据链路层，网络层，运输层，应用层；（将会话层、表示层、应用层合并为应用层）</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<h2 id="1-4七层模型的功能及相关协议"><a href="#1-4七层模型的功能及相关协议" class="headerlink" title="1.4七层模型的功能及相关协议"></a>1.4七层模型的功能及相关协议</h2><p><strong>应用层：</strong>因为用户的需求多种多样，需要不同的应用程序来完成。而应用层就是规定各个应用之间消息传递的形式，要求应用层采用不同的协议来解决不同应用类型的需求。典型的协议有：文件传输协议 FTP、电子邮件协议 SMTP、万维网 HTTP 等</p>
<p><strong>表示层：</strong>数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
<p><strong>会话层：</strong>用于建立、管理会话</p>
<p><strong>传输层：</strong>为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议  TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议  UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
<ul>
<li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li>
<li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li>
</ul>
<p><strong>网络层：</strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。那网络层的作用就是将传输层传递下来的报文段封装成分组，然后选择合适的网间路由和交换结点， 确保数据及时传送。网络层的相关协议如下：</p>
<ol>
<li>IP协议</li>
<li>ICMP：为了提高IP数据报交付成功的机会，在网络层使用了<code>网际控制报文协议</code>(Internet Control Message Protocol, <code>ICMP</code>)来<code>让主机或路由器报告差错和异常情况</code>。</li>
<li>IGMP</li>
<li>OSPF：外部网关协议</li>
<li>RIP：内部网关协议</li>
<li>ARP：将IP地址解析为MAC地址</li>
</ol>
<p><strong>数据链路层：</strong>通过 Mac 地址访问媒介。在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p><strong>物理层：</strong>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<h2 id="1-5数据在各层的具体传输过程"><a href="#1-5数据在各层的具体传输过程" class="headerlink" title="1.5数据在各层的具体传输过程"></a>1.5数据在各层的具体传输过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<p>交换机工作在数据链路层，它内部会维护一张 Mac 表，对应着不同的端口，在通讯中会将数据帧按照它的 Mac 地址传送到不同的端口，并没有涉及到网络层的协议所以是工作在数据链路层。</p>
<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h1><h2 id="2-1通信方式"><a href="#2-1通信方式" class="headerlink" title="2.1通信方式"></a>2.1通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="2-2带通调制"><a href="#2-2带通调制" class="headerlink" title="2.2带通调制"></a>2.2带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<h1 id="3-链路层"><a href="#3-链路层" class="headerlink" title="3.链路层"></a>3.链路层</h1><p><strong>MTU：</strong><code>一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)。</code>因为IP数据报被封装在链路层数据报中，因此<code>链路层的MTU严格地限制着IP数据报的长度，而且在IP数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU</code>。例如，以太网的MTU为<code>1500B</code>，而许多广域网的MTU不超过576B。当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在两个或多个较小的IP数据报中，这些较小的数据报称为<code>片</code>。</p>
<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h1><h2 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片03.png" alt="img" style="zoom: 50%;">



<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="4-2-IP-数据报格式"><a href="#4-2-IP-数据报格式" class="headerlink" title="4.2 IP 数据报格式"></a>4.2 IP 数据报格式</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片04.png" alt="img" style="zoom:67%;">



<ul>
<li><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong>   : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片05.png" alt="img" style="zoom: 50%;">

<h2 id="4-3-IP-地址编址方式"><a href="#4-3-IP-地址编址方式" class="headerlink" title="4.3 IP 地址编址方式"></a>4.3 IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片06.png" alt="img" style="zoom:50%;">

<h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2.子网划分"></a>2.子网划分</h3><p>子网划分的好处：</p>
<ol>
<li>更高效地利用 IP 资源</li>
<li>便于管理，比如不同的部门使用不同的网段</li>
</ol>
<p>子网划分是通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码，子网掩码的作用是在所有收到的数据包中，筛选出该子网中的数据包。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3.无分类"></a>3.无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h2 id="4-4地址解析协议-ARP"><a href="#4-4地址解析协议-ARP" class="headerlink" title="4.4地址解析协议 ARP"></a>4.4地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片07.png" alt="img" style="zoom:67%;">

<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片08.png" alt="img"></p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A  知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP  地址到 MAC 地址的映射。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片09.png" alt="img" style="zoom: 67%;">

<h2 id="4-5网际控制报文协议-ICMP"><a href="#4-5网际控制报文协议-ICMP" class="headerlink" title="4.5网际控制报文协议 ICMP"></a>4.5网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片10.png" alt="img" style="zoom: 67%;">

<p>ICMP 报文分为差错报告报文和询问报文。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片11.png" alt="img" style="zoom: 50%;">

<h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率</p>
<h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减  1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="4-6网络地址转换-NAT"><a href="#4-6网络地址转换-NAT" class="headerlink" title="4.6网络地址转换 NAT"></a>4.6网络地址转换 NAT</h2><p><strong>1.私有 IP 地址</strong></p>
<p>仅限于本地的局域网中使用，<strong>路由器对目的地址是私有 IP 地址的数据包一律不进行转发</strong>，也就是私有 IP 地址在网络中是无效的。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片23.png" alt="image-20210801163419306" style="zoom:80%;">

<p><strong>2.网络地址转换 NAT</strong></p>
<p>网络地址转换 NAT：在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装 NAT 软件，安装了 NAT 软件的路由器叫 <strong>NAT 路由器</strong>，它至少有一个有效的<strong>外部全球 IP 地址</strong>。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片24.png" alt="image-20210801165027982" style="zoom:50%;">

<p>A 主机和 C 主机（空白主机）在同一个内网中。</p>
<p><strong>A 主机与外网中的 B 主机通信的过程：</strong></p>
<ol>
<li>应用层产生一个数据报：目的地址–213.18.2.4，源地址–192.168.0.3，端口号 30000；</li>
<li>NAT 地址转换：到了 NAT 路由器这里，会按照 NAT table 将源地址替换成 172.38.1.5，端口号为 40001，也就是对外这个 IP 地址才是有效的；</li>
<li>发送数据包</li>
</ol>
<p><strong>外网中的 B 主机，向内网中 C 主机发送数据的过程：</strong></p>
<ol>
<li>应用层产生一个数据报：目的地址–172.38.1.5，端口号 30000（访问内网共用的 IP 地址），源地址–213.18.2.4；</li>
<li>NAT 地址转换：到了 NAT 路由器这里，会按照 NAT table 将源地址替换成 192.168.0.4，端口号为 30001；</li>
<li>发送数据包</li>
</ol>
<h2 id="4-7路由器"><a href="#4-7路由器" class="headerlink" title="4.7路由器"></a>4.7路由器</h2><h3 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h3><p>路由器从功能上可以划分为：路由选择部分和分组转发部分。</p>
<p><strong>路由选择部分：</strong></p>
<p>根据所选择的路由选择协议（RIP、OSPF、BGP）构造出路由表，并定期与相邻的路由器交换信息来维护路由表</p>
<p><strong>分组转发结构由三个部分组成：</strong></p>
<ol>
<li>交换结构：若收到 RIP/OSPF 分组，则把分组送往路由选择处理机，根据不同的路由选择协议来维护路由表；若是数据分组，根据转发表找到合适的输出端口，将分组发送出去</li>
<li>一组输入端口：分组输入</li>
<li>一组输出端口：找到合适的端口输出分组</li>
</ol>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片25.png" alt="img"></p>
<h3 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h3><p>路由器无论是是直接转发还是间接转发，都需要根据分组的目的IP地址和源IP地址是否属于同一网络判断。目的主机和源主机在同一网络，或者是当目的路由器向目的主机发送时，分组将直接发送。反之，则间接发送。</p>
<p>路由器在收到 IP 数据报告后执行的分组转发步骤如下：</p>
<ol>
<li>首先提取出目的主机的 IP 地址 D 得出其所在的网络 N。</li>
<li>若网络 N 与此路由器直接相连。则把数据报<strong>直接交付</strong>目的主机 D。否则是<strong>间接交付</strong>，运行(3)。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。 否则执行（4）</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传给路由表中所指明的下一跳路由器。 否则执行（5）</li>
<li>若路由表中有一个默认路由，则把数据报传给默认路由所指明的默认路由器。否则执行（6）</li>
<li>报告转发分组出错。</li>
</ol>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片27.png" alt="img" style="zoom:80%;">

<blockquote>
<p><strong>Note：</strong></p>
<p><strong>特定主机路由：</strong>这样的路由是为<strong>特定的目的主机</strong>指明一个路由。</p>
<p><strong>默认路由：</strong>目的网络在路由表中匹配不到，就一律选择默认路由。</p>
</blockquote>
<h3 id="路由选择协议（没掌握）"><a href="#路由选择协议（没掌握）" class="headerlink" title="路由选择协议（没掌握）"></a>路由选择协议（没掌握）</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<p><strong>1. 内部网关协议 RIP</strong></p>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<p><strong>2. 内部网关协议 OSPF</strong></p>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法（广播）。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示（路由器收到到其它路由器的链路状态之后，再通过 Dijkstra 算法来更新自己的路由表）。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<p><strong>3. 外部网关协议 BGP</strong></p>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片26.png" alt="img" style="zoom:67%;">

<h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h1><h2 id="5-1-TCP-与-UDP-协议的对比"><a href="#5-1-TCP-与-UDP-协议的对比" class="headerlink" title="5.1 TCP 与 UDP 协议的对比"></a>5.1 TCP 与 UDP 协议的对比</h2><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，可能会对大数据包进行拆分，并且在接收方进行重组数据包操作，每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h2 id="5-2-UDP-首部格式"><a href="#5-2-UDP-首部格式" class="headerlink" title="5.2 UDP 首部格式"></a>5.2 UDP 首部格式</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片12.png" alt="img" style="zoom:67%;">

<ul>
<li>源端口：源端口号。在需要对方回信时选用，不需要时可用全0。 </li>
<li>目的端口：目的端口号。这在终点交付报文时必须使用到。 </li>
<li>长度：UDP 数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。 </li>
<li>校验和：检测 UDP 数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全 0。</li>
</ul>
<h2 id="5-3-TCP-首部格式"><a href="#5-3-TCP-首部格式" class="headerlink" title="5.3 TCP 首部格式"></a>5.3 TCP 首部格式</h2><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom: 50%;">

<p><strong>序号（seq）：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p><strong>确认号（ack）：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
<p><strong>确认（ACK）：</strong>当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
<p><strong>同步（SYN）：</strong>在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
<p><strong>终止（FIN）：</strong>用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
<p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<h2 id="5-4-TCP-的三次握手"><a href="#5-4-TCP-的三次握手" class="headerlink" title="5.4 TCP 的三次握手"></a>5.4 TCP 的三次握手</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片13.png" alt="img" style="zoom: 50%;">

<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x(比如是100)，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1（101，客户端发过来的序列号+1），随机产生一个值seq=y（300），并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1（也就是确认服务器端已经收到了seq=100的报文），如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1（301），ACK是否为1（也就是确认客户端端已经收到了seq=300的报文），如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据</li>
</ul>
<p>（也就是双方确认双发都具有收、发功能的过程）</p>
<h3 id="1-为什么要三次握手，两次可以吗"><a href="#1-为什么要三次握手，两次可以吗" class="headerlink" title="1.为什么要三次握手，两次可以吗"></a>1.为什么要三次握手，两次可以吗</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>假如只有前面 2 次握手，那么服务端来收到 SYN 并且发出 SYN+ACK 包之后就会处于工作状态。如果服务端在某一时刻突然收到了一个来自客户端的 SYN 包，在发出 ACK 之后，服务端处于工作状态。但是可能这个包是卡了很久已经被客户端给丢弃了。客户端收到 SYN+ACK 之后，表示情绪淡定不予理会，但是服务端已经处于工作状态了，会造成资源的浪费。</p>
<h3 id="2-为什么要传回-SYN"><a href="#2-为什么要传回-SYN" class="headerlink" title="2.为什么要传回 SYN"></a>2.为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="3-传了-SYN，为啥还要传-ACK"><a href="#3-传了-SYN，为啥还要传-ACK" class="headerlink" title="3.传了 SYN，为啥还要传 ACK"></a>3.传了 SYN，为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h3 id="4-SYN-攻击"><a href="#4-SYN-攻击" class="headerlink" title="4.SYN 攻击"></a>4.SYN 攻击</h3><p><strong>1.SYN攻击概述</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p><strong>2.怎么检测是否受到了SYN攻击</strong></p>
<p>检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<p><strong>3.怎么解决SYN攻击</strong></p>
<ul>
<li>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</li>
<li>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li>
</ul>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<h2 id="5-5-TCP-的四次挥手"><a href="#5-5-TCP-的四次挥手" class="headerlink" title="5.5 TCP 的四次挥手"></a>5.5 TCP 的四次挥手</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片14.png" alt="img" style="zoom:67%;">

<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入<strong>TIME_WAIT状态</strong>，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
<h3 id="1-为什么要进行四次挥手过程"><a href="#1-为什么要进行四次挥手过程" class="headerlink" title="1.为什么要进行四次挥手过程"></a>1.为什么要进行四次挥手过程</h3><p>由于TCP连接是<strong>全双工的</strong>，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h3 id="2-TCP-连接出现故障问题"><a href="#2-TCP-连接出现故障问题" class="headerlink" title="2. TCP 连接出现故障问题"></a>2. TCP 连接出现故障问题</h3><p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<h3 id="3-关于-TIME-WAIT"><a href="#3-关于-TIME-WAIT" class="headerlink" title="3.关于 TIME_WAIT"></a>3.关于 TIME_WAIT</h3><p><strong>1.四次挥手主动方为什么需要等待 2MSL ？</strong></p>
<p>因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的 ACK 报文。也就是说 client 不能立刻关闭，要等待这个 TCP 连接断开之后再关闭。如果最后一次 ACK 没有被正确的传给被动方，被动关闭方会再次发送第三次的 FIN 信号。</p>
<p><strong>MSL表示最大报文生存周期</strong>，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p><strong>2.为什么会出现大量的TIME_WAIT状态？</strong></p>
<p>在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>正常的 TCP 客户端连接在关闭后，会进入一个 TIME_WAIT 的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的 socket 端口和句柄被用尽，系统无法再发起新的连接！（对于一个处理大量短连接的服务器,如果由服务器主动关闭客户端的连接,将导致服务器存在大量的处于 TIME_WAIT状态的socket，严重影响服务器的处理能力,甚至耗尽可用的 socket）。</p>
<p><strong>3.解决方法</strong></p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><strong>简单来说，就是打开系统的TIMEWAIT状态的Sockets的重用和快速回收。</strong></p>
<h2 id="5-6-TCP-可靠传输"><a href="#5-6-TCP-可靠传输" class="headerlink" title="5.6 TCP 可靠传输"></a>5.6 TCP 可靠传输</h2><p><strong>可靠性指的是：</strong>保证接收方进程从接收缓存中读出的字节流与发送方发出的字节流是完全一样的</p>
<ul>
<li><p><strong>校验：</strong> TCP 通过它首部的的检验和字段。目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p><strong>序号：</strong>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p><strong>确认：</strong><img src="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>重传</strong></p>
<p><strong>a.超时重传：</strong>当发送方在重传时间RTTs内没有收到接收方的确认报文，就要重传已发送的字段</p>
<p><strong>b.冗余ACK：</strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>流量控制</strong></p>
</li>
<li><p><strong>拥塞控制</strong></p>
</li>
</ul>
<h3 id="1-TCP-流量控制"><a href="#1-TCP-流量控制" class="headerlink" title="1. TCP 流量控制"></a>1. TCP 流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>滑动窗口的解释：</strong></p>
<p>接收方根据自己接收缓存的大小，通过调整确认报文段首部中的“窗口”字段值，动态地调整发送方的发送窗口大小，来限制发送方向网络注入报文的速率。这就是滑动窗口的思想。</p>
<h3 id="2-TCP-拥塞控制"><a href="#2-TCP-拥塞控制" class="headerlink" title="2. TCP 拥塞控制"></a>2. TCP 拥塞控制</h3><p>一条TCP连接上发送数据速度的影响因素有：服务器到客户端之间带宽瓶颈、客户端接收能力限制、服务器网卡处理能力</p>
<ol>
<li><p><strong>条件：</strong>对于资源的需求大于供应，导致网络的性能变坏，表现为网络的吞吐量随着网络负荷的增加而减小</p>
<p><strong>例如：</strong></p>
<ul>
<li><p>某个链路的传输速率为10Gb/s,某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。</p>
</li>
<li><p>但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>目的：</strong>是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>
</li>
<li><p><strong>过程：</strong>拥塞控制是一个<strong>全局性的过程</strong>，不止是控制发送方发送的数据量</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
</li>
<li><p><strong>四种TCP拥塞控制的算法</strong><img src="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>(1)慢开始算法</strong></p>
<p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加倍。用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</p>
<p>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</p>
<p><strong>(2)拥塞避免算法</strong></p>
<p>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
<blockquote>
<p><strong>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</strong></p>
<p><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</p>
<p><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p>
</blockquote>
<p> <strong>(1)快重传</strong></p>
<p>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</p>
<p><strong>(2)快恢复</strong></p>
<p><code>快恢复算法</code>的原理如下:</p>
<p>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</p>
<p>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</p>
<p><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</p>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程：</strong><img src="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>四种拥塞控制算法的总结</strong></p>
<ul>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<p><strong>拥塞控制与流量控制</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
</li>
</ol>
<h2 id="5-7-TCP-粘包现象"><a href="#5-7-TCP-粘包现象" class="headerlink" title="5.7 TCP 粘包现象"></a>5.7 TCP 粘包现象</h2><p><strong>TCP粘包概念：</strong>就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。</p>
<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h3><ul>
<li><strong>发送方原因：</strong>TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li><strong>接收方原因：</strong>TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p>
<ul>
<li><p><strong>发送方：</strong>发送方关闭Nagle算法。</p>
</li>
<li><p><strong>接收方：</strong>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p>
</li>
</ul>
<h3 id="3-为什么TCP会有粘包现象，而UDP没有"><a href="#3-为什么TCP会有粘包现象，而UDP没有" class="headerlink" title="3.为什么TCP会有粘包现象，而UDP没有"></a>3.为什么TCP会有粘包现象，而UDP没有</h3><p><strong>TCP：</strong>为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的。如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包，因此就会造成粘包现象。</p>
<p><strong>UDP：</strong>面向消息传输，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<blockquote>
<p><strong>消息边界：</strong></p>
<ul>
<li>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；</li>
<li>而面向流则是指无保护消息保护边界的,如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包。因此就会造成粘包现象</li>
</ul>
</blockquote>
<h2 id="5-8-TCP，UDP-协议的区别"><a href="#5-8-TCP，UDP-协议的区别" class="headerlink" title="5.8 TCP，UDP 协议的区别"></a>5.8 TCP，UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<ul>
<li>TCP协议进行数据通信之前需要三次握手建立连接，UDP协议不需要建立连接即可发送数据。 </li>
<li>TCP有确认机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。 </li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。 </li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。 </li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景</li>
<li>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</li>
</ul>
<h2 id="5-9点对点与端对端的区别"><a href="#5-9点对点与端对端的区别" class="headerlink" title="5.9点对点与端对端的区别"></a>5.9点对点与端对端的区别</h2><ul>
<li><strong>点到点通信：</strong>是针对<strong>数据链路层或网络层</strong>来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li><strong>端到端通信：</strong>是针对<strong>传输层</strong>来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。</li>
</ul>
<h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="1-浏览器输入url并回车的过程以及相关协议"><a href="#1-浏览器输入url并回车的过程以及相关协议" class="headerlink" title="1.浏览器输入url并回车的过程以及相关协议"></a>1.浏览器输入url并回车的过程以及相关协议</h2><ol>
<li>DNS解析：将域名解析成对应的服务器IP地址。</li>
<li>建立TCP连接：拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</li>
<li>建立TCP连接的基础上发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束：</li>
</ol>
<p><strong>使用的协议：</strong>DNS（获取域名的IP的地址），TCP（与服务器建立 TCP 连接）、IP（建立 TCP 协议时，需发送数据，在网络层用到 IP 协议）、OPSF（IP 数据包在路由之间传送，路由选择使用 OPSF 协议）、ARP（路由器与服务器通信时，将 IP 地址转化为 MAC 地址，使用 ARP 协议）、HTTP（TCP 建立之后，使用 HTTP 协议访问网页）。</p>
<h2 id="2-DNS域名解析的过程"><a href="#2-DNS域名解析的过程" class="headerlink" title="2.DNS域名解析的过程"></a>2.DNS域名解析的过程</h2><p><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-HTTP"><a href="#7-HTTP" class="headerlink" title="7. HTTP"></a>7. HTTP</h1><h2 id="7-1基础概念"><a href="#7-1基础概念" class="headerlink" title="7.1基础概念"></a>7.1基础概念</h2><h3 id="1-请求和响应报文"><a href="#1-请求和响应报文" class="headerlink" title="1.请求和响应报文"></a>1.请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>
<p><strong>请求报文结构：</strong></p>
<ul>
<li>第一行是包含了请求方法、URL、协议版本；</li>
<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>
<li>一个空行用来分隔首部和内容主体 Body</li>
<li>最后是请求的内容主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.example.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line"></span><br><span class="line">param1&#x3D;1&amp;param2&#x3D;2</span><br></pre></td></tr></table></figure>

<p><strong>响应报文结构：</strong></p>
<ul>
<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>
<li>接下来多行也是首部内容</li>
<li>一个空行分隔首部和内容主体</li>
<li>最后是响应的内容主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age&#x3D;604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc&#x2F;16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;&#x2F;title&gt;</span><br><span class="line">	&#x2F;&#x2F; 省略... </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p><strong>URI 是uniform resource identifier：</strong>统一资源标识符，用来唯一的标识一个资源。</p>
<p><strong>URL 是uniform resource locator：</strong>统一资源定位器，它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
<h2 id="7-2-HTTP-方法"><a href="#7-2-HTTP-方法" class="headerlink" title="7.2 HTTP 方法"></a>7.2 HTTP 方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p>
<ol>
<li><p>GET：获取资源，指定的资源经服务器解析之后，返回响应内容；</p>
</li>
<li><p>POST：用来传输实体的主体；</p>
</li>
<li><p>PUT：PUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 的指定位置；</p>
</li>
<li><p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分，主要用于确认 URL 的有效性以及资源更新的日期时间等；</p>
</li>
<li><p>DELETE：DELETE 方法用来删除文件，与 PUT 方法相反；</p>
</li>
<li><p>OPTIONS：查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
</li>
<li><p>CONNECT：要求在与代理服务器通信时建立隧道</p>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片15.png" alt="img"></p>
</li>
</ol>
<h2 id="7-3-GET-和-POST-比较"><a href="#7-3-GET-和-POST-比较" class="headerlink" title="7.3 GET 和 POST 比较"></a>7.3 GET 和 POST 比较</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>Get：用于获取资源</p>
<p>POST：用于传输实体主体</p>
<h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2.参数"></a>2.参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<h3 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。（因为是只读的）</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。（因为会修改服务器的资源）</p>
<h3 id="4-幂等性"><a href="#4-幂等性" class="headerlink" title="4.幂等性"></a>4.幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p><strong>PUT</strong> 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>
<p><strong>GET</strong> 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><strong>DELETE</strong> 是幂等的，即使不同的请求接收到的状态码不一样，因为多次删除同一个资源效果都是资源不存在，所以符合幂等性：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<p><strong>POST</strong> 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<h3 id="5-可缓存"><a href="#5-可缓存" class="headerlink" title="5.可缓存"></a>5.可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2 id="7-4-HTTP-状态码"><a href="#7-4-HTTP-状态码" class="headerlink" title="7.4 HTTP 状态码"></a>7.4 HTTP 状态码</h2><p><strong>状态码的类别：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody></table>
<p><strong>常见的状态码：</strong></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center"><strong>200</strong></td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">请求资源在多处可得到，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center"><strong>301</strong></td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center"><strong>302</strong></td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center"><strong>304</strong></td>
<td align="center">客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。</td>
</tr>
<tr>
<td align="center"><strong>401</strong></td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center"><strong>403</strong></td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center"><strong>404</strong></td>
<td align="center">服务器找不到请求资源</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td align="center"><strong>500</strong></td>
<td align="center">内部服务器错误</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center"><strong>502</strong></td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求，能连接但是超时（网关错误）</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center"><strong>504</strong></td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求，不能连接且超时（网关超时）</td>
</tr>
<tr>
<td align="center">505</td>
<td align="center">服务器不支持请求中所用的HTTP协议版本</td>
</tr>
</tbody></table>
<h2 id="7-5不同-HTTP-版本比较"><a href="#7-5不同-HTTP-版本比较" class="headerlink" title="7.5不同 HTTP 版本比较"></a>7.5不同 HTTP 版本比较</h2><h3 id="1-HTTP-1-0-和-HTTP-1-1-的区别"><a href="#1-HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="1. HTTP/1.0 和 HTTP/1.1 的区别"></a>1. HTTP/1.0 和 HTTP/1.1 的区别</h3><ol>
<li><p><strong>长连接</strong></p>
<p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</p>
</li>
<li><p><strong>节约带宽</strong></p>
<p>HTTP1.1 支持先只发送 Header 信息，不用包含请求的 body，如果服务器认为客户端有权限请求服务器，则返回 100，这时客户端可以发送 body 到服务器，否则返回 401 ，这时客户端就不用发送请求 body 了，这样就节约了带宽。</p>
</li>
<li><p><strong>错误状态响应码</strong></p>
<p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>HOST 域</strong></p>
<p>在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname），HTTP1.0 没有 host 域。</p>
<p>随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。也就是说我们的一台虚拟机（IP：111.111.111.111）上面其实是可以放很很多网站的（不然如果只能放一个网站的话就太不合理了，虚拟机那么多资源都浪费了），我们可以把 <a href="http://www.qiniu.com,www.taobao.com/">www.qiniu.com，www.taobao.com</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 这些网站都假设那台虚拟机上面，但是这样会有一个问题，我们每次访问这些域名其实都是解析到服务器 IP 111.111.111.111，我怎么来区分每次根据域名显示出不同的网站的内容呢，其实这就要用到请求头中 Host 的概念了（请求头中的 Host 字段），每个 Host 可以看做是我在服务器 111.111.111.111 上面的一个站点，每次我用那些域名访问的时候都是会解析同一个虚拟机没错，但是我通过不同的 Host 可以区分出我是访问这个虚拟机上的哪个站点。</p>
</li>
</ol>
<h3 id="2-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#2-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="2. HTTP/1.1 和 HTTP/2.0 的区别"></a>2. HTTP/1.1 和 HTTP/2.0 的区别</h3><p><strong>HTTP/1.x 缺陷：</strong></p>
<ul>
<li>客户端需要建立多个连接才能实现并发；</li>
<li>不会压缩请求头和响应头，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<p><strong>下面看 HTTP/2.0 的新特性：</strong></p>
<ol>
<li><p><strong>TCP 复用技术</strong></p>
<p>HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级。HTTP1.1 也可以多建立几个 TCP 连接，来支持处理更多并发的请求，但是创建 TCP 连接本身也是有开销的。</p>
<p>HTTP2.0 中将报文分成了 HEADERS 帧和 DATA 帧，每个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息，帧是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片21.png" alt="img" style="zoom:80%;">
</li>
<li><p><strong>服务端推送</strong></p>
<p>HTTP/2.0 在客户端请求一个资源时，<strong>会把相关的资源一起发送给客户端</strong>，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片22.png" alt="img" style="zoom:80%;">
</li>
<li><p><strong>首部压缩</strong></p>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码技术对首部字段进行压缩。</p>
</li>
</ol>
<h2 id="7-6具体应用"><a href="#7-6具体应用" class="headerlink" title="7.6具体应用"></a>7.6具体应用</h2><h3 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1.连接管理"></a>1.连接管理</h3><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片16.png" alt="img" style="zoom:67%;">

<p><strong>1.短连接与长连接</strong></p>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<p><strong>2.流水线</strong></p>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟</p>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><blockquote>
<p><strong>有状态与无状态的区别：</strong></p>
<ul>
<li>状态化请求，服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。</li>
<li>无状态请求，服务器端所能够处理的过程必须全部来自于请求所携带的信息，以及其他服务器端自身所保存的、并且可以被所有请求所使用的公共信息。</li>
</ul>
</blockquote>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p><strong>1.用途</strong></p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>2.创建过程</strong></p>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<p><strong>3.分类</strong></p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<p><strong>4. JavaScript</strong></p>
<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.cookie = &quot;yummy_cookie=choco&quot;;</span><br><span class="line">document.cookie = &quot;tasty_cookie=strawberry&quot;;</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure>

<p><strong>5. HttpOnly</strong></p>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p><strong>6. Secure</strong></p>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。                                                                                                                                                                 </p>
<p><strong>7. Cookie 的不可跨域名性</strong></p>
<p>很多网站都会使用 Cookie。例如，Google 会向客户端颁发 Cookie，Baidu 也会向客户端颁发 Cookie。那浏览器访问 Google 会不会也携带上 Baidu 颁发的Cookie 呢？或者 Google 能不能修改 Baidu 颁发的 Cookie 呢？</p>
<p>答案是否定的。<strong>Cookie 具有不可跨域名性</strong>。根据 Cookie 规范，浏览器访问 Google 只会携带 Google 的 Cookie，而不会携带 Baidu 的 Cookie。Google 也只能操作 Google 的 Cookie，而不能操作 Baidu 的 Cookie。</p>
<p>Cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 Cookie 而不会操作 Baidu 的 Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站 Cookie 的依据是域名。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 Cookie。</p>
<p>需要注意的是，虽然网站 images.google.com 与网站 <a href="http://www.google.com/">www.google.com</a> 同属于 Google，但是域名不一样，二者同样不能互相操作彼此的 Cookie。</p>
<h3 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID  值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session  管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<p><strong>1.浏览器禁用 Cookie</strong></p>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<p><strong>2. Cookie 与 Session 选择</strong></p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h3 id="4-Token"><a href="#4-Token" class="headerlink" title="4. Token"></a>4. Token</h3><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>
<p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p>
<p><strong>session 与 token 区别</strong></p>
<p><strong>session的状态保持及弊端：</strong></p>
<p>当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从服务器获取session数据，然后进行用户信息查询，查询到，就会将查询到的用户信息返回，从而实现状态保持。</p>
<p><img src="https://img-blog.csdnimg.cn/20181126151900484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_86,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_50" alt="img"></p>
<p><strong>弊端：</strong></p>
<ol>
<li><p>服务器压力增大</p>
<p>通常 session 是存储在内存中的，每个用户通过认证之后都会将 session 数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。</p>
</li>
<li><p>CSRF 跨站伪造请求攻击</p>
<p>session 是基于 cookie 进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
</li>
<li><p>扩展性不强</p>
<p>如果将来搭建了多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是 session 数据是保存在内存中的（不是共享的），用户第一次访问的是服务器1，当用户再次请求时可能访问的是另外一台服务器2，服务器2获取不到 session 信息，就判定用户没有登陆过。</p>
</li>
</ol>
<p><strong>token认证机制：</strong></p>
<p>token与session的不同主要在：</p>
<p>①认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）</p>
<p>②浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）</p>
<p>③再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它<strong>不需要在服务端去保留用户的认证信息（账号、密码）或者会话信息</strong>，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。</p>
<p>（只要每台服务器的加密规则和签名一致，因为客户端使用相同的公钥加密，所以不同服务器依然可以识别用户）</p>
<p>（<strong>token中含有用户的user id，所以状态可以从数据库中取出</strong>）</p>
<p>（session和token都是用于服务器区别用户的，只不过token不用在服务器中保存）</p>
<p><img src="https://img-blog.csdnimg.cn/20181126161842605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_90,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_70" alt="img"></p>
<h2 id="7-7-HTTPS"><a href="#7-7-HTTPS" class="headerlink" title="7.7 HTTPS"></a>7.7 HTTPS</h2><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1.加密"></a>1.加密</h3><p><strong>对称密钥加密</strong></p>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片17.png" alt="img" style="zoom: 80%;">

<p><strong>非对称密钥加密</strong></p>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片18.png" alt="img" style="zoom:80%;">

<h3 id="2-CA-证书"><a href="#2-CA-证书" class="headerlink" title="2. CA 证书"></a>2. CA 证书</h3><p>这里 Alice 表示客户端，Bob 表示服务端，这里的 Trent 就是 CA 机构，证书的颁布者，也是对证书进行管理的人。</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片19.png" alt="在这里插入图片描述"></p>
<p>下面这个图更详细一些：</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片20.png" alt="在这里插入图片描述"></p>
<ol>
<li>服务器端生成密钥对，并向 CA 机构注册自己的公钥；</li>
<li>CA 机构通过自己的私钥对该公钥加数字签名，并生成数字证书；</li>
<li>仓库中保存着所有已经注册的证书；</li>
<li>客户端从 CA 仓库中获取已经注册的证书，并通过对比数字签名的方式来确定服务端的身份。</li>
</ol>
<h3 id="3-认证"><a href="#3-认证" class="headerlink" title="3.认证"></a>3.认证</h3><p>首先是使用混合加密的方式，Https 的建立过程如下：</p>
<p><strong>建立TCP连接之后：</strong>（所以说是中间加了一层SSL/TLS）</p>
<p> <strong>step1</strong>： “客户”向服务端发送一个通信请求</p>
<p> “客户”-&gt;“服务器”：你好</p>
<p> <strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有。</p>
<p> “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>
<p> <strong>step3</strong>： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>
<p> “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串  </p>
<p> “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>
<p> <strong>step4</strong>： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>
<p> “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>
<p> “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>
<p> “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>
<p> …… //继续其它的通信</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\01.png" style="zoom: 67%;">

<p><strong>为什么建立连接的时候不能用对称加密的方式呢？</strong></p>
<ol>
<li>如果对称加密每个客户端拿到的秘钥都是相同的，那么黑客也能够通过截获其它客户端的秘钥来截获信息</li>
<li>如果为每个客户端都生成一个新的秘钥，那么就会占用服务器端大量的内存</li>
</ol>
<h3 id="4-完整性保护"><a href="#4-完整性保护" class="headerlink" title="4.完整性保护"></a>4.完整性保护</h3><p>MD5 是一种信息-摘要算法，它可以说是文件的“数字指纹”，不论是一个什么文件，都有一个独一无二的 MD5 信息值，假设这个文件被改动过，它的 MD5 值也将随之改变。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h3 id="5-HTTPS-的缺点"><a href="#5-HTTPS-的缺点" class="headerlink" title="5. HTTPS 的缺点"></a>5. HTTPS 的缺点</h3><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h2 id="7-8-HTTP-与-HTTPS-的区别"><a href="#7-8-HTTP-与-HTTPS-的区别" class="headerlink" title="7.8 HTTP 与 HTTPS 的区别"></a>7.8 HTTP 与 HTTPS 的区别</h2><ol>
<li>安全性：HTTP 使用明文传输，不需要验证服务端的身份，HTTPS 建立连接之前需要验证服务器的身份，使用密文传输安全性更高；</li>
<li>完整性：HTTP 不能保证报文的完整性，HTTPS 通过密文 + MD5 算法保证报文的完整性；</li>
<li>端口号：HTTP 默认的端口号是 80 端口，HTTPS 默认的端口号是 443 端口；</li>
<li>费用：HTTPS 需要 CA 证书，往往需要较高的费用；</li>
<li>效率：HTTPS 需要加密、解密等过程，因此速率比较低。</li>
</ol>
<h1 id="8-Web-安全相关"><a href="#8-Web-安全相关" class="headerlink" title="8. Web 安全相关"></a>8. Web 安全相关</h1><p>见《大型网站技术架构》</p>
<p><strong>解析：</strong>防御措施围绕着一个主题，“<strong>永远不要相信客户端</strong>”。对客户端的每次请求，我们都要做好充分的过滤，验证与授权，这样才可以尽可能的避免常见的 Web 安全漏洞，抵御来自外部世界的攻击。</p>
<h1 id="9-一个网络数据包的组成"><a href="#9-一个网络数据包的组成" class="headerlink" title="9.一个网络数据包的组成"></a>9.一个网络数据包的组成</h1><p><strong>面试官问题：一个网络数据包包括哪些有了解吗？</strong></p>
<p><strong>答：</strong>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\03.png" alt="图片说明" style="zoom:80%;">

<p>在UDP协议中就是UDP头部，各个头部都有其固定的格式，TCP头部最小20个字节，UDP头部最小8个字节。</p>
]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC执行原理</title>
    <url>/2021/03/08/SpringMVC/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p>
<img src="/2021/03/08/SpringMVC/SpringMVC执行流程.png" style="zoom:80%;">

<h1 id="组件作用"><a href="#组件作用" class="headerlink" title="组件作用"></a>组件作用</h1><ul>
<li><p><strong>DispatcherServlet：</strong>前端控制器。</p>
<p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p>
</li>
<li><p><strong>HandlerMapping：</strong>处理器映射器</p>
<p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p>
</li>
<li><p><strong>HandlerExecution：</strong>具体的Handler</p>
<p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p>
</li>
<li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p>
</li>
<li><p><strong>HandlAdapter：</strong>处理器适配器</p>
<p><strong>作用1：</strong>按照特定的规则去执行Handler；</p>
<p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p>
<p><strong>注：</strong>Model表示具体的数据，View表示视图</p>
</li>
<li><p><strong>View Resolver：</strong>视图解析器</p>
<p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>View：</strong>视图</p>
<p><strong>作用：</strong>向用户展示结果</p>
</li>
</ul>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><ol>
<li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li>
<li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li>
<li>HandlerExecution就是具体的Controller；</li>
<li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li>
<li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li>
<li>HandlAdapter找到相应的Controller去执行；</li>
<li>Controller将执行结果返回给HandlAdapter；</li>
<li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li>
<li>dispatcherServlet调用View Resolver得到相应的页面地址；</li>
<li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li>
<li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li>
</ol>
]]></content>
      <categories>
        <category>框架相关</category>
      </categories>
      <tags>
        <tag>Spring相关</tag>
      </tags>
  </entry>
  <entry>
    <title>win10系统激活方法</title>
    <url>/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示："><a href="#1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示：" class="headerlink" title="1、按下win+X，选择Windows PowerShell (管理员)，如下图所示："></a>1、按下win+X，选择Windows PowerShell (管理员)，如下图所示：</h1><img src="/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/图片1.png" style="zoom:90%;">

<h1 id="2、在命令提示符中依次输入："><a href="#2、在命令提示符中依次输入：" class="headerlink" title="2、在命令提示符中依次输入："></a>2、在命令提示符中依次输入：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slmgr &#x2F;ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr &#x2F;skms kms.03k.org</span><br><span class="line">slmgr &#x2F;ato</span><br></pre></td></tr></table></figure>

<h1 id="3、依次会弹出："><a href="#3、依次会弹出：" class="headerlink" title="3、依次会弹出："></a>3、依次会弹出：</h1><p>“成功地安装了产品密钥……”</p>
<p>“密钥管理服务计算机名成功的设置为 zh.us.to”</p>
<p>“正在激活……，成功地激活了产品”</p>
]]></content>
      <categories>
        <category>电脑使用中的问题</category>
      </categories>
      <tags>
        <tag>系统问题</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse快捷键</title>
    <url>/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、设置断点-amp-断点处运行快捷键"><a href="#1、设置断点-amp-断点处运行快捷键" class="headerlink" title="1、设置断点&amp;断点处运行快捷键"></a>1、设置断点&amp;断点处运行快捷键</h1><p><strong>设置断点</strong></p>
<p>在该行最前面边框双击或快捷键：Ctrl+Shift+B </p>
<p><strong>以Debug 方式运行Java程序</strong></p>
<p> Debug 运行启动 （在进行前后端联调时，Tomcat要在debug模式下运行）</p>
<p><strong>调试快捷键</strong></p>
<p> 运行到断点后： </p>
<p> F5：Step into/进入该行的函数内部 ；</p>
<p> F6：Step over/一行一行执行 ，它是不进入每一行的函数内部的；</p>
<p> F7：Step return/退出当前的函数；</p>
<p> F8：直接执行程序直到遇到下一个断点时暂停。</p>
<p>如果快捷键不能使用，可以通过窗口中的按钮运行程序，如图：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/设置断点及调试.png" style="zoom:90%;">

<h1 id="2、修改包的显示结构和显示方法"><a href="#2、修改包的显示结构和显示方法" class="headerlink" title="2、修改包的显示结构和显示方法"></a>2、修改包的显示结构和显示方法</h1><h2 id="Eclipse-中包结构展开有两种方式："><a href="#Eclipse-中包结构展开有两种方式：" class="headerlink" title="Eclipse 中包结构展开有两种方式："></a>Eclipse 中包结构展开有两种方式：</h2><p><strong>一：平坦方式（flat）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/平坦方式.png" style="zoom:110%;">

<p><strong>二、分层方式（hierarchical）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/分层方式.png" style="zoom:90%;">



<h2 id="快速展开包"><a href="#快速展开包" class="headerlink" title="快速展开包"></a>快速展开包</h2><p><strong>在右边选中类时，快速的将类对应的包结构展开（Link with editor）</strong></p>
<p>设置只需点击包机构面板中的双箭头即可。</p>
<p>双箭头按下，表示包自动展开，不按下，表示包不自动展开。</p>
<p>如图红色框内按钮：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/在右边选中类时，快速的将类对应的包结构展开.png" style="zoom:80%;">]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome调试快捷键</title>
    <url>/2021/02/28/Chrome%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h1><blockquote>
<p><strong>转自：<a href="https://www.cnblogs.com/lishanyang/p/7767135.html">https://www.cnblogs.com/lishanyang/p/7767135.html</a></strong></p>
</blockquote>
<p>快捷键有这么以下几大类.且看我一一道来<del>~</del>注:All pane是全局快捷键</p>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console()"></a>Console()</h2><ul>
<li>Ctrl + L : 清除控制台消息</li>
<li>Tab : 自动完成通用常缀</li>
<li>→: 接受建议</li>
<li>Ctrl +  U: 清除console的提示!!(实操查看源代码!!)</li>
<li>↓ / ↑ :选中下一行/上一行</li>
<li>Enter: 执行代码或者命令</li>
</ul>
<h2 id="Debugger-调试面板"><a href="#Debugger-调试面板" class="headerlink" title="Debugger(调试面板)"></a>Debugger(调试面板)</h2><ul>
<li>F8 or Ctrl + : 暂停/继续</li>
<li>F10 or  Ctrl + ‘: 单步执行</li>
<li>F11 or Ctrl +;: 单步进入</li>
<li>Shift + F11 or Ctrl + Shift+;: 单步退出</li>
<li>Ctrl +./Ctrl+, : 上一帧/下一帧(译为框架怪怪的)</li>
<li>Ctrl +Shift+E: 被选中代码在控制台中打印出console信息**(非常实用)**</li>
<li>Ctrl + Shift + A: 添加到debugger的watch里面,可以关注你选中内容的变化</li>
<li>Ctrl + B: 打断点/取消断点**(很实用)**</li>
</ul>
<p>Chrome调试面板上的对应按钮如图所示：</p>
<img src="/2021/02/28/Chrome%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/调试面板.png" style="zoom:80%;">

<h2 id="Text-Editor-文本编辑器"><a href="#Text-Editor-文本编辑器" class="headerlink" title="Text Editor(文本编辑器)"></a>Text Editor(文本编辑器)</h2><ul>
<li>Ctrl + Shift+P : 跳转到某个成员(不知鸟用)</li>
<li>Ctrl + Space: 自动完成</li>
<li>Ctrl + G : 跳转到某行</li>
<li>Ctrl + Shift + E</li>
<li>Alt + -: 跳转到之前的编辑位置</li>
<li>Alt + +: 跳转到下一个编辑的位置</li>
<li>Ctrl + /: 快捷键注释</li>
<li>Alt + ↑: 调整CSS度量单位,每次<strong>增加</strong>一个单元</li>
<li>Alt + ↓: 调整CSS度量单位,每次<strong>减少</strong>一个单元</li>
<li>Alt + PageUp: 调整CSS度量单位,每次<strong>增加</strong>10个单元</li>
<li>Alt + PageDown: 调整CSS度量单位,每次<strong>减少</strong>10个单元</li>
<li>Ctrl + D: 选择选中内容的下一个匹配内容</li>
<li>Ctrl + U: 软撤销</li>
<li>Ctrl + M: 进入匹配的括号</li>
<li>Alt + W: 关闭编辑便签</li>
<li>Alt + O: 切换相同名字的或者不同后缀的文件</li>
</ul>
<h2 id="All-Panels-所有面板"><a href="#All-Panels-所有面板" class="headerlink" title="All Panels(所有面板)"></a>All Panels(所有面板)</h2><ul>
<li>Ctrl + [ / Ctrl + ]:切换面板(向左向右)</li>
<li>Ctrl + Shift + [ / Ctrl + Shift+] : 返回之前之后的面板状态</li>
<li>Ctrl + Tilde[~]:显示Console</li>
<li>Esc: 小菜单弹出隐藏</li>
<li>Ctrl + Shift + M: 进入仿真设备模式(移动平板屏幕)</li>
<li>Ctrl + Shift + D: 切换调试面板在底部还是侧边栏展示</li>
<li>Ctrl + F: 搜索内容</li>
<li>Ctrl + Shift + F: 在所有代码中搜索(跨域),<strong>很实用</strong></li>
<li>Ctrl + Shift + C: 选择页面节点并且查看代码,<strong>最常用!!</strong></li>
<li>Ctrl + P: 快速切换源码文件,<strong>很常用!</strong></li>
</ul>
<h2 id="Style-Pane-风格面板"><a href="#Style-Pane-风格面板" class="headerlink" title="Style Pane(风格面板)"></a>Style Pane(风格面板)</h2><ul>
<li>Tab / Shift + Tab: 下一个/上一个属性</li>
<li>↑: 增加CSS度量单位-&gt;1单元</li>
<li>↓:减少CSS度量单位-&gt;1单元</li>
<li>PageUporShift + ↑:增加CSS度量单位-&gt;10单元</li>
<li>PageDownorShift + ↓:减少CSS度量单位-&gt;10单元</li>
<li>Shift + PageUp:增加CSS度量单位-&gt;100单元</li>
<li>Shift + PageDown:减少CSS度量单位-&gt;100单元</li>
<li>Alt + ↑:增加CSS度量单位-&gt;0.1单元</li>
<li>Alt + ↓:减少CSS度量单位-&gt;0.1单元</li>
</ul>
<h2 id="Timeline-Panel-时间轴面板"><a href="#Timeline-Panel-时间轴面板" class="headerlink" title="Timeline Panel(时间轴面板)"></a>Timeline Panel(时间轴面板)</h2><ul>
<li>Ctrl + E:开始</li>
<li>Ctrl + S:保存时间轴数据</li>
<li>Ctrl + O:加载时间轴数据</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="二叉树的遍历（三种）"><a href="#二叉树的遍历（三种）" class="headerlink" title="二叉树的遍历（三种）"></a>二叉树的遍历（三种）</h2><p>根据根节点的访问顺序可以将二叉树的遍历分为：</p>
<p><strong>前序遍历：</strong>根节点→左子树→右子树</p>
<p><strong>中序遍历：</strong>左子树→根节点→右子树</p>
<p><strong>后序遍历：</strong>左子树→右子树→根节点</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>以根访问顺序决定是什么遍历</li>
<li>左子树一般都是先于右子树的</li>
</ul>
</blockquote>
<p>二叉树的每种遍历方式都可以分为递归和非递归两种，其中<strong>非递归的方式一定要掌握</strong>！</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p><strong>前序递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前序非递归：（非递归都是用辅助栈实现）</strong></p>
<ul>
<li><p>节点 root 先到达最左端的叶子节点并将路径上的节点<strong>添加到res集合中</strong>、<strong>入栈</strong>；</p>
</li>
<li><p>然后每次从栈中弹出一个元素后，root 到达它的右孩子，并<strong>将右孩子看作 root</strong>上面的步骤。</p>
</li>
</ul>
<p>因为在到达左边叶子节点的过程中是先添加、后入栈，所以右节点作为 root 节点打印时，它的根节点以及根节点的左节点是已经打印的，满足根→左→右的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode temp=stack.pop();</span><br><span class="line">            root=temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><strong>中序递归：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序非递归：（非递归都是用辅助栈实现）</strong></p>
<ul>
<li>节点 root 先到达最左端的叶子节点并将路径上的节点<strong>入栈</strong>；</li>
<li>然后每次从栈中弹出一个元素后<strong>添加到res集合中</strong>，root 到达它的右孩子，并<strong>将右孩子看作 root</strong>上面的步骤。</li>
</ul>
<p>因为在到达左边叶子节点的过程中是先添加、后入栈，所以右节点作为 root 节点打印时，它的根节点以及根节点的左节点是已经打印的，满足左→根→右的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode temp=stack.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            root=temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><strong>后序遍历：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序非递归：（非递归都是用辅助栈实现）</strong></p>
<ul>
<li>节点 root 先到达最右端的叶子节点并将路径上的节点<strong>入栈</strong>；</li>
<li>然后每次从栈中弹出一个元素后<strong>添加到res集合中</strong>，root 到达它的左孩子，并<strong>将左孩子看作 root</strong>上面的步骤。</li>
</ul>
<p>因为在到达右边叶子节点的过程中是先添加、后入栈，所以左节点作为 root 节点打印时，它的根节点以及根节点的右节点是已经打印的，满足根→右→左的顺序</p>
<p>后序遍历的顺序为：左→右→根，所以将res集合反转就是后序遍历的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode temp=stack.pop();</span><br><span class="line">            root=temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);<span class="comment">//反转res</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=190&tqId=35221&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-实现二叉树前、中、后序遍历</strong></a></p>
<p>分别按照二叉树先序，中序和后序打印所有的节点。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>先得到二叉树的节点数目</li>
<li>用<strong>递归</strong>的方式，在<strong>不同的位置输出节点</strong>来实现前、中、后序打印二叉树的目的</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">0</span>, flag1 = <span class="number">0</span>, flag2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] threeOrders (TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][getRootSize(root)];</span><br><span class="line">         </span><br><span class="line">        getOrder(root, nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span>[][] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">        nums[<span class="number">0</span>][flag++] = root.val;</span><br><span class="line">        getOrder(root.left, nums);</span><br><span class="line">        nums[<span class="number">1</span>][flag1++] = root.val;</span><br><span class="line">        getOrder(root.right, nums);</span><br><span class="line">        nums[<span class="number">2</span>][flag2++] = root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRootSize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + getRootSize(root.left) + getRootSize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">热题100-124. 二叉树中的最大路径和</a></strong></p>
<p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>实现一个函数 maxPathSumImpl（TreeNode root）：</strong>该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p>
<p><strong>实现思路就是：</strong></p>
<p>递归左子树，如果左子树的返回值大于零返回该结果，反之返回零（负数还不如不选择）</p>
<p>递归右子树，如果右子树的返回值大于零返回该结果，反之返回零</p>
<p>（也就是说，当左子树的返回值为零，就不走左子树，右子树同理，当左子树和右子树的返回值同时为零，两边都不走）</p>
<p>返回该节点和其左子树、右子树中较大值的和</p>
<p><strong>因为最大路径和有可能出现在树中局部的一棵子树上，所以要对中间结果进行记录：</strong></p>
<p>定义一个全局变量 tempMaxSum</p>
<p>在每个节点的递归中，计算以该节点为根节点的子树最大路径和：</p>
<p><strong>一个子树中的最大路径和</strong> = 左子树<strong>提供</strong>的最大路径和 + 根节点值 + 右子树<strong>提供</strong>的最大路径和</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> tempMaxSum=Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxPathSumImpl(root);</span><br><span class="line">        <span class="keyword">return</span> tempMaxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回经过root的单边分支最大和， 即Math.max(root, root+left, root+right)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSumImpl</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左边分支最大值，左边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=Math.max(<span class="number">0</span>,maxPathSumImpl(root.left));</span><br><span class="line">        <span class="comment">//计算右边分支最大值，右边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> rightMax=Math.max(<span class="number">0</span>,maxPathSumImpl(root.right));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//left-&gt;root-&gt;right 作为某一子树的路径与已经计算过历史最大值做比较</span></span><br><span class="line">        tempMaxSum=Math.max(root.val+leftMax+rightMax,tempMaxSum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回经过root的单边最大分支给当前root的父节点计算使用</span></span><br><span class="line">        <span class="keyword">return</span> root.val+Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">热题100-剑指 Offer 68 - II. 二叉树的最近公共祖先</a></strong></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>二叉树的最近公共祖先：有一个节点的左右子树中同时包含要查找的两个节点</strong></p>
<p><strong>递归实现流程：</strong></p>
<ul>
<li><p>当超出叶子结点、或者该节点正好是要查找的某一个节点时，返回节点本身</p>
</li>
<li><p>left=左子树递归</p>
</li>
<li><p>right=右子树递归</p>
</li>
<li><p>递归结果的可能组合：</p>
<p>同时不为null，也就是该节点就是最近的公共节点，返回节点本身（一定要最先判断，否则就会返回单边不为null的情况）</p>
<p>有一个不为null，返回不为null的那个</p>
<p>剩下的情况就是都为null，返回null</p>
</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left=lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    TreeNode right=lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=190&tqId=36046&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-输出二叉树的右视图</a></strong></p>
<p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>重建二叉树的思路：</strong></p>
<ul>
<li><p>递推参数：根节点在前序遍历的索引root、子树在中序遍历的左边界left、子树在中序遍历的右边界right；</p>
</li>
<li><p>终止条件：当left&gt;right，代表已经越过叶节点，此时返回 null；</p>
</li>
<li><p>递推工作：</p>
<p>建立根节点 node ： 节点值为 preorder[root] ；</p>
<p>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；（主要根据中序遍历找到左子树的节点数，进而在前序中找到右子树的根节点，这里中序遍历中的右下标主要用于判断是否越界）</p>
</li>
</ul>
<p><strong>输出右视图的思路：</strong></p>
<ul>
<li>二叉树的右视图就是从右边看过去能看到的第一个节点</li>
<li>所以根据层序遍历的思路，每次输出每层的最后一个节点即可</li>
</ul>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 求二叉树的右视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> xianxu int整型一维数组 先序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zhongxu int整型一维数组 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] xianxu;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] solve (<span class="keyword">int</span>[] xianxu, <span class="keyword">int</span>[] zhongxu) &#123;</span><br><span class="line">        <span class="keyword">this</span>.xianxu=xianxu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;zhongxu.length;i++)&#123;</span><br><span class="line">            hm.put(zhongxu[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=dfs(<span class="number">0</span>,<span class="number">0</span>,zhongxu.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> rightView(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(xianxu[index]);</span><br><span class="line">        root.left=dfs(index+<span class="number">1</span>,left,hm.get(xianxu[index])-<span class="number">1</span>);</span><br><span class="line">        root.right=dfs(index+hm.get(xianxu[index])-left+<span class="number">1</span>,hm.get(xianxu[index])+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rightView(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dq.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            TreeNode temp=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                temp=dq.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>) dq.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>) dq.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer-54. 二叉搜索树的第k大节点</a></strong></p>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>主要是利用了二叉树的性质：中序遍历的结果是单调递增的，所以用倒序的中序遍历，当k==0时，便能得到第k大的节点。</p>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>,k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.k=k;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            res=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">热题100-617. 合并二叉树</a></strong></p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>略</p>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node=<span class="keyword">new</span> TreeNode(root1.val+root2.val);</span><br><span class="line">    node.left=mergeTrees(root1.left,root2.left);</span><br><span class="line">    node.right=mergeTrees(root1.right,root2.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer-27. 二叉树的镜像</a></strong></p>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>每个节点交换左右子树</p>
<h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp=root.left;</span><br><span class="line">    root.left=mirrorTree(root.right);</span><br><span class="line">    root.right=mirrorTree(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/4eaccec5ee8f4fe8a4309463b807a542?tpId=190&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-判断t1树中是否有与t2树拓扑结构完全相同的子树</strong></a></p>
<p>给定彼此独立的两棵二叉树，判断 t1 树是否有与 t2 树拓扑结构完全相同的子树。 </p>
<p>设 t1 树的边集为 E1，t2 树的边集为 E2，若 E2 等于 E1 ，则表示 t1 树和t2 树的拓扑结构完全相同。 </p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>若树 root2 是树 root1 的子结构，则子结构的根节点可能为树 root1 的任意一个节点。</strong></p>
<p><strong>方法isContains：</strong>遍历树 root1 中的每个节点NodeA</p>
<ul>
<li><p>特例处理： 当 树 root1 为空 或 树 root2 为空 时，直接返回 false </p>
</li>
<li><p>返回值： 若树 root2 是树 root1的子结构，则必满足以下三种情况之一</p>
<p>调用isContainsImpl方法，以 节点 root1 为根节点的子树包含树 root2 ，返回true</p>
<p>左子树中发现子结构root2</p>
<p>右子树中发现子结构root2（所以用||连接）</p>
</li>
</ul>
<p><strong>方法isContainsImpl：</strong>判断树 root1 中 <strong>以 NodeA 为根节点的子树</strong> 是否包含树 root2</p>
<ul>
<li><p>终止条件：</p>
</li>
<li><p>当节点root1与root2同时为空时，说明树 root2 已匹配完成（越过叶子节点），因此返回 true </p>
<p>当节点 root1 为空或者root2为空时，两者不等，返回 false </p>
<p>当节点 root1 和 root2 的值不同：说明匹配失败，返回 false ；</p>
</li>
<li><p>返回值：</p>
<p>判断 root1 和 root2 的左子节点是否相等，即isContainsImpl(root1.left, root2.left) ；</p>
<p>判断 root1 和 root2 的右子节点是否相等，即 isContainsImpl(root1.right, root2.right) ；</p>
</li>
</ul>
<h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root1 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root2 TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContains</span> <span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isContainsImpl(root1,root2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isContains(root1.left,root2)||isContains(root1.right,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContainsImpl</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isContainsImpl(root1.left,root2.left)&amp;&amp;isContainsImpl(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/path-sum-iii/">热题100-437. 路径总和 III</a></strong></p>
<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>与牛客上HashMap中的一道题目很像</strong></p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>在<strong>同一个路径之下</strong>（可以理解成二叉树从root节点出发，到叶子节点的某一条路径），如果<strong>两个数的前缀总和是相同的，那么这些节点之间的元素总和为零</strong>。进一步扩展相同的想法，<strong>如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target</strong>。</p>
<p>抵达当前节点(即B节点)后，将前缀和累加，然后在<strong>HashMap</strong>中查找有没有<strong>前缀和currSum-target的节点</strong>(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。</p>
<p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; preSum=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        preSum.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//根节点的前缀和为0，将这个节点添加到preSum中</span></span><br><span class="line">        <span class="keyword">return</span> recursionPathSum(root,preSum,<span class="number">0</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursionPathSum</span><span class="params">(TreeNode root,Map&lt;Integer,Integer&gt; preSum,<span class="keyword">int</span> curSum,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        curSum+=root.val;</span><br><span class="line">        count+=preSum.getOrDefault(curSum-target,<span class="number">0</span>);<span class="comment">//查看前面路径中有没有符合要求的节点</span></span><br><span class="line">        preSum.put(curSum,preSum.getOrDefault(curSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        count+=recursionPathSum(root.left,preSum,curSum,target);<span class="comment">//查看左子树路径中有没有符合要求的节点</span></span><br><span class="line">        count+=recursionPathSum(root.right,preSum,curSum,target);<span class="comment">//查看右子树路径中有没有符合要求的节点</span></span><br><span class="line">        preSum.put(curSum,preSum.get(curSum)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/">剑指 Offer-37. 序列化二叉树</a></strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
</blockquote>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><p>序列化就是将二叉树转换成字符串的形式，反序列化就是从序列化后的字符串重构成二叉树。</p>
<p>考虑到，二叉树有的节点是空节点，如果字符串中没有空节点的信息，重构的二叉树就会有问题，所以考虑将空节点作为NULL保存到字符串中。</p>
<p><strong>序列化：</strong></p>
<p>层序遍历的思想，通过双端队列，每次将队列中的节点打印，并将左右节点放到队列中，每次从队列中弹出节点，只要节点不为空，就将它的左右节点加到队列中，当前节点为空时，将该节点为空放入StringBuilder中，表示该节点为空，没有左右孩子。</p>
<p><strong>反序列化：</strong></p>
<p>先对字符串进行处理，将首字符转换成头结点，放入队列中</p>
<p>通过循环，将队列中的节点依次取出，然后去看它的子节点，也就是字符串中<strong>连续的两个字符</strong>，当字符为空时，跳过该字符（i++），当字符不为空时，将该字符转换成节点，根据顺序，作为取出节点的左/右节点。</p>
<p>然后将不为空的子节点加入到队列中，去为他连接子节点</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) dq.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            TreeNode node=dq.poll();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sb.append(node.val);</span><br><span class="line">                sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                dq.add(node.left);</span><br><span class="line">                dq.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] datas=data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(Integer.parseInt(datas[<span class="number">0</span>]));</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        dq.add(root);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            TreeNode node=dq.poll();</span><br><span class="line">            <span class="keyword">if</span>(!datas[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                TreeNode leftNode=<span class="keyword">new</span> TreeNode(Integer.parseInt(datas[i]));</span><br><span class="line">                node.left=leftNode;</span><br><span class="line">                dq.add(leftNode);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!datas[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                TreeNode rightNode=<span class="keyword">new</span> TreeNode(Integer.parseInt(datas[i]));</span><br><span class="line">                node.right=rightNode;</span><br><span class="line">                dq.add(rightNode);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">主站-662. 二叉树最大宽度</a></strong></p>
<p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
</blockquote>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>重点：</strong>是将节点的位置信息和节点封装到新的包装类对象 posNode 中</p>
<p>主要想法是给每个节点一个 <strong><code>position</code></strong> 值，如果我们走向左子树，那么 **<code>position -&gt; position * 2</code>**，如果我们走向右子树，那么 **<code>position -&gt; positon * 2 + 1</code>**。当我们在看同一层深度的位置值 l 和 r 的时候，宽度就是 **<code>r - l + 1</code>**。</p>
<p>l :就是每层的第一个节点的位置值</p>
<p>r :每层最后一个节点的位置值</p>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;posNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;posNode&gt;();</span><br><span class="line">        posNode root_posNode=<span class="keyword">new</span> posNode(root,<span class="number">0</span>);</span><br><span class="line">        dq.add(root_posNode);</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            l=dq.peekFirst().pos;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                posNode temp=dq.poll();</span><br><span class="line">                r=temp.pos;</span><br><span class="line">                <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    posNode l_posNode=<span class="keyword">new</span> posNode(temp.node.left,temp.pos*<span class="number">2</span>);</span><br><span class="line">                    dq.add(l_posNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    posNode r_posNode=<span class="keyword">new</span> posNode(temp.node.right,temp.pos*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">                    dq.add(r_posNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,r-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">posNode</span></span>&#123; </span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        posNode() &#123;&#125;</span><br><span class="line">        posNode(TreeNode node,<span class="keyword">int</span> pos) &#123;</span><br><span class="line">            <span class="keyword">this</span>.node=node;</span><br><span class="line">            <span class="keyword">this</span>.pos=pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="常见的位运算操作"><a href="#常见的位运算操作" class="headerlink" title="常见的位运算操作"></a>常见的位运算操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a=a^0</p>
<p>0=a^a</p>
<p>由上面两个推导出：a=a^b^b（与同一个数异或运算两次还是这个数本身）</p>
<h2 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h2><p>a=a^b</p>
<p>b=a^b</p>
<p>a=a^b</p>
<h2 id="移除最后一个1"><a href="#移除最后一个1" class="headerlink" title="移除最后一个1"></a>移除最后一个1</h2><p>a=n&amp;(n-1)</p>
<h2 id="获取最后一个1"><a href="#获取最后一个1" class="headerlink" title="获取最后一个1"></a>获取最后一个1</h2><p>diff=(n&amp;(n-1))^n</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/hamming-distance/">热题100-461. 汉明距离</a></strong></p>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和y，计算它们之间的汉明距离。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>异或操作当两个操作数的二进制位置不同时为1，对两个数进行异或操作就得到了两个数二进制不同位置的数目，再对结果统计1的个数就得到了两个数的汉明距离。</p>
<p>在统计结果中1的个数时，用到了<strong>移除最后一个1</strong>的操作，不断移除最后一个1，移除几次结果中就有多少个1。</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片.png" style="zoom:110%;">

<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=x^y;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(res!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        res=res&amp;(res-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></strong></p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</blockquote>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=(n-<span class="number">1</span>)&amp;n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></strong></p>
<p>一个整型数组 nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以把所有数字分成两组，使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<p>记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式 xkxk−1⋯x2x1x0，其中 xi∈{0,1}，我们考虑一下 xi=0和 xi=1的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，ai和 bi的关系——xi=1 表示 ai 和 bi 不等，xi=0 表示 ai 和 bi 相等。假如我们任选一个不为 0 的 xi，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件。</p>
<p>在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足 xi=1。但是为了方便，这里的代码选取的是「不为 0 的最低位」</p>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        ret^=i;<span class="comment">//对数组中的所有数做异或运算，则得到的结果等价于对两个只出现一次的数字做异或运算，因为两个数字不同，因此做异或运算中一定是有一位为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((k&amp;ret)==<span class="number">0</span>)&#123;</span><br><span class="line">        k&lt;&lt;=<span class="number">1</span>;<span class="comment">//得到最终结果中最低位的1的位置，并依据k分组，当一个数该位是1，做与运算时不等于0，当不是1，做与运算时等于0，因为与运算需要都是1才是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j&amp;k)==<span class="number">0</span>)&#123;<span class="comment">//将所有数字按第n位是否为1分成两组，那么相同的数字肯定分到一组，并且两个不同的数字因为第n位不同而被分到两个组里，对两个组中的数字分别进行异或运算，相同的数字做异或运算相互抵消为0，所以最后得到的a和b就是两个只出现一次的数字</span></span><br><span class="line">            a^=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b^=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[]  result=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"><strong>剑指 Offer 56 - II. 数组中数字出现的次数 II</strong></a></p>
<p>在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路 1"></a>解题思路 1</h3><p>如果一个数字出现了三次，那么它的二进制数中每一位也是出现了三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。</p>
<p>于是创建一个长度为32的数组来保存所有数字的二进制表示的每一位的和，如果某一位的和能被3整除，那么只出现一次的数字的二进制表示中对应的位为0，否则就是1。</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解 1"></a>代码及注解 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution56_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//本算法同样适用于数组nums中存在负数的情况（因为使用的是左移，不用考虑符号问题）</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];<span class="comment">//java int类型有32位，其中首位为符号位</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitMask=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//这个循环是为了统计增强for循环得到的每一个数字num中每一位上是否为1，所以bitMask需要每得到一个num就初始化一次；而且数组中的存储顺序是：索引小→大对应高位→低位</span></span><br><span class="line">                <span class="keyword">if</span>((num&amp;bitMask)!=<span class="number">0</span>) bitSum[i]++;<span class="comment">//这里判断条件不是==1（通过与运算得到的不一定是1，通过idea验证）</span></span><br><span class="line">                bitMask=bitMask&lt;&lt;<span class="number">1</span>;<span class="comment">//左移没有无符号、带符号的区别，都是在右侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从数组索引由小到大遍历得到每位上3的余数，通过res左移让高位向左，这里也避免了res右移可能引发的符号问题</span></span><br><span class="line">            res=res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            res+=bitSum[i]%<span class="number">3</span>;<span class="comment">//这两步顺序不能变，否则最后一步会多左移一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2（状态机）"><a href="#解题思路-2（状态机）" class="headerlink" title="解题思路 2（状态机）"></a>解题思路 2（状态机）</h3><p>解题思路：各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位1的个数，存在 3 种状态，即对 3 余数为 0,1,2。（不是0,1两种状态，当没加完有可能出现5,8等余数为2的情况），因此可以用两位二进制数表示这三种状态：00→01→10。</p>
<p>通过状态机可以得到对于三种状态输入的n为0或1时对应的真值表：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">one</th>
<th align="center">新one</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>通过真值表可以得到one的逻辑表达式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片1.png" style="zoom:80%;">

<p>逻辑表达式的化简公式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片2.png" style="zoom: 67%;">

<p>同理也能得到two的逻辑表达式，注意two是要通过新的one值获得，构造真值表时要用新的one值：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">新one</th>
<th align="center">新two</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解 2"></a>代码及注解 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;<span class="comment">//位运算，每次通过增强for循环得到的num，按位与ones和twos的每一位做运算，得到ones中每一位的值</span></span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;<span class="comment">// 遍历完所有数字后，各二进制位都处于状态 00 和状态 01（取决于 “只出现一次的数字” 的各二进制位是 1 还是 0 ），而此两状态是由 one来记录的（此两状态下 twos 恒为 0 ），因此返回 ones 即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/counting-bits/">热题100-338. 比特位计数</a></strong></p>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有一个整数：<br>$$<br>x=(1001011101)<em>2 = (605)</em>{10}<br>$$<br>我们已经计算了从 0 到 x−1 的全部结果。</p>
<p>我们知道，x 与 我们计算过的一个数只有一位之差:<br>$$<br>x=(0001011101)<em>2 = (93)</em>{10}<br>$$<br>它们<strong>只在最高有效位上不同</strong>，也就是我们可以通过在已经求得1的位数的一个数上+1来求得x。</p>
<p>得到状态转移函数：<br>$$<br>P(x+b)=P(x)+1,b=2^m&gt;x<br>$$<br>因为b每次肯定是大于x的</p>
<p>2的0次方为0001</p>
<p>2的1次方为0010</p>
<p>2的2次方为0100</p>
<p>2的3次方为1000</p>
<p>也就是每次在0到x这个范围内的数的最高位依次+1得到x到x+b这个范围内的数，而且1的位数只差刚加上的这个1，这样通过状态转移函数就能够得到x到x+b这个范围内的数的1的位数。</p>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [0, b) 已经求得，并存在结果数组res中</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt;= num) &#123;</span><br><span class="line">            <span class="comment">// 由 [0, b)得到 [b, 2b) 或者 [b, num) </span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; b &amp;&amp; i + b &lt;= num)&#123;</span><br><span class="line">                ans[i + b] = ans[i] + <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span>;   <span class="comment">// 将i复位</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>; <span class="comment">// b = 2b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>任何数和自身做异或运算等于0</li>
<li>任何数和0做异或运算等于该数本身</li>
<li>任何数的异或运算满足交换律</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        res=res^i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/majority-element/"><strong>热题100-169. 多数元素(同剑指 Offer 39)</strong></a></p>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>摩尔投票法：</strong>核心就是对拼消耗。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<p><strong>算法流程：</strong></p>
<p><strong>res作为假定众数</strong>，另一个是<strong>投票数voteNum</strong>，首先假设第一个数就是众数，另res=nums[0],然后向后遍历数组，每当相同时voteNum++，不相同时voteNum–；然后每当voteNum为0时，选择下一个数作为众数x，再去循环执行以上操作。因为此处的众数在数组中出现的次数超过了一半，所以最终voteNum的值一定大于0，并且最后一次把次数设为1时对应的数字就是要找的数字。</p>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> voteNum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(voteNum==<span class="number">0</span>)&#123;</span><br><span class="line">            res=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==res)&#123;</span><br><span class="line">            voteNum++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]!=res)&#123;</span><br><span class="line">            voteNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-148/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a></p>
</blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p><strong>进阶：</strong>请在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题使用的排序算法为归并排序算法，由于递归实现归并排序的空间复杂度较高，所以我选择非递归方式来实现归并排序算法，避免了递归调用函数使用的栈空间，提高了效率。</p>
<p>详细思路请看主页的归并排序算法。</p>
<p><strong>具体做法如下：</strong>（来自LeetCode官方题解：<a href="https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/%EF%BC%89">https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/）</a></p>
<ul>
<li><p>用 k 表示每次需要排序的子链表的长度，初始时 k=1。（也就是<strong>归并排序中的步长</strong>）</p>
</li>
<li><p>每次将链表拆分成若干个长度为 k 的子链表（最后一个子链表的长度可以小于 k），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 k×2的有序子链表（最后一个子链表的长度可以小于 k×2）。合并两个子链表仍然使用「21. 合并两个有序链表」的做法。</p>
</li>
<li><p>将 k 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于链表长度，整个链表排序完毕。</p>
</li>
</ul>
<p>如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。</p>
<p>初始时 k=1，每个长度为 1的子链表都是有序的。</p>
<p>如果每个长度为 k 的子链表已经有序，合并两个长度为 subLength\textit{subLength}subLength 的有序子链表，得到长度为 k×2 的子链表，一定也是有序的。</p>
<p>当最后一个子链表的长度小于 k 时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。</p>
<p>因此可以保证最后得到的链表是有序的。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>着重看MergePass方法中的内容</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        ListNode resNode=<span class="keyword">new</span> ListNode();</span><br><span class="line">        resNode.next=head;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;length)&#123;</span><br><span class="line">            MergePass(resNode,k,length);</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergePass</span><span class="params">(ListNode resNode,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = resNode, curr = resNode.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = mergeTwoLists(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p><strong>归并排序的递归实现：</strong>就是将含有<strong>n</strong>个记录的序列不断从<strong>中间划分</strong>成长度为<strong>2</strong>或<strong>1</strong>的序列，然后<strong>两两归并</strong>。不断归并，直到得到一个长度为<strong>n</strong>的有序序列为止，这种排序方法也称为<strong>2路归并排序</strong>。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片.png">

<p>下面模拟一遍<strong>递归</strong>方法实现的归并排序：</p>
<p>设输入的序列为：[50,10,90,30,70,40,80,60,20]</p>
<p>调用Msort函数，传入待排序数组SR，和结果数组TR1，左下标l=0，右下标r=8；</p>
<p><strong>Msort函数：利用m将数组SR分成两部分</strong>，左半部分[50,10,90,30,70]，右半部分[40,80,60,20];</p>
<p>​                       左边部分接着划分为[50,10,90]和[30,70]</p>
<p>​                       [50,10,90]继续划分为[50,10]和[90]</p>
<p>​                       [50,10]划分为[50]和[10]</p>
<p>​                        右边部分略</p>
<p><strong>Merge函数：先是单个元素的两两归并，接着对越来越长的数组归并</strong></p>
<p>​                       左边部分[50]和[10]组成TR2=[50,10]排序后存到TR1=[10,50]</p>
<p>​                        [10,50]和[90]组成的数组TR2=[10,50,90]排序后存到TR1=[10,50,90]</p>
<p>​                        [10,50,90]和[30,70]组成的数组TR2=[10,50,90,30,70]以m=2为分隔点，[10,50,90]作为左边部分，[30,70]作为右边部分，                    从元素10和元素30开始比较小的元素存入数组TR1，直到左边或右边部分结束，再将剩下的元素存入TR1</p>
<p>​                        右边部分略</p>
<h2 id="迭代实现（从底至顶直接合并）"><a href="#迭代实现（从底至顶直接合并）" class="headerlink" title="迭代实现（从底至顶直接合并）"></a>迭代实现（从底至顶直接合并）</h2><p><strong>归并排序的迭代实现：</strong>就是将待排序集合<strong>一分为二</strong>，直到待排序集合只剩下 1 个元素为止 。 然后<strong>不断合并2个排好序的数组段</strong>。</p>
<p><strong>迭代：</strong>通过迭代的方式我们可以省去一分为二的过程，用合并算法直接将它们排序，构成n/2组长度为2的排序序的数组段，然后再将它们排序成长度为4的排好序的子数组段。如此继续，直到整个数组排好序。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:80%;">

<ul>
<li>从归并段的长度为1开始，一次使用归并段的长度变为原来的2倍；</li>
<li>在每趟归并的过程中，要注意处理归并段的长度为奇数和最后一个归并段和之前不等的情况，需要进行处理</li>
</ul>
<h1 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h1><blockquote>
<p><strong>递归方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] TR1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        Msort(SR, TR1, <span class="number">0</span>, SR.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : TR1) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组SR：待排序的数组</span></span><br><span class="line"><span class="comment">    TR1：每次将SR数组中下标l,r范围内的数字排好序放入TR1中</span></span><br><span class="line"><span class="comment">    l,r分别表示SR数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Msort</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m;<span class="comment">//分隔待排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] TR2 = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];<span class="comment">//暂存待排数组左右两部分排序好的数组</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            TR1[l] = SR[r];<span class="comment">//递归到最后一层，相当于单个元素不做排序，先将单个元素按原来的位置写到TR1中，然后返回上层递归，从两个元素开始合并</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;<span class="comment">//将待排范围的数组从中间分开</span></span><br><span class="line">            Msort(SR, TR2, l, m);<span class="comment">//右半部分递归调用函数Msort</span></span><br><span class="line">            Msort(SR, TR2, m + <span class="number">1</span>, r);<span class="comment">//左半部分递归调用函数Msort</span></span><br><span class="line">            Merge(TR2, TR1, l, m, r);<span class="comment">//对TR2中的两部分数组归并排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 20 30 40 50 60 70 80 90 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>迭代方式实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">1000</span>, <span class="number">1100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; SR.length) &#123;</span><br><span class="line">            MergePass(SR, res, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">            MergePass(res, SR, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//从第一个元素开始合并大小为s的相邻2段子数组</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">2</span> * s - <span class="number">1</span> &lt;= n) &#123;<span class="comment">//i+2*s 要小于等于数组长度，也就是说未合并的元素个数要大于2*s</span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);</span><br><span class="line">            i = i + <span class="number">2</span> * s;</span><br><span class="line">        &#125;<span class="comment">//此循环执行的次数为： n+1/(2*s) 次</span></span><br><span class="line">        <span class="keyword">if</span> (i + s - <span class="number">1</span> &lt; n) &#123;<span class="comment">//未合并的元素个数大于 1*s </span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, n);<span class="comment">//合并最后两个序列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//未合并的元素个数小于 1*s，直接复制到y就行了</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                TR[j] = SR[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：同上</strong></p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-list">热题100-148.排序链表</a></strong></p>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>这道题对两个子序列归并的部分与数组是不同的</strong></p>
</blockquote>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode midNode=findMidnode(head);</span><br><span class="line">        ListNode secondHead=midNode.next;</span><br><span class="line">        midNode.next=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode left=sortList(head);</span><br><span class="line">        ListNode right=sortList(secondHead);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidnode</span><span class="params">(ListNode head)</span></span>&#123;<span class="comment">//找到每段链表的中间节点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line"></span><br><span class="line">        ListNode slow=dummy;</span><br><span class="line">        ListNode fast=dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;<span class="comment">//合并两段链表</span></span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer-51. 数组中的逆序对</a></strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>根据归并排序的思路，当合并两段数组时，如果我们以右边元素为基准，当右边元素放入结果数组中时，表示左边数组中剩下的元素都是大于它的，这就是每次得到的逆序对数，因为前面的元素都大于它。</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//统计逆序对的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] temp;<span class="comment">//长度与数组长度一致，暂存每次待排序的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Msort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">Msort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r&lt;=l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;<span class="comment">//通过m将数组一分为二</span></span><br><span class="line">        Msort(nums, l, m);</span><br><span class="line">        Msort(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        </span><br><span class="line">        Merge(nums, l, m, r);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=l;n&lt;=r;n++)&#123;</span><br><span class="line">            temp[n]=nums[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index=l;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=m||j&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;m) &#123;nums[index++]=temp[j++];&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;r) &#123;nums[index++]=temp[i++];&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp[i]&lt;=temp[j]) &#123;nums[index++]=temp[i++];&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;nums[index++]=temp[j++]; res+=m-i+<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解码</title>
    <url>/2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-394/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/decode-string">https://leetcode-cn.com/problems/decode-string</a></p>
</blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>这道题我看到总结的比较好的一句话：数字放在数字栈，字符串放在字符串栈，右括号弹出一个数字栈中的数字，字符串栈弹到0为止。</p>
</blockquote>
<p>在遍历一个编码字符串时我们遇到的字符有以下几种情况：（数字栈：nums         字符串栈：ss）</p>
<p>数字——括号内字符串的重复次数</p>
<p>普通字母——拼接到res中</p>
<p>左括号’[‘——当我们遇到左括号时：</p>
<ul>
<li>先将存储数字的变量num加入数字栈nums中</li>
<li>说明括号内的字符串要重复num次，然后与括号外面的字符串拼接，因此我们先将左括号左边的res转换成字符串压入字符串栈ss中</li>
<li>另res和数字num重新计数（因为括号中还可能套括号，比如a3[a2[c]]，就是先将最外层的res=a存到字符串栈ss中，数字num=3存到数字栈nums中，将res和num置零后，再将第一层括号的res=a存到字符串栈ss中，数字num=2存到数字栈nums中）</li>
</ul>
<p>右括号’]’——当我们遇到右括号时：（说明最内层字符串记录结束，存于res中）</p>
<ul>
<li>从数字栈nums中弹出栈顶的数字，这个数就是这一层括号前面记录重复次数的数字，将res中的字符串重复curnum次，存到StringBuilder类型的temp中</li>
<li>再弹出一个ss栈顶的字符串，这个字符串就是括号之前的字符串，将它与temp拼接起来，再用res保存，用于遇到下一个右括号时，这个res就是该括号内要重复的字符串（比如a3[a2[c]]，当遇到第一个右括号时，将数字栈中的2弹出，将res=c循环拼接3次，也就是拼成temp=cc，再将字符串栈ss中的a弹出，与temp拼接成res=acc，之后遇到第二个右括号，temp=accaccacc，再与a拼接成res=aaccaccacc）</li>
</ul>
<p>最后编码字符串遍历结束，返回res</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      LinkedList&lt;Integer&gt; nums=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      LinkedList&lt;String&gt; ss=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">          <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">              num=num*<span class="number">10</span>+Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">             nums.add(num);</span><br><span class="line">             ss.add(res.toString());</span><br><span class="line">             res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">             num=<span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">             StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">             <span class="keyword">int</span> curNum = nums.removeLast();</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curNum; i++) &#123;</span><br><span class="line">                 temp.append(res);</span><br><span class="line">             &#125;</span><br><span class="line">             res = <span class="keyword">new</span> StringBuilder(ss.removeLast() + temp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              res.append(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2021/02/04/%E5%89%91%E6%8C%87offer-16/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p>
</blockquote>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>本题的重点在于理解<strong>“快速幂法”</strong>为什么能把时间复杂度降低到<strong>log2n</strong></p>
</blockquote>
<p>求 x^n最简单的方法是通过循环将 n 个 x 乘起来，依次求x^1, x^2, …, x^{n-1}，直到求出x^n时间复杂度为 O(n) 。例如我们输入的幂次exponent为32，我们要求base的32次方就要在程序中对base乘31次。但是如果我们通过base的2次方求base的4次方接着求base的8次方，16次方，32次方，这样就能将循环次数降为对数级。我们可以通过以下公式来求得a的n次方：</p>
<p>我们设循环中的变量为i，初始值为n</p>
<p><strong>当i=n时：</strong><br>$$<br>{a^i} =<br>        \begin{cases}<br>        {a^{i/2}}·{a^{i/2}}    &amp; \text{如果 $i$ 为偶数}\<br>        {a^{i/2}}·{a^{i/2}}·a  &amp; \text{如果 $i$ 为奇数}<br>        \end{cases}<br>$$<br><strong>当i=n/2时：</strong>仍然按照上面的公式判断i的奇偶，求得a的i次方……</p>
<p>通过一个for循环，每次将幂次除以2，最终可以以O(log2n)的时间复杂度求得a的n次方，因为2^x=n,x=log2n,也就是循环x=log2n次。</p>
<blockquote>
<p>理解了快速幂法之后，下面是解题的流程：</p>
</blockquote>
<ul>
<li>当底数为0时没有意义，直接返回</li>
<li>当指数为负数时，将底数变为1/x，负数变为正数（转换成了常规的指数为正数的情况）</li>
<li>当指数为正数时，按照上面的公式求解</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b=n;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b=-b;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码中有两处注意点：</strong></p>
</blockquote>
<ol>
<li>用long类型的b去暂存n的值，因为int类型的负数范围比正数大1，这样做为了防止另n=-n时溢出</li>
<li>用指数的二进制形式来判断奇偶，并用移位来代替幂次每循环一次除以2，能够提高运算效率</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p><strong>堆：</strong>通常可以看成是一个完全二叉树的<strong>数组</strong>。（堆排序实际上是堆中元素的交换，因此可以用数组实现，并且数组的查询和修改效率比较高，能够提高性能）</p>
<p><strong>堆的两种形式：</strong></p>
<ul>
<li>大顶堆：根节点<strong>大于</strong>左右孩子的节点</li>
<li>小顶堆：根节点<strong>小于</strong>左右孩子的节点</li>
</ul>
<h2 id="构造堆"><a href="#构造堆" class="headerlink" title="构造堆"></a>构造堆</h2><p><strong>1、二叉树堆结构中元素与数组堆结构中元素的对应关系：</strong>（大小顶堆一样的）</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片.png" style="zoom:150%;">

<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:150%;">

<p>那么对于某一个节点index，它的左右孩子在数组中的下标分别为：</p>
<ul>
<li>Left=index*2+1</li>
<li>Right=index*2+2</li>
</ul>
<p>叶子结点和非叶子节点的区别：</p>
<ul>
<li>非叶子节点的下标&lt;节点个数/2-1</li>
<li>叶子节点的下标&gt;节点个数/2-1</li>
</ul>
<p><strong>2、大顶堆的维护（核心）</strong></p>
<p><strong>自下而上</strong>地维护一个大顶堆，使其满足大顶堆的性质：非叶子节点的左右孩子都小于它的根节点</p>
<p>维护分为初始化时大顶堆的维护和初始化后大顶堆的维护：</p>
<ul>
<li>刚开始将待排序数组中的前k个元素复制到堆结构中的数组中，并调用HeapAdjust（）方法，<strong>从非叶子节点开始，自下而上地维护</strong>；</li>
<li>而对于新插入的剩下的n-k个元素，只有当元素小于大顶堆的根节点时，才会移除根节点，并将该元素加入大顶堆。因此除了0号元素可能不满足大顶堆的性质外，它的下层的非叶子节点都满足性质，所以<strong>维护的实质是：</strong>维护index=0的情况。</li>
</ul>
<h1 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] input = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        result = HeapSort(input, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">            System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用数组来模拟k个节点的堆结构</span></span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, a, <span class="number">0</span>, k);<span class="comment">//初始化堆中的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//k就是我们要维护的堆结构的节点下标</span></span><br><span class="line">            HeapAdjust(i, a, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;<span class="comment">//遍历剩余的n-k个元素</span></span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; a[<span class="number">0</span>]) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = input[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, a, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将大顶堆中的元素进行升序操作</span></span><br><span class="line"><span class="comment">//        for (int i = a.length - 1; i &gt; 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//            //分为两个过程：1.交换 2.通过减小节点的个数来固定最大的元素</span></span><br><span class="line"><span class="comment">//            int temp = a[i];</span></span><br><span class="line"><span class="comment">//            a[i] = a[0];</span></span><br><span class="line"><span class="comment">//            a[0] = temp;</span></span><br><span class="line"><span class="comment">//            HeapAdjust(0, a, i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数功能就是维护每一个节点的大顶堆性质</span></span><br><span class="line"><span class="comment">    index 节点的下标</span></span><br><span class="line"><span class="comment">    a 堆结构</span></span><br><span class="line"><span class="comment">    length 堆结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];<span class="comment">//temp保存当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt; a[x]) &#123;<span class="comment">//取出当前节点的左右孩子的最大值</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;<span class="comment">//更新index的值，index代表的是temp的值最终在堆中的位置，index和x的关系其实就是根节点和子节点的关系</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//由于我们是从下往上维护的，当index=0的节点满足性质后，就没有更新的必要了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;<span class="comment">//index代表的是temp的值最终在堆中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码运行的结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40 30 20 10 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>堆排序用于解决<strong>TOPK</strong>类问题</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p>
<p>这里还对代码进行了优化，不用建立新数组，用给定数组直接作为堆结构数组</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>大顶堆</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, nums, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, nums, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &lt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &lt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof"><strong>剑指offer-40.最小的K个数</strong></a></p>
<p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>大顶堆</p>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, arr, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, arr, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,res,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优先队列实现堆排序"><a href="#优先队列实现堆排序" class="headerlink" title="优先队列实现堆排序"></a>优先队列实现堆排序</h1><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p><strong>1、匿名内部类：</strong>前提是存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p>
<blockquote>
<p><strong>格式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名()&#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Inter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、PriorityQueue（优先队列）</strong></p>
<p>优先级队列的元素按照自然排序进行排序，或者根据构造队列时提供的<strong>Comparator（比较器）</strong>进行排序，具体取决于所使用的构造方法。优先级队列不允许使用null元素，依靠自然排序的优先级队列还不允许插入不可比较的对象（这样容易导致ClassCastException）。</p>
<p><strong>队列的头</strong>相当于堆的<strong>根节点</strong></p>
<blockquote>
<p><strong>构造方法：</strong></p>
<p><strong>a.无Comparator参数：</strong>默认自然排序，实现小顶堆；</p>
<p><strong>b.传入Comparator：</strong>重写里面的compare方法，实现大顶堆。<strong>（常用）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据自然排序对元素排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据指定的比较器对元素排序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong>（第二个构造方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o2-o1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回0：o1等于o2，是同一元素</span></span><br><span class="line"><span class="comment">返回正数：认为o2大于o1，让o2排在更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">返回负数：认为o2小于o1，让o2排在远离队列头部的位置</span></span><br><span class="line"><span class="comment">这样就构成了大顶堆，相反当返回的是o1-o2时，比如返回正数，仍然认为o2大于o1，让小数o2排在了更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">热题100-347. 前 K 个高频元素</a></strong></p>
<p>输出数组中出现频率前K高的元素</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>借助 <strong>哈希表</strong> 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</p>
<p>通过比较器指定排序规则，即频率越高的元素越靠近队列的头部，排序过程如下图所示：</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片2.png" style="zoom: 120%;">

<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; requence=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(requence.containsKey(num))&#123;</span><br><span class="line">            requence.put(num,requence.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            requence.put(num,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1,Integer num2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> requence.get(num1)-requence.get(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:requence.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//当队列中元素个数小于k时，向队列中添加元素，先将队列中元素增加到k个</span></span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(requence.get(num)&gt;requence.get(pq.peek()))&#123;<span class="comment">//当队列中头部元素大于HashMap中频率时，先将头部弹出，再向队列中添加出现频率更高的元素</span></span><br><span class="line">            pq.poll();</span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        res[i]=pq.poll();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">热题100-23. 合并K个升序链表</a></strong></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>假设给定的链表集合中共有n个链表，存储的都是每个链表的头结点，我们通过维护一个长度为n的优先级队列，按照每个节点数值的大小顺序在优先级队列中排序，我们维护一个小顶堆，那么最小的元素将靠近队列的头部</li>
<li>将所有链表的头结点放入队列中</li>
<li>创建一个哑结点</li>
<li>每次取出队列中数值最小的节点，拼接到结果链表中，然后如果该节点后面不为null，继续向队列中添加节点</li>
<li>直到队列为空，结束循环</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> l1.val-l2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(ListNode node:lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)  pq.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            ListNode node=pq.poll();</span><br><span class="line">            cur.next=node;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(node.next);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-20/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>
</blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>分析题目可知，指针的指向实际上有两种情况：</p>
<ul>
<li>指向的字符为左括号</li>
<li>指向的字符为右括号</li>
</ul>
<p>要将所有的括号配对，也就是我们遇到左括号时，并不知道有没有右括号与之对应，因此先将左括号存储到一个栈中，并且遇到右括号时要将容器中对应的左括号出栈，最后栈中没有元素时，说明配对成功，返回true。</p>
<p><strong>改进：</strong>可以遇到左括号时将相应的右括号入栈，这样可以在遇到右括号时，只需要判断是否相等即可</p>
<p>在程序中，只要遇到不满足条件的情况，提前结束循环，返回false。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="comment">//该情况对应于栈为空，但是来了一个右括号的情况，或者不相等的情况，                                                     //直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a></p>
</blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java中的栈推荐用Deque双端队列来实现，效率比Stack 要高，其相关函数有：</p>
</blockquote>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E6%96%B9%E6%B3%95.png"></p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的难点在于将min函数从O（n）降为O（1），要得到栈A中的最小值首先想到的是用一个成员变量min来保存这个最小值，但是当栈中的该值弹出时，就没有办法得到次小值，因此仅用一个成员变量是不够的。</p>
<p>所以想到使用辅助栈B，将最小元素（置于栈顶）和次小元素都存储起来，使其非严格降序，每次栈A中弹出元素都要跟B栈中的栈顶元素值比较，若相等则使用pop（）函数弹出，否则不执行弹出。查看最小元素时使用peek（）函数。<a href="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png">如图所示：</a></p>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E5%9B%BE%E7%89%87.png"></p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A;</span><br><span class="line">    Deque&lt;Integer&gt; B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    B=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty() || B.peek() &gt;= x)<span class="comment">//B.empty（）对应最开始或者后面B栈中没有元素时，新压入的元素就是最小值要压入B中，当B中有元素时，新压入A栈的元素要与B中的元素比较，如果小于等于就压入B，这里等于号=很重要，因为当A栈中两个2相连压入时，就要在B中也有两个2对应，否则A中一个2弹出，也会将B中2弹出，这样会造成查询到的最小值不等于2。</span></span><br><span class="line">            B.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))&#123;<span class="comment">//判断A中弹出的值与B中栈顶的值（最小值）是否相等，若相等也将B中栈顶元素弹出。</span></span><br><span class="line">                                     <span class="comment">//因为栈中存储的是int的包装类Integer，因此只能用equals()方法，不能用“==”</span></span><br><span class="line">        B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>假期的阶段性总结</title>
    <url>/2021/01/31/%E5%81%87%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>研二的假期比往常来的稍早那么一些，回家的第二十一天，这段时间的学习效率是大打折扣，算是刚刚连抄带蒙地“刷完了”《剑指offer》里面的困难题暂时不准备刷，一部分因为懒，一部分因为菜。我属于是那种将就起来就会放飞自我的人哈哈，还是要梳理一下自己的进度，正视问题刺激一下自己才行。</p>
<h1 id="·-刷题方面"><a href="#·-刷题方面" class="headerlink" title="· 刷题方面"></a>· 刷题方面</h1><p>《剑指offer》刷完，共69道题，后面刷的一部分题勉强写了点题解：</p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-29/#more">顺时针打印矩阵</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-49/#more">丑数</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-38/#more">字符串的排列</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-66/#more">构建乘积数组</a></p>
<p><a href="https://eudemonia.tech/2021/01/27/%E5%89%91%E6%8C%87offer-45/#more">把数组排成最小的数</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-13/#more">机器人的运动范围</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-04/#more">二维数组中的查找</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">扑克牌中的顺子</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">矩阵中的路径</a></p>
<p><a href="https://eudemonia.tech/2021/01/19/%E5%89%91%E6%8C%87offer-34/#more">二叉树中和为某一值的路径</a></p>
<p>前面的题解以word文档的形式保存了，那时候还没有这个博客，后面打算二刷剑指的时候补齐。</p>
<p>下面开始刷LeetCode热题100，还是每天两道，坚持写题解，头年再刷二十道左右。</p>
<h1 id="·-校园商城项目"><a href="#·-校园商城项目" class="headerlink" title="· 校园商城项目"></a>· 校园商城项目</h1><p>慕课看到了第四章的商铺注册也就是前端的页面设计部分，还在项目1.0版本，用的是SSM框架，后面大体结构搭建起来了，但是很多细节自己并不清楚，打算再看看后面做的过程中对项目的理解情况，不行真得从头再刷一遍，有篇文章值得看一看，对项目整理架构的理解有帮助，<a href="https://www.jb51.net/article/127829.htm">点这里查看</a>。</p>
<p>每天晚上的时间都用来搞这个，进度要赶一赶了，年前争取项目1.0这块做的差不多了得。</p>
<h1 id="·-计算机网络"><a href="#·-计算机网络" class="headerlink" title="· 计算机网络"></a>· 计算机网络</h1><p>按照大佬的学习路线看王道考研视频，看完了传输层的部分，打算看完了这块之后开始结合面经学习。大佬说这个考研视频讲的偏重于前面的部分，实际面经中考点在后面的部分。</p>
<p>最多两天看完，打算用这部分时间写写论文，之后再背面经。</p>
<h1 id="·-GitHub个人博客"><a href="#·-GitHub个人博客" class="headerlink" title="· GitHub个人博客"></a>· GitHub个人博客</h1><p>大概一周的时间，自己学着做了一个个人博客，想写点东西，当个自己的学习笔记，或者是生活日记什么的。</p>
]]></content>
      <tags>
        <tag>个人随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-49/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
</blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>解题思路参考于：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></p>
<p>下面那个评论中的小伙伴解释的特别好！</p>
</blockquote>
<p>根据丑数的定义，我们可以得到<strong>丑数的递推性质</strong>：新的丑数可以由现有的丑数序列（排好序）乘以2、3、5得到。</p>
<p>在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, …, n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，</p>
<p>比如如果按照这样的顺序排列下去肯定有问题[1<em>2, 1</em>3, 1<em>5, 2</em>2, 2<em>3, 2</em>5, 3<em>2, 3</em>3, 3<em>5, … , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3</em> 3, n2 *  5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面，  后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。</p>
<p>关键在于怎么让得到的丑数序列是有序的，我们知道当序列中已经有n个丑数的情况下，后面的丑数是由现有序列中的丑数乘以2、3、5得来的，我们要先取得到的丑数中的最小值作为第n+1个丑数，这个丑数有可能是：</p>
<ul>
<li>前面序列中第M1个丑数乘以2</li>
<li>前面序列中第M2个丑数乘以3</li>
<li>前面序列中第M3个丑数乘以5</li>
</ul>
<p>也就是说，我们要取这三种途径中值最小的那个数，这个值就是新得到的丑数中的最小值。为保证每个数都能与2,3,5相乘，我们可以通过设置3个索引a, b, c，分别记录当前位置的丑数有没有与2,3,5相乘，每次循环通过以a,b,c为索引乘以相应的2,3,5得到新的丑数，取这三种途径的最小值。</p>
<p>我们模拟丑数序列的产生过程，<strong>重点是a,b,c分别指示该位置的丑数是不是已经与2,3,5相乘：</strong></p>
<img src="/2021/01/28/%E5%89%91%E6%8C%87offer-49/图片.png" style="zoom:80%;">

<p>对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道），  第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2，  第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。</p>
<p>求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5，  通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第  b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b  个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;</p>
<p>但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5，  说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数,  只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if,  这样才不会把应该加一的计数器漏掉</p>
<p>经过n次循环，就能得到第n 个丑数了。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">// 使用dp数组来存储丑数序列</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// dp[0]已知为1</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;    <span class="comment">// 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数</span></span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2)&#123;</span><br><span class="line">                a++; <span class="comment">// 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3)&#123;</span><br><span class="line">                b++; <span class="comment">// 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5)&#123;</span><br><span class="line">                c++; <span class="comment">// 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><blockquote>
<p><strong>参考文章：</strong><a href="https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack">https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack</a></p>
<p>字节大佬的文章写得特别棒，很实用！</p>
</blockquote>
<p><strong>回溯法（backtrack）</strong>常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于<code>全排列</code>，穷尽所有可能。时间复杂度一般 O(N!)，回溯算法就是纯暴力穷举，复杂度一般都很高。</p>
<p><strong>核心思想：</strong>就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(选择列表，路径)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">       result.add(路径);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(选择 in 选择列表)&#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtrack(选择列表,路径);</span><br><span class="line">        撤销选择;<span class="comment">//递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/"><strong>题目-38. 字符串的排列</strong></a></p>
<p>给定一个可包含重复元素的序列，返回所有不重复的全排列。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>要点：</strong></p>
<ul>
<li><p>包含重复元素的情况，要将数组排序，进行去重</p>
</li>
<li><p>递归中，for循环每次从数组的头部开始遍历</p>
<p>当flag数组中为true时，表示元素已经添加到temp临时结果集中，跳过该元素</p>
<p>因为将数组排序了，防止重复的结果出现，当满足**(i&gt;0&amp;&amp;ss[i]==ss[i-1]&amp;&amp;!flag[i-1])**时，跳过该元素</p>
<p>例：nums=[1，1，2，3，4]     flag=[false，false，false，false，false]</p>
<p>首先固定元素1，flag=[<strong>true</strong>，false，false，false，false]</p>
<p>当第二次固定第二个1时，考虑到1作为打头元素已经有一个结果了，所以我们要跳过该元素，如果我们只把条件设为<strong>ss[i]==ss[i-1]**时，那么第一次递归的几轮这个元素都不能添加到临时结果集中，这个结果就不会成立，注意到此时的前一个元素状态为false，而第一次递归的状态为true，所以我们将条件设为</strong>ss[i]==ss[i-1]&amp;&amp;!flag[i-1]**</p>
<p>换句话说，<strong>这个条件是为了不让同一层递归中同一个元素重复固定</strong>，而在<strong>不同层的递归中不用跳过重复元素</strong></p>
</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>过滤条件中一定是没有访问过，例如：[a,b,c,c,d]这种情况，当第一个c被标记为true，调用递归函数时，再遍历到第四个c时，当去判断时，如果判断条件没有加上没有被访问过时，第四个c就会被跳过，而且是一直被跳过，会导致路径无法满足长度，没有结果输出，其实这个条件过滤的是两个c在同一选择列表的情况，当两个c一个被固定时，就不在同一选择列表内，也就不用再过滤。</p>
</blockquote>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/permutations/">热题100-46. 全排列</a></strong></p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>上题的简化版，不用考虑去重</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=num.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        backTrace(n,num,flag,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>[] num,<span class="keyword">boolean</span>[] flag,ArrayList&lt;Integer&gt; temp,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.size()==n)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.add(num[i]);</span><br><span class="line">            backTrace(n,num,flag,temp,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/subsets/">热题100-78. 子集</a></strong></p>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>递归过程如下图所示：</strong></p>
<img src="/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/图片.png" style="zoom:120%;">

<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backTrack(nums,<span class="number">0</span>,temp,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nums 给定的集合</span></span><br><span class="line">    <span class="comment">// pos 下次添加到集合中的元素位置索引</span></span><br><span class="line">    <span class="comment">// temp 临时结果集合(每次需要复制保存)</span></span><br><span class="line">    <span class="comment">// res 最终结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos,List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把临时结果复制出来保存到最终结果</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="comment">// 选择、处理结果、再撤销选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTrack(nums,i+<span class="number">1</span>,temp,res);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/generate-parentheses/">热题100-22. 括号生成</a></strong></p>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>递归逻辑：</strong></p>
<ul>
<li>通过left和right来表示临时结果集中左括号和右括号的数目</li>
<li>当临时结果集中元素个数=n*2时，将临时结果集复制加入到结果集中</li>
<li>当左括号的个数小于n时，将个数+1，开启一次递归</li>
<li>当右括号的个数小于左括号的个数时，将个数+1，开启一次递归</li>
</ul>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">generateParenthesis</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        backTrace(<span class="number">0</span>,<span class="number">0</span>,n,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrace</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> n,StringBuilder temp,ArrayList&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.length()/<span class="number">2</span>==n)&#123;</span><br><span class="line">            res.add((<span class="keyword">new</span> StringBuilder(temp)).toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">            temp.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backTrace(left+<span class="number">1</span>,right,n,temp,res);</span><br><span class="line">            temp.deleteCharAt(temp.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;left)&#123;</span><br><span class="line">            temp.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backTrace(left,right+<span class="number">1</span>,n,temp,res);</span><br><span class="line">            temp.deleteCharAt(temp.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/combination-sum/">热题100-39. 组合总和</a></strong></p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>开启递归之前，将元素排序，便于去重</p>
<p><strong>递归实现：</strong></p>
<p>当target小于0时，递归结束，特别地，当等于0时就是我们要找的临时结果集，将临时结果集加入到结果数组</p>
<ul>
<li>用index保存本次遍历的初始位置</li>
<li>当i&gt;index时，也就是同一层递归时，不能选取同样的元素固定</li>
<li>将元素加入到临时结果集，target减去元素值，向下递归</li>
<li>递归结束，还原临时结果集和target，不影响下一次递归</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=num.length;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        backTrack(<span class="number">0</span>,num,target,n,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span>[] num,<span class="keyword">int</span> target,<span class="keyword">int</span> n,ArrayList&lt;Integer&gt; temp,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt; (temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;index&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(num[i]);</span><br><span class="line">            backTrack(i+<span class="number">1</span>,num,target-num[i],n,temp,res);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-66/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof</a></p>
</blockquote>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>方法一：暴力解法，每次用连乘n-1个数字的方法得到B[i]。但是这种方法的时间复杂度为O(n^2)。</p>
<p>方法二：通过分析乘积数组的特点，即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]，定义C[i]=A[0]×A[1]×…×A[i-1]，D[i]=A[i+1]×…×A[n-1]，也就是B[i]可以分成两部分C[i]和D[i]的乘积，如图所示：</p>
<p><img src="/2021/01/28/%E5%89%91%E6%8C%87offer-66/2021-01-28-%E5%89%91%E6%8C%87offer-66%5C%E5%9B%BE%E7%89%87.jpg"></p>
<p>而C[i]和D[i]可以分别通过两次循环得到，这种做法的时间复杂度为O(n)。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>快速排序算法的本质同冒泡排序一样，同属于交换排序类。也就是通过不断地比较和移动交换来实现排序，只不过对于快速排序来说增大了记录的比较和移动的距离，将较大的关键字记录从前面直接移动到后面，将较小的从后面直接移动到前面，减少了总的比较次数和移动交换次数。</p>
<p><strong>快排的基本思想是：</strong>选定一个分隔点，通过一趟排序将待排记录<code>按照数组中元素与分隔点的逻辑关系分割成独立的两部分</code>，然后按照同样的方式，对两侧的子数组再排序，直到实现整个序列有序的目的。</p>
<p>例如：对于如图所示的数组进行排序的过程如下</p>
<img src="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/图片.png" style="zoom: 67%;">

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiuckSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        QSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//l、r分别是每次排序的左右边界</span></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="comment">//以nums[l]作为分隔点，将元素左右移动</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[l];</span><br><span class="line">        nums[l] = temp;</span><br><span class="line">        QSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">        QSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span> </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-colors">75.颜色分类</a></strong></p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>快速排序</p>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=l)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=r;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]&lt;nums[l]) i++;</span><br><span class="line">            temp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]=temp;</span><br><span class="line">        nums[i]=nums[l];</span><br><span class="line">        quickSort(nums,l,i);</span><br><span class="line">        quickSort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/merge-intervals/">热题100-56. 合并区间</a></strong></p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个区间的关系有三种：区间有交集、区间重叠、区间无交集。如图所示：</p>
<img src="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/GitHub\MyBlogs\source\_posts\2021-02-08-LeetCode热题100-56\图片.png" style="zoom: 50%;">

<p>我们可以先对区间的左端点进行排序，如果区间可以合并的话那么排序之后它们应该是连续的，先将第一个区间加入到结果数组res，按排序后的顺序考虑后面的区间。</p>
<p><strong>可以跟前一个区间合并的条件为：</strong></p>
<p>区间符合图中1、2情况，<strong>即前一个区间的右端点大于等于该区间的左端点</strong>，此时我们要更新结果数组中区间的右端点值为该区间和结果数组中区间右端点的较大值，然后接着顺序比较后面的区间。</p>
<p><strong>不能合并的条件为：</strong></p>
<p>如果<strong>当前区间的左端点在结果数组中最后一个区间的右端点之后</strong>，那么它们不会重合，我们可以直接将这个区间加入结果数组的末尾。</p>
<p><strong>实现流程：</strong></p>
<ul>
<li><p>先按照区间起始位置排序</p>
</li>
<li><p>遍历区间</p>
<p>如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置， 则不合并，直接将当前区间加入结果数组</p>
<p>反之将当前区间合并至结果数组的最后区间</p>
</li>
</ul>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><blockquote>
<p><strong>LeetCode题解：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] interval1, <span class="keyword">int</span>[] interval2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历区间</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">            <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反之将当前区间合并至结果数组的最后区间</span></span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>牛客题解：</strong>差别在于牛客上定义了Interval这个类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Interval&gt; <span class="title">merge</span><span class="params">(ArrayList&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">        Collections.sort(intervals,<span class="keyword">new</span> Comparator&lt;Interval&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1,Interval o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.start-o2.start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Interval&gt; res=<span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Interval j:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index==-<span class="number">1</span>||res.get(index).end&lt;j.start)&#123;</span><br><span class="line">                res.add(j);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.get(index).end = Math.max(res.get(index).end, j.end);</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer-45. 把数组排成最小的数</a></strong></p>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>将数组排成最小的数，我们最直观的想法是小数在前，大数在后，但是这样的排序组成的数组不一定是最小的数字，例如：10,9，这两个数字组成的最小数字应该是109而不是910。因此需要定义一种排序规则，使组成的数字最小。</p>
<p><strong>主要是定义的这种排序规则：</strong></p>
<p>若我们另两个数字为a，b，两个数字的组合有三种情况：</p>
<ol>
<li>当ab&gt;ba时，我们定义b应该在前；</li>
<li>当ba&gt;ab时，我们定义a应该在前；</li>
<li>当ab=ba时，两数相同，谁在前都可以。</li>
</ol>
<p>那么程序中的排序部分应该写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line"><span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>本题除了排序规则之外，还应该在准备工作中将int类型转换为String类型，防止ab组合时溢出，所以这还是一个隐形的大数问题。</p>
</blockquote>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        fastSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        String tmp = strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        fastSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        fastSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/01/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h1><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/spiral-matrix/">剑指offer-54. 螺旋矩阵</a></strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><img src="/2021/01/25/%E6%95%B0%E7%BB%84/图片.png" style="zoom:50%;">

<p>以上图的矩阵为例，模拟一遍循环打印的过程：</p>
<p><strong>外圈：</strong></p>
<ul>
<li>从左上角的1开始，遍历顶部的一行，到右上角的元素3结束；</li>
<li>再从3下的元素6开始，遍历最右边的一列，到右下角的元素9结束；</li>
<li>再从9左边的元素8开始，遍历底部的一行，到左下角的元素7结束；</li>
<li>最后从7上边的元素4开始，遍历左边的一列，到起始元素的下边一个元素结束；  </li>
</ul>
<p><strong>内圈：</strong>元素多的话，与外圈的循环相同</p>
<p><strong>因此我们可以用多个重复的循环来解决这个问题：</strong>记左上角的元素坐标为（lr,lc）=（0,0），右下角的元素坐标为（rr,rc）=（sums.length-1,sums[0].length-1），那么每层中每次循环的起始坐标都可以用这四个元素来表示。</p>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> lr=<span class="number">0</span>;<span class="comment">//第一层循环的左上角元素为（0,0）</span></span><br><span class="line">    <span class="keyword">int</span> lc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rr=matrix.length-<span class="number">1</span>;<span class="comment">//第一层循环的右下角元素为（matrix.length-1，matrix[0].length-1）</span></span><br><span class="line">    <span class="keyword">int</span> rc=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[(rr+<span class="number">1</span>)*(rc+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//我们以第一层循环为例讲解代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lc;j&lt;=rc;j++)&#123;<span class="comment">//第一个循环改变的是列，行不变。另j等于顶层最左边坐标的列值lc，结束值是顶层最右边坐标的列值rc</span></span><br><span class="line">            res[k++]=matrix[lr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lr&gt;rr) <span class="keyword">break</span>;<span class="comment">//先另左边的行号+1，表示该行剔除，然后用加完后的值去跟右下角的行号比较，当大于该值，表示这两个在同                           //一行也就是只有一行，循环结束，下同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lr;i&lt;=rr;i++)&#123;</span><br><span class="line">            res[k++]=matrix[i][rc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rc&lt;lc) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=rc;j&gt;=lc;j--)&#123;</span><br><span class="line">            res[k++]=matrix[rr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rr&lt;lr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rr;i&gt;=lr;i--)&#123;</span><br><span class="line">            res[k++]=matrix[i][lc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lc&gt;rc) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>++a&gt;b表示先对a的值+1再和b的值比较，a++相反。</p>
</blockquote>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/1af528f68adc4c20bf5d1456eddb080a?tpId=190&tqId=35434&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-寻找峰值</strong></a></p>
<p>山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。 </p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为要找索引最大的峰值元素，所以<strong>从后往前</strong>遍历，第一个满足条件的元素索引就是结果</p>
<ul>
<li>要注意，峰值元素有可能出现在数组的两端，按照从后往前的顺序，先判断最后一个元素是不是峰值元素，他只要大于等于左边的相邻元素就可以</li>
<li>如果不是，循环遍历数组中间部分的元素，如果有满足条件的元素直接返回其下标</li>
<li>如果循环结束，还没有返回值，峰值有可能出现在数组的头部，对头部元素判断，他只要大于等于左边的相邻元素就可以</li>
<li>如果整个数组遍历完成，仍然没有返回结果，返回-1</li>
</ul>
<h3 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找最后的山峰</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=a.length;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[n-<span class="number">1</span>]&gt;=a[n-<span class="number">2</span>]) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=a[i+<span class="number">1</span>]&amp;&amp;a[i]&gt;=a[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]&gt;=a[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/next-permutation/">热题100-31. 下一个排列</a></strong></p>
<p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>注释思路比较清晰</p>
<h3 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=nums.length-<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;<span class="comment">//与后一个元素比较，直到找到一个元素比前一个元素小</span></span><br><span class="line">    <span class="comment">//必须要严格小于，防止几位连续相等的情况，找到的并不是突然变小的那个元素</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(j&gt;=i&amp;&amp;nums[i]&gt;=nums[j])&#123;<span class="comment">//从后往前找，找到那个比nums[i]【略大的】那个数</span></span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       swap(nums,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(nums,i+<span class="number">1</span>);<span class="comment">//此时从数组第i个位置往后肯定是递减的，改变一位后肯定比给定数大，但是并不是最接近它的，因为i后面大数仍然在高位，所以要对后面的序列翻转，越高位的数值越小，才是更接近给定值的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">       nums[i]=nums[j];</span><br><span class="line">       nums[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=i;</span><br><span class="line">        <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            swap(nums,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">剑指 Offer 61. 扑克牌中的顺子</a></strong></p>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>对于该题我们要分析怎样去判断给定的数组中的五个数字是不是连续的，那么首先应该对该数组进行排序，我们注意到本题中给定的条件中包括一条：<code>大小王为0，并且可以充当任意数字</code>。当不包含大小王时，判断五个数字是不是连续的非常简单，如果是连续的数字，每个数字相差1，也就是最大值和最小值的差为4，可以理解为4个间隔大小。因此本题可以转换为存在的大小王的个数能不能使最大值和最小值的间隔满足要求。根据大小王的个数可以分为以下情况：</p>
<p>1、不存在0：最大值和最小值的间隔为4；</p>
<p>2、存在一个0：剩下四个位置，可以是2,3,4,5这种情况（间隔为3），也可以是2,3,5,6（间隔为4），0作为4补齐，当2,3,6,7（间隔为5）此时只有一个0的情况不能再补齐，不满足条件；</p>
<p>3、存在两个0：剩下三个位置，可以是3,4,5这种情况（间隔为2），或者是3,5,6这种情况，0作位2,4或4,7 补齐，也可以是3,6,7（间隔为4），0作为4,5补齐，当3,7,8（间隔为5）此时只有两个0的情况不能再补齐，不满足条件；</p>
<p><strong>根据以上情况总结：</strong></p>
<ul>
<li>五个数连续的条件是最大值和最小值的间隔小于等于4个单位，当有一个王时，只能补齐一个位置，两个王时补齐两个位置，<code>实质就是通过最大值和最小值的差值来看中间有几个空缺的位置</code>；</li>
<li>数组中不能包含重复数字；</li>
</ul>
<h3 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> knums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) knums++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">4</span>]-nums[knums]&lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/first-missing-positive/">主站-41. 缺失的第一个正数</a></strong></p>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；</li>
<li>那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</li>
</ul>
<h3 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//当满足元素为正数，并且值不超过数组的索引，它的值与它的索引位置不匹配，因为要将它放到应该的位置上，并且那个位置上的值不能是它本身，要不然while循环会死循环。</span></span><br><span class="line">            <span class="comment">//之所以是while循环而不是if，是因为一次交换之后，该位置上的值仍然可能不属于该位置，因此满足条件要继续交换</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;n&amp;&amp;nums[i]!=i+<span class="number">1</span>&amp;&amp;nums[nums[i]-<span class="number">1</span>]!=nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=nums[nums[i]-<span class="number">1</span>];</span><br><span class="line">                nums[nums[i]-<span class="number">1</span>]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历找到元素值与数组的位置不匹配的那个值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-<span class="number">1</span>!=i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都正确则返回数组长度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/rotate-image/">热题100-48. 旋转图像</a></strong></p>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设矩阵中一个元素的位置为：（i，j），通过归纳，经过旋转后的位置为：（j，n-i-1）;</p>
<p>我们通过先对矩阵进行水平翻转：（x，y）=（n-x-1，j）</p>
<p>再对矩阵按主对角线翻转：（a，b）=（b，a）</p>
<p>因此经过两次翻转后的坐标应该是：（x，y）=（y，n-x-1）</p>
<p>正好就是旋转90°的坐标</p>
<h3 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;<span class="comment">//matrixnew​[col][n−row−1]=matrix[row][col]</span></span><br><span class="line">    <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[n-i-<span class="number">1</span>][j];</span><br><span class="line">            matrix[n-i-<span class="number">1</span>][j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/find-peak-element/">主站-162. 寻找峰值</a></strong></p>
<p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>与<a href="https://www.nowcoder.com/practice/1af528f68adc4c20bf5d1456eddb080a?tpId=190&tqId=35434&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-寻找峰值</strong></a>类似</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>遍历即可。</p>
<p>注意处理两端元素。</p>
<h3 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;nums[i-<span class="number">1</span>]&amp;&amp;nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;nums[nums.length-<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/diagonal-traverse/">主站-498. 对角线遍历</a></strong></p>
<p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>对角线：</strong></p>
<p>对角线的性质是行号x和列号x之和x+y为定值，m×n矩阵的对角线一共有m+n−1条。</p>
<p>用变量count记录当前正在输出第几条对角线，根据count的奇偶性可以知道这条对角线是向右上走还是向左下走。如果count从0开始，那么第偶数条对角线向右上走，第奇数条对角线向左下走。</p>
<p><strong>起点和终点的确定：</strong></p>
<p>如果是一个<strong>无限大的矩阵</strong>，向右上走的对角线起点一定是(count, 0)，终点是(0, count)，每次只需让列号y+1，行号x−1，从起点到终点即可。向左下走的对角线也能容易推出起点和终点。</p>
<p>现在是一个<strong>m×n的矩阵</strong>，可以想象成无限大矩阵加上了行号约束0≤x≤n−1，列号约束0≤y≤m−1。</p>
<p><strong>以向右上走的对角线为例，对角线由于受到行号约束，被迫将行号为最大值m−1的点作为起点，根据对角线的性质可以算出列号为count−(m−1)，同理也可以计算出受到约束下对角线的终点坐标。</strong></p>
<p>代码里没有计算对角线的终点，而是直接把行号和列号约束作为while循环的条件，也可达到目的。</p>
<h3 id="代码及注释-6"><a href="#代码及注释-6" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mat==<span class="keyword">null</span>||mat.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> r=mat.length;</span><br><span class="line">        <span class="keyword">int</span> c=mat[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[r*c];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bound=r+c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;bound)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> r0=count&lt;r? count:r-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> c0=count&lt;r? <span class="number">0</span>:count-r+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(r0&gt;=<span class="number">0</span>&amp;&amp;c0&lt;c)&#123;</span><br><span class="line">                    res[k++]=mat[r0--][c0++];</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> r0=count&lt;c? <span class="number">0</span>:count-c+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> c0=count&lt;c? count:c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(c0&gt;=<span class="number">0</span>&amp;&amp;r0&lt;r)&#123;</span><br><span class="line">                    res[k++]=mat[r0++][c0--];</span><br><span class="line">                 &#125;</span><br><span class="line">                 count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/rotate-array/">主站-189. 旋转数组</a></strong></p>
<p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><p>k 对数组长度取余，因为旋转的长度有可能超过数组长度的</p>
<p>该方法基于如下的事实：当我们将数组的元素向右移动 k 次后，尾部 k  个元素会移动至数组头部，其余元素向后移动 k  个位置。</p>
<p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 k  个元素就被移至数组头部，然后我们再翻转 [0,k ] 区间的元素和 [k ,n−1]区间的元素即能得到最后的答案。</p>
<h3 id="代码及注释-7"><a href="#代码及注释-7" class="headerlink" title="代码及注释"></a>代码及注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       k=k%nums.length;</span><br><span class="line">       <span class="comment">//先将数组全部翻转[7,6,5,4,3,2,1]</span></span><br><span class="line">       reverse(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//将头部 k 个元素翻转[5,6,7,4,3,2,1]</span></span><br><span class="line">       reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//将尾部 len-k 个元素翻转[5,6,7,1,2,3,4]</span></span><br><span class="line">       reverse(nums,k,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//翻转数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[j];</span><br><span class="line">            nums[j]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历</title>
    <url>/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>从图中的某个顶点K出发，按照一定的原则（比如：总是先选择右边第一个点）先去访问它的邻接点，初始状态下K的邻接点未被访问过，按照这个原则找到它的一个未被访问过的邻接点，然后将该邻接点标记为“true”，表示该点已经被访问过。直到有一个顶点N，按照该原则下，它的邻接点已经被访问，则退回到N点，再去访问它右边第二个点，以此类推，直到所有的顶点都被访问到，遍历结束。</p>
<p>这里我们以邻接矩阵的方式来讲解DFS的算法执行流程：</p>
<p>​                              <img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/邻接矩阵.jpg" style="zoom: 80%;"></p>
<p><strong>题目中的思路：</strong>通过DFS递归，先朝一个方向搜索，当路径上遇到一个节点k+1不满足条件时，再回溯至上个节点，沿其它方向搜索，以此类推。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><blockquote>
<p><strong>Note：</strong>该代码不包含图的建立部分。其中，numVertexes为图中的节点数目，vexs[]数组为顶点表 ,arc[] []为边表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.numVertexes];<span class="comment">//创建visited[]数组，作为节点的访问标志</span></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="keyword">false</span>;<span class="comment">//初始化visited[]数组为false，表示初始状态下节点未被访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//从V0开始循环遍历树中的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//若节点Vi不为false，说明该节点未被访问过，调用DFS()方法。这里可以视为对边表的行遍历</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    visited[i]=<span class="keyword">true</span>;<span class="comment">//另visited数组中的第i个节点的标志位true，表示该节点已经被访问</span></span><br><span class="line">    System.out.println(G.vexs[i]);<span class="comment">//可以对该顶点进行输出等操作</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//i表示边表矩阵的第i行，当满足G.[i][j]!==1（表示节点j是i的邻接点）且                                                   //visited[j]==false未被访问，则对节点j再进行DFS递归</span></span><br><span class="line">        <span class="keyword">if</span>(G.[i][j]!==<span class="number">1</span>&amp;&amp;visited[j]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当图是<strong>连通图</strong>时，DFSTraverse（）方法中的循环执行一次就可以；</p>
<p>当图是<strong>非连通图</strong>时，需要对它的连通分量分别进行DFS遍历，当图中尚有顶点还有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直到图中所有的节点都被访问到为止。</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/number-of-islands/">热题100-200. 岛屿数量</a></strong></p>
<p>  给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>  岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。 </p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>通过dfs，遍历岛屿时将对应的1置为0，当一个岛屿的周围都是0，表示该岛屿已经遍历完成，返回将结果+1</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断岛屿数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid char字符型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=grid.length;</span><br><span class="line">        <span class="keyword">int</span> c=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i,j,r,c,grid);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i==r||j==c||grid[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(i+<span class="number">1</span>,j,r,c,grid);</span><br><span class="line">        dfs(i-<span class="number">1</span>,j,r,c,grid);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>,r,c,grid);</span><br><span class="line">        dfs(i,j-<span class="number">1</span>,r,c,grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">热题100-105. 从前序与中序遍历序列构造二叉树</a></strong></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>递推参数：根节点在前序遍历的索引root、子树在中序遍历的左边界left、子树在中序遍历的右边界right；</p>
</li>
<li><p>终止条件：当left&gt;right，代表已经越过叶节点，此时返回 null；</p>
</li>
<li><p>递推工作：</p>
<p>建立根节点 node ： 节点值为 preorder[root] ；</p>
<p>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；（主要根据中序遍历找到左子树的节点数，进而在前序中找到右子树的根节点，这里中序遍历中的右下标主要用于判断是否越界）</p>
<p>可以理解为递归函数每次传入的都是子树的根节点、该子树在中序遍历中的左右边界，并且通过每次的root、left和right进一步在中序遍历中的索引找到左子树、右子树以及左右子树的根节点，每次先判断，当left&gt;right时，要么是没有左子树了，要么是没有右子树了，递归结束，否则对该根节点的左右子树继续递归构建。</p>
</li>
</ul>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; in_Map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.preorder=preorder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">        in_Map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consutruct(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">consutruct</span><span class="params">(<span class="keyword">int</span> root_pos,<span class="keyword">int</span> in_left,<span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left&gt;in_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[root_pos]);</span><br><span class="line">        <span class="keyword">int</span> in_pos=in_Map.get(preorder[root_pos]);</span><br><span class="line">        root.left=consutruct(root_pos+<span class="number">1</span>,in_left,in_pos-<span class="number">1</span>);</span><br><span class="line">        root.right=consutruct(root_pos+in_pos-in_left+<span class="number">1</span>,in_pos+<span class="number">1</span>,in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">热题100-104. 二叉树的最大深度</a></strong></p>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>递归到叶子结点，当root为空时返回0；</li>
<li>接收左右子树的返回值，也就是左右子树的最大深度</li>
<li>返回值为取左右子树的最大深度+1，表示该节点的最大深度</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_depth=maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth=maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left_depth,right_depth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">剑指 Offer-55 - II. 平衡二叉树</a></strong></p>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>通过treeDepth方法递归的得到二叉树中每个节点的深度</li>
<li>对于root节点：</li>
<li>当其为null时，超出了叶子结点，返回0</li>
<li>递归左子树，得到左子树深度</li>
<li>递归右子树，得到右子树深度</li>
<li>判断两边子树的深度差，当大于1时，返回-1</li>
</ul>
<blockquote>
<p><strong>剪枝：</strong>为了减少递归次数，当我们发现有一边的子树返回值为-1时，就直接返回-1，那么这棵树就不是平衡二叉树</p>
</blockquote>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> treeDepth(root)==-<span class="number">1</span>? <span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_depth=treeDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left_depth==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right_depth=treeDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right_depth==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left_depth-right_depth)&gt;<span class="number">1</span>? -<span class="number">1</span>:Math.max(left_depth,right_depth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer-面试题34. 二叉树中和为某一值的路径</a></strong></p>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>pathSum(root, sum) 函数：</strong></p>
<ul>
<li>初始化： 结果列表 res ，路径列表 temp 。</li>
<li>返回值： 返回 res 即可。</li>
</ul>
<p><strong>dfs(root,sum,temp,res)函数：</strong></p>
<ul>
<li>递推参数： 当前节点 root ，当前目标值 target，路径temp，结果集res。</li>
<li>终止条件： 若节点 root 为空，则直接返回。</li>
<li><strong>递推工作：</strong><pre><code>路径更新： 将当前节点值 root.val 加入路径 temp ；
目标值更新： target-=root.val（即目标值 tar 从 sum 减至 0 ）；
路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。**在记录完数据之后，不能立即返回，要将当前节点从路径 path 中删除，即执行 temp.remove(temp.size()-1)**
先序遍历： 递归左 / 右子节点。
路径恢复： 向上回溯前，需要将当前节点从路径 path 中删除，即执行  temp.remove(temp.size()-1)。</code></pre>
</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum (TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(root,sum,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; temp,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target-=root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,target,temp,res);</span><br><span class="line">        dfs(root.right,target,temp,res);</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/f31fc6d3caf24e7f8b4deb5cd9b5fa97?tpId=190&tqId=35223&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-判断一棵树是否为搜索二叉树和完全二叉树</a></strong></p>
<p>给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>搜索二叉树判定实现：</strong>搜索二叉树的中序遍历结果是严格递增的，因为左子树&lt;根节点&lt;右子树</p>
<ul>
<li>当根节点为null时，返回true</li>
<li>接收左子树递归的返回条件</li>
<li>左子树返回值为false直接返回false</li>
<li>用pre来作为中序遍历的前驱节点，每次遍历完当前节点的左子树后判断当前节点的值与pre的大小关系，只要当前节点的值小于pre，就返回false，否则将该节点作为下一节点的前驱节点再去做判断</li>
<li>接收右子树递归的返回条件</li>
<li>左子树返回值为false直接返回false</li>
<li>当两边的返回值都不为false，返回true</li>
</ul>
<blockquote>
<p><strong>Note：</strong>这里将pre的值设为Long.MIN_VALUE，原因是题目的val都是int，使用long为了满足在最左节点是INT_MIN的时候，也不会判断为false</p>
</blockquote>
<p><strong>完全二叉树判定实现：</strong>完全二叉树，层次遍历遇到第一个空节点后，剩余节点还有非空，则一定不是，巧用<code>continue</code>并配合标志位。</p>
<ul>
<li>当标志位为false时，循环中不断将队列头部元素取出，并将左右子树加入到队列中</li>
<li>当某一节点为null时，将标志位置为true，进入下一次循环</li>
<li><strong>当剩余节点有值不为null时，因为flag此时为true，所以直接就会触发if语句返回false</strong></li>
<li>否则循环结束，没有节点不为null了，返回true</li>
</ul>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> pre=Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] judgeIt (TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;dfs1(root),dfs2(root)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs1</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=dfs1(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root.val;</span><br><span class="line">        <span class="keyword">boolean</span> right=dfs1(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            dq.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            TreeNode node=dq.poll();</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.add(node.left);</span><br><span class="line">            dq.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/symmetric-tree/">热题100-101. 对称二叉树</a></strong></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一个前序遍历，一个后序遍历</li>
<li>当节点不同时，或者有一边返回false时，返回false</li>
<li>当左右子树都为true，且节点值相同时，返回true</li>
</ul>
<h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricImpl(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricImpl</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>||root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=isSymmetricImpl(root1.left,root2.right);</span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> right=isSymmetricImpl(root1.right,root2.left);</span><br><span class="line">        <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=190&tqId=35182&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-二叉树中是否存在指定和的路径</strong></a></p>
<p>给定一个二叉树和一个值 sum，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>与**<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer-面试题34. 二叉树中和为某一值的路径</a>**解法类似，不做介绍</p>
<h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;sum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum)||hasPathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解九"><a href="#题解九" class="headerlink" title="题解九"></a>题解九</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/7a71a88cdf294ce6bdf54c899be967a2?tpId=190&tqId=36044&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-矩阵最长递增路径</a></strong></p>
<p>  给定一个矩阵，矩阵内所有数均为非负整数。 </p>
<p>  求一条路径，该路径上所有数是递增的。 </p>
<p>  这个路径必须满足以下条件： </p>
<p>  1、对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外。 </p>
<p>  2、你不能走重复的单元格。即每个格子最多只能走一次。</p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>在solve方法中，通过for循环依次以矩阵中的每个元素为起始点开启dfs</p>
</li>
<li><p><strong>在dfs中的递归流程：</strong></p>
<p>当元素越界、或者小于等于前驱元素时，表示这条路径递归结束，返回0；</p>
<p>依次去递归上、下、左、右四个方向，递归结束，取四个方向最长的路径，加上该元素的1个长度，返回。</p>
</li>
</ul>
<h3 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 递增路径的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix int整型二维数组 描述矩阵的每个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                maxLength=Math.max(maxLength,dfs(i,j,r,c,-<span class="number">1</span>,matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> pre,<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i==r||j==c||matrix[i][j]&lt;=pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k1=dfs(i+<span class="number">1</span>,j,r,c,matrix[i][j],matrix);</span><br><span class="line">        <span class="keyword">int</span> k2=dfs(i-<span class="number">1</span>,j,r,c,matrix[i][j],matrix);</span><br><span class="line">        <span class="keyword">int</span> k3=dfs(i,j+<span class="number">1</span>,r,c,matrix[i][j],matrix);</span><br><span class="line">        <span class="keyword">int</span> k4=dfs(i,j-<span class="number">1</span>,r,c,matrix[i][j],matrix);</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(k1,k2),Math.max(k3,k4))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题解十"><a href="#题解十" class="headerlink" title="题解十"></a>题解十</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer-12. 矩阵中的路径</a></strong></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
</blockquote>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>首先，在矩阵中任选一个节点，作为一条path的起点；</p>
</li>
<li><p>然后，通过DFS以该节点作为起始点，开始递归。递归的结束结果有两种可能：</p>
<p>1、返回false：说明在递归的过程中，存在一个节点（r，c）假设它对应的字符串中第k个字符值，它的四个相邻的格子（r-1，c）（r+1，c）（r，c-1）（r，c+1）都找不到字符串的下一个字符值（k+1）；</p>
<p>2、返回true：如上图所示，从A点开始，到B、C、C、E每个点总有一个方向的字符值能和给定的字符串的下一个字符值相等，则递归结束，可以看出递归成功结束的条件是已经在矩阵中找到了与给定的字符串所有的字符。</p>
</li>
<li><p>最后，循环结束说明矩阵中没有该路径，返回false。</p>
</li>
</ul>
<img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/矩阵.png" style="zoom:80%;">

<h3 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words=word.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;board.length;r++)&#123;<span class="comment">//以矩阵的第一行为起始行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;board[<span class="number">0</span>].length;c++)&#123;<span class="comment">//以矩阵的第一列为起始列，依次以每个格子作为起始点，开启DFS遍历</span></span><br><span class="line">            <span class="keyword">if</span>(DFS(board,words,r,c,<span class="number">0</span>))&#123;<span class="comment">//每次传入的参数就是board、words、起始点坐标、字符串起始点0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//当找到对应路径，返回true，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//找不到对应的路径，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>||r&gt;board.length-<span class="number">1</span>||c&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||board[r][c]!=words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*递归的结束条件：</span></span><br><span class="line"><span class="comment">                       1、越界 r&lt;0||c&lt;0||r&gt;board.length-1||c&gt;board[0].length-1</span></span><br><span class="line"><span class="comment">                       2、矩阵的网格字符值与字符串的字符值不同 board[r][c]!=words[k]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//该行表示递归成功的出口</span></span><br><span class="line">        board[r][c]=<span class="string">&#x27; &#x27;</span>;<span class="comment">//每当一个网格字符值满足条件，将该值置为空值，防止二次访问</span></span><br><span class="line">        <span class="keyword">boolean</span> res=DFS(board,words,r+<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r-<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r,c+<span class="number">1</span>,k+<span class="number">1</span>)||DFS(board,words,r,c-<span class="number">1</span>,k+<span class="number">1</span>);<span class="comment">//每当访问到一个网格，对它的上下左右四个方向递归，只要有一个方向满足条件即可，当四个方向都返回false，说明此路不通，换下一个方向或者重新选择起始点</span></span><br><span class="line">        board[r][c]=words[k];<span class="comment">//当一个格点四个方向的邻接点都不合要求，将该网格值还原</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//返回递归结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/target-sum/">热题100-494. 目标和</a></strong></p>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
</blockquote>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码及注解-10"><a href="#代码及注解-10" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    dfs(nums,S,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        dfs(nums,target+nums[index],index+<span class="number">1</span>);</span><br><span class="line">        dfs(nums,target-nums[index],index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目十二"><a href="#题目十二" class="headerlink" title="题目十二"></a>题目十二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer-13. 机器人的运动范围</a></strong></p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
</blockquote>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题属于二维矩阵的搜索问题，考虑使用<strong>深度优先遍历（DFS）</strong>的方法。也就是暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。本题中一个优化是不用对一个格子的四个方向都递归，只需要对右、下两个方向递归即可，所有的能够进入的格子都能通过它的左边或上边的格子达到。</p>
<img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/GitHub\MyBlogs\source\_posts\2021-01-25-剑指offer-13\图片.png" style="zoom:80%;">

<p>我们可以通过上图来模拟DFS的执行流程：</p>
<blockquote>
<p><strong>Note：</strong>引入一个二维矩阵flag[] []来作为每个网格是否访问的标志</p>
</blockquote>
<p>机器人从（0,0）点出发，将flag[0] [0]记为true表示已经被访问过，向右递归，先判断（0,1）<code>1、网格是否越界 2、是否能进入 3、是否已经被访问过</code>，然后再从（0,1）点向右递归（这就是常说的向一个方向递归），依次类推，当到（0,2）时，经过判断不能进入（0,3）号格子，然后退回到（0,2）号格子，再向下递归，依次类推（这就是所说的该方向到底后，回溯到上一个节点沿另一个方向搜索）。</p>
<h3 id="代码及注解-11"><a href="#代码及注解-11" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">this</span>.m=m;</span><br><span class="line">    <span class="keyword">this</span>.n=n;</span><br><span class="line">    <span class="keyword">this</span>.k=k;</span><br><span class="line">    <span class="keyword">return</span> total(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||c&gt;=n||(r / <span class="number">10</span> + r % <span class="number">10</span> + c / <span class="number">10</span> + c % <span class="number">10</span> )&gt; k||flag[r][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        flag[r][c]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+total(r,c+<span class="number">1</span>)+total(r+<span class="number">1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串解码</title>
      <link href="2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-394/"/>
      <url>2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-394/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/decode-string">https://leetcode-cn.com/problems/decode-string</a></p></blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote><p>这道题我看到总结的比较好的一句话：数字放在数字栈，字符串放在字符串栈，右括号弹出一个数字栈中的数字，字符串栈弹到0为止。</p></blockquote><p>在遍历一个编码字符串时我们遇到的字符有以下几种情况：（数字栈：nums         字符串栈：ss）</p><p>数字——括号内字符串的重复次数</p><p>普通字母——拼接到res中</p><p>左括号’[‘——当我们遇到左括号时：</p><ul><li>先将存储数字的变量num加入数字栈nums中</li><li>说明括号内的字符串要重复num次，然后与括号外面的字符串拼接，因此我们先将左括号左边的res转换成字符串压入字符串栈ss中</li><li>另res和数字num重新计数（因为括号中还可能套括号，比如a3[a2[c]]，就是先将最外层的res=a存到字符串栈ss中，数字num=3存到数字栈nums中，将res和num置零后，再将第一层括号的res=a存到字符串栈ss中，数字num=2存到数字栈nums中）</li></ul><p>右括号’]’——当我们遇到右括号时：（说明最内层字符串记录结束，存于res中）</p><ul><li>从数字栈nums中弹出栈顶的数字，这个数就是这一层括号前面记录重复次数的数字，将res中的字符串重复curnum次，存到StringBuilder类型的temp中</li><li>再弹出一个ss栈顶的字符串，这个字符串就是括号之前的字符串，将它与temp拼接起来，再用res保存，用于遇到下一个右括号时，这个res就是该括号内要重复的字符串（比如a3[a2[c]]，当遇到第一个右括号时，将数字栈中的2弹出，将res=c循环拼接3次，也就是拼成temp=cc，再将字符串栈ss中的a弹出，与temp拼接成res=acc，之后遇到第二个右括号，temp=accaccacc，再与a拼接成res=aaccaccacc）</li></ul><p>最后编码字符串遍历结束，返回res</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      LinkedList&lt;Integer&gt; nums=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      LinkedList&lt;String&gt; ss=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">          <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">              num=num*<span class="number">10</span>+Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">             nums.add(num);</span><br><span class="line">             ss.add(res.toString());</span><br><span class="line">             res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">             num=<span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">             StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">             <span class="keyword">int</span> curNum = nums.removeLast();</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curNum; i++) &#123;</span><br><span class="line">                 temp.append(res);</span><br><span class="line">             &#125;</span><br><span class="line">             res = <span class="keyword">new</span> StringBuilder(ss.removeLast() + temp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              res.append(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode热题100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日温度</title>
      <link href="2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-739/"/>
      <url>2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-739/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a></p></blockquote><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><blockquote><p><strong>提示：</strong>气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p></blockquote><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>这个题我们需要借助<strong>递减栈</strong></p><p>当给定数组为： [73, 74, 75, 71, 69, 72, 76, 73]时，我们来模拟函数的运行过程</p><p>遍历数组（入栈操作时我们加入栈的是<strong>元素的下标</strong>，这样我们后面能够根据弹出的元素下标填入等待的天数）</p><p>元素73对应的下标压入栈中，</p><p>元素74，这时栈不为空，要用74跟栈顶的元素来比较，当它大于栈顶的元素时，要将栈顶的元素弹出，并且将此时的元素下标x减去弹出元素的index就是该位置的温度再等几天能够观测到更高温，这里弹出73，将2-1=1加入res数组中下标0的位置，</p><p>元素75，同元素74，</p><p>元素71，小于栈顶元素75，直接压入栈中，</p><p>元素69，同元素71，</p><p>元素72，大于69，弹出69，并将5-4=1填入res数组下标4对应的位置，大于71，将71弹出，将5-3=2填入res数组下标3对应位置，小于75，循环结束，将72压入栈中，</p><p>然后以此类推……</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">           <span class="keyword">int</span> index=stack.pop();</span><br><span class="line">           res[index]=i-index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode热题100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值的整数次方</title>
      <link href="2021/02/04/%E5%89%91%E6%8C%87offer-16/"/>
      <url>2021/02/04/%E5%89%91%E6%8C%87offer-16/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p></blockquote><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote><p>本题的重点在于理解<strong>“快速幂法”</strong>为什么能把时间复杂度降低到<strong>log2n</strong></p></blockquote><p>求 x^n最简单的方法是通过循环将 n 个 x 乘起来，依次求x^1, x^2, …, x^{n-1}，直到求出x^n时间复杂度为 O(n) 。例如我们输入的幂次exponent为32，我们要求base的32次方就要在程序中对base乘31次。但是如果我们通过base的2次方求base的4次方接着求base的8次方，16次方，32次方，这样就能将循环次数降为对数级。我们可以通过以下公式来求得a的n次方：</p><p>我们设循环中的变量为i，初始值为n</p><p><strong>当i=n时：</strong><br>$$<br>{a^i} =<br>        \begin{cases}<br>        {a^{i/2}}·{a^{i/2}}    &amp; \text{如果 $i$ 为偶数}\<br>        {a^{i/2}}·{a^{i/2}}·a  &amp; \text{如果 $i$ 为奇数}<br>        \end{cases}<br>$$<br><strong>当i=n/2时：</strong>仍然按照上面的公式判断i的奇偶，求得a的i次方……</p><p>通过一个for循环，每次将幂次除以2，最终可以以O(log2n)的时间复杂度求得a的n次方，因为2^x=n,x=log2n,也就是循环x=log2n次。</p><blockquote><p>理解了快速幂法之后，下面是解题的流程：</p></blockquote><ul><li>当底数为0时没有意义，直接返回</li><li>当指数为负数时，将底数变为1/x，负数变为正数（转换成了常规的指数为正数的情况）</li><li>当指数为正数时，按照上面的公式求解</li></ul><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b=n;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b=-b;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码中有两处注意点：</strong></p></blockquote><ol><li>用long类型的b去暂存n的值，因为int类型的负数范围比正数大1，这样做为了防止另n=-n时溢出</li><li>用指数的二进制形式来判断奇偶，并用移位来代替幂次每循环一次除以2，能够提高运算效率</li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串转换成整数</title>
      <link href="2021/02/04/%E5%89%91%E6%8C%87offer-67/"/>
      <url>2021/02/04/%E5%89%91%E6%8C%87offer-67/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p></blockquote><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><blockquote><p><strong>注意：</strong>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p><strong>说明：</strong></p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>当我们遍历给定的字符串时，当前的字符串有下面几种可能：</p><ul><li><p><strong>空格</strong>——跳过</p></li><li><p><strong>其它字符</strong>——循环遍历结束</p></li><li><p><strong>正负号</strong>——存储到flag变量中，后面再拼接到结果中</p></li><li><p><strong>数字字符：</strong></p><p>对数字字符要进行转换和拼接工作</p><p><strong>转换：</strong>将数字字符减去字符’0’，得到数字的值</p><p><strong>拼接：</strong>前一位得到的数字应该在高位，所以拼接公式为*<em>res=res</em>10+c**</p></li></ul><p>在对数字进行拼接工作时，要<strong>预判</strong>得到的结果是不是发生了越界，之所以要进行预判是因为得到的结果可能很大，不能确定用什么样类型的变量来接收这个结果。Java中int类型的数值范围为 [−231,  231 − 1]，也就是<strong>2147483647</strong>，要在进行本轮的拼接时，判断结果是否会发生越界，也就是上一轮的结果要小于<strong>214748364</strong>或者等于<strong>214748364</strong>且本轮的数值<strong>c</strong>小于等于7，这样按照公式*<em>res=res</em>10+c**拼接时才不会发生越界，当出现越界时直接返回题目要求的结果。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bndry = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;<span class="comment">//定位第一个非空格字符</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span>(str.charAt(first)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//去除多余的空格</span></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span>(first==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>) flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>||str.charAt(first)==<span class="string">&#x27;+&#x27;</span>) first++;<span class="comment">//如果第一个非空格字符为正负号时，保存到flag，且first++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;str.length();i++)&#123;<span class="comment">//拼接数字字符</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">&#x27;0&#x27;</span>||str.charAt(i)&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//遇到非数字字符，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;bndry||(res==bndry&amp;&amp;str.charAt(i)&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;<span class="comment">//预判结果是否越界</span></span><br><span class="line">            <span class="keyword">return</span> flag==<span class="number">1</span>? Integer.MAX_VALUE : Integer.MIN_VALUE;&#125;</span><br><span class="line">        res=res*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不越界的情况下，拼接数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p><strong>堆：</strong>通常可以看成是一个完全二叉树的<strong>数组</strong>。（堆排序实际上是堆中元素的交换，因此可以用数组实现，并且数组的查询和修改效率比较高，能够提高性能）</p><p><strong>堆的两种形式：</strong></p><ul><li>大顶堆：根节点<strong>大于</strong>左右孩子的节点</li><li>小顶堆：根节点<strong>小于</strong>左右孩子的节点</li></ul><p><strong>1、二叉树堆结构中元素与数组堆结构中元素的对应关系：</strong>（大小顶堆一样的）</p><img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片.png" style="zoom:150%;"><img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:150%;"><p>那么对于某一个节点index，它的左右孩子在数组中的下标分别为：</p><ul><li>Left=index*2+1</li><li>Right=index*2+2</li></ul><p>叶子结点和非叶子节点的区别：</p><ul><li>非叶子节点的下标&lt;节点个数/2-1</li><li>叶子节点的下标&gt;节点个数/2-1</li></ul><p><strong>2、大顶堆的维护（核心）</strong></p><p><strong>自下而上</strong>地维护一个大顶堆，使其满足大顶堆的性质：非叶子节点的左右孩子都小于它的根节点</p><p>维护分为初始化时大顶堆的维护和初始化后大顶堆的维护：</p><ul><li>刚开始将待排序数组中的前k个元素复制到堆结构中的数组中，并调用HeapAdjust（）方法，<strong>从非叶子节点开始，自下而上地维护</strong>；</li><li>而对于新插入的剩下的n-k个元素，只有当元素小于大顶堆的根节点时，才会移除根节点，并将该元素加入大顶堆。因此除了0号元素可能不满足大顶堆的性质外，它的下层的非叶子节点都满足性质，所以<strong>维护的实质是：</strong>维护index=0的情况。</li></ul><h1 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] input = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        result = HeapSort(input, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">            System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用数组来模拟k个节点的堆结构</span></span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, a, <span class="number">0</span>, k);<span class="comment">//初始化堆中的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//k就是我们要维护的堆结构的节点下标</span></span><br><span class="line">            HeapAdjust(i, a, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;<span class="comment">//遍历剩余的n-k个元素</span></span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; a[<span class="number">0</span>]) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = input[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, a, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将大顶堆中的元素进行升序操作</span></span><br><span class="line"><span class="comment">//        for (int i = a.length - 1; i &gt; 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//            //分为两个过程：1.交换 2.通过减小节点的个数来固定最大的元素</span></span><br><span class="line"><span class="comment">//            int temp = a[i];</span></span><br><span class="line"><span class="comment">//            a[i] = a[0];</span></span><br><span class="line"><span class="comment">//            a[0] = temp;</span></span><br><span class="line"><span class="comment">//            HeapAdjust(0, a, i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数功能就是维护每一个节点的大顶堆性质</span></span><br><span class="line"><span class="comment">    index 节点的下标</span></span><br><span class="line"><span class="comment">    a 堆结构</span></span><br><span class="line"><span class="comment">    length 堆结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];<span class="comment">//temp保存当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt; a[x]) &#123;<span class="comment">//取出当前节点的左右孩子的最大值</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;<span class="comment">//更新index的值，index代表的是temp的值最终在堆中的位置，index和x的关系其实就是根节点和子节点的关系</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//由于我们是从下往上维护的，当index=0的节点满足性质后，就没有更新的必要了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;<span class="comment">//index代表的是temp的值最终在堆中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码运行的结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">40 30 20 10 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><p>堆排序用于解决<strong>TOPK</strong>类问题</p><blockquote><p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p><p>这里还对代码进行了优化，不用建立新数组，用给定数组直接作为堆结构数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, nums, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, nums, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &lt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &lt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof"><strong>剑指offer-40.最小的K个数</strong></a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, arr, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, arr, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,res,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的中序遍历</title>
      <link href="2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-94/"/>
      <url>2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-94/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p></blockquote><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p><strong>中序遍历：</strong>先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</p><p><strong>核心就是：</strong>根节点必须在左节点弹出之后，再弹出</p><p><strong>方法一：</strong>递归遍历</p><p><strong>方法二：</strong>辅助栈法（非递归遍历）</p><p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后<strong>先遍历左子树</strong>，接着访问 A（A出栈），最后遍历右子树。这样保证根节点在左子树后面被访问，右子树在根节点后面被访问。</p><p>在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote><p><strong>方法一：</strong>递归遍历</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法二：</strong>辅助栈法（非递归遍历）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;<span class="comment">//1.root!=null 2.root==null但辅助栈中有元素，对应左子树访问完</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;<span class="comment">//每到一个节点，先去遍历左子树，只要它的左子树存在，就将该节点压入栈，直到有一个节点的左                                   //子树不存在为止，也就是它就是最左边的节点</span></span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();<span class="comment">//1.root!=null表示到了最左边的节点，弹出栈访问</span></span><br><span class="line">                             <span class="comment">//2.root==null但辅助栈中有元素，对应左子树访问完,也就是上一轮的root.right==null，此时的栈                              //顶元素就对应的该左子树的根节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;<span class="comment">//访问该节点的右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode热题100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的括号</title>
      <link href="2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-20/"/>
      <url>2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-20/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p></blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>分析题目可知，指针的指向实际上有两种情况：</p><ul><li>指向的字符为左括号</li><li>指向的字符为右括号</li></ul><p>要将所有的括号配对，也就是我们遇到左括号时，并不知道有没有右括号与之对应，因此先将左括号存储到一个栈中，并且遇到右括号时要将容器中对应的左括号出栈，最后栈中没有元素时，说明配对成功，返回true。</p><p><strong>改进：</strong>可以遇到左括号时将相应的右括号入栈，这样可以在遇到右括号时，只需要判断是否相等即可</p><p>在程序中，只要遇到不满足条件的情况，提前结束循环，返回false。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="comment">//该情况对应于栈为空，但是来了一个右括号的情况，或者不相等的情况，                                                     //直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode热题100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小栈</title>
      <link href="2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/"/>
      <url>2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a></p></blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br></pre></td></tr></table></figure><blockquote><p>Java中的栈推荐用Deque双端队列来实现，效率比Stack 要高，其相关函数有：</p></blockquote><p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E6%96%B9%E6%B3%95.png"></p><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的难点在于将min函数从O（n）降为O（1），要得到栈A中的最小值首先想到的是用一个成员变量min来保存这个最小值，但是当栈中的该值弹出时，就没有办法得到次小值，因此仅用一个成员变量是不够的。</p><p>所以想到使用辅助栈B，将最小元素（置于栈顶）和次小元素都存储起来，使其非严格降序，每次栈A中弹出元素都要跟B栈中的栈顶元素值比较，若相等则使用pop（）函数弹出，否则不执行弹出。查看最小元素时使用peek（）函数。<a href="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png">如图所示：</a></p><p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E5%9B%BE%E7%89%87.png"></p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A;</span><br><span class="line">    Deque&lt;Integer&gt; B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    B=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty() || B.peek() &gt;= x)<span class="comment">//B.empty（）对应最开始或者后面B栈中没有元素时，新压入的元素就是最小值要压入B中，当B中有元素时，新压入A栈的元素要与B中的元素比较，如果小于等于就压入B，这里等于号=很重要，因为当A栈中两个2相连压入时，就要在B中也有两个2对应，否则A中一个2弹出，也会将B中2弹出，这样会造成查询到的最小值不等于2。</span></span><br><span class="line">            B.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))&#123;<span class="comment">//判断A中弹出的值与B中栈顶的值（最小值）是否相等，若相等也将B中栈顶元素弹出。</span></span><br><span class="line">                                     <span class="comment">//因为栈中存储的是int的包装类Integer，因此只能用equals()方法，不能用“==”</span></span><br><span class="line">        B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode热题100 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假期的阶段性总结</title>
      <link href="2021/01/31/%E5%81%87%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>2021/01/31/%E5%81%87%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><p>研二的假期比往常来的稍早那么一些，回家的第二十一天，这段时间的学习效率是大打折扣，算是刚刚连抄带蒙地“刷完了”《剑指offer》里面的困难题暂时不准备刷，一部分因为懒，一部分因为菜。我属于是那种将就起来就会放飞自我的人哈哈，还是要梳理一下自己的进度，正视问题刺激一下自己才行。</p><h1 id="·-刷题方面"><a href="#·-刷题方面" class="headerlink" title="· 刷题方面"></a>· 刷题方面</h1><p>《剑指offer》刷完，共69道题，后面刷的一部分题勉强写了点题解：</p><p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-29/#more">顺时针打印矩阵</a></p><p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-49/#more">丑数</a></p><p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-38/#more">字符串的排列</a></p><p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-66/#more">构建乘积数组</a></p><p><a href="https://eudemonia.tech/2021/01/27/%E5%89%91%E6%8C%87offer-45/#more">把数组排成最小的数</a></p><p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-13/#more">机器人的运动范围</a></p><p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-04/#more">二维数组中的查找</a></p><p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">扑克牌中的顺子</a></p><p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">矩阵中的路径</a></p><p><a href="https://eudemonia.tech/2021/01/19/%E5%89%91%E6%8C%87offer-34/#more">二叉树中和为某一值的路径</a></p><p>前面的题解以word文档的形式保存了，那时候还没有这个博客，后面打算二刷剑指的时候补齐。</p><p>下面开始刷LeetCode热题100，还是每天两道，坚持写题解，头年再刷二十道左右。</p><h1 id="·-校园商城项目"><a href="#·-校园商城项目" class="headerlink" title="· 校园商城项目"></a>· 校园商城项目</h1><p>慕课看到了第四章的商铺注册也就是前端的页面设计部分，还在项目1.0版本，用的是SSM框架，后面大体结构搭建起来了，但是很多细节自己并不清楚，打算再看看后面做的过程中对项目的理解情况，不行真得从头再刷一遍，有篇文章值得看一看，对项目整理架构的理解有帮助，<a href="https://www.jb51.net/article/127829.htm">点这里查看</a>。</p><p>每天晚上的时间都用来搞这个，进度要赶一赶了，年前争取项目1.0这块做的差不多了得。</p><h1 id="·-计算机网络"><a href="#·-计算机网络" class="headerlink" title="· 计算机网络"></a>· 计算机网络</h1><p>按照大佬的学习路线看王道考研视频，看完了传输层的部分，打算看完了这块之后开始结合面经学习。大佬说这个考研视频讲的偏重于前面的部分，实际面经中考点在后面的部分。</p><p>最多两天看完，打算用这部分时间写写论文，之后再背面经。</p><h1 id="·-GitHub个人博客"><a href="#·-GitHub个人博客" class="headerlink" title="· GitHub个人博客"></a>· GitHub个人博客</h1><p>大概一周的时间，自己学着做了一个个人博客，想写点东西，当个自己的学习笔记，或者是生活日记什么的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丑数</title>
      <link href="2021/01/28/%E5%89%91%E6%8C%87offer-49/"/>
      <url>2021/01/28/%E5%89%91%E6%8C%87offer-49/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p></blockquote><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote><p>解题思路参考于：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></p><p>下面那个评论中的小伙伴解释的特别好！</p></blockquote><p>根据丑数的定义，我们可以得到<strong>丑数的递推性质</strong>：新的丑数可以由现有的丑数序列（排好序）乘以2、3、5得到。</p><p>在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, …, n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，</p><p>比如如果按照这样的顺序排列下去肯定有问题[1<em>2, 1</em>3, 1<em>5, 2</em>2, 2<em>3, 2</em>5, 3<em>2, 3</em>3, 3<em>5, … , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3</em> 3, n2 *  5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面，  后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。</p><p>关键在于怎么让得到的丑数序列是有序的，我们知道当序列中已经有n个丑数的情况下，后面的丑数是由现有序列中的丑数乘以2、3、5得来的，我们要先取得到的丑数中的最小值作为第n+1个丑数，这个丑数有可能是：</p><ul><li>前面序列中第M1个丑数乘以2</li><li>前面序列中第M2个丑数乘以3</li><li>前面序列中第M3个丑数乘以5</li></ul><p>也就是说，我们要取这三种途径中值最小的那个数，这个值就是新得到的丑数中的最小值。为保证每个数都能与2,3,5相乘，我们可以通过设置3个索引a, b, c，分别记录当前位置的丑数有没有与2,3,5相乘，每次循环通过以a,b,c为索引乘以相应的2,3,5得到新的丑数，取这三种途径的最小值。</p><p>我们模拟丑数序列的产生过程，<strong>重点是a,b,c分别指示该位置的丑数是不是已经与2,3,5相乘：</strong></p><img src="/2021/01/28/%E5%89%91%E6%8C%87offer-49/图片.png" style="zoom:80%;"><p>对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道），  第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2，  第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。</p><p>求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5，  通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第  b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b  个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;</p><p>但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5，  说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数,  只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if,  这样才不会把应该加一的计数器漏掉</p><p>经过n次循环，就能得到第n 个丑数了。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">// 使用dp数组来存储丑数序列</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// dp[0]已知为1</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;    <span class="comment">// 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数</span></span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2)&#123;</span><br><span class="line">                a++; <span class="comment">// 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3)&#123;</span><br><span class="line">                b++; <span class="comment">// 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5)&#123;</span><br><span class="line">                c++; <span class="comment">// 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><blockquote><p><strong>参考文章：</strong><a href="https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack">https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack</a></p><p>字节大佬的文章写得特别棒，很实用！</p></blockquote><p>回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于<code>全排列</code>，穷尽所有可能。时间复杂度一般 O(N!)，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p><strong>核心思想：</strong>就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(选择列表，路径)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">       result.add(路径);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(选择 in 选择列表)&#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtrack(选择列表,路径);</span><br><span class="line">        撤销选择;<span class="comment">//递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>题型一：</strong>给定一个可包含重复元素的序列，返回所有不重复的全排列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note：</strong>过滤条件中一定是没有访问过，例如：[a,b,c,c,d]这种情况，当第一个c被标记为true，调用递归函数时，再遍历到第四个c时，当去判断时，如果判断条件没有加上没有被访问过时，第四个c就会被跳过，而且是一直被跳过，会导致路径无法满足长度，没有结果输出，其实这个条件过滤的是两个c在同一选择列表的情况，当两个c一个被固定时，就不在同一选择列表内，也就不用再过滤。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的排列</title>
      <link href="2021/01/28/%E5%89%91%E6%8C%87offer-38/"/>
      <url>2021/01/28/%E5%89%91%E6%8C%87offer-38/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p></blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>我们把一个字符串看成是由<strong>两部分</strong>组成：</p><ul><li>第一部分是它的第一个字符；</li><li>第二部分是后面的所有字符；</li></ul><p>这里也体现的是<a href="https://eudemonia.tech/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#more">回溯法</a>的思想：</p><ol><li>首先所有的字符都有可能出现在第一个位置，则循环另所有的元素都轮流作为第一个元素，</li><li>然后固定完第一个元素后，剩下的n-1个元素都有可能出现在第二个位置，此时的选择列表为剩下的n-1个元素，</li><li>固定完第二个元素之后，剩下的n-2个元素再作为选择列表去枚举第三个位置，以此类推，直到临时路径的长度等于给定数组长度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建乘积数组</title>
      <link href="2021/01/28/%E5%89%91%E6%8C%87offer-66/"/>
      <url>2021/01/28/%E5%89%91%E6%8C%87offer-66/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof</a></p></blockquote><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>方法一：暴力解法，每次用连乘n-1个数字的方法得到B[i]。但是这种方法的时间复杂度为O(n^2)。</p><p>方法二：通过分析乘积数组的特点，即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]，定义C[i]=A[0]×A[1]×…×A[i-1]，D[i]=A[i+1]×…×A[n-1]，也就是B[i]可以分成两部分C[i]和D[i]的乘积，如图所示：</p><p><img src="/2021/01/28/%E5%89%91%E6%8C%87offer-66/2021-01-28-%E5%89%91%E6%8C%87offer-66%5C%E5%9B%BE%E7%89%87.jpg"></p><p>而C[i]和D[i]可以分别通过两次循环得到，这种做法的时间复杂度为O(n)。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把数组排成最小的数</title>
      <link href="2021/01/27/%E5%89%91%E6%8C%87offer-45/"/>
      <url>2021/01/27/%E5%89%91%E6%8C%87offer-45/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p></blockquote><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>将数组排成最小的数，我们最直观的想法是小数在前，大数在后，但是这样的排序组成的数组不一定是最小的数字，例如：10,9，这两个数字组成的最小数字应该是109而不是910。因此需要定义一种排序规则，使组成的数字最小。</p><p>若我们另两个数字为a，b，两个数字的组合有三种情况：</p><ol><li>当ab&gt;ba时，我们定义b应该在前；</li><li>当ba&gt;ab时，我们定义a应该在前；</li><li>当ab=ba时，两数相同，谁在前都可以。</li></ol><p>那么程序中的排序部分应该写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line"><span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note：</strong>本题除了排序规则之外，还应该在准备工作中将int类型转换为String类型，防止ab组合时溢出，所以这还是一个隐形的大数问题。</p></blockquote><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        fastSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        String tmp = strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        fastSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        fastSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p>快速排序算法的本质同冒泡排序一样，同属于交换排序类。也就是通过不断地比较和移动交换来实现排序，只不过对于快速排序来说增大了记录的比较和移动的距离，将较大的关键字记录从前面直接移动到后面，将较小的从后面直接移动到前面，减少了总的比较次数和移动交换次数。</p><p><strong>快排的基本思想是：</strong>选定一个分隔点，通过一趟排序将待排记录<code>按照数组中元素与分隔点的逻辑关系分割成独立的两部分</code>，然后按照同样的方式，对两侧的子数组再排序，直到实现整个序列有序的目的。</p><p>例如：对于如图所示的数组进行排序的过程如下</p><img src="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/图片.png" style="zoom: 67%;"><h1 id="·-代码实现"><a href="#·-代码实现" class="headerlink" title="· 代码实现"></a>· 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiuckSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        QSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[l];</span><br><span class="line">        nums[l] = temp;</span><br><span class="line">        QSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">        QSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序执行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span> </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人的运动范围</title>
      <link href="2021/01/25/%E5%89%91%E6%8C%87offer-13/"/>
      <url>2021/01/25/%E5%89%91%E6%8C%87offer-13/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p></blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题属于二维矩阵的搜索问题，考虑使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历（DFS）</a>的方法。也就是暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。本题中一个优化是不用对一个格子的四个方向都递归，只需要对右、下两个方向递归即可，所有的能够进入的格子都能通过它的左边或上边的格子达到。</p><img src="/2021/01/25/%E5%89%91%E6%8C%87offer-13/图片.png" style="zoom:80%;"><p>我们可以通过上图来模拟DFS的执行流程：</p><blockquote><p><strong>Note：</strong>引入一个二维矩阵flag[] []来作为每个网格是否访问的标志</p></blockquote><p>机器人从（0,0）点出发，将flag[0] [0]记为true表示已经被访问过，向右递归，先判断（0,1）<code>1、网格是否越界 2、是否能进入 3、是否已经被访问过</code>，然后再从（0,1）点向右递归（这就是常说的向一个方向递归），依次类推，当到（0,2）时，经过判断不能进入（0,3）号格子，然后退回到（0,2）号格子，再向下递归，依次类推（这就是所说的该方向到底后，回溯到上一个节点沿另一个方向搜索）。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">this</span>.m=m;</span><br><span class="line">    <span class="keyword">this</span>.n=n;</span><br><span class="line">    <span class="keyword">this</span>.k=k;</span><br><span class="line">    <span class="keyword">return</span> total(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||c&gt;=n||(r / <span class="number">10</span> + r % <span class="number">10</span> + c / <span class="number">10</span> + c % <span class="number">10</span> )&gt; k||flag[r][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        flag[r][c]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+total(r,c+<span class="number">1</span>)+total(r+<span class="number">1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="2021/01/25/%E5%89%91%E6%8C%87offer-29/"/>
      <url>2021/01/25/%E5%89%91%E6%8C%87offer-29/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自LeetCode：</strong><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p></blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><img src="/2021/01/25/%E5%89%91%E6%8C%87offer-29/图片.png" style="zoom:50%;"><p>以<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">上图</a>的矩阵为例，模拟一遍循环打印的过程：</p><p><strong>外圈：</strong></p><ul><li>从左上角的1开始，遍历顶部的一行，到右上角的元素3结束；</li><li>再从3下的元素6开始，遍历最右边的一列，到右下角的元素9结束；</li><li>再从9左边的元素8开始，遍历底部的一行，到左下角的元素7结束；</li><li>最后从7上边的元素4开始，遍历左边的一列，到起始元素的下边一个元素结束；  </li></ul><p><strong>内圈：</strong>元素多的话，与外圈的循环相同</p><p><strong>因此我们可以用多个重复的循环来解决这个问题：</strong>记左上角的元素坐标为（lr,lc）=（0,0），右下角的元素坐标为（rr,rc）=（sums.length-1,sums[0].length-1），那么每层中每次循环的起始坐标都可以用这四个元素来表示。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> lr=<span class="number">0</span>;<span class="comment">//第一层循环的左上角元素为（0,0）</span></span><br><span class="line">    <span class="keyword">int</span> lc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rr=matrix.length-<span class="number">1</span>;<span class="comment">//第一层循环的右下角元素为（matrix.length-1，matrix[0].length-1）</span></span><br><span class="line">    <span class="keyword">int</span> rc=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[(rr+<span class="number">1</span>)*(rc+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//我们以第一层循环为例讲解代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lc;j&lt;=rc;j++)&#123;<span class="comment">//第一个循环改变的是列，行不变。另j等于顶层最左边坐标的列值lc，结束值是顶层最右边坐标的列值                                 //rc</span></span><br><span class="line">            res[k++]=matrix[lr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lr&gt;rr) <span class="keyword">break</span>;<span class="comment">//先另左边的行号+1，表示该行剔除，然后用加完后的值去跟右下角的行号比较，当大于该值，表示这两个在同                           //一行也就是只有一行，循环结束，下同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lr;i&lt;=rr;i++)&#123;</span><br><span class="line">            res[k++]=matrix[i][rc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rc&lt;lc) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=rc;j&gt;=lc;j--)&#123;</span><br><span class="line">            res[k++]=matrix[rr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rr&lt;lr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rr;i&gt;=lr;i--)&#123;</span><br><span class="line">            res[k++]=matrix[i][lc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lc&gt;rc) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note：</strong>++a&gt;b表示先对a的值+1再和b的值比较，a++相反。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="2021/01/25/%E5%89%91%E6%8C%87offer-04/"/>
      <url>2021/01/25/%E5%89%91%E6%8C%87offer-04/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p></blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p><p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一次比较都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p><blockquote><p>解法可以参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/</a></p></blockquote><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//flag作为标志位</span></span><br><span class="line">       <span class="keyword">if</span>((matrix.length)==<span class="number">0</span>||(matrix[<span class="number">0</span>].length)==<span class="number">0</span>) <span class="keyword">return</span> flag;</span><br><span class="line">       <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//（r,c）作为右上角的起始坐标</span></span><br><span class="line">       <span class="keyword">while</span>(r&lt;=(matrix.length-<span class="number">1</span>)&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix[r][c]==target)&#123;<span class="comment">//如果右上角的坐标等于目标值，返回true，结束循环</span></span><br><span class="line">               flag=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c]&gt;target)&#123;<span class="comment">//当右上角的值大于目标值，左移一步，剔除右边的列，小于时，下移一步，剔除顶部一行</span></span><br><span class="line">               c--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扑克牌中的顺子</title>
      <link href="2021/01/25/%E5%89%91%E6%8C%87offer-61/"/>
      <url>2021/01/25/%E5%89%91%E6%8C%87offer-61/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p></blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>对于该题我们要分析怎样去判断给定的数组中的五个数字是不是连续的，那么首先应该对该数组进行排序，我们注意到本题中给定的条件中包括一条：<code>大小王为0，并且可以充当任意数字</code>。当不包含大小王时，判断五个数字是不是连续的非常简单，如果是连续的数字，每个数字相差1，也就是最大值和最小值的差为4，可以理解为4个间隔大小。因此本题可以转换为存在的大小王的个数能不能使最大值和最小值的间隔满足要求。根据大小王的个数可以分为以下情况：</p><p>1、不存在0：最大值和最小值的间隔为4；</p><p>2、存在一个0：剩下四个位置，可以是2,3,4,5这种情况（间隔为3），也可以是2,3,5,6（间隔为4），0作为4补齐，当2,3,6,7（间隔为5）此时只有一个0的情况不能再补齐，不满足条件；</p><p>3、存在两个0：剩下三个位置，可以是3,4,5这种情况（间隔为2），或者是3,5,6这种情况，0作位2,4或4,7 补齐，也可以是3,6,7（间隔为4），0作为4,5补齐，当3,7,8（间隔为5）此时只有两个0的情况不能再补齐，不满足条件；</p><p><strong>根据以上情况总结：</strong></p><ul><li>五个数连续的条件是最大值和最小值的间隔小于等于4个单位，当有一个王时，只能补齐一个位置，两个王时补齐两个位置，<code>实质就是通过最大值和最小值的差值来看中间有几个空缺的位置</code>；</li><li>数组中不能包含重复数字；</li></ul><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> knums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) knums++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">4</span>]-nums[knums]&lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵中的路径</title>
      <link href="2021/01/21/%E5%89%91%E6%8C%87offer-12/"/>
      <url>2021/01/21/%E5%89%91%E6%8C%87offer-12/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p></blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>该题属于矩阵的搜索问题，可以想到使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历算法</a>来解决。通过DFS递归，先朝一个方向搜索，当路径上遇到一个节点k+1不满足条件时，再回溯至上个节点，沿其它方向搜索，以此类推。如<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/hui-su-suan-fa-qiu-jie-by-sdwwld/">下图</a>所示：</p><p><img src="/2021/01/21/%E5%89%91%E6%8C%87offer-12/%E7%9F%A9%E9%98%B5.png"></p><p>首先，在矩阵中任选一个节点，作为一条path的起点；</p><p>然后，通过DFS以该节点作为起始点，开始递归。递归的结束结果有两种可能：</p><p>1、返回false：说明在递归的过程中，存在一个节点（r，c）假设它对应的字符串中第k个字符值，它的四个相邻的格子（r-1，c）（r+1，c）（r，c-1）（r，c+1）都找不到字符串的下一个字符值（k+1）；</p><p>2、返回true：如上图所示，从A点开始，到B、C、C、E每个点总有一个方向的字符值能和给定的字符串的下一个字符值相等，则递归结束，可以看出递归成功结束的条件是已经在矩阵中找到了与给定的字符串所有的字符。</p><p>最后，循环结束说明矩阵中没有该路径，返回false。</p><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words=word.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;board.length;r++)&#123;<span class="comment">//以矩阵的第一行为起始行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;board[<span class="number">0</span>].length;c++)&#123;<span class="comment">//以矩阵的第一列为起始列，依次以每个格子作为起始点，开启DFS遍历</span></span><br><span class="line">            <span class="keyword">if</span>(DFS(board,words,r,c,<span class="number">0</span>))&#123;<span class="comment">//每次传入的参数就是board、words、起始点坐标、字符串起始点0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//当找到对应路径，返回true，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//找不到对应的路径，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>||r&gt;board.length-<span class="number">1</span>||c&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||board[r][c]!=words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*递归的结束条件：</span></span><br><span class="line"><span class="comment">                       1、越界 r&lt;0||c&lt;0||r&gt;board.length-1||c&gt;board[0].length-1</span></span><br><span class="line"><span class="comment">                       2、矩阵的网格字符值与字符串的字符值不同 board[r][c]!=words[k]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//该行表示递归成功的出口</span></span><br><span class="line">        board[r][c]=<span class="string">&#x27; &#x27;</span>;<span class="comment">//每当一个网格字符值满足条件，将该值置为空值，防止二次访问</span></span><br><span class="line">        <span class="keyword">boolean</span> res=DFS(board,words,r+<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r-<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r,c+<span class="number">1</span>,k+<span class="number">1</span>)||DFS(board,words,r,c-<span class="number">1</span>,k+<span class="number">1</span>);<span class="comment">//每当访问到一个网格，对它的上下左右四个方向递归，只要有一个方向满足条件即可，当四个方向都返回false，说明此路不通，换下一个方向或者重新选择起始点</span></span><br><span class="line">        board[r][c]=words[k];<span class="comment">//当一个格点四个方向的邻接点都不合要求，将该网格值还原</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//返回递归结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先遍历</title>
      <link href="2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p>从图中的某个顶点K出发，按照一定的原则（比如：总是先选择右边第一个点）先去访问它的邻接点，初始状态下K的邻接点未被访问过，按照这个原则找到它的一个未被访问过的邻接点，然后将该邻接点标记为“true”，表示该点已经被访问过。直到有一个顶点N，按照该原则下，它的邻接点已经被访问，则退回到N点，再去访问它右边第二个点，以此类推，直到所有的顶点都被访问到，遍历结束。</p><p>这里我们以邻接矩阵的方式来讲解DFS的算法执行流程：</p><p>​                              <img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/邻接矩阵.jpg" style="zoom: 80%;"></p><h1 id="·-代码实现"><a href="#·-代码实现" class="headerlink" title="· 代码实现"></a>· 代码实现</h1><blockquote><p><strong>Note：</strong>该代码不包含图的建立部分。其中，numVertexes为图中的节点数目，vexs[]数组为顶点表 ,arc[] []为边表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.numVertexes];<span class="comment">//创建visited[]数组，作为节点的访问标志</span></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="keyword">false</span>;<span class="comment">//初始化visited[]数组为false，表示初始状态下节点未被访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//从V0开始循环遍历树中的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//若节点Vi不为false，说明该节点未被访问过，调用DFS()方法。这里可以视为对边表的行遍历</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    visited[i]=<span class="keyword">true</span>;<span class="comment">//另visited数组中的第i个节点的标志位true，表示该节点已经被访问</span></span><br><span class="line">    System.out.println(G.vexs[i]);<span class="comment">//可以对该顶点进行输出等操作</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//i表示边表矩阵的第i行，当满足G.[i][j]!==1（表示节点j是i的邻接点）且                                                   //visited[j]==false未被访问，则对节点j再进行DFS递归</span></span><br><span class="line">        <span class="keyword">if</span>(G.[i][j]!==<span class="number">1</span>&amp;&amp;visited[j]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当图是<strong>连通图</strong>时，DFSTraverse（）方法中的循环执行一次就可以；</p><p>当图是<strong>非连通图</strong>时，需要对它的连通分量分别进行DFS遍历，当图中尚有顶点还有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直到图中所有的节点都被访问到为止。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构及算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大话数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="2021/01/19/%E5%89%91%E6%8C%87offer-34/"/>
      <url>2021/01/19/%E5%89%91%E6%8C%87offer-34/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote><p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p></blockquote><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><img src="/2021/01/19/%E5%89%91%E6%8C%87offer-34/1.png" style="zoom:50%;"><h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于路径是从根节点出发到叶节点，也就是路径总是以根节点作为起始点，因此我们需要先遍历根节点，考虑使用前序遍历。</p><p>对于上图中的二叉树，其前序遍历过程如下表所示：</p><table><thead><tr><th>操作</th><th>是否叶节点</th><th>路径</th><th>路径节点的和</th><th>是否符合要求</th></tr></thead><tbody><tr><td>访问节点5</td><td>否</td><td>5</td><td>5</td><td>否</td></tr><tr><td>访问节点4</td><td>否</td><td>5,4</td><td>9</td><td>否</td></tr><tr><td>访问节点11</td><td>否</td><td>5,4,11</td><td>20</td><td>否</td></tr><tr><td>访问节点7</td><td>是</td><td>5,4,11,7</td><td>27</td><td>否</td></tr><tr><td>访问节点2</td><td>是</td><td>5,4,11,2</td><td>22</td><td>是</td></tr><tr><td>访问节点8</td><td>否</td><td>5,8</td><td>13</td><td>否</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td><td></td></tr></tbody></table><p>通过表，我们可以得到算法的执行流程：</p><p>当访问一个节点时，首先判断该节点是不是null，当节点为null时，直接返回；</p><p>当访问的节点不为null，将该节点的值加到动态数组temp中，并在目标值tar上减去该节点的数值。通过上表可知当一个节点为<strong>叶子节点</strong>且<strong>路径的和等于sum</strong>时该路径复合题目要求（此处当tar的值为零时表示路径的和等于sum）；</p><p>当被访问的节点不为null，也不满足第二条的要求时，进行左右子树的递归；</p><p>一个被访问的节点递归结束，要从temp中删除该节点的值，比如：5→4→11→7，当节点7访问结束，要将7从temp删除，然后返回        到访问节点11的函数，开始递归它的右子树，也就是节点2。</p><blockquote><p><strong>Note：</strong>当一条路径满足要求时，要新建一个LinkedList(temp)对象传入res中（复制），因为如果直接res.add(temp)相当于传入temp对象，当temp改变时，res也会随之变化。</p></blockquote><h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//res中存储的是满足要求的所有路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//temp存储动态变化的路径</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        path(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar-=root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(tar==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> LinkedList(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        path(root.left,tar);</span><br><span class="line">        path(root.right,tar);</span><br><span class="line">        temp.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

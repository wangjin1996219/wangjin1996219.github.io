<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2021/01/19/%E5%89%91%E6%8C%87offer-34/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof</a></p>
</blockquote>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<img src="/2021/01/19/%E5%89%91%E6%8C%87offer-34/1.png" style="zoom:50%;">

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于路径是从根节点出发到叶节点，也就是路径总是以根节点作为起始点，因此我们需要先遍历根节点，考虑使用前序遍历。</p>
<p>对于上图中的二叉树，其前序遍历过程如下表所示：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>是否叶节点</th>
<th>路径</th>
<th>路径节点的和</th>
<th>是否符合要求</th>
</tr>
</thead>
<tbody><tr>
<td>访问节点5</td>
<td>否</td>
<td>5</td>
<td>5</td>
<td>否</td>
</tr>
<tr>
<td>访问节点4</td>
<td>否</td>
<td>5,4</td>
<td>9</td>
<td>否</td>
</tr>
<tr>
<td>访问节点11</td>
<td>否</td>
<td>5,4,11</td>
<td>20</td>
<td>否</td>
</tr>
<tr>
<td>访问节点7</td>
<td>是</td>
<td>5,4,11,7</td>
<td>27</td>
<td>否</td>
</tr>
<tr>
<td>访问节点2</td>
<td>是</td>
<td>5,4,11,2</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>访问节点8</td>
<td>否</td>
<td>5,8</td>
<td>13</td>
<td>否</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td></td>
</tr>
</tbody></table>
<p>通过表，我们可以得到算法的执行流程：</p>
<p>当访问一个节点时，首先判断该节点是不是null，当节点为null时，直接返回；</p>
<p>当访问的节点不为null，将该节点的值加到动态数组temp中，并在目标值tar上减去该节点的数值。通过上表可知当一个节点为<strong>叶子节点</strong>且<strong>路径的和等于sum</strong>时该路径复合题目要求（此处当tar的值为零时表示路径的和等于sum）；</p>
<p>当被访问的节点不为null，也不满足第二条的要求时，进行左右子树的递归；</p>
<p>一个被访问的节点递归结束，要从temp中删除该节点的值，比如：5→4→11→7，当节点7访问结束，要将7从temp删除，然后返回        到访问节点11的函数，开始递归它的右子树，也就是节点2。</p>
<blockquote>
<p><strong>Note：</strong>当一条路径满足要求时，要新建一个LinkedList(temp)对象传入res中（复制），因为如果直接res.add(temp)相当于传入temp对象，当temp改变时，res也会随之变化。</p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//res中存储的是满足要求的所有路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//temp存储动态变化的路径</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        path(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">(TreeNode root,<span class="keyword">int</span> tar)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tar-=root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(tar==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> LinkedList(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        path(root.left,tar);</span><br><span class="line">        path(root.right,tar);</span><br><span class="line">        temp.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历</title>
    <url>/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p>从图中的某个顶点K出发，按照一定的原则（比如：总是先选择右边第一个点）先去访问它的邻接点，初始状态下K的邻接点未被访问过，按照这个原则找到它的一个未被访问过的邻接点，然后将该邻接点标记为“true”，表示该点已经被访问过。直到有一个顶点N，按照该原则下，它的邻接点已经被访问，则退回到N点，再去访问它右边第二个点，以此类推，直到所有的顶点都被访问到，遍历结束。</p>
<p>这里我们以邻接矩阵的方式来讲解DFS的算法执行流程：</p>
<p>​                              <img src="/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/邻接矩阵.jpg" style="zoom: 80%;"></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><blockquote>
<p><strong>Note：</strong>该代码不包含图的建立部分。其中，numVertexes为图中的节点数目，vexs[]数组为顶点表 ,arc[] []为边表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.numVertexes];<span class="comment">//创建visited[]数组，作为节点的访问标志</span></span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先遍历操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)&#123;</span><br><span class="line">        visited[i]=<span class="keyword">false</span>;<span class="comment">//初始化visited[]数组为false，表示初始状态下节点未被访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//从V0开始循环遍历树中的节点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//若节点Vi不为false，说明该节点未被访问过，调用DFS()方法。这里可以视为对边表的行遍历</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*邻接矩阵的深度优先递归算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    visited[i]=<span class="keyword">true</span>;<span class="comment">//另visited数组中的第i个节点的标志位true，表示该节点已经被访问</span></span><br><span class="line">    System.out.println(G.vexs[i]);<span class="comment">//可以对该顶点进行输出等操作</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)&#123;<span class="comment">//i表示边表矩阵的第i行，当满足G.[i][j]!==1（表示节点j是i的邻接点）且                                                   //visited[j]==false未被访问，则对节点j再进行DFS递归</span></span><br><span class="line">        <span class="keyword">if</span>(G.[i][j]!==<span class="number">1</span>&amp;&amp;visited[j]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            DFS(G,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当图是<strong>连通图</strong>时，DFSTraverse（）方法中的循环执行一次就可以；</p>
<p>当图是<strong>非连通图</strong>时，需要对它的连通分量分别进行DFS遍历，当图中尚有顶点还有顶点未被访问，则另选图中一个未曾被访问的顶点作为起始点，重复上述过程，直到图中所有的节点都被访问到为止。</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/number-of-islands/">热题100-200. 岛屿数量</a></strong></p>
<p>  给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。</p>
<p>  岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。 </p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>通过dfs，遍历岛屿时将对应的1置为0，当一个岛屿的周围都是0，表示该岛屿已经遍历完成，返回将结果+1</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断岛屿数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid char字符型二维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r=grid.length;</span><br><span class="line">        <span class="keyword">int</span> c=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i,j,r,c,grid);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i==r||j==c||grid[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(i+<span class="number">1</span>,j,r,c,grid);</span><br><span class="line">        dfs(i-<span class="number">1</span>,j,r,c,grid);</span><br><span class="line">        dfs(i,j+<span class="number">1</span>,r,c,grid);</span><br><span class="line">        dfs(i,j-<span class="number">1</span>,r,c,grid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">热题100-105. 从前序与中序遍历序列构造二叉树</a></strong></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>递推参数：根节点在前序遍历的索引root、子树在中序遍历的左边界left、子树在中序遍历的右边界right；</p>
</li>
<li><p>终止条件：当left&gt;right，代表已经越过叶节点，此时返回 null；</p>
</li>
<li><p>递推工作：</p>
<p>建立根节点 node ： 节点值为 preorder[root] ；</p>
<p>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p>
<p>可以理解为递归函数每次传入的都是子树的根节点、该子树在中序遍历中的左右边界，并且通过每次的root、left和right进一步在中序遍历中找到左子树、右子树以及左右子树的根节点，每次先判断，当left&gt;right时，要么是没有左子树了，要么是没有右子树了，递归结束，否则对该根节点的左右子树继续递归构建。</p>
</li>
</ul>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; in_Map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.preorder=preorder;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">        in_Map.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consutruct(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">consutruct</span><span class="params">(<span class="keyword">int</span> root_pos,<span class="keyword">int</span> in_left,<span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left&gt;in_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(preorder[root_pos]);</span><br><span class="line">        <span class="keyword">int</span> in_pos=in_Map.get(preorder[root_pos]);</span><br><span class="line">        root.left=consutruct(root_pos+<span class="number">1</span>,in_left,in_pos-<span class="number">1</span>);</span><br><span class="line">        root.right=consutruct(root_pos+in_pos-in_left+<span class="number">1</span>,in_pos+<span class="number">1</span>,in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>递归到叶子结点，当root为空时返回0；</li>
<li>接收左右子树的返回值，也就是左右子树的最大深度</li>
<li>返回值为取左右子树的最大深度+1，表示该节点的最大深度</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_depth=maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth=maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left_depth,right_depth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>通过treeDepth方法递归的得到二叉树中每个节点的深度</li>
<li>对于root节点：</li>
<li>当其为null时，超出了叶子结点，返回0</li>
<li>递归左子树，得到左子树深度</li>
<li>递归右子树，得到右子树深度</li>
<li>判断两边子树的深度差，当大于1时，返回-1</li>
</ul>
<blockquote>
<p><strong>剪枝：</strong>为了减少递归次数，当我们发现有一边的子树返回值为-1时，就直接返回-1，那么这棵树就不是平衡二叉树</p>
</blockquote>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> treeDepth(root)==-<span class="number">1</span>? <span class="keyword">false</span>:<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left_depth=treeDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left_depth==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right_depth=treeDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right_depth==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left_depth-right_depth)&gt;<span class="number">1</span>? -<span class="number">1</span>:Math.max(left_depth,right_depth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer-面试题34. 二叉树中和为某一值的路径</a></strong></p>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>pathSum(root, sum) 函数：</strong></p>
<ul>
<li>初始化： 结果列表 res ，路径列表 temp 。</li>
<li>返回值： 返回 res 即可。</li>
</ul>
<p><strong>dfs(root,sum,temp,res)函数：</strong></p>
<ul>
<li>递推参数： 当前节点 root ，当前目标值 target，路径temp，结果集res。</li>
<li>终止条件： 若节点 root 为空，则直接返回。</li>
<li><strong>递推工作：</strong><pre><code>路径更新： 将当前节点值 root.val 加入路径 temp ；
目标值更新： target-=root.val（即目标值 tar 从 sum 减至 0 ）；
路径记录： 当 ① root 为叶节点 且 ② 路径和等于目标值 ，则将此路径 path 加入 res 。**在记录完数据之后，不能立即返回，要将当前节点从路径 path 中删除，即执行 temp.remove(temp.size()-1)**
先序遍历： 递归左 / 右子节点。
路径恢复： 向上回溯前，需要将当前节点从路径 path 中删除，即执行  temp.remove(temp.size()-1)。</code></pre>
</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathSum (TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        dfs(root,sum,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; temp,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target-=root.val;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,target,temp,res);</span><br><span class="line">        dfs(root.right,target,temp,res);</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/f31fc6d3caf24e7f8b4deb5cd9b5fa97?tpId=190&tqId=35223&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-判断一棵树是否为搜索二叉树和完全二叉树</a></strong></p>
<p>给定一棵二叉树，已经其中没有重复值的节点，请判断该二叉树是否为搜索二叉树和完全二叉树</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>搜索二叉树判定实现：</strong>搜索二叉树的中序遍历结果是严格递增的，因为左子树&lt;根节点&lt;右子树</p>
<ul>
<li>当根节点为null时，返回true</li>
<li>接收左子树递归的返回条件</li>
<li>左子树返回值为false直接返回false</li>
<li>用pre来作为中序遍历的前驱节点，每次遍历完当前节点的左子树后判断当前节点的值与pre的大小关系，只要当前节点的值小于pre，就返回false，否则将该节点作为下一节点的前驱节点再去做判断</li>
<li>接收右子树递归的返回条件</li>
<li>左子树返回值为false直接返回false</li>
<li>当两边的返回值都不为false，返回true</li>
</ul>
<blockquote>
<p><strong>Note：</strong>这里将pre的值设为Long.MIN_VALUE，原因是题目的val都是int，使用long为了满足在最左节点是INT_MIN的时候，也不会判断为false</p>
</blockquote>
<p><strong>完全二叉树判定实现：</strong>完全二叉树，层次遍历遇到第一个空节点后，剩余节点还有非空，则一定不是，巧用<code>continue</code>并配合标志位。</p>
<ul>
<li>当标志位为false时，循环中不断将队列头部元素取出，并将左右子树加入到队列中</li>
<li>当某一节点为null时，将标志位置为true，进入下一次循环</li>
<li><strong>当剩余节点有值不为null时，因为flag此时为true，所以直接就会触发if语句返回false</strong></li>
<li>否则循环结束，没有节点不为null了，返回true</li>
</ul>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 the root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> pre=Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span>[] judgeIt (TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">boolean</span>[]&#123;dfs1(root),dfs2(root)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs1</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=dfs1(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;pre)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root.val;</span><br><span class="line">        <span class="keyword">boolean</span> right=dfs1(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs2</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            dq.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            TreeNode node=dq.poll();</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.add(node.left);</span><br><span class="line">            dq.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/symmetric-tree/">热题100-101. 对称二叉树</a></strong></p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>一个前序遍历，一个后序遍历</li>
<li>当节点不同时，或者有一边返回false时，返回false</li>
<li>当左右子树都为true，且节点值相同时，返回true</li>
</ul>
<h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span> <span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricImpl(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricImpl</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>||root1.val!=root2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> left=isSymmetricImpl(root1.left,root2.right);</span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> right=isSymmetricImpl(root1.right,root2.left);</span><br><span class="line">        <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><a href="https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=190&tqId=35182&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-二叉树中是否存在指定和的路径</strong></a></p>
<p>给定一个二叉树和一个值 sum\ sum sum，判断是否有从根节点到叶子节点的节点值之和等于 sum\ sum sum 的路径。</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p>与**<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer-面试题34. 二叉树中和为某一值的路径</a>**解法类似，不做介绍</p>
<h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span> <span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;sum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum)||hasPathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径</title>
    <url>/2021/01/21/%E5%89%91%E6%8C%87offer-12/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof</a></p>
</blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>该题属于矩阵的搜索问题，可以想到使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历算法</a>来解决。通过DFS递归，先朝一个方向搜索，当路径上遇到一个节点k+1不满足条件时，再回溯至上个节点，沿其它方向搜索，以此类推。如<a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/hui-su-suan-fa-qiu-jie-by-sdwwld/">下图</a>所示：</p>
<p><img src="/2021/01/21/%E5%89%91%E6%8C%87offer-12/%E7%9F%A9%E9%98%B5.png"></p>
<p>首先，在矩阵中任选一个节点，作为一条path的起点；</p>
<p>然后，通过DFS以该节点作为起始点，开始递归。递归的结束结果有两种可能：</p>
<p>1、返回false：说明在递归的过程中，存在一个节点（r，c）假设它对应的字符串中第k个字符值，它的四个相邻的格子（r-1，c）（r+1，c）（r，c-1）（r，c+1）都找不到字符串的下一个字符值（k+1）；</p>
<p>2、返回true：如上图所示，从A点开始，到B、C、C、E每个点总有一个方向的字符值能和给定的字符串的下一个字符值相等，则递归结束，可以看出递归成功结束的条件是已经在矩阵中找到了与给定的字符串所有的字符。</p>
<p>最后，循环结束说明矩阵中没有该路径，返回false。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words=word.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;board.length;r++)&#123;<span class="comment">//以矩阵的第一行为起始行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;board[<span class="number">0</span>].length;c++)&#123;<span class="comment">//以矩阵的第一列为起始列，依次以每个格子作为起始点，开启DFS遍历</span></span><br><span class="line">            <span class="keyword">if</span>(DFS(board,words,r,c,<span class="number">0</span>))&#123;<span class="comment">//每次传入的参数就是board、words、起始点坐标、字符串起始点0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//当找到对应路径，返回true，结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//找不到对应的路径，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>||r&gt;board.length-<span class="number">1</span>||c&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||board[r][c]!=words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/*递归的结束条件：</span></span><br><span class="line"><span class="comment">                       1、越界 r&lt;0||c&lt;0||r&gt;board.length-1||c&gt;board[0].length-1</span></span><br><span class="line"><span class="comment">                       2、矩阵的网格字符值与字符串的字符值不同 board[r][c]!=words[k]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//该行表示递归成功的出口</span></span><br><span class="line">        board[r][c]=<span class="string">&#x27; &#x27;</span>;<span class="comment">//每当一个网格字符值满足条件，将该值置为空值，防止二次访问</span></span><br><span class="line">        <span class="keyword">boolean</span> res=DFS(board,words,r+<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r-<span class="number">1</span>,c,k+<span class="number">1</span>)||DFS(board,words,r,c+<span class="number">1</span>,k+<span class="number">1</span>)||DFS(board,words,r,c-<span class="number">1</span>,k+<span class="number">1</span>);<span class="comment">//每当访问到一个网格，对它的上下左右四个方向递归，只要有一个方向满足条件即可，当四个方向都返回false，说明此路不通，换下一个方向或者重新选择起始点</span></span><br><span class="line">        board[r][c]=words[k];<span class="comment">//当一个格点四个方向的邻接点都不合要求，将该网格值还原</span></span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//返回递归结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>扑克牌中的顺子</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-61/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof</a></p>
</blockquote>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>对于该题我们要分析怎样去判断给定的数组中的五个数字是不是连续的，那么首先应该对该数组进行排序，我们注意到本题中给定的条件中包括一条：<code>大小王为0，并且可以充当任意数字</code>。当不包含大小王时，判断五个数字是不是连续的非常简单，如果是连续的数字，每个数字相差1，也就是最大值和最小值的差为4，可以理解为4个间隔大小。因此本题可以转换为存在的大小王的个数能不能使最大值和最小值的间隔满足要求。根据大小王的个数可以分为以下情况：</p>
<p>1、不存在0：最大值和最小值的间隔为4；</p>
<p>2、存在一个0：剩下四个位置，可以是2,3,4,5这种情况（间隔为3），也可以是2,3,5,6（间隔为4），0作为4补齐，当2,3,6,7（间隔为5）此时只有一个0的情况不能再补齐，不满足条件；</p>
<p>3、存在两个0：剩下三个位置，可以是3,4,5这种情况（间隔为2），或者是3,5,6这种情况，0作位2,4或4,7 补齐，也可以是3,6,7（间隔为4），0作为4,5补齐，当3,7,8（间隔为5）此时只有两个0的情况不能再补齐，不满足条件；</p>
<p><strong>根据以上情况总结：</strong></p>
<ul>
<li>五个数连续的条件是最大值和最小值的间隔小于等于4个单位，当有一个王时，只能补齐一个位置，两个王时补齐两个位置，<code>实质就是通过最大值和最小值的差值来看中间有几个空缺的位置</code>；</li>
<li>数组中不能包含重复数字；</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> knums=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==<span class="number">0</span>) knums++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">4</span>]-nums[knums]&lt;<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-04/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode ：</strong><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
</blockquote>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一次比较都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<blockquote>
<p>解法可以参考：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-b-3/</a></p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//flag作为标志位</span></span><br><span class="line">       <span class="keyword">if</span>((matrix.length)==<span class="number">0</span>||(matrix[<span class="number">0</span>].length)==<span class="number">0</span>) <span class="keyword">return</span> flag;</span><br><span class="line">       <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> c=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//（r,c）作为右上角的起始坐标</span></span><br><span class="line">       <span class="keyword">while</span>(r&lt;=(matrix.length-<span class="number">1</span>)&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix[r][c]==target)&#123;<span class="comment">//如果右上角的坐标等于目标值，返回true，结束循环</span></span><br><span class="line">               flag=<span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c]&gt;target)&#123;<span class="comment">//当右上角的值大于目标值，左移一步，剔除右边的列，小于时，下移一步，剔除顶部一行</span></span><br><span class="line">               c--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-29/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自LeetCode：</strong><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a></p>
</blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><img src="/2021/01/25/%E5%89%91%E6%8C%87offer-29/图片.png" style="zoom:50%;">

<p>以<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-di/">上图</a>的矩阵为例，模拟一遍循环打印的过程：</p>
<p><strong>外圈：</strong></p>
<ul>
<li>从左上角的1开始，遍历顶部的一行，到右上角的元素3结束；</li>
<li>再从3下的元素6开始，遍历最右边的一列，到右下角的元素9结束；</li>
<li>再从9左边的元素8开始，遍历底部的一行，到左下角的元素7结束；</li>
<li>最后从7上边的元素4开始，遍历左边的一列，到起始元素的下边一个元素结束；  </li>
</ul>
<p><strong>内圈：</strong>元素多的话，与外圈的循环相同</p>
<p><strong>因此我们可以用多个重复的循环来解决这个问题：</strong>记左上角的元素坐标为（lr,lc）=（0,0），右下角的元素坐标为（rr,rc）=（sums.length-1,sums[0].length-1），那么每层中每次循环的起始坐标都可以用这四个元素来表示。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> lr=<span class="number">0</span>;<span class="comment">//第一层循环的左上角元素为（0,0）</span></span><br><span class="line">    <span class="keyword">int</span> lc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rr=matrix.length-<span class="number">1</span>;<span class="comment">//第一层循环的右下角元素为（matrix.length-1，matrix[0].length-1）</span></span><br><span class="line">    <span class="keyword">int</span> rc=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[(rr+<span class="number">1</span>)*(rc+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;<span class="comment">//我们以第一层循环为例讲解代码</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=lc;j&lt;=rc;j++)&#123;<span class="comment">//第一个循环改变的是列，行不变。另j等于顶层最左边坐标的列值lc，结束值是顶层最右边坐标的列值                                 //rc</span></span><br><span class="line">            res[k++]=matrix[lr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lr&gt;rr) <span class="keyword">break</span>;<span class="comment">//先另左边的行号+1，表示该行剔除，然后用加完后的值去跟右下角的行号比较，当大于该值，表示这两个在同                           //一行也就是只有一行，循环结束，下同</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lr;i&lt;=rr;i++)&#123;</span><br><span class="line">            res[k++]=matrix[i][rc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rc&lt;lc) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=rc;j&gt;=lc;j--)&#123;</span><br><span class="line">            res[k++]=matrix[rr][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(--rr&lt;lr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=rr;i&gt;=lr;i--)&#123;</span><br><span class="line">            res[k++]=matrix[i][lc];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(++lc&gt;rc) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>++a&gt;b表示先对a的值+1再和b的值比较，a++相反。</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/2021/01/25/%E5%89%91%E6%8C%87offer-13/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
</blockquote>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题属于二维矩阵的搜索问题，考虑使用<a href="https://eudemonia.tech/2021/01/20/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/#more">深度优先遍历（DFS）</a>的方法。也就是暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。本题中一个优化是不用对一个格子的四个方向都递归，只需要对右、下两个方向递归即可，所有的能够进入的格子都能通过它的左边或上边的格子达到。</p>
<img src="/2021/01/25/%E5%89%91%E6%8C%87offer-13/图片.png" style="zoom:80%;">

<p>我们可以通过上图来模拟DFS的执行流程：</p>
<blockquote>
<p><strong>Note：</strong>引入一个二维矩阵flag[] []来作为每个网格是否访问的标志</p>
</blockquote>
<p>机器人从（0,0）点出发，将flag[0] [0]记为true表示已经被访问过，向右递归，先判断（0,1）<code>1、网格是否越界 2、是否能进入 3、是否已经被访问过</code>，然后再从（0,1）点向右递归（这就是常说的向一个方向递归），依次类推，当到（0,2）时，经过判断不能进入（0,3）号格子，然后退回到（0,2）号格子，再向下递归，依次类推（这就是所说的该方向到底后，回溯到上一个节点沿另一个方向搜索）。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">this</span>.m=m;</span><br><span class="line">    <span class="keyword">this</span>.n=n;</span><br><span class="line">    <span class="keyword">this</span>.k=k;</span><br><span class="line">    <span class="keyword">return</span> total(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||c&gt;=n||(r / <span class="number">10</span> + r % <span class="number">10</span> + c / <span class="number">10</span> + c % <span class="number">10</span> )&gt; k||flag[r][c]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        flag[r][c]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+total(r,c+<span class="number">1</span>)+total(r+<span class="number">1</span>,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><p>快速排序算法的本质同冒泡排序一样，同属于交换排序类。也就是通过不断地比较和移动交换来实现排序，只不过对于快速排序来说增大了记录的比较和移动的距离，将较大的关键字记录从前面直接移动到后面，将较小的从后面直接移动到前面，减少了总的比较次数和移动交换次数。</p>
<p><strong>快排的基本思想是：</strong>选定一个分隔点，通过一趟排序将待排记录<code>按照数组中元素与分隔点的逻辑关系分割成独立的两部分</code>，然后按照同样的方式，对两侧的子数组再排序，直到实现整个序列有序的目的。</p>
<p>例如：对于如图所示的数组进行排序的过程如下</p>
<img src="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/图片.png" style="zoom: 67%;">

<h1 id="·-代码实现"><a href="#·-代码实现" class="headerlink" title="· 代码实现"></a>· 代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QiuckSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        QSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l;</span><br><span class="line">        <span class="keyword">int</span> j = r;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[l];</span><br><span class="line">        nums[l] = temp;</span><br><span class="line">        QSort(nums, l, i - <span class="number">1</span>);</span><br><span class="line">        QSort(nums, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span> </span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-colors">75.颜色分类</a></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=l)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=r;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]&gt;=nums[l]) j--;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]&lt;nums[l]) i++;</span><br><span class="line">            temp=nums[i];</span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l]=temp;</span><br><span class="line">        nums[i]=nums[l];</span><br><span class="line">        quickSort(nums,l,i);</span><br><span class="line">        quickSort(nums,i+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2021/01/27/%E5%89%91%E6%8C%87offer-45/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof</a></p>
</blockquote>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>将数组排成最小的数，我们最直观的想法是小数在前，大数在后，但是这样的排序组成的数组不一定是最小的数字，例如：10,9，这两个数字组成的最小数字应该是109而不是910。因此需要定义一种排序规则，使组成的数字最小。</p>
<p>若我们另两个数字为a，b，两个数字的组合有三种情况：</p>
<ol>
<li>当ab&gt;ba时，我们定义b应该在前；</li>
<li>当ba&gt;ab时，我们定义a应该在前；</li>
<li>当ab=ba时，两数相同，谁在前都可以。</li>
</ol>
<p>那么程序中的排序部分应该写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line"><span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>本题除了排序规则之外，还应该在准备工作中将int类型转换为String类型，防止ab组合时溢出，所以这还是一个隐形的大数问题。</p>
</blockquote>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        fastSort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fastSort</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        String tmp = strs[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span>((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) j--;</span><br><span class="line">            <span class="keyword">while</span>((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="number">0</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">            tmp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        strs[i] = strs[l];</span><br><span class="line">        strs[l] = tmp;</span><br><span class="line">        fastSort(strs, l, i - <span class="number">1</span>);</span><br><span class="line">        fastSort(strs, i + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-38/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p>
</blockquote>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>我们把一个字符串看成是由<strong>两部分</strong>组成：</p>
<ul>
<li>第一部分是它的第一个字符；</li>
<li>第二部分是后面的所有字符；</li>
</ul>
<p>这里也体现的是<a href="https://eudemonia.tech/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/#more">回溯法</a>的思想：</p>
<ol>
<li>首先所有的字符都有可能出现在第一个位置，则循环另所有的元素都轮流作为第一个元素，</li>
<li>然后固定完第一个元素后，剩下的n-1个元素都有可能出现在第二个位置，此时的选择列表为剩下的n-1个元素，</li>
<li>固定完第二个元素之后，剩下的n-2个元素再作为选择列表去枚举第三个位置，以此类推，直到临时路径的长度等于给定数组长度。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><blockquote>
<p><strong>参考文章：</strong><a href="https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack">https://greyireland.gitbook.io/algorithm-pattern/suan-fa-si-wei/backtrack</a></p>
<p>字节大佬的文章写得特别棒，很实用！</p>
</blockquote>
<p><strong>回溯法（backtrack）</strong>常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于<code>全排列</code>，穷尽所有可能。时间复杂度一般 O(N!)，回溯算法就是纯暴力穷举，复杂度一般都很高。</p>
<p><strong>核心思想：</strong>就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(选择列表，路径)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">       result.add(路径);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(选择 in 选择列表)&#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtrack(选择列表,路径);</span><br><span class="line">        撤销选择;<span class="comment">//递归完成以后，需要撤销选择，递归方法执行之前做了什么，递归方法执行以后就需要做相应的逆向操作</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>题型一：</strong>给定一个可包含重复元素的序列，返回所有不重复的全排列。</p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/"><strong>剑指 Offer 38. 字符串的排列</strong></a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">    List&lt;String&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    Arrays.sort(ss);<span class="comment">//对集合排序，方便后面的去重</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];<span class="comment">//标记这个元素是否已经添加到结果集</span></span><br><span class="line">    backTrack(ss,temp,flag,res);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">char</span>[] ss,StringBuilder temp,<span class="keyword">boolean</span>[] flag,List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ss 输入集合</span></span><br><span class="line">        <span class="comment">// flag 当前递归标记过的元素</span></span><br><span class="line">        <span class="comment">// temp 临时结果集</span></span><br><span class="line">        <span class="comment">// res 最终结果</span></span><br><span class="line">        <span class="keyword">if</span>(temp.length()==ss.length)&#123;<span class="comment">// 临时结果和输入集合长度一致 才是全排列</span></span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ss.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="keyword">true</span>)&#123;<span class="comment">// 已经添加过的元素，直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;ss[i]==ss[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])&#123;<span class="comment">// 上一个元素和当前相同，并且没有访问过就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            temp.append(ss[i]);</span><br><span class="line">            backTrack(ss,temp,flag,res);</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>过滤条件中一定是没有访问过，例如：[a,b,c,c,d]这种情况，当第一个c被标记为true，调用递归函数时，再遍历到第四个c时，当去判断时，如果判断条件没有加上没有被访问过时，第四个c就会被跳过，而且是一直被跳过，会导致路径无法满足长度，没有结果输出，其实这个条件过滤的是两个c在同一选择列表的情况，当两个c一个被固定时，就不在同一选择列表内，也就不用再过滤。</p>
</blockquote>
<blockquote>
<p><strong>题型二：</strong>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p><strong><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></strong></p>
</blockquote>
<p><strong>递归过程如下图所示：</strong></p>
<img src="/2021/01/28/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/图片.png" style="zoom:120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backTrack(nums,<span class="number">0</span>,temp,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// nums 给定的集合</span></span><br><span class="line">    <span class="comment">// pos 下次添加到集合中的元素位置索引</span></span><br><span class="line">    <span class="comment">// temp 临时结果集合(每次需要复制保存)</span></span><br><span class="line">    <span class="comment">// res 最终结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> pos,List&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把临时结果复制出来保存到最终结果</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="comment">// 选择、处理结果、再撤销选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            backTrack(nums,i+<span class="number">1</span>,temp,res);</span><br><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-66/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof</a></p>
</blockquote>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>方法一：暴力解法，每次用连乘n-1个数字的方法得到B[i]。但是这种方法的时间复杂度为O(n^2)。</p>
<p>方法二：通过分析乘积数组的特点，即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]，定义C[i]=A[0]×A[1]×…×A[i-1]，D[i]=A[i+1]×…×A[n-1]，也就是B[i]可以分成两部分C[i]和D[i]的乘积，如图所示：</p>
<p><img src="/2021/01/28/%E5%89%91%E6%8C%87offer-66/2021-01-28-%E5%89%91%E6%8C%87offer-66%5C%E5%9B%BE%E7%89%87.jpg"></p>
<p>而C[i]和D[i]可以分别通过两次循环得到，这种做法的时间复杂度为O(n)。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2021/01/28/%E5%89%91%E6%8C%87offer-49/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/chou-shu-lcof">https://leetcode-cn.com/problems/chou-shu-lcof</a></p>
</blockquote>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>解题思路参考于：<a href="https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/">https://leetcode-cn.com/problems/chou-shu-lcof/solution/mian-shi-ti-49-chou-shu-dong-tai-gui-hua-qing-xi-t/</a></p>
<p>下面那个评论中的小伙伴解释的特别好！</p>
</blockquote>
<p>根据丑数的定义，我们可以得到<strong>丑数的递推性质</strong>：新的丑数可以由现有的丑数序列（排好序）乘以2、3、5得到。</p>
<p>在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, …, n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，</p>
<p>比如如果按照这样的顺序排列下去肯定有问题[1<em>2, 1</em>3, 1<em>5, 2</em>2, 2<em>3, 2</em>5, 3<em>2, 3</em>3, 3<em>5, … , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3</em> 3, n2 *  5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面，  后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。</p>
<p>关键在于怎么让得到的丑数序列是有序的，我们知道当序列中已经有n个丑数的情况下，后面的丑数是由现有序列中的丑数乘以2、3、5得来的，我们要先取得到的丑数中的最小值作为第n+1个丑数，这个丑数有可能是：</p>
<ul>
<li>前面序列中第M1个丑数乘以2</li>
<li>前面序列中第M2个丑数乘以3</li>
<li>前面序列中第M3个丑数乘以5</li>
</ul>
<p>也就是说，我们要取这三种途径中值最小的那个数，这个值就是新得到的丑数中的最小值。为保证每个数都能与2,3,5相乘，我们可以通过设置3个索引a, b, c，分别记录当前位置的丑数有没有与2,3,5相乘，每次循环通过以a,b,c为索引乘以相应的2,3,5得到新的丑数，取这三种途径的最小值。</p>
<p>我们模拟丑数序列的产生过程，<strong>重点是a,b,c分别指示该位置的丑数是不是已经与2,3,5相乘：</strong></p>
<img src="/2021/01/28/%E5%89%91%E6%8C%87offer-49/图片.png" style="zoom:80%;">

<p>对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道），  第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2，  第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。</p>
<p>求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5，  通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第  b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b  个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;</p>
<p>但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5，  说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数,  只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if,  这样才不会把应该加一的计数器漏掉</p>
<p>经过n次循环，就能得到第n 个丑数了。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];  <span class="comment">// 使用dp数组来存储丑数序列</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// dp[0]已知为1</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;    <span class="comment">// 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数</span></span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2)&#123;</span><br><span class="line">                a++; <span class="comment">// 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3)&#123;</span><br><span class="line">                b++; <span class="comment">// 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5)&#123;</span><br><span class="line">                c++; <span class="comment">// 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>假期的阶段性总结</title>
    <url>/2021/01/31/%E5%81%87%E6%9C%9F%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>研二的假期比往常来的稍早那么一些，回家的第二十一天，这段时间的学习效率是大打折扣，算是刚刚连抄带蒙地“刷完了”《剑指offer》里面的困难题暂时不准备刷，一部分因为懒，一部分因为菜。我属于是那种将就起来就会放飞自我的人哈哈，还是要梳理一下自己的进度，正视问题刺激一下自己才行。</p>
<h1 id="·-刷题方面"><a href="#·-刷题方面" class="headerlink" title="· 刷题方面"></a>· 刷题方面</h1><p>《剑指offer》刷完，共69道题，后面刷的一部分题勉强写了点题解：</p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-29/#more">顺时针打印矩阵</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-49/#more">丑数</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-38/#more">字符串的排列</a></p>
<p><a href="https://eudemonia.tech/2021/01/28/%E5%89%91%E6%8C%87offer-66/#more">构建乘积数组</a></p>
<p><a href="https://eudemonia.tech/2021/01/27/%E5%89%91%E6%8C%87offer-45/#more">把数组排成最小的数</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-13/#more">机器人的运动范围</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-04/#more">二维数组中的查找</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">扑克牌中的顺子</a></p>
<p><a href="https://eudemonia.tech/2021/01/25/%E5%89%91%E6%8C%87offer-61/#more">矩阵中的路径</a></p>
<p><a href="https://eudemonia.tech/2021/01/19/%E5%89%91%E6%8C%87offer-34/#more">二叉树中和为某一值的路径</a></p>
<p>前面的题解以word文档的形式保存了，那时候还没有这个博客，后面打算二刷剑指的时候补齐。</p>
<p>下面开始刷LeetCode热题100，还是每天两道，坚持写题解，头年再刷二十道左右。</p>
<h1 id="·-校园商城项目"><a href="#·-校园商城项目" class="headerlink" title="· 校园商城项目"></a>· 校园商城项目</h1><p>慕课看到了第四章的商铺注册也就是前端的页面设计部分，还在项目1.0版本，用的是SSM框架，后面大体结构搭建起来了，但是很多细节自己并不清楚，打算再看看后面做的过程中对项目的理解情况，不行真得从头再刷一遍，有篇文章值得看一看，对项目整理架构的理解有帮助，<a href="https://www.jb51.net/article/127829.htm">点这里查看</a>。</p>
<p>每天晚上的时间都用来搞这个，进度要赶一赶了，年前争取项目1.0这块做的差不多了得。</p>
<h1 id="·-计算机网络"><a href="#·-计算机网络" class="headerlink" title="· 计算机网络"></a>· 计算机网络</h1><p>按照大佬的学习路线看王道考研视频，看完了传输层的部分，打算看完了这块之后开始结合面经学习。大佬说这个考研视频讲的偏重于前面的部分，实际面经中考点在后面的部分。</p>
<p>最多两天看完，打算用这部分时间写写论文，之后再背面经。</p>
<h1 id="·-GitHub个人博客"><a href="#·-GitHub个人博客" class="headerlink" title="· GitHub个人博客"></a>· GitHub个人博客</h1><p>大概一周的时间，自己学着做了一个个人博客，想写点东西，当个自己的学习笔记，或者是生活日记什么的。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>最小栈</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a></p>
</blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java中的栈推荐用Deque双端队列来实现，效率比Stack 要高，其相关函数有：</p>
</blockquote>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E6%96%B9%E6%B3%95.png"></p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的难点在于将min函数从O（n）降为O（1），要得到栈A中的最小值首先想到的是用一个成员变量min来保存这个最小值，但是当栈中的该值弹出时，就没有办法得到次小值，因此仅用一个成员变量是不够的。</p>
<p>所以想到使用辅助栈B，将最小元素（置于栈顶）和次小元素都存储起来，使其非严格降序，每次栈A中弹出元素都要跟B栈中的栈顶元素值比较，若相等则使用pop（）函数弹出，否则不执行弹出。查看最小元素时使用peek（）函数。<a href="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png">如图所示：</a></p>
<p><img src="/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-155/2021-02-02-LeetCode%E7%83%AD%E9%A2%98100-155%5C%E5%9B%BE%E7%89%87.png"></p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; A;</span><br><span class="line">    Deque&lt;Integer&gt; B;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    B=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        A.push(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty() || B.peek() &gt;= x)<span class="comment">//B.empty（）对应最开始或者后面B栈中没有元素时，新压入的元素就是最小值要压入B中，当B中有元素时，新压入A栈的元素要与B中的元素比较，如果小于等于就压入B，这里等于号=很重要，因为当A栈中两个2相连压入时，就要在B中也有两个2对应，否则A中一个2弹出，也会将B中2弹出，这样会造成查询到的最小值不等于2。</span></span><br><span class="line">            B.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))&#123;<span class="comment">//判断A中弹出的值与B中栈顶的值（最小值）是否相等，若相等也将B中栈顶元素弹出。</span></span><br><span class="line">                                     <span class="comment">//因为栈中存储的是int的包装类Integer，因此只能用equals()方法，不能用“==”</span></span><br><span class="line">        B.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-94/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a></p>
</blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p><strong>中序遍历：</strong>先中序遍历左子树，<strong>再访问根节点</strong>，再中序遍历右子树</p>
<p><strong>核心就是：</strong>根节点必须在左节点弹出之后，再弹出</p>
<p><strong>方法一：</strong>递归遍历</p>
<p><strong>方法二：</strong>辅助栈法（非递归遍历）</p>
<p>每到一个节点 A，因为根的访问在中间，将 A 入栈。然后<strong>先遍历左子树</strong>，接着访问 A（A出栈），最后遍历右子树。这样保证根节点在左子树后面被访问，右子树在根节点后面被访问。</p>
<p>在访问完 A 后，A 就可以出栈了。因为 A 和其左子树都已经访问完成。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>方法一：</strong>递归遍历</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           inorder(root);</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法二：</strong>辅助栈法（非递归遍历）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stk.isEmpty()) &#123;<span class="comment">//1.root!=null 2.root==null但辅助栈中有元素，对应左子树访问完</span></span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;<span class="comment">//每到一个节点，先去遍历左子树，只要它的左子树存在，就将该节点压入栈，直到有一个节点的左                                   //子树不存在为止，也就是它就是最左边的节点</span></span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();<span class="comment">//1.root!=null表示到了最左边的节点，弹出栈访问</span></span><br><span class="line">                             <span class="comment">//2.root==null但辅助栈中有元素，对应左子树访问完,也就是上一轮的root.right==null，此时的栈                              //顶元素就对应的该左子树的根节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;<span class="comment">//访问该节点的右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2021/02/02/LeetCode%E7%83%AD%E9%A2%98100-20/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>
</blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>分析题目可知，指针的指向实际上有两种情况：</p>
<ul>
<li>指向的字符为左括号</li>
<li>指向的字符为右括号</li>
</ul>
<p>要将所有的括号配对，也就是我们遇到左括号时，并不知道有没有右括号与之对应，因此先将左括号存储到一个栈中，并且遇到右括号时要将容器中对应的左括号出栈，最后栈中没有元素时，说明配对成功，返回true。</p>
<p><strong>改进：</strong>可以遇到左括号时将相应的右括号入栈，这样可以在遇到右括号时，只需要判断是否相等即可</p>
<p>在程序中，只要遇到不满足条件的情况，提前结束循环，返回false。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack=<span class="keyword">new</span> ArrayDeque&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty()||c!=stack.pop())<span class="comment">//该情况对应于栈为空，但是来了一个右括号的情况，或者不相等的情况，                                                     //直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-算法思想"><a href="#·-算法思想" class="headerlink" title="· 算法思想"></a>· 算法思想</h1><h2 id="·-堆的概念"><a href="#·-堆的概念" class="headerlink" title="· 堆的概念"></a>· 堆的概念</h2><p><strong>堆：</strong>通常可以看成是一个完全二叉树的<strong>数组</strong>。（堆排序实际上是堆中元素的交换，因此可以用数组实现，并且数组的查询和修改效率比较高，能够提高性能）</p>
<p><strong>堆的两种形式：</strong></p>
<ul>
<li>大顶堆：根节点<strong>大于</strong>左右孩子的节点</li>
<li>小顶堆：根节点<strong>小于</strong>左右孩子的节点</li>
</ul>
<h2 id="·-构造堆"><a href="#·-构造堆" class="headerlink" title="· 构造堆"></a>· 构造堆</h2><p><strong>1、二叉树堆结构中元素与数组堆结构中元素的对应关系：</strong>（大小顶堆一样的）</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片.png" style="zoom:150%;">

<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:150%;">

<p>那么对于某一个节点index，它的左右孩子在数组中的下标分别为：</p>
<ul>
<li>Left=index*2+1</li>
<li>Right=index*2+2</li>
</ul>
<p>叶子结点和非叶子节点的区别：</p>
<ul>
<li>非叶子节点的下标&lt;节点个数/2-1</li>
<li>叶子节点的下标&gt;节点个数/2-1</li>
</ul>
<p><strong>2、大顶堆的维护（核心）</strong></p>
<p><strong>自下而上</strong>地维护一个大顶堆，使其满足大顶堆的性质：非叶子节点的左右孩子都小于它的根节点</p>
<p>维护分为初始化时大顶堆的维护和初始化后大顶堆的维护：</p>
<ul>
<li>刚开始将待排序数组中的前k个元素复制到堆结构中的数组中，并调用HeapAdjust（）方法，<strong>从非叶子节点开始，自下而上地维护</strong>；</li>
<li>而对于新插入的剩下的n-k个元素，只有当元素小于大顶堆的根节点时，才会移除根节点，并将该元素加入大顶堆。因此除了0号元素可能不满足大顶堆的性质外，它的下层的非叶子节点都满足性质，所以<strong>维护的实质是：</strong>维护index=0的情况。</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] input = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        result = HeapSort(input, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : result) &#123;</span><br><span class="line">            System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; input.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//用数组来模拟k个节点的堆结构</span></span><br><span class="line">        System.arraycopy(input, <span class="number">0</span>, a, <span class="number">0</span>, k);<span class="comment">//初始化堆中的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//k就是我们要维护的堆结构的节点下标</span></span><br><span class="line">            HeapAdjust(i, a, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; input.length; i++) &#123;<span class="comment">//遍历剩余的n-k个元素</span></span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; a[<span class="number">0</span>]) &#123;</span><br><span class="line">                a[<span class="number">0</span>] = input[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, a, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将大顶堆中的元素进行升序操作</span></span><br><span class="line"><span class="comment">//        for (int i = a.length - 1; i &gt; 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//            //分为两个过程：1.交换 2.通过减小节点的个数来固定最大的元素</span></span><br><span class="line"><span class="comment">//            int temp = a[i];</span></span><br><span class="line"><span class="comment">//            a[i] = a[0];</span></span><br><span class="line"><span class="comment">//            a[0] = temp;</span></span><br><span class="line"><span class="comment">//            HeapAdjust(0, a, i);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数功能就是维护每一个节点的大顶堆性质</span></span><br><span class="line"><span class="comment">    index 节点的下标</span></span><br><span class="line"><span class="comment">    a 堆结构</span></span><br><span class="line"><span class="comment">    length 堆结构的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];<span class="comment">//temp保存当前位置的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt; a[x]) &#123;<span class="comment">//取出当前节点的左右孩子的最大值</span></span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;<span class="comment">//更新index的值，index代表的是temp的值最终在堆中的位置，index和x的关系其实就是根节点和子节点的关系</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//由于我们是从下往上维护的，当index=0的节点满足性质后，就没有更新的必要了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;<span class="comment">//index代表的是temp的值最终在堆中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>代码运行的结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">40 30 20 10 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><p>堆排序用于解决<strong>TOPK</strong>类问题</p>
<blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></strong></p>
<p>这里还对代码进行了优化，不用建立新数组，用给定数组直接作为堆结构数组</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, nums, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, nums, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &lt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &lt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof"><strong>剑指offer-40.最小的K个数</strong></a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HeapAdjust(i, arr, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[<span class="number">0</span>]) &#123;</span><br><span class="line">                arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">                HeapAdjust(<span class="number">0</span>, arr, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        System.arraycopy(arr,<span class="number">0</span>,res,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] a, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = index * <span class="number">2</span> + <span class="number">1</span>; x &lt; length; x = x * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; length &amp;&amp; a[x + <span class="number">1</span>] &gt;= a[x]) &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt;= temp) &#123;</span><br><span class="line">                a[index] = a[x];</span><br><span class="line">                index = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="·-通过优先队列实现堆排序"><a href="#·-通过优先队列实现堆排序" class="headerlink" title="· 通过优先队列实现堆排序"></a>· 通过优先队列实现堆排序</h1><h2 id="·-补充内容"><a href="#·-补充内容" class="headerlink" title="· 补充内容"></a>· 补充内容</h2><p><strong>1、匿名内部类：</strong>前提是存在一个类或者接口，这里的类可以是具体类也可以是抽象类</p>
<blockquote>
<p><strong>格式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名()&#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Inter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、PriorityQueue（优先队列）</strong></p>
<p>优先级队列的元素按照自然排序进行排序，或者根据构造队列时提供的<strong>Comparator（比较器）</strong>进行排序，具体取决于所使用的构造方法。优先级队列不允许使用null元素，依靠自然排序的优先级队列还不允许插入不可比较的对象（这样容易导致ClassCastException）。</p>
<p><strong>队列的头</strong>相当于堆的<strong>根节点</strong></p>
<blockquote>
<p><strong>构造方法：</strong></p>
<p><strong>a.无Comparator参数：</strong>默认自然排序，实现小顶堆；</p>
<p><strong>b.传入Comparator：</strong>重写里面的compare方法，实现大顶堆。<strong>（常用）</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据自然排序对元素排序</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue(<span class="keyword">int</span> initialCapacity,Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span><br><span class="line"><span class="comment">//使用指定的初始容量创建一个PriorityQueue，并根据指定的比较器对元素排序</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>范例：</strong>（第二个构造方法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1,Integer o2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> o2-o1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回0：o1等于o2，是同一元素</span></span><br><span class="line"><span class="comment">返回正数：认为o2大于o1，让o2排在更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">返回负数：认为o2小于o1，让o2排在远离队列头部的位置</span></span><br><span class="line"><span class="comment">这样就构成了大顶堆，相反当返回的是o1-o2时，比如返回正数，仍然认为o2大于o1，让小数o2排在了更靠近队列头部的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="·-相关题目-1"><a href="#·-相关题目-1" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></strong></p>
</blockquote>
<h2 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h2><p>借助 <strong>哈希表</strong> 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</p>
<p>通过比较器指定排序规则，即频率越高的元素越靠近队列的头部，排序过程如下图所示：</p>
<img src="/2021/02/02/%E5%A0%86%E6%8E%92%E5%BA%8F/图片2.png" style="zoom: 120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; requence=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(requence.containsKey(num))&#123;</span><br><span class="line">            requence.put(num,requence.get(num)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            requence.put(num,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;(k,<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer num1,Integer num2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> requence.get(num1)-requence.get(num2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:requence.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//当队列中元素个数小于k时，向队列中添加元素，先将队列中元素增加到k个</span></span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(requence.get(num)&gt;requence.get(pq.peek()))&#123;<span class="comment">//当队列中头部元素大于HashMap中频率时，先将头部弹出，再向队列中添加出现频率更高的元素</span></span><br><span class="line">            pq.poll();</span><br><span class="line">            pq.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        res[i]=pq.poll();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解码</title>
    <url>/2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-394/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/decode-string">https://leetcode-cn.com/problems/decode-string</a></p>
</blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s &#x3D; &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>这道题我看到总结的比较好的一句话：数字放在数字栈，字符串放在字符串栈，右括号弹出一个数字栈中的数字，字符串栈弹到0为止。</p>
</blockquote>
<p>在遍历一个编码字符串时我们遇到的字符有以下几种情况：（数字栈：nums         字符串栈：ss）</p>
<p>数字——括号内字符串的重复次数</p>
<p>普通字母——拼接到res中</p>
<p>左括号’[‘——当我们遇到左括号时：</p>
<ul>
<li>先将存储数字的变量num加入数字栈nums中</li>
<li>说明括号内的字符串要重复num次，然后与括号外面的字符串拼接，因此我们先将左括号左边的res转换成字符串压入字符串栈ss中</li>
<li>另res和数字num重新计数（因为括号中还可能套括号，比如a3[a2[c]]，就是先将最外层的res=a存到字符串栈ss中，数字num=3存到数字栈nums中，将res和num置零后，再将第一层括号的res=a存到字符串栈ss中，数字num=2存到数字栈nums中）</li>
</ul>
<p>右括号’]’——当我们遇到右括号时：（说明最内层字符串记录结束，存于res中）</p>
<ul>
<li>从数字栈nums中弹出栈顶的数字，这个数就是这一层括号前面记录重复次数的数字，将res中的字符串重复curnum次，存到StringBuilder类型的temp中</li>
<li>再弹出一个ss栈顶的字符串，这个字符串就是括号之前的字符串，将它与temp拼接起来，再用res保存，用于遇到下一个右括号时，这个res就是该括号内要重复的字符串（比如a3[a2[c]]，当遇到第一个右括号时，将数字栈中的2弹出，将res=c循环拼接3次，也就是拼成temp=cc，再将字符串栈ss中的a弹出，与temp拼接成res=acc，之后遇到第二个右括号，temp=accaccacc，再与a拼接成res=aaccaccacc）</li>
</ul>
<p>最后编码字符串遍历结束，返回res</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      LinkedList&lt;Integer&gt; nums=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      LinkedList&lt;String&gt; ss=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">      StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span>(Character c : s.toCharArray())&#123;</span><br><span class="line">          <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">              num=num*<span class="number">10</span>+Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">             nums.add(num);</span><br><span class="line">             ss.add(res.toString());</span><br><span class="line">             res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">             num=<span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">             StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">             <span class="keyword">int</span> curNum = nums.removeLast();</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curNum; i++) &#123;</span><br><span class="line">                 temp.append(res);</span><br><span class="line">             &#125;</span><br><span class="line">             res = <span class="keyword">new</span> StringBuilder(ss.removeLast() + temp);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">              res.append(c);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res.toString(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2021/02/04/LeetCode%E7%83%AD%E9%A2%98100-739/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a></p>
</blockquote>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<blockquote>
<p><strong>提示：</strong>气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
</blockquote>
<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>这个题我们需要借助<strong>递减栈</strong></p>
<p>当给定数组为： [73, 74, 75, 71, 69, 72, 76, 73]时，我们来模拟函数的运行过程</p>
<p>遍历数组（入栈操作时我们加入栈的是<strong>元素的下标</strong>，这样我们后面能够根据弹出的元素下标填入等待的天数）</p>
<p>元素73对应的下标压入栈中，</p>
<p>元素74，这时栈不为空，要用74跟栈顶的元素来比较，当它大于栈顶的元素时，要将栈顶的元素弹出，并且将此时的元素下标x减去弹出元素的index就是该位置的温度再等几天能够观测到更高温，这里弹出73，将2-1=1加入res数组中下标0的位置，</p>
<p>元素75，同元素74，</p>
<p>元素71，小于栈顶元素75，直接压入栈中，</p>
<p>元素69，同元素71，</p>
<p>元素72，大于69，弹出69，并将5-4=1填入res数组下标4对应的位置，大于71，将71弹出，将5-3=2填入res数组下标3对应位置，小于75，循环结束，将72压入栈中，</p>
<p>然后以此类推……</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;T[i]&gt;T[stack.peek()])&#123;</span><br><span class="line">           <span class="keyword">int</span> index=stack.pop();</span><br><span class="line">           res[index]=i-index;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2021/02/04/%E5%89%91%E6%8C%87offer-16/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof</a></p>
</blockquote>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><blockquote>
<p>本题的重点在于理解<strong>“快速幂法”</strong>为什么能把时间复杂度降低到<strong>log2n</strong></p>
</blockquote>
<p>求 x^n最简单的方法是通过循环将 n 个 x 乘起来，依次求x^1, x^2, …, x^{n-1}，直到求出x^n时间复杂度为 O(n) 。例如我们输入的幂次exponent为32，我们要求base的32次方就要在程序中对base乘31次。但是如果我们通过base的2次方求base的4次方接着求base的8次方，16次方，32次方，这样就能将循环次数降为对数级。我们可以通过以下公式来求得a的n次方：</p>
<p>我们设循环中的变量为i，初始值为n</p>
<p><strong>当i=n时：</strong><br>$$<br>{a^i} =<br>        \begin{cases}<br>        {a^{i/2}}·{a^{i/2}}    &amp; \text{如果 $i$ 为偶数}\<br>        {a^{i/2}}·{a^{i/2}}·a  &amp; \text{如果 $i$ 为奇数}<br>        \end{cases}<br>$$<br><strong>当i=n/2时：</strong>仍然按照上面的公式判断i的奇偶，求得a的i次方……</p>
<p>通过一个for循环，每次将幂次除以2，最终可以以O(log2n)的时间复杂度求得a的n次方，因为2^x=n,x=log2n,也就是循环x=log2n次。</p>
<blockquote>
<p>理解了快速幂法之后，下面是解题的流程：</p>
</blockquote>
<ul>
<li>当底数为0时没有意义，直接返回</li>
<li>当指数为负数时，将底数变为1/x，负数变为正数（转换成了常规的指数为正数的情况）</li>
<li>当指数为正数时，按照上面的公式求解</li>
</ul>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> b=n;</span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        b=-b;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>代码中有两处注意点：</strong></p>
</blockquote>
<ol>
<li>用long类型的b去暂存n的值，因为int类型的负数范围比正数大1，这样做为了防止另n=-n时溢出</li>
<li>用指数的二进制形式来判断奇偶，并用移位来代替幂次每循环一次除以2，能够提高运算效率</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换成整数</title>
    <url>/2021/02/04/%E5%89%91%E6%8C%87offer-67/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a></p>
</blockquote>
<p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<blockquote>
<p><strong>注意：</strong>假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>当我们遍历给定的字符串时，当前的字符串有下面几种可能：</p>
<ul>
<li><p><strong>空格</strong>——跳过</p>
</li>
<li><p><strong>其它字符</strong>——循环遍历结束</p>
</li>
<li><p><strong>正负号</strong>——存储到flag变量中，后面再拼接到结果中</p>
</li>
<li><p><strong>数字字符：</strong></p>
<p>对数字字符要进行转换和拼接工作</p>
<p><strong>转换：</strong>将数字字符减去字符’0’，得到数字的值</p>
<p><strong>拼接：</strong>前一位得到的数字应该在高位，所以拼接公式为*<em>res=res</em>10+c**</p>
</li>
</ul>
<p>在对数字进行拼接工作时，要<strong>预判</strong>得到的结果是不是发生了越界，之所以要进行预判是因为得到的结果可能很大，不能确定用什么样类型的变量来接收这个结果。Java中int类型的数值范围为 [−231,  231 − 1]，也就是<strong>2147483647</strong>，要在进行本轮的拼接时，判断结果是否会发生越界，也就是上一轮的结果要小于<strong>214748364</strong>或者等于<strong>214748364</strong>且本轮的数值<strong>c</strong>小于等于7，这样按照公式*<em>res=res</em>10+c**拼接时才不会发生越界，当出现越界时直接返回题目要求的结果。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bndry = Integer.MAX_VALUE/<span class="number">10</span>;<span class="comment">//边界值</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>;<span class="comment">//符号位</span></span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>;<span class="comment">//定位第一个非空格字符</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span>(str.charAt(first)==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//去除多余的空格</span></span><br><span class="line">        first++;</span><br><span class="line">        <span class="keyword">if</span>(first==str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>) flag=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(str.charAt(first)==<span class="string">&#x27;-&#x27;</span>||str.charAt(first)==<span class="string">&#x27;+&#x27;</span>) first++;<span class="comment">//如果第一个非空格字符为正负号时，保存到flag，且first++</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=first;i&lt;str.length();i++)&#123;<span class="comment">//拼接数字字符</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i)&lt;<span class="string">&#x27;0&#x27;</span>||str.charAt(i)&gt;<span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//遇到非数字字符，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(res&gt;bndry||(res==bndry&amp;&amp;str.charAt(i)&gt;<span class="string">&#x27;7&#x27;</span>)) &#123;<span class="comment">//预判结果是否越界</span></span><br><span class="line">            <span class="keyword">return</span> flag==<span class="number">1</span>? Integer.MAX_VALUE : Integer.MIN_VALUE;&#125;</span><br><span class="line">        res=res*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);<span class="comment">//不越界的情况下，拼接数字字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><p><strong>归并排序的递归实现：</strong>就是将含有<strong>n</strong>个记录的序列不断从<strong>中间划分</strong>成长度为<strong>2</strong>或<strong>1</strong>的序列，然后<strong>两两归并</strong>。不断归并，直到得到一个长度为<strong>n</strong>的有序序列为止，这种排序方法也称为<strong>2路归并排序</strong>。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片.png">

<p>下面模拟一遍<strong>递归</strong>方法实现的归并排序：</p>
<p>设输入的序列为：[50,10,90,30,70,40,80,60,20]</p>
<p>调用Msort函数，传入待排序数组SR，和结果数组TR1，左下标l=0，右下标r=8；</p>
<p><strong>Msort函数：</strong>利用m将数组SR分成两部分，左半部分[50,10,90,30,70]，右半部分[40,80,60,20];</p>
<p>​                       左边部分接着划分为[50,10,90]和[30,70]</p>
<p>​                       [50,10,90]继续划分为[50,10]和[90]</p>
<p>​                       [50,10]划分为[50]和[10]</p>
<p>​                        右边部分略</p>
<p><strong>Merge函数：</strong>先是单个元素的两两归并，接着对越来越长的数组归并</p>
<p>​                       左边部分[50]和[10]组成TR2=[50,10]排序后存到TR1=[10,50]</p>
<p>​                        [10,50]和[90]组成的数组TR2=[10,50,90]排序后存到TR1=[10,50,90]</p>
<p>​                        [10,50,90]和[30,70]组成的数组TR2=[10,50,90,30,70]以m=2为分隔点，[10,50,90]作为左边部分，[30,70]作为右边部分，                    从元素10和元素30开始比较小的元素存入数组TR1，直到左边或右边部分结束，再将剩下的元素存入TR1</p>
<p>​                        右边部分略</p>
<h2 id="迭代实现（从底至顶直接合并）"><a href="#迭代实现（从底至顶直接合并）" class="headerlink" title="迭代实现（从底至顶直接合并）"></a>迭代实现（从底至顶直接合并）</h2><p><strong>归并排序的迭代实现：</strong>就是将待排序集合<strong>一分为二</strong>，直到待排序集合只剩下 1 个元素为止 。 然后<strong>不断合并2个排好序的数组段</strong>。</p>
<p><strong>迭代：</strong>通过迭代的方式我们可以省去一分为二的过程，用合并算法直接将它们排序，构成n/2组长度为2的排序序的数组段，然后再将它们排序成长度为4的排好序的子数组段。如此继续，直到整个数组排好序。如图所示：</p>
<img src="/2021/02/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/图片1.png" style="zoom:80%;">

<ul>
<li>从归并段的长度为1开始，一次使用归并段的长度变为原来的2倍；</li>
<li>在每趟归并的过程中，要注意处理归并段的长度为奇数和最后一个归并段和之前不等的情况，需要进行处理</li>
</ul>
<h1 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h1><blockquote>
<p><strong>递归方式：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] TR1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">        Msort(SR, TR1, <span class="number">0</span>, SR.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : TR1) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    数组SR：待排序的数组</span></span><br><span class="line"><span class="comment">    TR1：每次将SR数组中下标l,r范围内的数字排好序放入TR1中</span></span><br><span class="line"><span class="comment">    l,r分别表示SR数组中的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Msort</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m;<span class="comment">//分隔待排序的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] TR2 = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];<span class="comment">//暂存待排数组左右两部分排序好的数组</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            TR1[l] = SR[r];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;<span class="comment">//将待排范围的数组从中间分开</span></span><br><span class="line">            Msort(SR, TR2, l, m);<span class="comment">//右半部分递归调用函数Msort</span></span><br><span class="line">            Msort(SR, TR2, m + <span class="number">1</span>, r);<span class="comment">//左半部分递归调用函数Msort</span></span><br><span class="line">            Merge(TR2, TR1, l, m, r);<span class="comment">//对TR2中的两部分数组归并排序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 20 30 40 50 60 70 80 90 </span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>迭代方式实现：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] SR = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">1000</span>, <span class="number">1100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[SR.length];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; SR.length) &#123;</span><br><span class="line">            MergePass(SR, res, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">            MergePass(res, SR, k, SR.length - <span class="number">1</span>);</span><br><span class="line">            k = k * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] SR, <span class="keyword">int</span>[] TR, <span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//从第一个元素开始合并大小为s的相邻2段子数组</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">2</span> * s - <span class="number">1</span> &lt;= n) &#123;<span class="comment">//i+2*s 要小于等于数组长度，也就是说未合并的元素个数要大于2*s</span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, i + <span class="number">2</span> * s - <span class="number">1</span>);</span><br><span class="line">            i = i + <span class="number">2</span> * s;</span><br><span class="line">        &#125;<span class="comment">//此循环执行的次数为： n+1/(2*s) 次</span></span><br><span class="line">        <span class="keyword">if</span> (i + s - <span class="number">1</span> &lt; n) &#123;<span class="comment">//未合并的元素个数大于 1*s </span></span><br><span class="line">            Merge(SR, TR, i, i + s - <span class="number">1</span>, n);<span class="comment">//合并最后两个序列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//未合并的元素个数小于 1*s，直接复制到y就行了</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt;= n; j++) &#123;</span><br><span class="line">                TR[j] = SR[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Merge方法将有序的TR2[l...m]和TR2[m+1...r]归并为有序的TR1[l...r]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>[] TR2, <span class="keyword">int</span>[] TR1, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l指向TR2前半段</span></span><br><span class="line"><span class="comment">        j指向TR2后半段</span></span><br><span class="line"><span class="comment">        k作为TR1数组的下标</span></span><br><span class="line"><span class="comment">        i将剩余元素复制到数组TR1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="comment">//数组TR2的左右两部分，直到有一部分进入TR1数组，退出循环</span></span><br><span class="line">        <span class="keyword">for</span> (k = l, j = m + <span class="number">1</span>; l &lt;= m &amp;&amp; j &lt;= r; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (TR2[l] &lt; TR2[j]) &#123;</span><br><span class="line">                TR1[k] = TR2[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TR1[k] = TR2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后面将TR2中剩余部分的元素复制到TR1数组</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - l; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[l + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - j; i++) &#123;</span><br><span class="line">                TR1[k + i] = TR2[j + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>程序执行结果：同上</strong></p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/sort-list">热题100-148.排序链表</a></strong></p>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>这道题对两个子序列归并的部分与数组是不同的</strong></p>
</blockquote>
<h2 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        ListNode resNode=<span class="keyword">new</span> ListNode();</span><br><span class="line">        resNode.next=head;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;length)&#123;</span><br><span class="line">            MergePass(resNode,k,length);</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergePass</span><span class="params">(ListNode resNode,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = resNode, curr = resNode.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = mergeTwoLists(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;<span class="comment">//合并两个排序链表</span></span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-148/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a></p>
</blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p><strong>进阶：</strong>请在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入：head = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题使用的排序算法为归并排序算法，由于递归实现归并排序的空间复杂度较高，所以我选择非递归方式来实现归并排序算法，避免了递归调用函数使用的栈空间，提高了效率。</p>
<p>详细思路请看主页的归并排序算法。</p>
<p><strong>具体做法如下：</strong>（来自LeetCode官方题解：<a href="https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/%EF%BC%89">https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/）</a></p>
<ul>
<li><p>用 k 表示每次需要排序的子链表的长度，初始时 k=1。（也就是<strong>归并排序中的步长</strong>）</p>
</li>
<li><p>每次将链表拆分成若干个长度为 k 的子链表（最后一个子链表的长度可以小于 k），按照每两个子链表一组进行合并，合并后即可得到若干个长度为 k×2的有序子链表（最后一个子链表的长度可以小于 k×2）。合并两个子链表仍然使用「21. 合并两个有序链表」的做法。</p>
</li>
<li><p>将 k 的值加倍，重复第 2 步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于链表长度，整个链表排序完毕。</p>
</li>
</ul>
<p>如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。</p>
<p>初始时 k=1，每个长度为 1的子链表都是有序的。</p>
<p>如果每个长度为 k 的子链表已经有序，合并两个长度为 subLength\textit{subLength}subLength 的有序子链表，得到长度为 k×2 的子链表，一定也是有序的。</p>
<p>当最后一个子链表的长度小于 k 时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。</p>
<p>因此可以保证最后得到的链表是有序的。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><blockquote>
<p><strong>着重看MergePass方法中的内容</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">        ListNode resNode=<span class="keyword">new</span> ListNode();</span><br><span class="line">        resNode.next=head;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;length)&#123;</span><br><span class="line">            MergePass(resNode,k,length);</span><br><span class="line">            k*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MergePass</span><span class="params">(ListNode resNode,<span class="keyword">int</span> k,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        ListNode prev = resNode, curr = resNode.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode head1 = curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode head2 = curr.next;</span><br><span class="line">                curr.next = <span class="keyword">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k &amp;&amp; curr != <span class="keyword">null</span> &amp;&amp; curr.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode merged = mergeTwoLists(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-56/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p>题目来自于LeetCode：<a href="https://leetcode-cn.com/problems/merge-intervals">https://leetcode-cn.com/problems/merge-intervals</a></p>
</blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>两个区间的关系有三种：区间有交集、区间重叠、区间无交集。如图所示：</p>
<img src="/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-56/图片.png" style="zoom: 50%;">

<p>我们可以先对区间的左端点进行排序，如果区间可以合并的话那么排序之后它们应该是连续的，先将第一个区间加入到结果数组res，按排序后的顺序考虑后面的区间。</p>
<p><strong>可以跟前一个区间合并的条件为：</strong></p>
<p>区间符合图中1、2情况，<strong>即前一个区间的右端点大于等于该区间的左端点</strong>，此时我们要更新结果数组中区间的右端点值为该区间和结果数组中区间右端点的较大值，然后接着顺序比较后面的区间。</p>
<p><strong>不能合并的条件为：</strong></p>
<p>如果<strong>当前区间的左端点在结果数组中最后一个区间的右端点之后</strong>，那么它们不会重合，我们可以直接将这个区间加入结果数组的末尾。</p>
<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] interval1, <span class="keyword">int</span>[] interval2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">0</span>] - interval2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 遍历区间</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">            <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">            <span class="keyword">if</span> (idx == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[idx][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++idx] = interval;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反之将当前区间合并至结果数组的最后区间</span></span><br><span class="line">                res[idx][<span class="number">1</span>] = Math.max(res[idx][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-21/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-题目描述"><a href="#·-题目描述" class="headerlink" title="· 题目描述"></a>· 题目描述</h1><blockquote>
<p><strong>题目来自于LeetCode：</strong><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a></p>
</blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<h1 id="·-解题思路"><a href="#·-解题思路" class="headerlink" title="· 解题思路"></a>· 解题思路</h1><p>本题的实质就是<strong>归并排序中的归并两个子序列</strong></p>
<p>首先，我们设定一个哨兵节点 res ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 head指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p>
<img src="/2021/02/08/LeetCode%E7%83%AD%E9%A2%98100-21/图片.png" style="zoom:150%;">

<h1 id="·-代码及注解"><a href="#·-代码及注解" class="headerlink" title="· 代码及注解"></a>· 代码及注解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;<span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>LeetCode热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="常见的位运算操作"><a href="#常见的位运算操作" class="headerlink" title="常见的位运算操作"></a>常见的位运算操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a=a^0</p>
<p>0=a^a</p>
<p>由上面两个推导出：a=a^b^b（与同一个数异或运算两次还是这个数本身）</p>
<h2 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h2><p>a=a^b</p>
<p>b=a^b</p>
<p>a=a^b</p>
<h2 id="移除最后一个1"><a href="#移除最后一个1" class="headerlink" title="移除最后一个1"></a>移除最后一个1</h2><p>a=n&amp;(n-1)</p>
<h2 id="获取最后一个1"><a href="#获取最后一个1" class="headerlink" title="获取最后一个1"></a>获取最后一个1</h2><p>diff=(n&amp;(n-1))^n</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/hamming-distance/">热题100-461. 汉明距离</a></strong></p>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和y，计算它们之间的汉明距离。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>异或操作当两个操作数的二进制位置不同时为1，对两个数进行异或操作就得到了两个数二进制不同位置的数目，再对结果统计1的个数就得到了两个数的汉明距离。</p>
<p>在统计结果中1的个数时，用到了<strong>移除最后一个1</strong>的操作，不断移除最后一个1，移除几次结果中就有多少个1。</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片.png" style="zoom:110%;">

<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=x^y;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(res!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        res=res&amp;(res-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></strong></p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
</blockquote>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        n=(n-<span class="number">1</span>)&amp;n;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></strong></p>
<p>一个整型数组 nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们可以把所有数字分成两组，使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<p>记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式 xkxk−1⋯x2x1x0，其中 xi∈{0,1}，我们考虑一下 xi=0和 xi=1的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，ai和 bi的关系——xi=1 表示 ai 和 bi 不等，xi=0 表示 ai 和 bi 相等。假如我们任选一个不为 0 的 xi，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件。</p>
<p>在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足 xi=1。但是为了方便，这里的代码选取的是「不为 0 的最低位」</p>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        ret^=i;<span class="comment">//对数组中的所有数做异或运算，则得到的结果等价于对两个只出现一次的数字做异或运算，因为两个数字不同，因此做异或运算中一定是有一位为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((k&amp;ret)==<span class="number">0</span>)&#123;</span><br><span class="line">        k&lt;&lt;=<span class="number">1</span>;<span class="comment">//得到最终结果中最低位的1的位置，并依据k分组，当一个数该位是1，做与运算时不等于0，当不是1，做与运算时等于0，因为与运算需要都是1才是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>((j&amp;k)==<span class="number">0</span>)&#123;<span class="comment">//将所有数字按第n位是否为1分成两组，那么相同的数字肯定分到一组，并且两个不同的数字因为第n位不同而被分到两个组里，对两个组中的数字分别进行异或运算，相同的数字做异或运算相互抵消为0，所以最后得到的a和b就是两个只出现一次的数字</span></span><br><span class="line">            a^=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b^=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[]  result=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"><strong>剑指 Offer 56 - II. 数组中数字出现的次数 II</strong></a></p>
<p>在一个数组 nums中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路 1"></a>解题思路 1</h3><p>如果一个数字出现了三次，那么它的二进制数中每一位也是出现了三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。</p>
<p>于是创建一个长度为32的数组来保存所有数字的二进制表示的每一位的和，如果某一位的和能被3整除，那么只出现一次的数字的二进制表示中对应的位为0，否则就是1。</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解 1"></a>代码及注解 1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution56_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;<span class="comment">//本算法同样适用于数组nums中存在负数的情况（因为使用的是左移，不用考虑符号问题）</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];<span class="comment">//java int类型有32位，其中首位为符号位</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> bitMask=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//这个循环是为了统计增强for循环得到的每一个数字num中每一位上是否为1，所以bitMask需要每得到一个num就初始化一次；而且数组中的存储顺序是：索引小→大对应高位→低位</span></span><br><span class="line">                <span class="keyword">if</span>((num&amp;bitMask)!=<span class="number">0</span>) bitSum[i]++;<span class="comment">//这里判断条件不是==1（通过与运算得到的不一定是1，通过idea验证）</span></span><br><span class="line">                bitMask=bitMask&lt;&lt;<span class="number">1</span>;<span class="comment">//左移没有无符号、带符号的区别，都是在右侧补0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//从数组索引由小到大遍历得到每位上3的余数，通过res左移让高位向左，这里也避免了res右移可能引发的符号问题</span></span><br><span class="line">            res=res&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            res+=bitSum[i]%<span class="number">3</span>;<span class="comment">//这两步顺序不能变，否则最后一步会多左移一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解题思路-2（状态机）"><a href="#解题思路-2（状态机）" class="headerlink" title="解题思路 2（状态机）"></a>解题思路 2（状态机）</h3><p>解题思路：各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位1的个数，存在 3 种状态，即对 3 余数为 0,1,2。（不是0,1两种状态，当没加完有可能出现5,8等余数为2的情况），因此可以用两位二进制数表示这三种状态：00→01→10。</p>
<p>通过状态机可以得到对于三种状态输入的n为0或1时对应的真值表：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">one</th>
<th align="center">新one</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>通过真值表可以得到one的逻辑表达式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片1.png" style="zoom:80%;">

<p>逻辑表达式的化简公式：</p>
<img src="/2021/02/22/%E4%BD%8D%E8%BF%90%E7%AE%97/图片2.png" style="zoom: 67%;">

<p>同理也能得到two的逻辑表达式，注意two是要通过新的one值获得，构造真值表时要用新的one值：</p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">two</th>
<th align="center">新one</th>
<th align="center">新two</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解 2"></a>代码及注解 2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;<span class="comment">//位运算，每次通过增强for循环得到的num，按位与ones和twos的每一位做运算，得到ones中每一位的值</span></span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;<span class="comment">// 遍历完所有数字后，各二进制位都处于状态 00 和状态 01（取决于 “只出现一次的数字” 的各二进制位是 1 还是 0 ），而此两状态是由 one来记录的（此两状态下 twos 恒为 0 ），因此返回 ones 即可。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/counting-bits/">热题100-338. 比特位计数</a></strong></p>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
</blockquote>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设有一个整数：<br>$$<br>x=(1001011101)<em>2 = (605)</em>{10}<br>$$<br>我们已经计算了从 0 到 x−1 的全部结果。</p>
<p>我们知道，x 与 我们计算过的一个数只有一位之差:<br>$$<br>x=(0001011101)<em>2 = (93)</em>{10}<br>$$<br>它们<strong>只在最高有效位上不同</strong>，也就是我们可以通过在已经求得1的位数的一个数上+1来求得x。</p>
<p>得到状态转移函数：<br>$$<br>P(x+b)=P(x)+1,b=2^m&gt;x<br>$$<br>因为b每次肯定是大于x的</p>
<p>2的0次方为0001</p>
<p>2的1次方为0010</p>
<p>2的2次方为0100</p>
<p>2的3次方为1000</p>
<p>也就是每次在0到x这个范围内的数的最高位依次+1得到x到x+b这个范围内的数，而且1的位数只差刚加上的这个1，这样通过状态转移函数就能够得到x到x+b这个范围内的数的1的位数。</p>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// [0, b) 已经求得，并存在结果数组res中</span></span><br><span class="line">        <span class="keyword">while</span> (b &lt;= num) &#123;</span><br><span class="line">            <span class="comment">// 由 [0, b)得到 [b, 2b) 或者 [b, num) </span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; b &amp;&amp; i + b &lt;= num)&#123;</span><br><span class="line">                ans[i + b] = ans[i] + <span class="number">1</span>;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            i = <span class="number">0</span>;   <span class="comment">// 将i复位</span></span><br><span class="line">            b &lt;&lt;= <span class="number">1</span>; <span class="comment">// b = 2b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></strong></p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>任何数和自身做异或运算等于0</li>
<li>任何数和0做异或运算等于该数本身</li>
<li>任何数的异或运算满足交换律</li>
</ul>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        res=res^i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/majority-element/"><strong>热题100-169. 多数元素(同剑指 Offer 39)</strong></a></p>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>摩尔投票法：</strong>核心就是对拼消耗。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<p><strong>算法流程：</strong></p>
<p><strong>res作为假定众数</strong>，另一个是<strong>投票数voteNum</strong>，首先假设第一个数就是众数，另res=nums[0],然后向后遍历数组，每当相同时voteNum++，不相同时voteNum–；然后每当voteNum为0时，选择下一个数作为众数x，再去循环执行以上操作。因为此处的众数在数组中出现的次数超过了一半，所以最终voteNum的值一定大于0，并且最后一次把次数设为1时对应的数字就是要找的数字。</p>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> voteNum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(voteNum==<span class="number">0</span>)&#123;</span><br><span class="line">            res=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==res)&#123;</span><br><span class="line">            voteNum++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]!=res)&#123;</span><br><span class="line">            voteNum--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>根据根节点的访问顺序可以将二叉树的遍历分为：</p>
<p><strong>前序遍历：</strong>根节点→左子树→右子树</p>
<p><strong>中序遍历：</strong>左子树→根节点→右子树</p>
<p><strong>后序遍历：</strong>左子树→右子树→根节点</p>
<p>注意：左子树一般都是先于右子树的</p>
]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器调试快捷键</title>
    <url>/2021/02/28/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="快捷键大全"><a href="#快捷键大全" class="headerlink" title="快捷键大全"></a>快捷键大全</h1><blockquote>
<p><strong>转自：<a href="https://www.cnblogs.com/lishanyang/p/7767135.html">https://www.cnblogs.com/lishanyang/p/7767135.html</a></strong></p>
</blockquote>
<p>快捷键有这么以下几大类.且看我一一道来<del>~</del>注:All pane是全局快捷键</p>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console()"></a>Console()</h2><ul>
<li>Ctrl + L : 清除控制台消息</li>
<li>Tab : 自动完成通用常缀</li>
<li>→: 接受建议</li>
<li>Ctrl +  U: 清除console的提示!!(实操查看源代码!!)</li>
<li>↓ / ↑ :选中下一行/上一行</li>
<li>Enter: 执行代码或者命令</li>
</ul>
<h2 id="Debugger-调试面板"><a href="#Debugger-调试面板" class="headerlink" title="Debugger(调试面板)"></a>Debugger(调试面板)</h2><ul>
<li>F8 or Ctrl + : 暂停/继续</li>
<li>F10 or  Ctrl + ‘: 单步执行</li>
<li>F11 or Ctrl +;: 单步进入</li>
<li>Shift + F11 or Ctrl + Shift+;: 单步退出</li>
<li>Ctrl +./Ctrl+, : 上一帧/下一帧(译为框架怪怪的)</li>
<li>Ctrl +Shift+E: 被选中代码在控制台中打印出console信息**(非常实用)**</li>
<li>Ctrl + Shift + A: 添加到debugger的watch里面,可以关注你选中内容的变化</li>
<li>Ctrl + B: 打断点/取消断点**(很实用)**</li>
</ul>
<p>Chrome调试面板上的对应按钮如图所示：</p>
<img src="/2021/02/28/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95%E5%BF%AB%E6%8D%B7%E9%94%AE/调试面板.png" style="zoom:80%;">

<h2 id="Text-Editor-文本编辑器"><a href="#Text-Editor-文本编辑器" class="headerlink" title="Text Editor(文本编辑器)"></a>Text Editor(文本编辑器)</h2><ul>
<li>Ctrl + Shift+P : 跳转到某个成员(不知鸟用)</li>
<li>Ctrl + Space: 自动完成</li>
<li>Ctrl + G : 跳转到某行</li>
<li>Ctrl + Shift + E</li>
<li>Alt + -: 跳转到之前的编辑位置</li>
<li>Alt + +: 跳转到下一个编辑的位置</li>
<li>Ctrl + /: 快捷键注释</li>
<li>Alt + ↑: 调整CSS度量单位,每次<strong>增加</strong>一个单元</li>
<li>Alt + ↓: 调整CSS度量单位,每次<strong>减少</strong>一个单元</li>
<li>Alt + PageUp: 调整CSS度量单位,每次<strong>增加</strong>10个单元</li>
<li>Alt + PageDown: 调整CSS度量单位,每次<strong>减少</strong>10个单元</li>
<li>Ctrl + D: 选择选中内容的下一个匹配内容</li>
<li>Ctrl + U: 软撤销</li>
<li>Ctrl + M: 进入匹配的括号</li>
<li>Alt + W: 关闭编辑便签</li>
<li>Alt + O: 切换相同名字的或者不同后缀的文件</li>
</ul>
<h2 id="All-Panels-所有面板"><a href="#All-Panels-所有面板" class="headerlink" title="All Panels(所有面板)"></a>All Panels(所有面板)</h2><ul>
<li>Ctrl + [ / Ctrl + ]:切换面板(向左向右)</li>
<li>Ctrl + Shift + [ / Ctrl + Shift+] : 返回之前之后的面板状态</li>
<li>Ctrl + Tilde[~]:显示Console</li>
<li>Esc: 小菜单弹出隐藏</li>
<li>Ctrl + Shift + M: 进入仿真设备模式(移动平板屏幕)</li>
<li>Ctrl + Shift + D: 切换调试面板在底部还是侧边栏展示</li>
<li>Ctrl + F: 搜索内容</li>
<li>Ctrl + Shift + F: 在所有代码中搜索(跨域),<strong>很实用</strong></li>
<li>Ctrl + Shift + C: 选择页面节点并且查看代码,<strong>最常用!!</strong></li>
<li>Ctrl + P: 快速切换源码文件,<strong>很常用!</strong></li>
</ul>
<h2 id="Style-Pane-风格面板"><a href="#Style-Pane-风格面板" class="headerlink" title="Style Pane(风格面板)"></a>Style Pane(风格面板)</h2><ul>
<li>Tab / Shift + Tab: 下一个/上一个属性</li>
<li>↑: 增加CSS度量单位-&gt;1单元</li>
<li>↓:减少CSS度量单位-&gt;1单元</li>
<li>PageUporShift + ↑:增加CSS度量单位-&gt;10单元</li>
<li>PageDownorShift + ↓:减少CSS度量单位-&gt;10单元</li>
<li>Shift + PageUp:增加CSS度量单位-&gt;100单元</li>
<li>Shift + PageDown:减少CSS度量单位-&gt;100单元</li>
<li>Alt + ↑:增加CSS度量单位-&gt;0.1单元</li>
<li>Alt + ↓:减少CSS度量单位-&gt;0.1单元</li>
</ul>
<h2 id="Timeline-Panel-时间轴面板"><a href="#Timeline-Panel-时间轴面板" class="headerlink" title="Timeline Panel(时间轴面板)"></a>Timeline Panel(时间轴面板)</h2><ul>
<li>Ctrl + E:开始</li>
<li>Ctrl + S:保存时间轴数据</li>
<li>Ctrl + O:加载时间轴数据</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse使用</title>
    <url>/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、设置断点-amp-断点处运行快捷键"><a href="#1、设置断点-amp-断点处运行快捷键" class="headerlink" title="1、设置断点&amp;断点处运行快捷键"></a>1、设置断点&amp;断点处运行快捷键</h1><p><strong>设置断点</strong></p>
<p>在该行最前面边框双击或快捷键：Ctrl+Shift+B </p>
<p><strong>以Debug 方式运行Java程序</strong></p>
<p> Debug 运行启动 （在进行前后端联调时，Tomcat要在debug模式下运行）</p>
<p><strong>调试快捷键</strong></p>
<p> 运行到断点后： </p>
<p> F5：Step into/进入该行的函数内部 ；</p>
<p> F6：Step over/一行一行执行 ，它是不进入每一行的函数内部的；</p>
<p> F7：Step return/退出当前的函数；</p>
<p> F8：直接执行程序直到遇到下一个断点时暂停。</p>
<p>如果快捷键不能使用，可以通过窗口中的按钮运行程序，如图：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/设置断点及调试.png" style="zoom:90%;">

<h1 id="2、修改包的显示结构和显示方法"><a href="#2、修改包的显示结构和显示方法" class="headerlink" title="2、修改包的显示结构和显示方法"></a>2、修改包的显示结构和显示方法</h1><h2 id="Eclipse-中包结构展开有两种方式："><a href="#Eclipse-中包结构展开有两种方式：" class="headerlink" title="Eclipse 中包结构展开有两种方式："></a>Eclipse 中包结构展开有两种方式：</h2><p><strong>一：平坦方式（flat）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/平坦方式.png" style="zoom:110%;">

<p><strong>二、分层方式（hierarchical）</strong></p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/分层方式.png" style="zoom:90%;">



<h2 id="快速展开包"><a href="#快速展开包" class="headerlink" title="快速展开包"></a>快速展开包</h2><p><strong>在右边选中类时，快速的将类对应的包结构展开（Link with editor）</strong></p>
<p>设置只需点击包机构面板中的双箭头即可。</p>
<p>双箭头按下，表示包自动展开，不按下，表示包不自动展开。</p>
<p>如图红色框内按钮：</p>
<img src="/2021/02/28/eclipse%E4%BD%BF%E7%94%A8/在右边选中类时，快速的将类对应的包结构展开.png" style="zoom:80%;">]]></content>
      <categories>
        <category>IDE工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>win10系统激活方法</title>
    <url>/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示："><a href="#1、按下win-X，选择Windows-PowerShell-管理员-，如下图所示：" class="headerlink" title="1、按下win+X，选择Windows PowerShell (管理员)，如下图所示："></a>1、按下win+X，选择Windows PowerShell (管理员)，如下图所示：</h1><img src="/2021/03/03/win10%E7%B3%BB%E7%BB%9F%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95/图片1.png" style="zoom:90%;">

<h1 id="2、在命令提示符中依次输入："><a href="#2、在命令提示符中依次输入：" class="headerlink" title="2、在命令提示符中依次输入："></a>2、在命令提示符中依次输入：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slmgr &#x2F;ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr &#x2F;skms kms.03k.org</span><br><span class="line">slmgr &#x2F;ato</span><br></pre></td></tr></table></figure>

<h1 id="3、依次会弹出："><a href="#3、依次会弹出：" class="headerlink" title="3、依次会弹出："></a>3、依次会弹出：</h1><p>“成功地安装了产品密钥……”</p>
<p>“密钥管理服务计算机名成功的设置为 zh.us.to”</p>
<p>“正在激活……，成功地激活了产品”</p>
]]></content>
      <categories>
        <category>电脑使用中的问题</category>
      </categories>
      <tags>
        <tag>系统问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Dao层、Service层和Controller层的初步理解</title>
    <url>/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="DAO层（Data-Access-Object）"><a href="#DAO层（Data-Access-Object）" class="headerlink" title="DAO层（Data Access Object）"></a>DAO层（Data Access Object）</h1><p><strong>Dao层：</strong>全称为数据访问层，属于一种比较底层，比较基础的操作，具体到对于某个表的增删改查，也就是说某个Dao层一定是和数据库的某一张表一一对应的，其中封装了增删改查基本操作，建议Dao只做原子操作，也就是增删改查操作。</p>
<p><strong>如图，先创建一个获取店铺区域列表的接口：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片1.png" style="zoom:80%;">

<p><strong>然后通过MyBatis框架实现这个接口：</strong></p>
<p><strong>NOTE:</strong></p>
<ul>
<li>namespace 是接口的完全限定名</li>
<li>id是接口中的方法名</li>
<li>resultType是方法的返回值类型</li>
</ul>
<p>后面是SQL语句</p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片2.png" style="zoom:80%;">

<h1 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h1><p><strong>Service层：</strong>又称为服务层，被称为服务，如果粗略一点理解的话就是对一个或多个Dao进行的再次封装，封装成一个服务，所以这里不再是一个原子操作了，需要对事务控制。</p>
<p><strong>如图，先创建一个店铺区域服务的接口：</strong></p>
<p>在这个接口中可以定义很多方法，比如：增加区域、修改区域等。这里暂时只有一个获取区域列表的方法，因为Dao层中的AreaDao中只有一个获取区域列表的方法</p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片3.png" style="zoom:80%;">

<p><strong>然后，再创建实体类来实现这个接口：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片4.png" style="zoom:80%;">

<p>在这个实体类中实现了AreaService接口，通过areaDao对象调用它的queryArea方法，返回了区域列表。</p>
<p><strong>Spring对于Service层的配置：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片5.png" style="zoom:80%;">

<h1 id="Controler层"><a href="#Controler层" class="headerlink" title="Controler层"></a>Controler层</h1><p><strong>Controller层：</strong>负责请求转发，接受web页面传来的参数，交给相应的Service处理，接到Service返回的值，再传送给web页面。</p>
<p><strong>比如输入：<a href="http://localhost:8080/o2o/shopadmin/shopoperation">http://localhost:8080/o2o/shopadmin/shopoperation</a></strong></p>
<p>先通过配置好的SpringMVC解析Url，就会访问到shopoperation.html文件，并将其内容展示到浏览器中。</p>
<p>根据shopoperation.js文件的逻辑执行其中的方法，根据不同的路由（Url）调用后端Controller层的方法，Controller层再根据前端传入的信息调用不同的服务，然后把Service的返回值再返回到前端。</p>
<p><strong>部分JS代码如图所示：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片6.png" style="zoom:110%;">

<p><strong>部分Controller代码如图所示：</strong></p>
<img src="/2021/03/04/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E5%92%8CController%E5%B1%82%E7%9A%84%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3/图片7.png" style="zoom:80%;">

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>Dao层面向数据库中的表：在进行后端开发时，先要在数据库中创建出所用到的表，然后对应表去设计Dao层</p>
<p>Service层面向服务：在数据库中有了所需要的表之后，根据具体的需求或者业务逻辑，将Dao层封装成Service层，对外提供服务使用</p>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC执行原理</title>
    <url>/2021/03/08/SpringMVC/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>SpringMVC的web框架围绕DispatcherServlet设计，DispatcherServlet的作用是将请求分发到不同的处理器，同其它的框架一样，<strong>SpringMVC以请求为驱动，围绕一个中心Servelet分派请求并提供相应的功能，DispatcherServlet是一个实际的Servelet。</strong></p>
<img src="/2021/03/08/SpringMVC/SpringMVC执行流程.png" style="zoom:80%;">

<h1 id="组件作用"><a href="#组件作用" class="headerlink" title="组件作用"></a>组件作用</h1><ul>
<li><p><strong>DispatcherServlet：</strong>前端控制器。</p>
<p>它就相当于 mvc 模式中的 c， dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求， dispatcherServlet 的存在降低了组件之间的耦合性。</p>
<p><strong>作用：</strong>DispatcherServlet负责拦截处理用户发起的请求。</p>
</li>
<li><p><strong>HandlerMapping：</strong>处理器映射器</p>
<p><strong>作用：</strong>HandlerMapping 负责根据用户请求的url找到 Handler 即处理器。</p>
</li>
<li><p><strong>HandlerExecution：</strong>具体的Handler</p>
<p>HandlerExecution 负责根据用户请求的url找到具体的控制器Controller。</p>
</li>
<li><p><strong>Handler：</strong>处理器 (自己写的Controller类中的方法)</p>
<p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。</p>
</li>
<li><p><strong>HandlAdapter：</strong>处理器适配器</p>
<p><strong>作用1：</strong>按照特定的规则去执行Handler；</p>
<p><strong>作用2：</strong>将Controller返回的ModelAndView回传给DispatcherServlet。</p>
<p><strong>注：</strong>Model表示具体的数据，View表示视图</p>
</li>
<li><p><strong>View Resolver：</strong>视图解析器</p>
<p><strong>作用：</strong>View Resolver 负责将处理结果生成 View 视图， View Resolver 首先根据逻辑视图名解析成具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</p>
</li>
<li><p><strong>View：</strong>视图</p>
<p><strong>作用：</strong>向用户展示结果</p>
</li>
</ul>
<h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><ol>
<li>用户在浏览器中输入url，被dispatcherServlet 拦截；</li>
<li>dispatcherServlet 调用HandlerMapping找到相应的Handler；</li>
<li>HandlerExecution就是具体的Controller；</li>
<li>HandlerExecution将解析的Controller回传给dispatcherServlet ；</li>
<li>dispatcherServlet 调用HandlAdapter去适配相应的Controller；</li>
<li>HandlAdapter找到相应的Controller去执行；</li>
<li>Controller将执行结果返回给HandlAdapter；</li>
<li>HandlAdapter将执行数据回传给dispatcherServlet ，如ModelAndView；</li>
<li>dispatcherServlet调用View Resolver得到相应的页面地址；</li>
<li>View Resolver解析得到相应的页面地址，回传给dispatcherServlet；</li>
<li>dispatcherServlet根据View Resolver的结果调用相应的视图。</li>
</ol>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringMVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-Logback配置与使用</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-Logback%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1Logback介绍"><a href="#1-1Logback介绍" class="headerlink" title="1.1Logback介绍"></a>1.1Logback介绍</h1><h2 id="1-1-1使用日志的目的"><a href="#1-1-1使用日志的目的" class="headerlink" title="1.1.1使用日志的目的"></a>1.1.1使用日志的目的</h2><ul>
<li>做故障定位 </li>
<li>显示程序运行状态</li>
</ul>
<h2 id="1-1-2日志的三个主要模块"><a href="#1-1-2日志的三个主要模块" class="headerlink" title="1.1.2日志的三个主要模块"></a>1.1.2日志的三个主要模块</h2><ul>
<li><p><strong>logback-access</strong></p>
<p><strong>第三方的软件</strong>可以通过logback-access访问我们日志记录的内容</p>
</li>
<li><p><strong>logback-classic</strong></p>
<p>方便更换成其它的日志系统</p>
</li>
<li><p><strong>logback-core</strong></p>
<p>为以上的两个模块提供基础</p>
</li>
</ul>
<h2 id="1-1-3日志的三个标签"><a href="#1-1-3日志的三个标签" class="headerlink" title="1.1.3日志的三个标签"></a>1.1.3日志的三个标签</h2><ul>
<li><p><strong>logger</strong></p>
<p>存放日志的对象，定义日志的类型还有级别等信息</p>
</li>
<li><p><strong>appender</strong></p>
<p>指定日志输出的媒介，比如：控制台，文件，远程套接字服务器等</p>
</li>
<li><p><strong>layout</strong></p>
<p>格式化日志信息的输出</p>
</li>
</ul>
<h1 id="1-2Logback的配置"><a href="#1-2Logback的配置" class="headerlink" title="1.2Logback的配置"></a>1.2Logback的配置</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">//1.定义扫描属性，间隔60秒更新一次看是否变化了</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 定义参数常量 --&gt;</span> </span><br><span class="line">    //2.也就是定义全局变量</span><br><span class="line">	<span class="comment">&lt;!-- 日志的级别：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- logger.trace(&quot;msg&quot;) logger.debug... --&gt;</span></span><br><span class="line">    //3.设置级别，默认级别为debug</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.level&quot;</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    //4.最大的保留历史的时间为30</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.maxHistory&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">    //5.设置日志存储的根路径</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.filePath&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&quot;$&#123;catalina.base&#125;/logs/webapps&quot;</span> /&gt;</span></span><br><span class="line">    //6.定义日志展现的格式：时间格式||哪个线程执行的||哪个级别的日志||哪个包下的哪个类||日志信息</span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;[%thread]%-5level %logger&#123;50&#125;-%msg%n&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 控制台设置 --&gt;</span></span><br><span class="line">    //7.设置输出媒介——控制台</span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;consoleAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            //8.定义log的输出格式（encoder既将输出转换成字符串，又将字符串保存到文件中）</span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- DEBUG --&gt;</span></span><br><span class="line">    //8.设置输出媒介——文件（该文件随着滚动，它的size不断增大）</span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;debugAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">        //9.输出媒介的文件路径</span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">            //10.输出媒介的文件名称</span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/debug/debug.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            //11.输出媒介的文件最大保存历史数量</span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            //12.设置输出格式</span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        //13.设置过滤器，只保留DEBUG相关的日志</span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- INFO --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;infoAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ERROR --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;errorAppender&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.filePath&#125;/error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">			<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.filePath&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.log.gz</span><br><span class="line">			<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>$&#123;log.maxHistory&#125;<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;log.pattern&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    //14.将logger与appender绑定，表示logger对象会往绑定的三个文件中输出日志信息</span><br><span class="line">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.imooc.o2o&quot;</span> <span class="attr">level</span>=<span class="string">&quot;$&#123;log.level&#125;&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;debugAppender&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;infoAppender&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;errorAppender&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;consoleAppender&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="1-3验证配置"><a href="#1-3验证配置" class="headerlink" title="1.3验证配置"></a>1.3验证配置</h1><p><strong>1.调用方法生成logger对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger=LoggerFactory.getLogger(AreaController.class);</span><br></pre></td></tr></table></figure>

<p><strong>2.打印日志信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;===start===&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.error(<span class="string">&quot;test error!&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;constTime:[&#123;&#125;ms]&quot;</span>,endTime-startTime);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-主从库同步与读写分离</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1为什么要用主从同步，及其原理"><a href="#1-1为什么要用主从同步，及其原理" class="headerlink" title="1.1为什么要用主从同步，及其原理"></a>1.1为什么要用主从同步，及其原理</h1><p>在MySQL相关的文章里</p>
<h1 id="1-2主从同步数据库配置"><a href="#1-2主从同步数据库配置" class="headerlink" title="1.2主从同步数据库配置"></a>1.2主从同步数据库配置</h1><h2 id="1-2-1主服务器配置文件"><a href="#1-2-1主服务器配置文件" class="headerlink" title="1.2.1主服务器配置文件"></a>1.2.1主服务器配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//服务器id，必须唯一</span><br><span class="line">server-id=1</span><br><span class="line">//开启log-bin二进制日志</span><br><span class="line">log-bin=master-bin</span><br><span class="line">//开启索引</span><br><span class="line">log-bin-index=master-bin.index</span><br></pre></td></tr></table></figure>

<p><strong>重启主服务器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p><strong>查看主服务器状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show master status</span><br></pre></td></tr></table></figure>

<p><strong>创建repl账号：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user repl</span><br></pre></td></tr></table></figure>

<p><strong>给与使用repl账号登录的服务器的权限：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant replication slave on *.* TO &#39;repl&#39;@&#39;服务器IP&#39; IDENTIFIED BY &#39;mysql&#39;</span><br></pre></td></tr></table></figure>

<p><strong>刷新：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges</span><br></pre></td></tr></table></figure>

<h2 id="1-2-2从服务器配置文件"><a href="#1-2-2从服务器配置文件" class="headerlink" title="1.2.2从服务器配置文件"></a>1.2.2从服务器配置文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//服务器id，必须唯一</span><br><span class="line">server-id=2</span><br><span class="line">//开启relay-log二进制日志</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">//开启索引</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">//由于在同一台机器上，要修改端口号</span><br><span class="line">port=3305</span><br></pre></td></tr></table></figure>

<p><strong>重启从服务器：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p><strong>将master与slave联系起来：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用repl账号从主库的日志文件的位置开启同步</span><br><span class="line">change master to master_host&#x3D;&#39;主库IP&#39;,master_port&#x3D;3306,master_user&#x3D;&#39;repl&#39;,master_password&#x3D;&#39;mysql&#39;,master_log_file&#x3D;&#39;master-bin.000001&#39;,master_log_pos&#x3D;0;</span><br></pre></td></tr></table></figure>

<p><strong>开启从库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start slave</span><br></pre></td></tr></table></figure>

<p><strong>查看从服务器状态：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-3数据库备份与导入"><a href="#1-2-3数据库备份与导入" class="headerlink" title="1.2.3数据库备份与导入"></a>1.2.3数据库备份与导入</h2><p><strong>备份数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将指定的数据库输出到指定的文件</span><br><span class="line">mysqldump -uroot -p o2o &gt; o2o.sql</span><br></pre></td></tr></table></figure>

<p><strong>引入备份的数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;xx路径下的xx.sql文件</span><br><span class="line">source ~&#x2F;o2o.sql;</span><br></pre></td></tr></table></figure>

<h1 id="1-3代码层面读写分离的实现"><a href="#1-3代码层面读写分离的实现" class="headerlink" title="1.3代码层面读写分离的实现"></a>1.3代码层面读写分离的实现</h1><h2 id="1-3-1创建DynamicDataSource类"><a href="#1-3-1创建DynamicDataSource类" class="headerlink" title="1.3.1创建DynamicDataSource类"></a>1.3.1创建DynamicDataSource类</h2><p>创建DynamicDataSource类让它继承抽象类AbstractRoutingDataSource，重写determineCurrentLookupKey方法，实现不同数据源的选择：</p>
<h2 id="1-3-2创建DynamicDataSourceHolder类"><a href="#1-3-2创建DynamicDataSourceHolder类" class="headerlink" title="1.3.2创建DynamicDataSourceHolder类"></a>1.3.2创建DynamicDataSourceHolder类</h2><p><strong>引入ThreadLocal保证线程安全：</strong>维持线程封闭性的一种规范方法是使用ThreadLocal。它提供了set和get等访问方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get方法总是返回由当前执行线程在调用set时设置的最新值。一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的”，每个线程都只能看到自己线程的值，这也就是<strong>ThreadLocal的核心作用：实现线程范围的局部变量。</strong><br><strong>getDbType方法：</strong>获取数据源类型</p>
<p><strong>setDbType方法：</strong>设置数据源类型</p>
<p>clearDBType方法：略</p>
<h2 id="1-3-3创建DynamicDataSourceInterceptor类"><a href="#1-3-3创建DynamicDataSourceInterceptor类" class="headerlink" title="1.3.3创建DynamicDataSourceInterceptor类"></a>1.3.3创建DynamicDataSourceInterceptor类</h2><p>DynamicDataSourceHolder这个类决定返回的数据源是master还是slave，这个类的初始化我们就需要借助DateSourceSelectInterceptor了，我们拦截所有的数据库操作请求，通过分析sql语句来判断是读还是写操作，读操作就给DynamicDataSourceHolder设置slave源，写操作就给其设置master源，代码如下：</p>
<ul>
<li><p>添加@Intercepts注解：说明要拦截的类型，其中update涵盖了增删改的操作</p>
</li>
<li><p>创建日志对象来输出显示使用数据源的类型</p>
</li>
<li><p>编写正则表达式：能够匹配的要用主库</p>
</li>
<li><p>intercept方法：</p>
<p>synchronizationActive：判断是不是事务</p>
<p>objects：获取传入对象的SQL语句参数</p>
<p>ms：接收参数的第一个值objects[0]，第一个值往往就是操作名称</p>
<p>lookupKey：保存数据源的类型</p>
<p><strong>判断不是事务管理：</strong></p>
<p>如果是SELECT方法，再去判断Mybatis是否调用了获取自增主键的方法，比如我们注册店铺根据<strong>选择的</strong>shopID生成图片地址，再将图片的地址插入到数据库，这个我们应该选择<strong>主库</strong>；</p>
<p>如果没有调用获取自增主键的方法，再将ms的第二个内容也就是SQL语句统一格式去匹配写好的正则表达式，如果能匹配上也要用<strong>主库</strong>，反之，匹配不上用从库。</p>
<p><strong>判断是事务管理：</strong></p>
<p>一般使用事务管理的都是写操作，我们使用主库</p>
<p>通过DynamicDataSourceHolder中的setDbType()方法最终决定使用哪个数据源</p>
<p>invocation.proceed()：程序继续执行</p>
</li>
<li><p>plugin方法：</p>
</li>
<li><p>setProperties方法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过拦截器，根据不同的SQL请求选择对应的数据源 select、query--选择读的数据源（slave）</span></span><br><span class="line"><span class="comment"> * updata、insert--选择写的数据源（master）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 王进</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(&#123; @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class &#125;),</span></span><br><span class="line"><span class="meta">		@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class,</span></span><br><span class="line"><span class="meta">				RowBounds.class, ResultHandler.class &#125;) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSourceInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建日志对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DynamicDataSourceInterceptor.class);</span><br><span class="line">	<span class="comment">// 正则表达式</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">&quot;.*insert\\u0020.*.*delete\\u0020.*.*updata\\u0020.*&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 主要的拦截方法，根据不同的情况去做拦截</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 判断是不是事务</span></span><br><span class="line">		<span class="keyword">boolean</span> synchronizationActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">		<span class="comment">// 获取传入对象的SQL参数</span></span><br><span class="line">		Object[] objects = invocation.getArgs();</span><br><span class="line">		MappedStatement ms = (MappedStatement) objects[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 保存dataSourceType</span></span><br><span class="line">		String lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">		<span class="keyword">if</span> (synchronizationActive != <span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 读方法</span></span><br><span class="line">			<span class="keyword">if</span> (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) &#123;</span><br><span class="line">				<span class="comment">// selectKey 为自增id查询主键（SELECT LAST_INSERT_ID()）方法，使用主库</span></span><br><span class="line">				<span class="keyword">if</span> (ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) &#123;</span><br><span class="line">					lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line">					<span class="comment">// 替换SQL中所有的制表符、换行符为空格</span></span><br><span class="line">					String sql = boundSql.getSql().toLowerCase(Locale.CHINA).replaceAll(<span class="string">&quot;[\\t\\n\\r]&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">					<span class="comment">// 用sql去匹配正则表达式，如果是insert、delete、updata使用主库</span></span><br><span class="line">					<span class="keyword">if</span> (sql.matches(REGEX)) &#123;</span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						lookupKey = DynamicDataSourceHolder.DB_SLAVE;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 使用事务管理的都是写操作，使用主库</span></span><br><span class="line">			lookupKey = DynamicDataSourceHolder.DB_MASTER;</span><br><span class="line">		&#125;</span><br><span class="line">		logger.debug(<span class="string">&quot;设置方法[&#123;&#125;] use [&#123;&#125;] Strategy,SqlCommandType [&#123;&#125;]..&quot;</span>, ms.getId(), lookupKey,</span><br><span class="line">				ms.getSqlCommandType().name());</span><br><span class="line">		<span class="comment">// 通过DynamicDataSourceHolder中的setDbType()方法最终决定使用哪个数据源</span></span><br><span class="line">		DynamicDataSourceHolder.setDbType(lookupKey);</span><br><span class="line">		<span class="keyword">return</span> invocation.proceed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回代理对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (target <span class="keyword">instanceof</span> Executor) &#123;<span class="comment">// Mybatis中的Executor支持增删改查操作，发现对象中有这个对象，</span></span><br><span class="line">											<span class="comment">// 要去调用intercept方法来决定使用哪个数据源</span></span><br><span class="line">			<span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> target;<span class="comment">// 返回本体，不做拦截</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化时所做的相关配置（不必要）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-4Mybatis-config-xml中配置拦截器"><a href="#1-3-4Mybatis-config-xml中配置拦截器" class="headerlink" title="1.3.4Mybatis-config.xml中配置拦截器"></a>1.3.4Mybatis-config.xml中配置拦截器</h2><h2 id="1-3-5Spring-dao中重新配置datesource"><a href="#1-3-5Spring-dao中重新配置datesource" class="headerlink" title="1.3.5Spring-dao中重新配置datesource"></a>1.3.5Spring-dao中重新配置datesource</h2><p>将原来配置的连接池属性的bean设为抽象的并保留原先配置的属性，让id为master和slave的bean继承这些私有属性，而master和slave连接数据库的属性是不同的（url、密码等）：</p>
<p>这里已经更改了jdbc.properties文件，多了一个连接主库的变量：jdbc.master.url</p>
<p>配置动态数据源，创建DynamicDataSource类的对象dynamicDataSource，因为它继承了AbstractRoutingDataSource，所以它有一个成员变量targetDataSources是Map类型的，将定义好的两个bean加到这个成员变量中去；</p>
<p>因为数据源的选择只有在SQL语句执行时才会触发，所以引入一个类实现懒加载，将对象dynamicDataSource放到里面：</p>
]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-前端展示系统</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%89%8D%E7%AB%AF%E5%B1%95%E7%A4%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>校园商铺1.0-商品模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>校园商铺1.0-店铺注册功能模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1Dao层之新增店铺"><a href="#1-1Dao层之新增店铺" class="headerlink" title="1.1Dao层之新增店铺"></a>1.1Dao层之新增店铺</h1><h2 id="1-1-1创建ShopDao接口"><a href="#1-1-1创建ShopDao接口" class="headerlink" title="1.1.1创建ShopDao接口"></a>1.1.1创建ShopDao接口</h2><p><strong>接口中仅包含一个方法：插入店铺</strong></p>
<h2 id="1-1-2创建ShopDao-xml文件"><a href="#1-1-2创建ShopDao-xml文件" class="headerlink" title="1.1.2创建ShopDao.xml文件"></a>1.1.2创建ShopDao.xml文件</h2><p><strong>useGeneratedKeys=”true”：</strong>使用自增主键，表示店铺插入成功之后，将该店铺的主键值返回，为了<strong>后续图片插入能与店铺对应</strong>起来</p>
<p>INSERT INTO中的参数名是与数据库o2o表中的<strong>列名</strong>一一对应的；VALUES中是与实体类中的<strong>成员变量</strong>对应的</p>
<h2 id="1-1-3ShopDao接口测试"><a href="#1-1-3ShopDao接口测试" class="headerlink" title="1.1.3ShopDao接口测试"></a>1.1.3ShopDao接口测试</h2><p>同区域查询测试方法差不多</p>
<h1 id="1-2Dao层之更新店铺"><a href="#1-2Dao层之更新店铺" class="headerlink" title="1.2Dao层之更新店铺"></a>1.2Dao层之更新店铺</h1><p><strong>因为本项目很多增删改查的内容，从本节开始，只记录与之前代码不一样的地方</strong></p>
<h2 id="1-2-1在ShopDao中加入更新方法"><a href="#1-2-1在ShopDao中加入更新方法" class="headerlink" title="1.2.1在ShopDao中加入更新方法"></a>1.2.1在ShopDao中加入更新方法</h2><h2 id="1-2-2在ShopDao-xml中实现更新方法"><a href="#1-2-2在ShopDao-xml中实现更新方法" class="headerlink" title="1.2.2在ShopDao.xml中实现更新方法"></a>1.2.2在ShopDao.xml中实现更新方法</h2><p><strong>这里使用了动态SQL：</strong></p>
<p>当需要更新不同内容的值时，如果不使用动态SQL就需要多个更新方法实现，所以这里使用动态SQL只更新传入的不为NULL的列值</p>
<p><strong>格式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;xxx是实体类中对应的字段名，xxx_xxx是数据库中对应的字段名</span><br><span class="line">&lt;if test&#x3D;&quot;xxx !&#x3D;null&quot;&gt;xxx_xxx&#x3D;#&#123;xxx&#125;,&lt;&#x2F;if&gt;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-3ShopDao接口测试"><a href="#1-2-3ShopDao接口测试" class="headerlink" title="1.2.3ShopDao接口测试"></a>1.2.3ShopDao接口测试</h2><h1 id="1-3Thumbnailator图片处理和封装Util"><a href="#1-3Thumbnailator图片处理和封装Util" class="headerlink" title="1.3Thumbnailator图片处理和封装Util"></a>1.3Thumbnailator图片处理和封装Util</h1><h2 id="1-3-1导入Thumbnailator相关的-jar包"><a href="#1-3-1导入Thumbnailator相关的-jar包" class="headerlink" title="1.3.1导入Thumbnailator相关的.jar包"></a>1.3.1导入Thumbnailator相关的.jar包</h2><p>通过pom.xml导入Thumbnailator相关的.jar包</p>
<h2 id="1-3-2创建PathUtil工具类"><a href="#1-3-2创建PathUtil工具类" class="headerlink" title="1.3.2创建PathUtil工具类"></a>1.3.2创建PathUtil工具类</h2><p><strong>方法一，获取图片根路径：</strong></p>
<ul>
<li>因为图片或者文件的处理要获取文件路径，所以创建一个工具类能够根据不同的系统获取文件的路径</li>
<li>用Seperator变量获取系统文件的分隔符</li>
<li>获取系统名称</li>
<li>根据不同的系统名称获取变量</li>
</ul>
<p><strong>方法二，获取相对子路径：</strong></p>
<ul>
<li>获取相对子路径并返回</li>
</ul>
<h2 id="1-3-3创建ImageUtil工具类"><a href="#1-3-3创建ImageUtil工具类" class="headerlink" title="1.3.3创建ImageUtil工具类"></a>1.3.3创建ImageUtil工具类</h2><p><strong>transferCommonsMultipartFileToFile方法：</strong>因为CommonsMultipartFile实现类只能通过前端的文件上传控件来初始化，而CommonsMultipartFile的构造方法中也不是用的File类的实例对象，因此将File类转换成CommonsMultipartFile是不现实的，InputStream类在我们对Service层进行junit测试时更便于初始化，因此要将CommonsMultipartFile转化成File类型</p>
<p>**==改进：==**如果图片类型为File类型，虽然方便我们做UT测试，但是controller调用时，每次都要讲InputStream转换成File类型，因此我们这里直接将类型从File类型装换成InputStream类型</p>
<p><strong>generateThumbnail方法：</strong></p>
<ul>
<li><p>先调用getRandomFileName方法得到一个随机的图片名称</p>
</li>
<li><p>再调用getFileExtension方法得到插入图片的扩展名称</p>
</li>
<li><p>调用makeDirPath方法创建目标路径</p>
</li>
<li><p>由targetAddr + realFileName + extension得到图片的<strong>相对路径</strong>地址</p>
<p>存为相对路径更有利于项目的移植，根路径可以通过getBasePath来获取</p>
</li>
</ul>
<p><strong>getRandomFileName方法：</strong>由随机生成的五位数还有当前的日期为插入的图片生成随机的文件名称</p>
<p><strong>getFileExtension方法：</strong>由传入图片名称的最后一个点为分隔，获取图片的扩展名</p>
<p><strong>makeDirPath方法：</strong>判断目标文件是否存在，如果不存在递归地生成该路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String basePath = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>).getPath();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ImageUtil.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将CommonsMultipartFile转换成File类</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cFile</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">transferCommonsMultipartFileToFile</span><span class="params">(CommonsMultipartFile cFile)</span> </span>&#123;</span><br><span class="line">		File newFile = <span class="keyword">new</span> File(cFile.getOriginalFilename());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			cFile.transferTo(newFile);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newFile;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 处理缩略图，并返回新生成图片的相对值路径</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thumbnail</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetAddr</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateThumbnail</span><span class="params">(ImageHolder thumbnail, String targetAddr)</span> </span>&#123;</span><br><span class="line">		String realFileName = getRandomFileName();</span><br><span class="line">		String extension = getFileExtension(thumbnail.getImageName());</span><br><span class="line">		makeDirPath(targetAddr);</span><br><span class="line">		String relativeAddr = targetAddr + realFileName + extension;</span><br><span class="line">		logger.debug(<span class="string">&quot;current relativeAddr is:&quot;</span> + relativeAddr);</span><br><span class="line">		File dest = <span class="keyword">new</span> File(PathUtil.getImgBasePath() + relativeAddr);</span><br><span class="line">		logger.debug(<span class="string">&quot;current complete addr is:&quot;</span> + PathUtil.getImgBasePath() + relativeAddr);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thumbnails.of(thumbnail.getImage()).size(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">					.watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\index.jpg&quot;</span>)), <span class="number">0.25f</span>)</span><br><span class="line">					.outputQuality(<span class="number">0.8f</span>).toFile(dest);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			logger.error(e.toString());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> relativeAddr;<span class="comment">// 存为相对路径更有利于项目的移植，根路径可以通过getBasePath来获取</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 创建目标路径所涉及到的目录，即/home/work/wangjin/xxx.jpg,那么home work wangjin 这三个文件夹都得自动创建出来</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetAddr</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeDirPath</span><span class="params">(String targetAddr)</span> </span>&#123;</span><br><span class="line">		String realFileParentPath = PathUtil.getImgBasePath() + targetAddr;</span><br><span class="line">		File dirPath = <span class="keyword">new</span> File(realFileParentPath);</span><br><span class="line">		<span class="keyword">if</span> (!dirPath.exists()) &#123;</span><br><span class="line">			dirPath.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取输入文件流的扩展名（jpg、pnm）</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> thumbnail</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFileExtension</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 生成随机文件名，用当前的年月日小时分钟秒钟+五位随机数来保证随机文件名不一样</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRandomFileName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取随机的五位数</span></span><br><span class="line">		<span class="keyword">int</span> rannum = r.nextInt(<span class="number">89999</span>) + <span class="number">10000</span>;</span><br><span class="line">		String nowTimeStr = sDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">return</span> nowTimeStr + rannum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Thumbnails.of(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\xiaohuangren.jpg&quot;</span>)).size(<span class="number">1200</span>, <span class="number">1200</span>)</span><br><span class="line">				.watermark(Positions.BOTTOM_RIGHT, ImageIO.read(<span class="keyword">new</span> File(<span class="string">&quot;D:\\GitHub\\index.jpg&quot;</span>)), <span class="number">0.25f</span>)</span><br><span class="line">				.outputQuality(<span class="number">0.8f</span>).toFile(<span class="string">&quot;D:\\GitHub\\xintupian3.jpg&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-4Dto之ShopExecution的实现"><a href="#1-4Dto之ShopExecution的实现" class="headerlink" title="1.4Dto之ShopExecution的实现"></a>1.4Dto之ShopExecution的实现</h1><h2 id="1-4-1创建枚举类型来存储店铺的对应状态"><a href="#1-4-1创建枚举类型来存储店铺的对应状态" class="headerlink" title="1.4.1创建枚举类型来存储店铺的对应状态"></a>1.4.1创建枚举类型来存储店铺的对应状态</h2><ul>
<li><p>枚举实例：包括CHECK(0, “审核中”), OFFLINE(-1, “非法店铺”)类似的，需要什么状态就在这里添加，最后要用分号结束</p>
</li>
<li><p>定义两个私有的成员变量：状态和状态信息</p>
</li>
<li><p>定义构造方法：</p>
<p><strong>stateOf方法：</strong>根据传入的状态值返回相应的状态信息到前端</p>
</li>
</ul>
<h2 id="1-4-2创建ShopExecution类"><a href="#1-4-2创建ShopExecution类" class="headerlink" title="1.4.2创建ShopExecution类"></a>1.4.2创建ShopExecution类</h2><p><strong>成员变量：</strong></p>
<ul>
<li>状态值和状态信息：店铺插入成功或失败的返回信息</li>
<li>店铺数量</li>
<li>操作的店铺：存储当前操作的店铺</li>
<li>店铺列表：当查询店铺时，将查询结果存储到店铺列表中</li>
</ul>
<p><strong>构造方法：</strong></p>
<ul>
<li>店铺操作失败的时候使用的构造器：当操作失败时，仅将失败的信息赋值给ShopExecution对象的状态值和状态信息</li>
<li>店铺操作成功时候使用的构造器：当操作成功，除了返回状态信息外，还要将店铺赋值给ShopExecution对象的shop变量中</li>
<li>店铺操作成功时候使用的构造器：当操作成功时，将店铺的列表赋值给ShopExecution对象的shoplist变量中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopExecution</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 结果状态</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 状态标识(以文字的形式来解释state的状态)</span></span><br><span class="line">	<span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺的数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 操作的shop（增删改店铺的时候用到）</span></span><br><span class="line">	<span class="keyword">private</span> Shop shop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shop列表（查询店铺列表的时候使用）</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Shop&gt; shopList;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个枚举类型中存储的是状态值，针对失败的时候去生成的ShopExecution对象，</span></span><br><span class="line">	<span class="comment">//因此是店铺操作失败的时候使用的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回Shop对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 店铺操作成功时候使用的构造器，返回ShopList对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ShopExecution</span><span class="params">(ShopStateEnum stateEnum, List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = stateEnum.getState();</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateEnum.getStateInfo();</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateInfo</span><span class="params">(String stateInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Shop <span class="title">getShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShop</span><span class="params">(Shop shop)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shop = shop;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Shop&gt; <span class="title">getShopList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shopList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShopList</span><span class="params">(List&lt;Shop&gt; shopList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.shopList = shopList;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="1-5店铺注册之Service层的实现"><a href="#1-5店铺注册之Service层的实现" class="headerlink" title="1.5店铺注册之Service层的实现"></a>1.5店铺注册之Service层的实现</h1><h2 id="1-5-1创建ShopService接口"><a href="#1-5-1创建ShopService接口" class="headerlink" title="1.5.1创建ShopService接口"></a>1.5.1创建ShopService接口</h2><p><strong>只有一个addShop方法：</strong></p>
<h2 id="1-5-2创建ShopServiceImpl实现ShopService接口"><a href="#1-5-2创建ShopServiceImpl实现ShopService接口" class="headerlink" title="1.5.2创建ShopServiceImpl实现ShopService接口"></a>1.5.2创建ShopServiceImpl实现ShopService接口</h2><p><strong>addShop方法的实现：</strong></p>
<ul>
<li><p>通过@Transactional引入事务管理：因为该方法包括在数据库中存入店铺信息、插入图片等多个操作，其中一个操作不成功就要回滚</p>
</li>
<li><p>注入ShopDao实例</p>
</li>
<li><p>首先判断店铺是否为空</p>
<p>如果为空调用ShopExecution类中操作失败的构造器，将对应的状态赋值给ShopExecution对象</p>
<p>如果不为空，设置店铺的状态、创建时间和最近修改时间</p>
</li>
<li><p>调用ShopDao的insertShop方法：插入传入的对象</p>
<p>如果返回的影响行数小于等于0，说明店铺插入失败，通过ShopOperationException抛出异常信息</p>
<p><strong>注：</strong>ShopOperationException要继承RuntimeException类，只有这个类抛出异常信息时，才会回滚，普通的抛出异常信息不会</p>
</li>
<li><p>存储图片信息：</p>
<p>先判断图片的信息是否为空，空则抛出异常，不为空就调用addShopImg方法将图片信息插入</p>
</li>
<li><p>店铺和图片都插入成功之后，通过ShopExecution操作成功的构造方法，将店铺的状态和相应的店铺对象赋值给ShopExecution创建ShopExecution对象并返回该对象</p>
</li>
</ul>
<p><strong>addShopImg方法的实现：</strong></p>
<ul>
<li>通过shopId获取图片存储的相对值路径</li>
<li>调用ImageUtil工具类的generateThumbnail方法，得到图片的相对值路径，并赋值给相应的店铺ShopImg成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopServiceImpl</span> <span class="keyword">implements</span> <span class="title">ShopService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ShopServiceImpl.class);</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopDao shopDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ShopExecution <span class="title">addShop</span><span class="params">(Shop shop, ImageHolder thumbnail)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> ShopOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// 空值判断，判断shop中是否包含必须的值</span></span><br><span class="line">		<span class="keyword">if</span> (shop == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.NULL_SHOP);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 给店铺信息赋初始值（状态为0，审核中；以及创建时间和最近修改时间）</span></span><br><span class="line">			shop.setEnableStatus(<span class="number">0</span>);</span><br><span class="line">			shop.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">			shop.setLastEditTime(<span class="keyword">new</span> Date());</span><br><span class="line">			<span class="comment">// 添加店铺信息：成功→else；失败→进入店铺创建失败</span></span><br><span class="line">			<span class="keyword">int</span> effectedNum = shopDao.insertShop(shop);</span><br><span class="line">			<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;店铺创建失败&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (thumbnail.getImage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// 存储图片(参数shop:根据shopId得到图片的地址，参数shopImg:保存到相应的地址中)</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						addShopImg(shop, thumbnail);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;addShopImg error:&quot;</span> + e.getMessage());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 更新店铺的图片地址</span></span><br><span class="line">					effectedNum = shopDao.updateShop(shop);</span><br><span class="line">					<span class="keyword">if</span> (effectedNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;更新图片地址失败&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ShopOperationException(<span class="string">&quot;addShop error:&quot;</span> + e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ShopExecution(ShopStateEnum.CHECK, shop);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addShopImg</span><span class="params">(Shop shop, ImageHolder thumbnail)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取shop图片目录的相对值路径</span></span><br><span class="line">		String dest = PathUtil.getShopImagePath(shop.getShopId());</span><br><span class="line">		String shopImgAddr = ImageUtil.generateThumbnail(thumbnail, dest);</span><br><span class="line">		shop.setShopImg(shopImgAddr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-5-3创建ShopOperationException类"><a href="#1-5-3创建ShopOperationException类" class="headerlink" title="1.5.3创建ShopOperationException类"></a>1.5.3创建ShopOperationException类</h2><p><strong>该类对于RuntimeException做了一个简单的封装，用于更好地看出是程序的哪个类或者操作抛出的异常信息</strong></p>
<ul>
<li>该类继承了RuntimeException类（当该类抛出异常时，用事务管理的方法就会回滚）</li>
<li>只有一个构造方法</li>
<li>有一个序列化的ID</li>
</ul>
<h2 id="1-5-4Service层的测试"><a href="#1-5-4Service层的测试" class="headerlink" title="1.5.4Service层的测试"></a>1.5.4Service层的测试</h2><h1 id="1-6店铺注册功能之Controller层的实现"><a href="#1-6店铺注册功能之Controller层的实现" class="headerlink" title="1.6店铺注册功能之Controller层的实现"></a>1.6店铺注册功能之Controller层的实现</h1><ul>
<li><p>通过@Controller标签告诉spring该类为Controller类型</p>
</li>
<li><p>设置根路由为：/shopadmin</p>
</li>
<li><p>注入所需要的的实例对象</p>
</li>
<li><p>设置方法的路由为：/registershop</p>
</li>
<li><p>设置访问的方法为POST：向指定资源提交数据进行处理请求</p>
</li>
<li><p>registerShop方法的实现：（三部分）</p>
<p>方法传入的参数为：HttpServletRequest类型，url的请求头都会封装到该类的对象中，通过调用相关的方法就能获取传入的店铺相关的所有参数</p>
<p>返回类型为：Map类型，@ResponseBody标签将Map转换成json类型</p>
<p>创建modelMap用于保存方法的执行结果</p>
<p><strong>1.接收并转化相应的参数，包括店铺信息以及图片信息</strong></p>
<p>通过HttpServletRequestUtil中的getString方法，将request中key为shopStr对应的值转换成String，并用shopStr接收；</p>
<p>创建ObjectMapper对象，将json串转换成实体类shop</p>
<p>转换图片文件，创建文件上传解析器CommonsMultipartResolver，在request会话的上下文中获取文件信息，当CommonsMultipartResolver中的内容不为空，将request转换成MultipartHttpServletRequest类型的对象，再从multipartHttpServletRequest对象中取出shopImg变量的信息转换成CommonsMultipartFile，也就是spring能够处理的类型</p>
<p><strong>2.注册店铺</strong></p>
<p><strong>通过session获取店家信息：</strong>在登陆时，我们将user信息写入到session中，key设为user，这里从session中取出即可</p>
<p>当店铺和图片信息都不为空时，程序开始执行</p>
<p>从当前请求的request中取出user对应的owner信息</p>
<p>将CommonsMultipartFile类型的shopImg转换成InputStream，满足addShop方法参数要求</p>
<p>调用shopService中的addShop方法，将店铺和店铺图片封装成ShopExecution对象</p>
<p>将注册好的店铺插入到用户可操作的店铺列表中：在会话中取出用户可操作的店铺列表，没有就创建，有就取出，添加新店铺后，再将列表填入到session中</p>
<p><strong>3.返回结果</strong></p>
<p>将每步操作的执行结果放入modelMap，转换成json返回给前端</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shopadmin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopManagementController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopService shopService;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ShopCategoryService shopCategoryService;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> AreaService areaService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/registershop&quot;, method = RequestMethod.POST)</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">registerShop</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		<span class="keyword">if</span> (!CodeUtil.checkVerifyCode(request)) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;输入了错误的验证码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.接收并转化相应的参数，包括店铺信息以及图片信息</span></span><br><span class="line">		String shopStr = HttpServletRequestUtil.getString(request, <span class="string">&quot;shopStr&quot;</span>);</span><br><span class="line">		ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		Shop shop = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			shop = mapper.readValue(shopStr, Shop.class);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		CommonsMultipartFile shopImg = <span class="keyword">null</span>;</span><br><span class="line">		CommonsMultipartResolver commonsMultipartResolver = <span class="keyword">new</span> CommonsMultipartResolver(</span><br><span class="line">				request.getSession().getServletContext());</span><br><span class="line">		<span class="keyword">if</span> (commonsMultipartResolver.isMultipart(request)) &#123;</span><br><span class="line">			MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request;</span><br><span class="line">			shopImg = (CommonsMultipartFile) multipartHttpServletRequest.getFile(<span class="string">&quot;shopImg&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;上传图片不能为空&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.注册店铺</span></span><br><span class="line">		<span class="keyword">if</span> (shop != <span class="keyword">null</span> &amp;&amp; shopImg != <span class="keyword">null</span>) &#123;</span><br><span class="line">			PersonInfo owner = (PersonInfo) request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			shop.setOwner(owner);</span><br><span class="line">			ShopExecution se;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				ImageHolder imageHolder = <span class="keyword">new</span> ImageHolder(shopImg.getOriginalFilename(), shopImg.getInputStream());</span><br><span class="line">				se = shopService.addShop(shop, imageHolder);</span><br><span class="line">				<span class="keyword">if</span> (se.getState() == ShopStateEnum.CHECK.getState()) &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">					<span class="comment">// 该用户可以操作的店铺列表</span></span><br><span class="line">					<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">					List&lt;Shop&gt; shopList = (List&lt;Shop&gt;) request.getSession().getAttribute(<span class="string">&quot;shopList&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span> (shopList == <span class="keyword">null</span> || shopList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">						shopList = <span class="keyword">new</span> ArrayList&lt;Shop&gt;();</span><br><span class="line">					&#125;</span><br><span class="line">					shopList.add(se.getShop());</span><br><span class="line">					request.getSession().setAttribute(<span class="string">&quot;shopList&quot;</span>, shopList);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">					modelMap.put(<span class="string">&quot;errMsg&quot;</span>, se.getStateInfo());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ShopOperationException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">				modelMap.put(<span class="string">&quot;errMsg&quot;</span>, e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelMap.put(<span class="string">&quot;success&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">			modelMap.put(<span class="string">&quot;errMsg&quot;</span>, <span class="string">&quot;请输入店铺信息&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> modelMap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-1创建工具类HttpServletRequestUtil"><a href="#1-6-1创建工具类HttpServletRequestUtil" class="headerlink" title="1.6.1创建工具类HttpServletRequestUtil"></a>1.6.1创建工具类HttpServletRequestUtil</h2><p><strong>HttpServletRequestUtil用于转换HttpServletRequest中的数据，传入一个key，将这个key对应的值转换成相应的数据类型的值。</strong></p>
<h1 id="1-9店铺注册之前端设计"><a href="#1-9店铺注册之前端设计" class="headerlink" title="1.9店铺注册之前端设计"></a>1.9店铺注册之前端设计</h1><h2 id="1-9-1SUI-Mobile介绍"><a href="#1-9-1SUI-Mobile介绍" class="headerlink" title="1.9.1SUI Mobile介绍"></a>1.9.1SUI Mobile介绍</h2><p>SUI Mobile 是一套基于 <a href="http://framework7.taobao.org/">Framework7</a> 开发的UI库。它非常轻量、精美，只需要引入我们的CDN文件就可以使用，并且能兼容到 iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。</p>
<h2 id="1-9-2创建shopoperation-html页面"><a href="#1-9-2创建shopoperation-html页面" class="headerlink" title="1.9.2创建shopoperation.html页面"></a>1.9.2创建shopoperation.html页面</h2><p><strong>分段介绍shopoperation.html的作用：</strong></p>
<p><strong>1.表头提供设备方面的信息，能根据设备的属性来调整页面到适合设备的尺寸</strong></p>
<p><strong>2.表头之下引入css文件</strong></p>
<p>这里的css文件要在js静态资源之前，是因为在加载html页面时，我们要先生成页面的轮廓或者布局，再将静态资源填到页面中</p>
<p><strong>3.主体</strong></p>
<ul>
<li><strong>li标签：</strong>页面显示中的一些控件等，</li>
<li><strong>id：</strong>通过给这些控件加<strong>id</strong>命名，可以方便在js代码中对这些控件进行选中、响应或其他操作</li>
<li><strong>input type：</strong>控件的类型</li>
</ul>
<p><strong>4.结尾</strong></p>
<ul>
<li><strong>给出静态资源的位置，导入必要的.css文件和.js文件</strong></li>
</ul>
<h2 id="1-9-3创建ShopAdminController"><a href="#1-9-3创建ShopAdminController" class="headerlink" title="1.9.3创建ShopAdminController"></a>1.9.3创建ShopAdminController</h2><p>因为我们为了隐藏我们的项目结构，所以不能直接在url中体现我们shopoperation.html页面的位置，但是放在WEB-INF下外部是访问不到的，因此创建ShopAdminController根据url进行页面的转发：</p>
<p>这个返回的字符串再与spring-web中配置的前后缀拼接，得到页面的全路径</p>
<h2 id="1-9-4店铺注册之js实现"><a href="#1-9-4店铺注册之js实现" class="headerlink" title="1.9.4店铺注册之js实现"></a>1.9.4店铺注册之js实现</h2><p> 创建<strong>shopoperation.js文件</strong>，这个文件的功能为<strong>操作html页面</strong>：</p>
<ul>
<li>获取初始的信息，将一些信息填充到控件中</li>
<li>当我们点击提交时，获取表单的信息，并通过ajax将这个json对象传递到后端</li>
</ul>
<p>所有动作都是<strong>异步</strong>的，不影响用户的前端体验</p>
<p><strong>功能一的实现：</strong></p>
<ul>
<li><p>定义两个url：一个是获取店铺信息的url，另一个是注册店铺的url</p>
</li>
<li><p>方法getShopInitInfo：</p>
<p>通过获取店铺信息的url从后端获取区域和店铺列表数据data</p>
<p>如果json中key=success为true，开始遍历json中的区域和店铺信息，并将它们填充到html页面的相应控件中</p>
</li>
</ul>
<p><strong>功能二的实现：</strong></p>
<ul>
<li>从html页面的各个控件中选择其中的内容放到shop集合中，特殊的像区域和店铺类型要将用户的选择放到集合中</li>
</ul>
<ul>
<li>ajax将shop集合转换成json对象，通过注册店铺的url将这些数据返回到后端的方法中</li>
</ul>
<h1 id="1-10引入kaptcha实现验证码"><a href="#1-10引入kaptcha实现验证码" class="headerlink" title="1.10引入kaptcha实现验证码"></a>1.10引入kaptcha实现验证码</h1><h2 id="1-10-1引入kaptcha的jar包"><a href="#1-10-1引入kaptcha的jar包" class="headerlink" title="1.10.1引入kaptcha的jar包"></a>1.10.1引入kaptcha的jar包</h2><h2 id="1-10-2在web-xml中创建验证码的servlet"><a href="#1-10-2在web-xml中创建验证码的servlet" class="headerlink" title="1.10.2在web.xml中创建验证码的servlet"></a>1.10.2在web.xml中创建验证码的servlet</h2><p>servlet是运行在服务器上的一个小程序，用来处理服务器请求的</p>
<p><strong>每个servlet都要有映射！：</strong>如果不加映射，会找不到对应的servlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet-name指向servlet的注册名称 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- url-pattern 设置servlet对外访问的路径（一定要加斜杠） --&gt;</span></span><br></pre></td></tr></table></figure>

<p>例如：这里对验证码这个servlet的请求为<a href="http://localhost:8080/o2o/Kaptcha%EF%BC%8C%E6%98%A0%E5%B0%84%E4%BC%9A%E7%94%B1/Kaptcha%E6%98%A0%E5%B0%84%E5%88%B0servlet%E7%9A%84%E6%B3%A8%E5%86%8C%E5%90%8D%E7%A7%B0Kaptcha%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81servlet">http://localhost:8080/o2o/Kaptcha，映射会由/Kaptcha映射到servlet的注册名称Kaptcha，找到对应的验证码servlet</a></p>
<h2 id="1-10-3在html中加入kaptcha控件"><a href="#1-10-3在html中加入kaptcha控件" class="headerlink" title="1.10.3在html中加入kaptcha控件"></a>1.10.3在html中加入kaptcha控件</h2><ul>
<li><strong>id：</strong>验证码控件的名称</li>
<li><strong>changeVerifyCode：</strong>自定义的一个方法，即点击本身更换验证码</li>
<li><strong>src：</strong>指定验证码的servlet</li>
</ul>
<h2 id="1-10-4创建js文件，实现kaptcha控件中changeVerifyCode方法"><a href="#1-10-4创建js文件，实现kaptcha控件中changeVerifyCode方法" class="headerlink" title="1.10.4创建js文件，实现kaptcha控件中changeVerifyCode方法"></a>1.10.4创建js文件，实现kaptcha控件中changeVerifyCode方法</h2><h2 id="1-10-5将kaptcha控件中的内容传入后台"><a href="#1-10-5将kaptcha控件中的内容传入后台" class="headerlink" title="1.10.5将kaptcha控件中的内容传入后台"></a>1.10.5将kaptcha控件中的内容传入后台</h2><p>将kaptcha控件中的内容读取到js文件中，在js文件里读取控件内容，将验证码内容读取保存到json中，通过ajax传到后台</p>
<h2 id="1-10-6创建CodeUtil工具类"><a href="#1-10-6创建CodeUtil工具类" class="headerlink" title="1.10.6创建CodeUtil工具类"></a>1.10.6创建CodeUtil工具类</h2><ul>
<li>CodeUtil工具类用于比较图片中实际的验证码与输入的验证码是否一致</li>
<li>图片中的验证码是从请求会话中得到的</li>
<li>在店铺注册中调用工具类来比较验证码是否一致</li>
</ul>
<h1 id="1-11前后端联合调试"><a href="#1-11前后端联合调试" class="headerlink" title="1.11前后端联合调试"></a>1.11前后端联合调试</h1><ol>
<li><p>以Debug方式启动Tomcat</p>
</li>
<li><p>在前端打断点，<strong>建议设置在明确执行的方法的入口处</strong>，这里我们选择设置在<code>点击提交按钮</code>后的代码处</p>
</li>
<li><p>后端打断点，在店铺注册的Controller方法的入口处</p>
</li>
<li><p>在前端打断点，在ajax中的弹出结果信息方法入口处</p>
</li>
<li><p>输入店铺的注册信息，输入验证码，点击提交，执行到前端js中的断点位置</p>
</li>
</ol>
<ol start="6">
<li><p>在js代码逻辑中获取表单的各项信息，并将验证码也填入集合对象中</p>
</li>
<li><p>ajax通过注册店铺的url进入后端店铺注册的Controller方法中的断点处</p>
</li>
</ol>
<ol start="8">
<li>方法执行结束，返回前端，弹出执行的结果信息</li>
</ol>
]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-店铺编辑和列表功能</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BA%97%E9%93%BA%E7%BC%96%E8%BE%91%E5%92%8C%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1店铺信息编辑之Dao层开发"><a href="#1-1店铺信息编辑之Dao层开发" class="headerlink" title="1.1店铺信息编辑之Dao层开发"></a>1.1店铺信息编辑之Dao层开发</h1><h2 id="1-1-1ShopDao接口"><a href="#1-1-1ShopDao接口" class="headerlink" title="1.1.1ShopDao接口"></a>1.1.1ShopDao接口</h2><p><strong>新建queryByShopId方法：</strong>因为对店铺进行编辑之前，要先将店铺的信息查询出来</p>
<h2 id="1-1-2Mapper中实现queryByShopId方法"><a href="#1-1-2Mapper中实现queryByShopId方法" class="headerlink" title="1.1.2Mapper中实现queryByShopId方法"></a>1.1.2Mapper中实现queryByShopId方法</h2><p><strong>在Mapper中自定义返回类型：</strong></p>
<p>主要是复合类型的定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//resultMap type：自定义的Shop实体类</span><br><span class="line">//id：返回类型的名称</span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.imooc.o2o.entity.Shop&quot;</span> <span class="attr">id</span>=<span class="string">&quot;shopMap&quot;</span>&gt;</span></span><br><span class="line">        //id column：主键为shop_id，与数据库中列名一致</span><br><span class="line">        //property：与实体类中的成员变量名称一致</span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;shop_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopId&quot;</span> /&gt;</span></span><br><span class="line">		//result column：与数据库中列名一致</span><br><span class="line">        //property：与实体类中的成员变量名称一致</span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_desc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopDesc&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_addr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopAddr&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">property</span>=<span class="string">&quot;phone&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_img&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopImg&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;priority&quot;</span> <span class="attr">property</span>=<span class="string">&quot;priority&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;last_edit_time&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastEditTime&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;enable_status&quot;</span> <span class="attr">property</span>=<span class="string">&quot;enableStatus&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;advice&quot;</span> <span class="attr">property</span>=<span class="string">&quot;advice&quot;</span> /&gt;</span></span><br><span class="line">		//复合类型，property：与实体类中的成员变量名称一致</span><br><span class="line">		//通过area_id连接</span><br><span class="line">		//javaType：该复合类型所对应的Java实体类</span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;area&quot;</span> <span class="attr">column</span>=<span class="string">&quot;area_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.Area&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;area_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;areaId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;area_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;areaName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;shopCategory&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">column</span>=<span class="string">&quot;shop_category_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.ShopCategory&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;shop_category_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;shopCategoryId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;shop_category_name&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">property</span>=<span class="string">&quot;shopCategoryName&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;owner&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">javaType</span>=<span class="string">&quot;com.imooc.o2o.entity.PersonInfo&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>对应的SQL语句：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByShopId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;shopMap&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">        //要选出的店铺信息</span><br><span class="line">		s.shop_id,</span><br><span class="line">		s.shop_name,</span><br><span class="line">		s.shop_desc,</span><br><span class="line">		s.shop_addr,</span><br><span class="line">		s.phone,</span><br><span class="line">		s.shop_img,</span><br><span class="line">		s.priority,</span><br><span class="line">		s.create_time,</span><br><span class="line">		s.last_edit_time,</span><br><span class="line">		s.enable_status,</span><br><span class="line">		s.advice,</span><br><span class="line">        //要选出的区域信息</span><br><span class="line">		a.area_id,</span><br><span class="line">		a.area_name,</span><br><span class="line">        //要选出的店铺类别信息</span><br><span class="line">		sc.shop_category_id,</span><br><span class="line">		sc.shop_category_name</span><br><span class="line">		FROM</span><br><span class="line">		tb_shop s,</span><br><span class="line">		tb_area a,</span><br><span class="line">		tb_shop_category sc</span><br><span class="line">		WHERE</span><br><span class="line">        //where子查询定义查询的条件，也就是与店铺中area_id和shop_category_id中相等的区域和类别信息</span><br><span class="line">		s.area_id=a.area_id</span><br><span class="line">		AND</span><br><span class="line">		s.shop_category_id = sc.shop_category_id</span><br><span class="line">		AND</span><br><span class="line">        //传入的参数也就是店铺Id</span><br><span class="line">		s.shop_id=#&#123;shopId&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="1-2店铺信息编辑之Service层的实现"><a href="#1-2店铺信息编辑之Service层的实现" class="headerlink" title="1.2店铺信息编辑之Service层的实现"></a>1.2店铺信息编辑之Service层的实现</h1><h2 id="1-2-1ShopService接口"><a href="#1-2-1ShopService接口" class="headerlink" title="1.2.1ShopService接口"></a>1.2.1ShopService接口</h2><p><strong>getByShopId方法：</strong></p>
<ul>
<li>返回shop实体类对象</li>
</ul>
<p><strong>modifyShop方法：</strong></p>
<ul>
<li>传入店铺和图片</li>
<li>更新店铺信息，包括对图片的处理</li>
<li>返回ShopExecution对象</li>
</ul>
<h2 id="1-2-2ShopServiceImpl实现方法"><a href="#1-2-2ShopServiceImpl实现方法" class="headerlink" title="1.2.2ShopServiceImpl实现方法"></a>1.2.2ShopServiceImpl实现方法</h2><p><strong>modifyShop方法：</strong></p>
<ol>
<li><p>判断是否需要处理图片</p>
<p>当有图片时，先调用工具类中的方法，将图片删除</p>
<p>调用添加图片的方法，将图片更新到数据库中</p>
</li>
<li><p>更新店铺信息</p>
<p>这里要用已经修改后的店铺（有最新的图片信息），而不是刚开始通过shopID查询的tempShop</p>
</li>
</ol>
<p>其中对于图片的处理需要工具类中加入方法deleteFileOrPath：</p>
<ul>
<li>先判断storePath是文件的路径还是目录的路径 如果storePath是文件的路径，直接删除该文件</li>
<li>如果storePath是目录的路径则删除该目录下的所有文件</li>
</ul>
<h1 id="1-3店铺信息编辑之Controller层实现"><a href="#1-3店铺信息编辑之Controller层实现" class="headerlink" title="1.3店铺信息编辑之Controller层实现"></a>1.3店铺信息编辑之Controller层实现</h1><h2 id="1-3-1getShopById方法的实现"><a href="#1-3-1getShopById方法的实现" class="headerlink" title="1.3.1getShopById方法的实现"></a>1.3.1getShopById方法的实现</h2><ul>
<li>创建modelMap用来接收返回结果</li>
<li>从request中获取shopId</li>
<li>通过调用Service层的getByShopId和getAreaList方法获取店铺信息及区域列表，将这些信息放入modelMap</li>
<li>操作成功：将成功信息放入modelMap</li>
<li>操作失败：将失败信息放入modelMap</li>
<li>操作异常：将异常信息放入modelMap</li>
<li>返回modelMap</li>
</ul>
<h2 id="1-3-2modifyShop方法的实现"><a href="#1-3-2modifyShop方法的实现" class="headerlink" title="1.3.2modifyShop方法的实现"></a>1.3.2modifyShop方法的实现</h2><ul>
<li>创建modelMap用于将结果返回到前端</li>
<li>判断验证码信息</li>
</ul>
<p><strong>下面与注册店铺的逻辑基本相同</strong></p>
<ul>
<li><p>接收并转化相应的参数，包括店铺信息以及图片信息</p>
</li>
<li><p>修改店铺信息</p>
<p>店铺注册时图片信息不能为空</p>
<p>这里的图片信息是可以为空的，只对店铺内容更新即可</p>
</li>
</ul>
<h1 id="1-4店铺信息编辑之前端实现"><a href="#1-4店铺信息编辑之前端实现" class="headerlink" title="1.4店铺信息编辑之前端实现"></a>1.4店铺信息编辑之前端实现</h1><h2 id="1-4-1shopoperation-js文件修改"><a href="#1-4-1shopoperation-js文件修改" class="headerlink" title="1.4.1shopoperation.js文件修改"></a>1.4.1shopoperation.js文件修改</h2><ul>
<li><p>在common.js中添加getQueryString方法来获取ShopId</p>
</li>
<li><p>通过判断shopId是否为空来决定使用哪个功能</p>
<p>shopId=null：店铺注册</p>
<p>shopId！=null：修改店铺</p>
</li>
<li><p>创建两个Url：</p>
<p>shopInfoUrl：获取店铺信息（上面获取的shopId要拼接到这个Url中）</p>
<p>editShopUrl：修改店铺</p>
</li>
<li><p>这里的逻辑就是当shopId为空时，通过initUrl来获取店铺注册所需要的信息（区域列表、店铺类别等）</p>
<p>当shopId不为空时，通过shopInfoUrl来获取店铺信息，后面进行修改</p>
<p>同时，在ajax中也要判断shopId是否为空来决定将数据传送给后端的哪个controller方法</p>
</li>
</ul>
<h1 id="1-5店铺列表展示之Dao层的实现"><a href="#1-5店铺列表展示之Dao层的实现" class="headerlink" title="1.5店铺列表展示之Dao层的实现"></a>1.5店铺列表展示之Dao层的实现</h1><h2 id="1-5-1ShopDao接口"><a href="#1-5-1ShopDao接口" class="headerlink" title="1.5.1ShopDao接口"></a>1.5.1ShopDao接口</h2><p><strong>新建queryShopList方法：</strong>分页查询店铺，可输入的条件有：店铺名（模糊查询），店铺状态，店铺类别，区域Id，owner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 分页查询店铺，可输入的条件有：店铺名（模糊查询），店铺类别，区域Id，owner</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> shopCondition</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rowIndex      从第几行开始取数据</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pageSize      返回的数据条数（从起始行算起）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">List&lt;Shop&gt; <span class="title">queryShopList</span><span class="params">(<span class="meta">@Param(&quot;shopCondition&quot;)</span> Shop shopCondition, <span class="meta">@Param(&quot;rowIndex&quot;)</span> <span class="keyword">int</span> rowIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Param(&quot;pageSize&quot;)</span> <span class="keyword">int</span> pageSize)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@Param标签：</strong>当方法中有多个参数时，需要用标签将不同的参数区分开</p>
</blockquote>
<p><strong>新建queryShopCount方法：</strong>返回查询的店铺总数，<strong>用来支持分页查询</strong></p>
<h2 id="1-5-2Mapper中实现queryShopList方法"><a href="#1-5-2Mapper中实现queryShopList方法" class="headerlink" title="1.5.2Mapper中实现queryShopList方法"></a>1.5.2Mapper中实现queryShopList方法</h2><p><strong>代码的逻辑就是在where子句中加入动态SQL，只要参数有值就会将多个参数组合起来查询</strong></p>
<p><strong>注意：</strong>对于商铺名称我们使用模糊查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模糊查询用like ‘%xxx%’</span><br><span class="line">where s.shop_name like &#39;%要匹配的字符串%&#39;</span><br></pre></td></tr></table></figure>

<p>这里加入了分页查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;按照权重从高到低排序后，按照传入的参数确定返回的数据条数</span><br><span class="line">ORDER BY</span><br><span class="line">s.priority DESC</span><br><span class="line">LIMIT #&#123;rowIndex&#125;,#&#123;pageSize&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryShopList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;shopMap&quot;</span>&gt;</span></span><br><span class="line">		SELECT</span><br><span class="line">		s.shop_id,</span><br><span class="line">		s.shop_name,</span><br><span class="line">		s.shop_desc,</span><br><span class="line">		s.shop_addr,</span><br><span class="line">		s.phone,</span><br><span class="line">		s.shop_img,</span><br><span class="line">		s.priority,</span><br><span class="line">		s.create_time,</span><br><span class="line">		s.last_edit_time,</span><br><span class="line">		s.enable_status,</span><br><span class="line">		s.advice,</span><br><span class="line">		a.area_id,</span><br><span class="line">		a.area_name,</span><br><span class="line">		sc.shop_category_id,</span><br><span class="line">		sc.shop_category_name</span><br><span class="line">		FROM</span><br><span class="line">		tb_shop s,</span><br><span class="line">		tb_area a,</span><br><span class="line">		tb_shop_category sc</span><br><span class="line">		<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.shopCategory != null and </span></span></span><br><span class="line"><span class="tag"><span class="string">			shopCondition.shopCategory.shopCategoryId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_category_id =</span><br><span class="line">				#&#123;shopCondition.shopCategory.shopCategoryId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.shopCategory != null </span></span></span><br><span class="line"><span class="tag"><span class="string">			and shopCondition.shopCategory.parent!=null </span></span></span><br><span class="line"><span class="tag"><span class="string">			and shopCondition.shopCategory.parent.shopCategoryId !=null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_category_id in (select shop_category_id from</span><br><span class="line">				tb_shop_category</span><br><span class="line">				WHERE parent_id =</span><br><span class="line">				#&#123;shopCondition.shopCategory.parent.shopCategoryId&#125;)</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.area != null and </span></span></span><br><span class="line"><span class="tag"><span class="string">			shopCondition.area.areaId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.area_id =</span><br><span class="line">				#&#123;shopCondition.area.areaId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopCondition.shopName != null&quot;</span>&gt;</span></span><br><span class="line">				and s.shop_name like &#x27;%$&#123;shopCondition.shopName&#125;%&#x27;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;shopCondition.enableStatus != null&quot;</span>&gt;</span></span><br><span class="line">				and s.enable_status = #&#123;shopCondition.enableStatus&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span></span></span><br><span class="line"><span class="tag">				<span class="attr">test</span>=<span class="string">&quot;shopCondition.owner != null and shopCondition.owner.userId != null&quot;</span>&gt;</span></span><br><span class="line">				and s.owner_id = #&#123;shopCondition.owner.userId&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			AND</span><br><span class="line">			s.area_id=a.area_id</span><br><span class="line">			AND</span><br><span class="line">			s.shop_category_id = sc.shop_category_id</span><br><span class="line">		<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">		ORDER BY</span><br><span class="line">		s.priority DESC</span><br><span class="line">		LIMIT #&#123;rowIndex&#125;,#&#123;pageSize&#125;;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="1-6店铺列表展示之Service层的实现"><a href="#1-6店铺列表展示之Service层的实现" class="headerlink" title="1.6店铺列表展示之Service层的实现"></a>1.6店铺列表展示之Service层的实现</h1><h2 id="1-6-1ShopService接口"><a href="#1-6-1ShopService接口" class="headerlink" title="1.6.1ShopService接口"></a>1.6.1ShopService接口</h2><p><strong>getShopList方法：</strong></p>
<ul>
<li>根据shopCondition分页返回相应店铺列表</li>
</ul>
<h2 id="1-6-2ShopServiceImpl实现方法"><a href="#1-6-2ShopServiceImpl实现方法" class="headerlink" title="1.6.2ShopServiceImpl实现方法"></a>1.6.2ShopServiceImpl实现方法</h2><p><strong>getShopList方法：</strong></p>
<p>这里获取店铺列表时，由于在数据库中我们只认行数，而在前端要转换成页数，因此要添加工具类，将行数转换成页码</p>
]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-项目升级</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>校园商铺1.0-商品类别模块</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%95%86%E5%93%81%E7%B1%BB%E5%88%AB%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>校园商铺1.0-开发准备</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1环境准备"><a href="#1-1环境准备" class="headerlink" title="1.1环境准备"></a>1.1环境准备</h1><ul>
<li>  JDK 1.8：提供Java基础类库的支持；</li>
<li>  Maven 3.3.9：对项目用到的jar包进行管理；</li>
<li>  MySQL 5.5+：存储数据；</li>
<li>  Chrome：展示与前端调试；</li>
<li>  Tomcat 8：运行Java项目；</li>
<li>  Eclipse：开发工具</li>
</ul>
<h1 id="1-2开发准备"><a href="#1-2开发准备" class="headerlink" title="1.2开发准备"></a>1.2开发准备</h1><h2 id="1-2-1JDK1-8"><a href="#1-2-1JDK1-8" class="headerlink" title="1.2.1JDK1.8"></a>1.2.1JDK1.8</h2><h3 id="1-2-1-1下载安装"><a href="#1-2-1-1下载安装" class="headerlink" title="1.2.1.1下载安装"></a>1.2.1.1下载安装</h3><h3 id="1-2-1-1配置到eclipse中"><a href="#1-2-1-1配置到eclipse中" class="headerlink" title="1.2.1.1配置到eclipse中"></a>1.2.1.1配置到eclipse中</h3><p><strong>如下图所示：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片01.png" style="zoom:67%;">

<h2 id="1-2-2Tomcat"><a href="#1-2-2Tomcat" class="headerlink" title="1.2.2Tomcat"></a>1.2.2Tomcat</h2><h3 id="1-2-2-1下载安装"><a href="#1-2-2-1下载安装" class="headerlink" title="1.2.2.1下载安装"></a>1.2.2.1下载安装</h3><p><strong>详细的Tomcat服务器下载、安装、配置环境变量教程请点击：<a href="https://blog.csdn.net/qq_40881680/article/details/83582484?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161694559516780264078493%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161694559516780264078493&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-83582484.nonecase&utm_term=Tomcat">点击这里</a></strong></p>
<h3 id="1-2-2-1配置到eclipse中"><a href="#1-2-2-1配置到eclipse中" class="headerlink" title="1.2.2.1配置到eclipse中"></a>1.2.2.1配置到eclipse中</h3><p><strong>按下图将Tomcat配置到eclipse中：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片02.png" style="zoom:67%;">

<h2 id="1-2-3Maven"><a href="#1-2-3Maven" class="headerlink" title="1.2.3Maven"></a>1.2.3Maven</h2><h3 id="1-2-3-1下载安装"><a href="#1-2-3-1下载安装" class="headerlink" title="1.2.3.1下载安装"></a>1.2.3.1下载安装</h3><h3 id="1-2-3-1配置到eclipse中"><a href="#1-2-3-1配置到eclipse中" class="headerlink" title="1.2.3.1配置到eclipse中"></a>1.2.3.1配置到eclipse中</h3><p><strong>将eclipse自带的Maven插件与我们本地的Maven对应起来：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片03.png" style="zoom:67%;">

<p><strong>配置eclipse让它读取我们本地的Maven配置文件，以及告诉eclipse读取我们本地的jar包：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片04.png" style="zoom:67%;">

<h2 id="1-2-3下载安装Mysql5-7"><a href="#1-2-3下载安装Mysql5-7" class="headerlink" title="1.2.3下载安装Mysql5.7"></a>1.2.3下载安装Mysql5.7</h2><h2 id="1-2-4创建Maven项目"><a href="#1-2-4创建Maven项目" class="headerlink" title="1.2.4创建Maven项目"></a>1.2.4创建Maven项目</h2><p><strong>选择Maven Project&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片05.png" style="zoom:67%;">

<p><strong>点击Next&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片06.png" style="zoom:67%;">

<p><strong>选择Java动态项目工程如下图&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片07.png" style="zoom:67%;">

<p><strong>给创建的Maven项目命名为：o2o&gt;</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片08.png" style="zoom:67%;">

<p><strong>创建完成！</strong> </p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片09.png" style="zoom:67%;">

<p><strong>配置输出文件的位置，如下图所示：</strong></p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片10.png" style="zoom:67%;">

<h2 id="1-2-5动态Javaweb项目与静态的Javaweb项目"><a href="#1-2-5动态Javaweb项目与静态的Javaweb项目" class="headerlink" title="1.2.5动态Javaweb项目与静态的Javaweb项目"></a>1.2.5动态Javaweb项目与静态的Javaweb项目</h2><p><strong>动态的Javaweb项目：</strong>包含一些Java代码，像JavaScript，它可以向后台传入数据，还可以响应请求从后端取出数据；</p>
<p><strong>静态的Javaweb项目：</strong>不能包含动态信息，在编写代码时直接写死，点击就可以看到效果。</p>
<p>这里使用的是动态的Javaweb项目，要及时修改Dynamic Web Module实现更好的网页性能，并要确保与jdk版本兼容</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片11.png" style="zoom:67%;">

<p>修改版本之后，要修改web.xml中的规范，这里使用的是version=3.1</p>
<img src="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/GitHub\MyBlogs\source\_posts\2021-03-24-校园商铺1.0-开发准备\图片12.png" style="zoom:67%;">]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-项目设计和框架搭建</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="2-1系统功能模块划分"><a href="#2-1系统功能模块划分" class="headerlink" title="2.1系统功能模块划分"></a>2.1系统功能模块划分</h1><p> 2.1.1前端展示系统</p>
<ul>
<li><p>头条展示：通过轮播图的形式，将数据库中的头条图片展示出来</p>
</li>
<li><p>店铺类别展示：将一级类别展示出来</p>
</li>
<li><p>区域展示</p>
</li>
<li><p>店铺：</p>
<p>列表展示（点击全部商店）</p>
<p>查询店铺（搜索框）</p>
<p>查看店铺详情</p>
</li>
<li><p>商品（同上）</p>
</li>
</ul>
<p>2.1.2店家系统</p>
<ul>
<li>Local账号维护（注册账户、与微信账号绑定）</li>
<li>微信账号维护（支持微信登录）</li>
<li>店铺信息维护</li>
<li>权限验证（检测账号是否具有相关的权限去修改商品信息）</li>
<li>商品类别维护</li>
</ul>
<p>2.1.3 超级管理员系统</p>
<h1 id="2-2实体类与表创建A"><a href="#2-2实体类与表创建A" class="headerlink" title="2.2实体类与表创建A"></a>2.2实体类与表创建A</h1><h2 id="2-2-1实体类的框架"><a href="#2-2-1实体类的框架" class="headerlink" title="2.2.1实体类的框架"></a>2.2.1实体类的框架</h2><h3 id="2-2-1-1项目1-0实体类框架："><a href="#2-2-1-1项目1-0实体类框架：" class="headerlink" title="2.2.1.1项目1.0实体类框架："></a>2.2.1.1项目1.0实体类框架：</h3><h3 id="2-2-1-2区域"><a href="#2-2-1-2区域" class="headerlink" title="2.2.1.2区域"></a>2.2.1.2区域</h3><ul>
<li><strong>区域ID：</strong>主键（自增+1）</li>
<li><strong>名称：</strong>唯一键，区域名称不能重复</li>
<li>权重：权重越大，排序越靠前</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
<li>更新时间</li>
</ul>
<h3 id="2-2-1-3用户"><a href="#2-2-1-3用户" class="headerlink" title="2.2.1.3用户"></a>2.2.1.3用户</h3><ul>
<li><p><strong>用户ID：</strong>主键（自增+1）</p>
</li>
<li><p>姓名：</p>
</li>
<li><p>性别：</p>
</li>
<li><p><strong>状态：</strong>标志用户是否有资格进入商城对商铺和商品信息做操作</p>
<p>能操作：1</p>
<p>不能操作：0</p>
</li>
<li><p><strong>身份标识：</strong></p>
<p>顾客：1</p>
<p>店家：2</p>
<p>超级管理员：3</p>
</li>
<li><p>头像：存储头像的地址</p>
</li>
<li><p>邮箱</p>
</li>
<li><p>创建时间</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<h3 id="2-2-1-4微信账号与本地账号"><a href="#2-2-1-4微信账号与本地账号" class="headerlink" title="2.2.1.4微信账号与本地账号"></a>2.2.1.4微信账号与本地账号</h3><p><strong>微信账号：</strong></p>
<ul>
<li><p>ID：主键（自增+1）</p>
</li>
<li><p><strong>用户ID：</strong>作为<strong>外键</strong>与<strong>用户信息</strong>关联</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//创建外键：</span><br><span class="line">constraint `外键名称` foreign key(`要指定为外键的列`) references `与哪个表关联`(`关联表的主键`)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>openID：</strong>设置为<strong>唯一索引</strong>，来<strong>提升查询的性能</strong>，微信账号与微信公众号绑定的标识</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
</ul>
<p><strong>本地账号：</strong></p>
<ul>
<li>ID：主键（自增+1） </li>
<li><strong>用户ID：</strong>作为<strong>外键</strong>与<strong>用户信息</strong>关联</li>
<li><strong>用户名：</strong>唯一键，用户名不能重复</li>
<li>密码</li>
<li>创建时间</li>
</ul>
<h3 id="2-2-1-5头条"><a href="#2-2-1-5头条" class="headerlink" title="2.2.1.5头条"></a>2.2.1.5头条</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p>名称：唯一键，区域名称不能重复</p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>状态：表示头条是否可用</p>
<p>可用：0</p>
<p>不可用：1</p>
</li>
<li><p>链接：点击首页的头条会链接到相应的url</p>
</li>
<li><p>图片</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<h3 id="2-2-1-6店铺类别"><a href="#2-2-1-6店铺类别" class="headerlink" title="2.2.1.6店铺类别"></a>2.2.1.6店铺类别</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>上级ID：</strong>上级ID为null时就是我们的根类，往下就是子类 </p>
<p>作为外键使用，与表本身的tb_shop_category链接起来，也就是它的父类是哪个类</p>
</li>
<li><p>名称</p>
</li>
<li><p>描述</p>
</li>
<li><p>图片  </p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>更新时间</p>
</li>
</ul>
<h3 id="2-2-1-7店铺"><a href="#2-2-1-7店铺" class="headerlink" title="2.2.1.7店铺"></a>2.2.1.7店铺</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>店名：</strong>唯一键，区域名称不能重复</p>
</li>
<li><p>权重：权重越大，排序越靠前</p>
</li>
<li><p>描述</p>
</li>
<li><p>联系方式</p>
</li>
<li><p>门面照</p>
</li>
<li><p>地址</p>
</li>
<li><p>状态：店铺是否可用</p>
<p>不可用：-1 表示前端看不到店铺，店家无法修改店铺信息，发布商品等</p>
<p>审核中：0 表示前端看不到店铺，但是店家能够对店铺操作</p>
<p> 可用：通过了审核，正常状态</p>
</li>
<li><p>建议：超级管理员对店铺的建议</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>更新时间</p>
</li>
<li><p><strong>区域ID：外键，</strong>与区域ID关联，表示属于校园的哪个区域</p>
</li>
<li><p><strong>类别ID：外键，</strong>表示店铺属于哪个类</p>
</li>
<li><p><strong>用户ID：外键，</strong>表示店铺的创建者 </p>
</li>
</ul>
<h3 id="2-2-1-8商品类别"><a href="#2-2-1-8商品类别" class="headerlink" title="2.2.1.8商品类别"></a>2.2.1.8商品类别</h3><ul>
<li><strong>ID：</strong>主键（自增+1）</li>
<li><strong>店铺ID：</strong>所属于哪个店铺</li>
<li>权重</li>
<li>名称</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
</ul>
<h3 id="2-2-1-9详情图片"><a href="#2-2-1-9详情图片" class="headerlink" title="2.2.1.9详情图片"></a>2.2.1.9详情图片</h3><ul>
<li><strong>ID：</strong>主键（自增+1）</li>
<li><strong>商品ID：外键，</strong>属于哪个商品的详情图片</li>
<li>图片的地址</li>
<li>描述</li>
<li>权重</li>
<li>名称</li>
<li>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</li>
</ul>
<h3 id="2-2-1-10商品"><a href="#2-2-1-10商品" class="headerlink" title="2.2.1.10商品"></a>2.2.1.10商品</h3><ul>
<li><p><strong>ID：</strong>主键（自增+1）</p>
</li>
<li><p><strong>店铺ID：外键，</strong>属于哪个店铺的商品</p>
</li>
<li><p><strong>类别ID：外键</strong>该商品属于哪个类别</p>
</li>
<li><p>描述</p>
</li>
<li><p>权重</p>
</li>
<li><p>商品名</p>
</li>
<li><p>原价</p>
</li>
<li><p>折扣价</p>
</li>
<li><p>状态</p>
<p>下架：0</p>
<p>在前端展示系统显示：1</p>
</li>
<li><p>缩略图：缩略图的地址</p>
</li>
<li><p>创建时间：类型是时间戳datetime，它的范围比较大，所以这里不用timestamp</p>
</li>
<li><p>修改时间</p>
</li>
</ul>
<h2 id="2-2-2实体类之间的关联"><a href="#2-2-2实体类之间的关联" class="headerlink" title="2.2.2实体类之间的关联"></a>2.2.2实体类之间的关联</h2><h3 id="2-2-2-1用户信息关联"><a href="#2-2-2-1用户信息关联" class="headerlink" title="2.2.2.1用户信息关联"></a>2.2.2.1用户信息关联</h3><h3 id="2-2-2-2店铺信息关联"><a href="#2-2-2-2店铺信息关联" class="headerlink" title="2.2.2.2店铺信息关联"></a>2.2.2.2店铺信息关联</h3><h3 id="2-2-2-3商品信息关联"><a href="#2-2-2-3商品信息关联" class="headerlink" title="2.2.2.3商品信息关联"></a>2.2.2.3商品信息关联</h3><h2 id="2-2-3可视化软件SQLYog"><a href="#2-2-3可视化软件SQLYog" class="headerlink" title="2.2.3可视化软件SQLYog"></a>2.2.3可视化软件SQLYog</h2><p><strong>使用可视化软件SQLYog对数据库进行表的创建和修改</strong></p>
<h2 id="2-2-4配置Maven"><a href="#2-2-4配置Maven" class="headerlink" title="2.2.4配置Maven"></a>2.2.4配置Maven</h2><h3 id="2-2-4-1项目1-0的整体架构"><a href="#2-2-4-1项目1-0的整体架构" class="headerlink" title="2.2.4.1项目1.0的整体架构"></a>2.2.4.1项目1.0的整体架构</h3><ul>
<li><p><strong>1.src/main/java：</strong>存放业务的Java代码；</p>
</li>
<li><p><strong>2.src/main/resources：</strong>存放项目用到的资源文件，如spring、mybatis、日志的配置文件；</p>
<p>​     src/main/resources/spring：存放spring相关的配置信息；</p>
<p>​     src/main/resources/mapper：存放Dao中每个方法对应的SQL，<strong>Mybatis让我们不用去写Dao的实现类</strong></p>
</li>
<li><p><strong>3.src/test/java：</strong>存放单元测试所涉及到的Java代码；</p>
</li>
<li><p><strong>4.src/test/resources：</strong>存放单元测试所涉及到的配置文件；</p>
</li>
<li><p><strong>5.Maven Dependencies：</strong>存储项目中通过Maven管理的.jar包，通常通过<strong>pom.xml</strong>指定下载；</p>
</li>
<li><p><strong>6.Apache Tomcat：</strong>存放的是Tomcat所依赖的.jar包；</p>
</li>
<li><p><strong>7.JRE System Library：</strong>存放Java运行时所需要的.jar包；</p>
</li>
<li><p><strong>8.src文件夹下的webapp下的resources：</strong>存放项目的静态资源，如js文件，css文件，图片；</p>
<p>​     src文件夹下的webapp下的WEB-INF：外界不能通过URL对web-inf下的文件直接进行访问，而通过内部程序可以；</p>
<p>​     src文件夹下的webapp下的WEB-INF下的web.xml：初始化配置信息，比如设置默认访问页面等；</p>
</li>
<li><p><strong>9.target：</strong>存放项目构建后的文件和目录，.jar 包等，编译后的文件等</p>
</li>
<li><p><strong>10.com.imooc.o2o：</strong></p>
<p>​     com.imooc.o2o下的web：**相当于controlor层，存放controlor控制器；</p>
<p>​     com.imooc.o2o下的service：业务逻辑层；</p>
<p>​     com.imooc.o2o下的impl：实现service接口；</p>
<p>​     com.imooc.o2o下的dao：与数据库打交道，存放与数据相关的操作，不需要impl，因为我们用的是mybatis，可以<strong>直接在配置文件中实现接口的每一个方法</strong>，也就是在src/main/resources/mapper中实现dao接口的逻辑；</p>
<p>​     com.imooc.o2o下的dto：弥补entity的不足，比如要返回一个商品列表，还要返回是否成功、状态等信息只通过实体类的product不能满足，就要用到dto；</p>
<p>​     com.imooc.o2o下的enums：存放枚举类型；</p>
<p>​     com.imooc.o2o下的interceptor：拦截器的代码；</p>
<p>​     com.imooc.o2o下的util：通用的工具类；</p>
<p>​     com.imooc.o2o下的exceptions：保存异常处理类；</p>
<p>​     com.imooc.o2o下的cache：redis缓存相关的工具类等。</p>
</li>
</ul>
<h3 id="2-2-4-2项目1-0引入-jar包（pom-xml）"><a href="#2-2-4-2项目1-0引入-jar包（pom-xml）" class="headerlink" title="2.2.4.2项目1.0引入.jar包（pom.xml）"></a>2.2.4.2项目1.0引入.jar包（pom.xml）</h3><ul>
<li>groupId</li>
<li>artifactId：.jar包的名称</li>
<li>version：.jar包的版本</li>
<li>scope：.jar包的使用范围</li>
</ul>
<blockquote>
<p><strong>NOTE：</strong>设置了一个全局变量${spring.version}，下面的与spring相关的都用这个全局变量为版本，方便后续对spring框架的升级</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.imooc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>o2o<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>o2o Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Spring --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 1)包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 2)这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion of Control </span></span><br><span class="line"><span class="comment">			/ Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar </span></span><br><span class="line"><span class="comment">			及spring-beans.jar 文件就可以了。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 3)这个jar 文件为Spring 核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，JDNI </span></span><br><span class="line"><span class="comment">			所需的全部类，instrumentation组件以及校验Validation 方面的相关类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 4) 这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 5) 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 6)Spring web 包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 7)包含SpringMVC框架相关的所有类。 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 8)Spring test 对JUNIT等测试框架的简单封装 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Servlet web --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- json解析 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Map工具类 对标准java Collection的扩展 spring-core.jar需commons-collections.jar --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- DAO: MyBatis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 图片处理 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.coobird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thumbnailator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 实现验证码 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.penggle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kaptcha<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- redis客户端：Jedis --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>o2o<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-compiler-plugin --&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-5逐层（自底向上）完成SSM的各项配置"><a href="#2-2-5逐层（自底向上）完成SSM的各项配置" class="headerlink" title="2.2.5逐层（自底向上）完成SSM的各项配置"></a>2.2.5逐层（自底向上）完成SSM的各项配置</h2><h3 id="2-2-5-1数据库连接配置"><a href="#2-2-5-1数据库连接配置" class="headerlink" title="2.2.5.1数据库连接配置"></a>2.2.5.1数据库连接配置</h3><ul>
<li>定义MySQL相关的驱动器</li>
<li>设置jdbc的URL， 也就是MySQL所在主机的端口号和要连接的数据库</li>
<li>设置登录账号</li>
<li>设置登录密码</li>
</ul>
<h3 id="2-2-5-2Mybatis配置"><a href="#2-2-5-2Mybatis配置" class="headerlink" title="2.2.5.2Mybatis配置"></a>2.2.5.2Mybatis配置</h3><h3 id="2-2-5-3Spring-dao的配置"><a href="#2-2-5-3Spring-dao的配置" class="headerlink" title="2.2.5.3Spring-dao的配置"></a>2.2.5.3Spring-dao的配置</h3><p>这里的Spring-dao.xml文件是最终版，涉及到redis配置、动态数据源的选择将在后面介绍  </p>
<ol>
<li>找到需要读取变量的文件——jdbc.properties</li>
<li>定义数据库连接池的属性</li>
<li>创建一个负责创建数据库连接池的对象 </li>
<li> 给定路径，需要到什么路径下去扫描Dao层，并将3中创建的对象传入 </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置整合mybatis过程 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.util.EncryptPropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:redis.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;abstractDataSource&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;master&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;abstractDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.master.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;slave&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;abstractDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.slave.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置动态数据源，这儿targetDataSources就是路由数据源所对应的名称 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dynamicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.dao.split.DynamicDataSource&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;master&quot;</span> <span class="attr">key</span>=<span class="string">&quot;master&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">entry</span> <span class="attr">value-ref</span>=<span class="string">&quot;slave&quot;</span> <span class="attr">key</span>=<span class="string">&quot;slave&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetDataSource&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;dynamicDataSource&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 扫描entity包 使用别名 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.imooc.entity&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.imooc.o2o.dao&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-3Spring-service的配置"><a href="#2-2-5-3Spring-service的配置" class="headerlink" title="2.2.5.3Spring-service的配置"></a>2.2.5.3Spring-service的配置</h3><p>这里的Spring-service.xml文件是最终版</p>
<ol>
<li><p>扫描service包下所有使用注解的类型</p>
</li>
<li><p>配置事务管理，因为可能涉及多个Dao操作，当其中一个执行出错时进行回滚，要用事务进行管理</p>
<p>并且注入spring-dao.xml中定义的连接池</p>
</li>
<li><p>支持事务注解——transaction-manager</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 扫描service包下所有使用注解的类型 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">		<span class="attr">base-package</span>=<span class="string">&quot;com.imooc.o2o.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 配置基于注解的声明式事务 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span><br><span class="line"><span class="tag">		<span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-4Spring-web的配置"><a href="#2-2-5-4Spring-web的配置" class="headerlink" title="2.2.5.4Spring-web的配置"></a>2.2.5.4Spring-web的配置</h3><p>这里的Spring-web.xml文件是最终版</p>
<ol>
<li>开启注解模式，能够识别Controller层的注解</li>
<li>告诉SpringMVC的核心类DispatcherServlet，不要去拦截以resources文件夹下的.js 、图片等，而是将这些静态资源统一 交给&lt;mvc:default-servlet-handler /&gt;来处理</li>
<li>视图解析器能够根据url请求解析出相应的.html页面 </li>
<li>指定相关的扫描路径</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.开启SpringMVC注解模式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用&quot;/&quot;做整体映射 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/resources/**&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">location</span>=<span class="string">&quot;/resources/&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3.定义视图解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/html/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 文件上传解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 1024 * 1024 * 20 = 20M --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20971520&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20971520&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 4.扫描web相关的bean --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">		<span class="attr">base-package</span>=<span class="string">&quot;com.imooc.o2o.web&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 5.权限拦截器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 校验是否已登录了店家管理系统的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 校验是否对该店铺有操作权限的拦截器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shoplist page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/shopadmin/shoplist&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshoplist&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shopregister page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopinitinfo&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/registershop&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopoperation&quot;</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- shopmanage page --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/shopmanagement&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/shopadmin/getshopmanagementinfo&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ShopPermissionInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.shopadmin.ShopPermissionInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 超级管理员系统拦截部分 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/**&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/login&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/logincheck&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/main&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/superadmin/top&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4area&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4headline&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span></span></span><br><span class="line"><span class="tag">				<span class="attr">path</span>=<span class="string">&quot;/superadmin/clearcache4shopcategory&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;SuperAdminLoginInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">class</span>=<span class="string">&quot;com.imooc.o2o.interceptor.superadmin.SuperAdminLoginInterceptor&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-5整合spring的相关配置"><a href="#2-2-5-5整合spring的相关配置" class="headerlink" title="2.2.5.5整合spring的相关配置"></a>2.2.5.5整合spring的相关配置</h3><p>在web.xml中完成以下配置：</p>
<ul>
<li><p>配置DispatcherServlet</p>
<p>定义Servlet-name</p>
<p>定义Servlet-class</p>
<p>初始化参数，定义参数名称，还有param-value也就是spring相关配置的路径</p>
</li>
<li><p>配置servelet-mapping，让它与spring-dispatcher映射在一起 ，默认将所有的url请求都转入到spring-dispatcher来处理</p>
</li>
</ul>
<h2 id="2-2-6逐层验证"><a href="#2-2-6逐层验证" class="headerlink" title="2.2.6逐层验证"></a>2.2.6逐层验证</h2><p>这里以获取区域信息为例，演示从Dao层到Controller层的实现</p>
<h3 id="2-2-6-1Dao层"><a href="#2-2-6-1Dao层" class="headerlink" title="2.2.6.1Dao层"></a>2.2.6.1Dao层</h3><p><strong>创建AreaDao接口：</strong>只包含一个queryArea()方法</p>
<p><strong>在Mapper下创建AreaDao.xml配置文件来实现AreaDao接口中的方法：</strong></p>
<ul>
<li>定义AreaDao.xml文件中的编写规范</li>
<li>namespace：AreaDao的绝对路径</li>
<li>id：AreaDao接口中的方法名</li>
<li>resultType：定义查询数据库后的返回值类型，也就是每条记录都会转换成Area对象</li>
<li>在SELECT中编写SQL语句</li>
</ul>
<h3 id="2-2-6-2Dao层测试"><a href="#2-2-6-2Dao层测试" class="headerlink" title="2.2.6.2Dao层测试"></a>2.2.6.2Dao层测试</h3><p>先在src/test/java下创建一个BaseTest类，该类的作用是告诉junit：<strong>spring要用哪个类来跑这个单元测试以及spring的配置文件在哪里</strong></p>
<p><strong>让测试类继承BaseTest，这样每次启动这个测试单元时都会去加载BaseTest中的方法以及spring的配置文件。</strong></p>
<blockquote>
<p><strong>NOTE：</strong>@Autowired标签能自动注入所需要的bean</p>
</blockquote>
<h3 id="2-2-6-3Service层"><a href="#2-2-6-3Service层" class="headerlink" title="2.2.6.3Service层"></a>2.2.6.3Service层</h3><p><strong>创建AreaService接口：</strong>只包含一个getAreaList()方法</p>
<p><strong>创建实现类AreaServiceImpl去实现AreaService中的方法：</strong></p>
<blockquote>
<p><strong>NOTE：</strong>@Service标签告诉spring这是service层的类<strong>需要托管在spring容器中</strong>，当其它类中用到这个AreaService时SpringIOC会将这个AreaServiceImpl注入到所需要的类中去</p>
</blockquote>
<h3 id="2-2-6-4Controller层"><a href="#2-2-6-4Controller层" class="headerlink" title="2.2.6.4Controller层"></a>2.2.6.4Controller层</h3><ul>
<li><p>@Controller标签：告诉spring容器这是Controller ，作用等同于@service</p>
</li>
<li><p>@RequestMapping(“/superadmin”)： 指定路由为o2o下面的shopadmin</p>
</li>
<li><p>@Autowired：自动注入AreaService实例</p>
</li>
<li><p>@RequestMapping(value = “/listarea”, method = RequestMethod.GET)：定义路由，指定访问shopadmin下的listarea方法，使用的方法为GET方法</p>
</li>
<li><p>@ResponseBody：将返回对象转换为json对象返回给前台</p>
</li>
<li><p>程序中的逻辑：</p>
<p>创建一个HashMap类型的对象来保存返回结果</p>
<p>创建一个ArrayList集合来保存areaService中getAreaList方法返回的结果</p>
<p>方法执行成功：将返回结果和返回结果的元素数put进modelmap中</p>
<p>方法执行失败：返回false并返回异常信息</p>
</li>
</ul>
<h3 id="2-2-6-5Controller层测试"><a href="#2-2-6-5Controller层测试" class="headerlink" title="2.2.6.5Controller层测试"></a>2.2.6.5Controller层测试</h3>]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>校园商铺1.0-阿里云远程部署及远程微信开发调试</title>
    <url>/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E9%98%BF%E9%87%8C%E4%BA%91%E8%BF%9C%E7%A8%8B%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-1阿里云初始化与执行环境安装"><a href="#1-1阿里云初始化与执行环境安装" class="headerlink" title="1.1阿里云初始化与执行环境安装"></a>1.1阿里云初始化与执行环境安装</h1><h2 id="1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）"><a href="#1-1-1阿里云部署Java网站和微信开发调试心得技巧（上）" class="headerlink" title="1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）"></a>1.1.1阿里云部署Java网站和微信开发调试心得技巧（上）</h2><ol>
<li>申请阿里云服务器</li>
<li>搭建出程序的执行环境</li>
<li>在服务器上发布并运行自己的web project</li>
<li>域名解析</li>
<li>微信测试号的申请与连接以获取微信用户信息</li>
</ol>
<h3 id="1-1-1-1申请阿里云服务器"><a href="#1-1-1-1申请阿里云服务器" class="headerlink" title="1.1.1.1申请阿里云服务器"></a><strong>1.1.1.1申请阿里云服务器</strong></h3><p> （1）PC访问阿里云<a href="https://www.aliyun.com/%EF%BC%8C%E7%94%B3%E8%AF%B7%E9%98%BF%E9%87%8C%E4%BA%91%E5%B8%90%E5%8F%B7%EF%BC%88%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%82%A8%E7%9A%84%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E7%99%BB%E5%BD%95%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B8%90%E5%8F%B7%E5%B7%B2%E7%BB%8F%E8%BF%9B%E8%A1%8C%E4%BA%86%E5%AE%9E%E5%90%8D%E8%AE%A4%E8%AF%81%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E6%9B%B4%E6%96%B9%E4%BE%BF%EF%BC%89%E5%B9%B6%E7%99%BB%E5%BD%95">https://www.aliyun.com/，申请阿里云帐号（可以用您的支付宝帐号登录，因为支付宝帐号已经进行了实名认证，使用起来更方便）并登录</a><br> （2）找到云服务器ECS购买页面（页面展现随时会变，当前为全部导航-&gt;产品-&gt;弹性计算-&gt;云服务器ECS-&gt;选择自己需要的型号(我选择的是入门级)），购买云服务器，这里主要有三种方式：9块9的学生服务器（大家如果不是学生的话可以用还在读大学的小伙伴的学生证来薅羊毛，购买）、包年包月的服务器（不管你怎么使用，按年按月收费）还有按量付费的服务器（按小时计费，不用可以随时注销掉）<br><img src="http://img1.sycdn.imooc.com/59da2e00000182cc24921486.png" alt="图片描述"><br> 操作系统记得选择centos,这里我用的是最新的7.3版本<br><img src="http://img1.sycdn.imooc.com/59da2e4e0001282423901122.png" alt="图片描述"><br> 上半部分的安全设置里面需要填写上root的登录密码，以后咱们需要用这个root帐号来远程登录服务器去做部署，下半部分主要显示的是您选择的阿里云清单<br><img src="http://img1.sycdn.imooc.com/59da2e7d0001b61723841066.png" alt="图片描述"><br> 开通成功后，服务器会启动并运行，同时会自动分配一个公网IP，咱们外网就可以通过这个公网IP访问服务器，同时也可以将域名解析到这个服务器中。<br><img src="http://img1.sycdn.imooc.com/59da2ea10001283b25420984.png" alt="图片描述"><br> 这里翔仔的公网IP为47.104.1.235</p>
<h3 id="1-1-1-2搭建程序的执行环境"><a href="#1-1-1-2搭建程序的执行环境" class="headerlink" title="1.1.1.2搭建程序的执行环境"></a><strong>1.1.1.2搭建程序的执行环境</strong></h3><p> 搭建程序的执行环境，咱们先列一下常用的执行环境清单：<br> （1）    JDK(这里选择的是JDK1.8)<br> 下载地址为<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br> 选择的是jdk-8u144-linux-x64.rpm<br> （2）    Tomcat 8<br> 下载地址为<br><a href="http://tomcat.apache.org/download-80.cgi#8.0.46">http://tomcat.apache.org/download-80.cgi#8.0.46</a><br> 选择的是apache-tomcat-8.0.46.tar.gz<br> （3）    Mysql(这里选择的是Mysql5.7)repo源，后通过centos自带的yum安装<br> 下载的地址为<br><a href="https://dev.mysql.com/downloads/repo/yum/">https://dev.mysql.com/downloads/repo/yum/</a><br> 这里选择mysql57-community-release-el7-11.noarch.rpm<br> （4）    Redis(可选，最好预先安装上，这里选择的版本为4.0.2)<br> 下载地址为<br><a href="https://redis.io/download">https://redis.io/download</a><br> 这里选择redis-4.0.2.tar.gz<br> 将上面的软件都下载到本地，并上传到服务器(如果您的系统为MAC或LINUX，直接使用SCP命令行上传，具体指令可以查询网上，如果您的系统为WIN，推荐使用filezilla可视化上传工具上传)，或者您也可以直接登录服务器，wget+ftp地址直接下载这些软件；同时需要大家注意的是，我们在服务器上部署了数据库之后，需要往数据库里面去补充数据，我们的线上数据访问的是线上的数据库而非本地的数据库。图片包也需要上传到服务器并通过配置server.xml确保能读取到这些图片（前提是docBase配置上的路径已经在服务器上创建）<br><img src="http://img1.sycdn.imooc.com/59da2edf0001118319361120.png" alt="图片描述"><br> 可以在阿里云控制台进入终端<br><img src="http://img1.sycdn.imooc.com/59da2f3c0001925208650121.png" alt="图片描述"><br> 在服务器的终端，正确的情况下就能看到这些软件了。<br><img src="http://img1.sycdn.imooc.com/59da2f5600011a9419040246.png" alt="图片描述"><br> 接下来开始安装这些软件：</p>
<p><strong>安装JDK</strong><br> Java程序需要运行在JRE里边，因此咱们需要安装JDK，在软件路径里执行<br> //添加可执行权限<br> chmod +x jdk-8u144-linux-x64.rpm<br> //安装RPM软件包<br> rpm -ivh jdk-8u144-linux-x64.rpm<br> //查看<a href="https://coding.imooc.com/?c=java">java</a>的版本信息，若出现版本信息则成功<br> <a href="https://coding.imooc.com/?c=java">java</a> –version<br><img src="http://img1.sycdn.imooc.com/59da2f6c0001f46a19061000.png" alt="图片描述"></p>
<p><strong>安装Mysql</strong><br> 安装用来配置mysql的yum源的rpm包<br> rpm -Uvh mysql57-community-release-el7-11.noarch.rpm<br> 安装Mysql<br> yum install mysql-community-server<br><img src="http://img1.sycdn.imooc.com/59da2fdf0001c0d408650502.png" alt="图片描述"><br> 开启mysql服务<br> service mysqld start<br><img src="http://img1.sycdn.imooc.com/59da2ffa0001edd619340382.png" alt="图片描述"><br> mysql安装成功后创建的超级用户’root’@‘localhost’的密码会被存储在/var/log/mysqld.log，可以使用如下命令查看密码<br> grep ‘temporary password’ /var/log/mysqld.log<br><img src="http://img1.sycdn.imooc.com/59da301d0001785925080182.png" alt="图片描述"><br> 使用mysql生成的’root’@‘localhost’用户和密码登录数据库，并修改 其密码，具体命令<br> mysql -uroot -p<br> ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘Xiangze230!’;<br><img src="http://img1.sycdn.imooc.com/59da30390001bba520861422.png" alt="图片描述"><br> 开启远程连接<br> 通过阿里云控制台开放3306端口<br> 在阿里云控制台咱们的实例页面下面选择安全组-&gt;配置规则<br><img src="http://img1.sycdn.imooc.com/59da30620001aaff25221452.png" alt="图片描述"><br> 进入到规则配置页面之后，咱们可以看到目前只有22端口和3389端口支持远程访问，咱们还需要额外开通80端口（微信公众号用），3306端口(mysql)以及6379端口(redis)<br><img src="http://img1.sycdn.imooc.com/59da30760001f73125541440.png" alt="图片描述"><br> 配置一个支持远程登录的帐号，这里配置一个work帐号<br> mysql -u root -p<br> use mysql;<br> grant SELECT,UPDATE,INSERT,DELETE on <em>.</em> to ‘work’@’%’ identified by ‘Xiangze230!’;//创建work帐号并授权，同时设置密码<br> flush privileges;//生效配置<br> 之后便能在我们本地通过调用mysql指令远程登录阿里云服务器上的mysql server中，<br> mysql -uwork -P3306 -h47.104.1.235 –p //本机远程登录mysql指令<br><img src="http://img1.sycdn.imooc.com/59da309400012e1f19880836.png" alt="图片描述"></p>
<p>安装redis<br> redis安装真的特别简单，首先先解压redis安装包<br> tar -zxvf redis-4.0.2.tar.gz<br> 设置redis以支持远程登录<br> vi redis-4.0.2/redis.conf<br> 将bind 127.0.0.1这句话用井号注释掉，这样就能支持远程连接了<br><img src="http://img1.sycdn.imooc.com/59da30d50001a68521601362.png" alt="图片描述"><br> <strong>此外，还需要给redis.conf添加配置以支持redis作为守护进程一直跑在后台</strong><br> 需要加入『daemonize yes』<br><img src="http://img1.sycdn.imooc.com/59da313000013ead08650187.png" alt="图片描述"><br> 安装redis<br> 去到解压后的目录里<br> cd redis-4.0.2<br> make  //安装redis<br> 启动redis服务<br> src/redis-server redis.conf<br><img src="http://img1.sycdn.imooc.com/59da314a0001d36125400270.png" alt="图片描述"><br> redis连接测试<br> 通过redis-cli连接到redis服务器<br> src/redis-cli<br> 当输入ping 得到pong的回应之后，证明redis配置已经完成<br><img src="http://img1.sycdn.imooc.com/59da316b0001170217480234.png" alt="图片描述"><br> 4．安装tomcat 8<br> tomcat 8的安装更为简单<br> 解压tomcat压缩包<br> tar -zxvf apache-tomcat-8.0.46.tar.gz<br> 启动tomcat<br> ./apache-tomcat-8.0.46/bin/startup.sh<br><img src="http://img1.sycdn.imooc.com/59da31850001020825280504.png" alt="图片描述"></p>
<h3 id="1-1-1-3在服务器上发布并运行自己的web-project"><a href="#1-1-1-3在服务器上发布并运行自己的web-project" class="headerlink" title="1.1.1.3在服务器上发布并运行自己的web project"></a><strong>1.1.1.3在服务器上发布并运行自己的web project</strong></h3><p> 修改tomcat默认启动端口，从8080修改为80端口，便于微信登录<br> vi apache-tomcat-8.0.46/conf/server.xml<br><img src="http://img1.sycdn.imooc.com/59da31960001a44d21681462.png" alt="图片描述"><br> 重启tomcat<br> ./apache-tomcat-8.0.46/bin/shutdown.sh<br> ./apache-tomcat-8.0.46/bin/startup.sh<br> 修改自己本地的网站的配置<br> 这里由于大家自己的<a href="https://coding.imooc.com/?c=java">java</a>网站项目的配置都不相同，只能说大概的，即把项目里的mysql配置(如果有的话)，redis配置(如果有的话)修改为阿里云服务器对应的配置(即ip，端口，密码等配置修改成服务器里安装好的这些软件的对应的配置)<br><img src="http://img1.sycdn.imooc.com/59da31b100014ae324660598.png" alt="图片描述"><br> 打出自己项目的war包<br><img src="http://img1.sycdn.imooc.com/59da31c30001ed4024681500.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31ce0001be2c08650907.png" alt="图片描述"><br><img src="http://img1.sycdn.imooc.com/59da31db0001cb4808650907.png" alt="图片描述"><br> 将export出来的war包上传到服务器tomcat的webapps目录下<br> scp o2o.war <a href="mailto:root@47.104.1.235">root@47.104.1.235</a>:/root/apache-tomcat-8.0.46/webapps<br><img src="http://img1.sycdn.imooc.com/59da32070001e2d708640065.png" alt="图片描述"><br> 上传成功后，没过几秒tomcat便会在webapps目录下自动从项目war包中解析出项目工程目录来<br><img src="http://img1.sycdn.imooc.com/59da32220001dc1008650056.png" alt="图片描述"><br> 之后通过ip+请求路径的形式便能访问到自己的项目(因为已经设置成80端口，这是http默认访问的端口，所以不需要在URL里添加端口信息了)<br><img src="http://img1.sycdn.imooc.com/59da324a000107b108650519.png" alt="图片描述"></p>
<h3 id="1-1-1-4域名解析"><a href="#1-1-1-4域名解析" class="headerlink" title="1.1.1.4域名解析"></a><strong>1.1.1.4域名解析</strong></h3><p> 如果通过ip连接微信号，则总会弹出烦人的警告窗口，因此咱们可以先购买一个域名并对域名进行认证(具体的备案步骤不同服务商有不同要求，大家可以按照他们的要求来，主要分有个人认证和企业认证两种，当然大家如果不嫌烦，可以直接用ip即跳过域名解析这一步)，建议大家看看周围的朋友有谁已经有经过验证的域名了，这样可以直接借他的域名创建一个二级域名来用，方便省事，翔仔购买的是阿里云控制台里面的万网域名，购买并认证成功后，会有如下截图，选择购买好的域名并点击解析创建出二级域名<br><img src="http://img1.sycdn.imooc.com/59da326600014ec708650260.png" alt="图片描述"><br> 进入到解析的页面，选择添加解析，并在A记录里面设置好O2O，IP里面设置咱们的阿里云服务器公网IP。这样就能创建出o2o.yitiaojieinfo.com这样的域名指向该公网IP<br><img src="http://img1.sycdn.imooc.com/59da32830001b76108650508.png" alt="图片描述"><br> 隔一段时间，大概5-10分钟这样子，通过域名访问咱们的站点，就能发现访问是okay的<br><img src="http://img1.sycdn.imooc.com/59da329d0001476708650543.png" alt="图片描述"></p>
<h1 id="1-1-2阿里云部署Java网站和微信开发调试心得技巧-下"><a href="#1-1-2阿里云部署Java网站和微信开发调试心得技巧-下" class="headerlink" title="1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)"></a>1.1.2阿里云部署Java网站和微信开发调试心得技巧(下)</h1><h2 id="1-1-2-5微信测试号的申请与连接以获取微信用户信息"><a href="#1-1-2-5微信测试号的申请与连接以获取微信用户信息" class="headerlink" title="1.1.2.5微信测试号的申请与连接以获取微信用户信息"></a><strong>1.1.2.5微信测试号的申请与连接以获取微信用户信息</strong></h2><p> 在咱们自己的程序里面编写servlet以响应微信号<br> 在接下来的步骤中，我们将在测试号里面设置接口配置信息的URL，一经设置，微信公众号便会发请求到我们设置好的URL去，我们必须编写程序应答才能顺利连通微信公众号，因此咱们需要编写相应的响应程序<br> 需要编写两个类<br> 【SignUtil】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.weixin;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信请求校验工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SignUtil &#123;</span><br><span class="line">    &#x2F;&#x2F; 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token &#x3D; &quot;myo2o&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 验证签名</span><br><span class="line">     * </span><br><span class="line">     * @param signature</span><br><span class="line">     * @param timestamp</span><br><span class="line">     * @param nonce</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp, String nonce) &#123;</span><br><span class="line">        String[] arr &#x3D; new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        &#x2F;&#x2F; 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        StringBuilder content &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md &#x3D; null;</span><br><span class="line">        String tmpStr &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            md &#x3D; MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            &#x2F;&#x2F; 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest &#x3D; md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr &#x3D; byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        content &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr !&#x3D; null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param byteArray</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest &#x3D; &quot;&quot;;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest +&#x3D; byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param mByte</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;</span><br><span class="line">        char[] tempArr &#x3D; new char[2];</span><br><span class="line">        tempArr[0] &#x3D; Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] &#x3D; Digit[mByte &amp; 0X0F];</span><br><span class="line"></span><br><span class="line">        String s &#x3D; new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatController】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.util.wechat.SignUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">&#x2F;&#x2F;一会在设置的URL里面就设置上这个路由</span><br><span class="line">@RequestMapping(&quot;wechat&quot;)</span><br><span class="line">public class WechatController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">        String signature &#x3D; request.getParameter(&quot;signature&quot;);</span><br><span class="line">        &#x2F;&#x2F; 时间戳</span><br><span class="line">        String timestamp &#x3D; request.getParameter(&quot;timestamp&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机数</span><br><span class="line">        String nonce &#x3D; request.getParameter(&quot;nonce&quot;);</span><br><span class="line">        &#x2F;&#x2F; 随机字符串</span><br><span class="line">        String echostr &#x3D; request.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">        PrintWriter out &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            out &#x3D; response.getWriter();</span><br><span class="line">            if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">                log.debug(&quot;weixin get success....&quot;);</span><br><span class="line">                out.print(echostr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (out !&#x3D; null)</span><br><span class="line">                out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重新部署一版最新的程序</p>
<p>访问微信测试号登录页面，通过打开自己手机的微信，扫一扫登录<br><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a><br><img src="https://img1.sycdn.imooc.com/59da332500011d0308650391.png" alt="图片描述"><br> 进入到测试号页面后，分别看到如下信息<br> 【测试号信息】<br> appID:开发者ID，是公众号开发识别码，配合开发者密码可以调用微信公众号接口，如获取微信昵称等<br> appsecret:开发者密码，是检验公众号开发者身份的密码，具有极高的安全性。切记不要把密码交给第三方开发者或者编写到代码里<br><img src="https://img1.sycdn.imooc.com/59da33380001aa6608650121.png" alt="图片描述"><br> 【接口配置信息】<br> URL: 是开发者用来接收微信消息和事件的接口URL<br> Token:由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）<br><img src="https://img1.sycdn.imooc.com/59da334f000153d408650159.png" alt="图片描述"><br> 【JS接口安全域名】<br> 域名：想调用jssdk(如想要通过微信公众号js接口获取地图等工具)必须得填写此域名，在此域名的范围内才能调用jssdk工具，注意这里必须是域名，不是带有http之类的URL，这里直接填写o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da336d0001ccc608650117.png" alt="图片描述"><br> 【测试号二维码】<br> 里面包含了测试号二维码以及已经关注了的用户信息<br><img src="https://img1.sycdn.imooc.com/59da33840001e2f508650283.png" alt="图片描述"><br> 【体验接口权限表】<br> 这里主要介绍【网页服务】里面的【网页帐号】<br> 网页帐号主要用来设置OAuth2.0里面的网页授权域名，用户在网页授权页同意授权给公众号后，微信会将授权数据传给一个回调页面，回调页面需在此域名下，以确保安全可靠。沙盒号回调地址支持域名和ip，正式公众号回调地址只支持域名。这里直接设置为o2o.yitiaojieinfo.com<br><img src="https://img1.sycdn.imooc.com/59da33e400010e7d08650549.png" alt="图片描述"><br><img src="https://img1.sycdn.imooc.com/59da340100017e1308650619.png" alt="图片描述"><br> 有不清楚的地方可以直接参考微信官方文档<br><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</a><br> 接下来需要编写自己的程序以获取关注此公众号的用户信息<br> 需要编写5个类 WechatLoginController.<a href="https://coding.imooc.com/?c=java">java</a>，UserAccessToken.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUser.<a href="https://coding.imooc.com/?c=java">java</a>，WechatUtil.<a href="https://coding.imooc.com/?c=java">java</a>以及MyX509TrustManager.<a href="https://coding.imooc.com/?c=java">java</a><br> 【WechatLoginController】主要用来获取已关注此微信号的用户信息并做相应处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.web.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line">import com.imooc.o2o.util.wechat.WeiXinUserUtil;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;wechatlogin&quot;)</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 获取关注公众号之后的微信用户信息的接口，如果在微信浏览器里访问</span><br><span class="line"> * https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;oauth2&#x2F;authorize?appid&#x3D;您的appId&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;o2o.yitiaojieinfo.com&#x2F;o2o&#x2F;wechatlogin&#x2F;logincheck&amp;role_type&#x3D;1&amp;response_type&#x3D;code&amp;scope&#x3D;snsapi_userinfo&amp;state&#x3D;1#wechat_redirect</span><br><span class="line"> * 则这里将会获取到code,之后再可以通过code获取到access_token 进而获取到用户信息</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatLoginController &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatLoginController.class);</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;logincheck&quot;, method &#x3D; &#123; RequestMethod.GET &#125;)</span><br><span class="line">    public String doGet(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        log.debug(&quot;weixin login get...&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取微信公众号传输过来的code,通过code可获取access_token,进而获取用户信息</span><br><span class="line">        String code &#x3D; request.getParameter(&quot;code&quot;);</span><br><span class="line">        &#x2F;&#x2F; 这个state可以用来传我们自定义的信息，方便程序调用，这里也可以不用</span><br><span class="line">        &#x2F;&#x2F; String roleType &#x3D; request.getParameter(&quot;state&quot;);</span><br><span class="line">        log.debug(&quot;weixin login code:&quot; + code);</span><br><span class="line">        WechatUser user &#x3D; null;</span><br><span class="line">        String openId &#x3D; null;</span><br><span class="line">        if (null !&#x3D; code) &#123;</span><br><span class="line">            UserAccessToken token;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 通过code获取access_token</span><br><span class="line">                token &#x3D; WeiXinUserUtil.getUserAccessToken(code);</span><br><span class="line">                log.debug(&quot;weixin login token:&quot; + token.toString());</span><br><span class="line">                &#x2F;&#x2F; 通过token获取accessToken</span><br><span class="line">                String accessToken &#x3D; token.getAccessToken();</span><br><span class="line">                &#x2F;&#x2F; 通过token获取openId</span><br><span class="line">                openId &#x3D; token.getOpenId();</span><br><span class="line">                &#x2F;&#x2F; 通过access_token和openId获取用户昵称等信息</span><br><span class="line">                user &#x3D; WeiXinUserUtil.getUserInfo(accessToken, openId);</span><br><span class="line">                log.debug(&quot;weixin login user:&quot; + user.toString());</span><br><span class="line">                request.getSession().setAttribute(&quot;openId&quot;, openId);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                log.error(&quot;error in getUserAccessToken or getUserInfo or findByOpenId: &quot; + e.toString());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo begin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        &#x2F;&#x2F; 前面咱们获取到openId后，可以通过它去数据库判断该微信帐号是否在我们网站里有对应的帐号了，</span><br><span class="line">        &#x2F;&#x2F; 没有的话这里可以自动创建上，直接实现微信与咱们网站的无缝对接。</span><br><span class="line">        &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;todo end&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取到微信验证的信息后返回到指定的路由（需要自己设定）</span><br><span class="line">            return &quot;frontend&#x2F;index&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【UserAccessToken】用户AccessToken实体类，用来接收accesstoken以及openid等信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户授权token</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UserAccessToken &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取到的凭证</span><br><span class="line">    @JsonProperty(&quot;access_token&quot;)</span><br><span class="line">    private String accessToken;</span><br><span class="line">    &#x2F;&#x2F; 凭证有效时间，单位：秒</span><br><span class="line">    @JsonProperty(&quot;expires_in&quot;)</span><br><span class="line">    private String expiresIn;</span><br><span class="line">    &#x2F;&#x2F; 表示更新令牌，用来获取下一次的访问令牌，这里没太大用处</span><br><span class="line">    @JsonProperty(&quot;refresh_token&quot;)</span><br><span class="line">    private String refreshToken;</span><br><span class="line">    &#x2F;&#x2F; 该用户在此公众号下的身份标识，对于此微信号具有唯一性</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 表示权限范围，这里可省略</span><br><span class="line">    @JsonProperty(&quot;scope&quot;)</span><br><span class="line">    private String scope;</span><br><span class="line"></span><br><span class="line">    public String getAccessToken() &#123;</span><br><span class="line">        return accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccessToken(String accessToken) &#123;</span><br><span class="line">        this.accessToken &#x3D; accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getExpiresIn() &#123;</span><br><span class="line">        return expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setExpiresIn(String expiresIn) &#123;</span><br><span class="line">        this.expiresIn &#x3D; expiresIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRefreshToken() &#123;</span><br><span class="line">        return refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRefreshToken(String refreshToken) &#123;</span><br><span class="line">        this.refreshToken &#x3D; refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getScope() &#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScope(String scope) &#123;</span><br><span class="line">        this.scope &#x3D; scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;accessToken:&quot; + this.getAccessToken() + &quot;,openId:&quot; + this.getOpenId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatUser】微信用户实体类，用来接收昵称 openid等用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.dto;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信用户实体类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUser implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -4684067645282292327L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; openId,标识该公众号下面的该用户的唯一Id</span><br><span class="line">    @JsonProperty(&quot;openid&quot;)</span><br><span class="line">    private String openId;</span><br><span class="line">    &#x2F;&#x2F; 用户昵称</span><br><span class="line">    @JsonProperty(&quot;nickname&quot;)</span><br><span class="line">    private String nickName;</span><br><span class="line">    &#x2F;&#x2F; 性别</span><br><span class="line">    @JsonProperty(&quot;sex&quot;)</span><br><span class="line">    private int sex;</span><br><span class="line">    &#x2F;&#x2F; 省份</span><br><span class="line">    @JsonProperty(&quot;province&quot;)</span><br><span class="line">    private String province;</span><br><span class="line">    &#x2F;&#x2F; 城市</span><br><span class="line">    @JsonProperty(&quot;city&quot;)</span><br><span class="line">    private String city;</span><br><span class="line">    &#x2F;&#x2F; 区</span><br><span class="line">    @JsonProperty(&quot;country&quot;)</span><br><span class="line">    private String country;</span><br><span class="line">    &#x2F;&#x2F; 头像图片地址</span><br><span class="line">    @JsonProperty(&quot;headimgurl&quot;)</span><br><span class="line">    private String headimgurl;</span><br><span class="line">    &#x2F;&#x2F; 语言</span><br><span class="line">    @JsonProperty(&quot;language&quot;)</span><br><span class="line">    private String language;</span><br><span class="line">    &#x2F;&#x2F; 用户权限，这里没什么作用</span><br><span class="line">    @JsonProperty(&quot;privilege&quot;)</span><br><span class="line">    private String[] privilege;</span><br><span class="line"></span><br><span class="line">    public String getOpenId() &#123;</span><br><span class="line">        return openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOpenId(String openId) &#123;</span><br><span class="line">        this.openId &#x3D; openId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNickName() &#123;</span><br><span class="line">        return nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNickName(String nickName) &#123;</span><br><span class="line">        this.nickName &#x3D; nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSex() &#123;</span><br><span class="line">        return sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSex(int sex) &#123;</span><br><span class="line">        this.sex &#x3D; sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getProvince() &#123;</span><br><span class="line">        return province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProvince(String province) &#123;</span><br><span class="line">        this.province &#x3D; province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCity() &#123;</span><br><span class="line">        return city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCity(String city) &#123;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCountry() &#123;</span><br><span class="line">        return country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCountry(String country) &#123;</span><br><span class="line">        this.country &#x3D; country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getHeadimgurl() &#123;</span><br><span class="line">        return headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeadimgurl(String headimgurl) &#123;</span><br><span class="line">        this.headimgurl &#x3D; headimgurl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLanguage() &#123;</span><br><span class="line">        return language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLanguage(String language) &#123;</span><br><span class="line">        this.language &#x3D; language;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getPrivilege() &#123;</span><br><span class="line">        return privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrivilege(String[] privilege) &#123;</span><br><span class="line">        this.privilege &#x3D; privilege;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;openId:&quot; + this.getOpenId() + &quot;,nikename:&quot; + this.getNickName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【WechatUtil】主要用来提交https请求给微信获取用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.ConnectException;</span><br><span class="line">import java.net.URL;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.HttpsURLConnection;</span><br><span class="line">import javax.net.ssl.SSLContext;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import javax.net.ssl.TrustManager;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.core.JsonParseException;</span><br><span class="line">import com.fasterxml.jackson.databind.JsonMappingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import com.imooc.o2o.dto.UserAccessToken;</span><br><span class="line">import com.imooc.o2o.dto.WechatUser;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 微信工具类</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class WechatUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(WechatUtil.class);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取UserAccessToken实体类</span><br><span class="line">     * </span><br><span class="line">     * @param code</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static UserAccessToken getUserAccessToken(String code) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appId</span><br><span class="line">        String appId &#x3D; &quot;您的appId&quot;;</span><br><span class="line">        log.debug(&quot;appId:&quot; + appId);</span><br><span class="line">        &#x2F;&#x2F; 测试号信息里的appsecret</span><br><span class="line">        String appsecret &#x3D; &quot;您的appsecret&quot;;</span><br><span class="line">        log.debug(&quot;secret:&quot; + appsecret);</span><br><span class="line">        &#x2F;&#x2F; 根据传入的code,拼接出访问微信定义好的接口的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token?appid&#x3D;&quot; + appId + &quot;&amp;secret&#x3D;&quot; + appsecret</span><br><span class="line">                + &quot;&amp;code&#x3D;&quot; + code + &quot;&amp;grant_type&#x3D;authorization_code&quot;;</span><br><span class="line">        &#x2F;&#x2F; 向相应URL发送请求获取token json字符串</span><br><span class="line">        String tokenStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;userAccessToken:&quot; + tokenStr);</span><br><span class="line">        UserAccessToken token &#x3D; new UserAccessToken();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            token &#x3D; objectMapper.readValue(tokenStr, UserAccessToken.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (token &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户accessToken失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取WechatUser实体类</span><br><span class="line">     * </span><br><span class="line">     * @param accessToken</span><br><span class="line">     * @param openId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static WechatUser getUserInfo(String accessToken, String openId) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据传入的accessToken以及openId拼接出访问微信定义的端口并获取用户信息的URL</span><br><span class="line">        String url &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo?access_token&#x3D;&quot; + accessToken + &quot;&amp;openid&#x3D;&quot; + openId</span><br><span class="line">                + &quot;&amp;lang&#x3D;zh_CN&quot;;</span><br><span class="line">        &#x2F;&#x2F; 访问该URL获取用户信息json 字符串</span><br><span class="line">        String userStr &#x3D; httpsRequest(url, &quot;GET&quot;, null);</span><br><span class="line">        log.debug(&quot;user info :&quot; + userStr);</span><br><span class="line">        WechatUser user &#x3D; new WechatUser();</span><br><span class="line">        ObjectMapper objectMapper &#x3D; new ObjectMapper();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 将json字符串转换成相应对象</span><br><span class="line">            user &#x3D; objectMapper.readValue(userStr, WechatUser.class);</span><br><span class="line">        &#125; catch (JsonParseException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (JsonMappingException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败: &quot; + e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (user &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.error(&quot;获取用户信息失败。&quot;);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发起https请求并获取结果</span><br><span class="line">     * </span><br><span class="line">     * @param requestUrl</span><br><span class="line">     *            请求地址</span><br><span class="line">     * @param requestMethod</span><br><span class="line">     *            请求方式（GET、POST）</span><br><span class="line">     * @param outputStr</span><br><span class="line">     *            提交的数据</span><br><span class="line">     * @return json字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</span><br><span class="line">        StringBuffer buffer &#x3D; new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建SSLContext对象，并使用我们指定的信任管理器初始化</span><br><span class="line">            TrustManager[] tm &#x3D; &#123; new MyX509TrustManager() &#125;;</span><br><span class="line">            SSLContext sslContext &#x3D; SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</span><br><span class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</span><br><span class="line">            &#x2F;&#x2F; 从上述SSLContext对象中得到SSLSocketFactory对象</span><br><span class="line">            SSLSocketFactory ssf &#x3D; sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">            URL url &#x3D; new URL(requestUrl);</span><br><span class="line">            HttpsURLConnection httpUrlConn &#x3D; (HttpsURLConnection) url.openConnection();</span><br><span class="line">            httpUrlConn.setSSLSocketFactory(ssf);</span><br><span class="line"></span><br><span class="line">            httpUrlConn.setDoOutput(true);</span><br><span class="line">            httpUrlConn.setDoInput(true);</span><br><span class="line">            httpUrlConn.setUseCaches(false);</span><br><span class="line">            &#x2F;&#x2F; 设置请求方式（GET&#x2F;POST）</span><br><span class="line">            httpUrlConn.setRequestMethod(requestMethod);</span><br><span class="line"></span><br><span class="line">            if (&quot;GET&quot;.equalsIgnoreCase(requestMethod))</span><br><span class="line">                httpUrlConn.connect();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 当有数据需要提交时</span><br><span class="line">            if (null !&#x3D; outputStr) &#123;</span><br><span class="line">                OutputStream outputStream &#x3D; httpUrlConn.getOutputStream();</span><br><span class="line">                &#x2F;&#x2F; 注意编码格式，防止中文乱码</span><br><span class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将返回的输入流转换成字符串</span><br><span class="line">            InputStream inputStream &#x3D; httpUrlConn.getInputStream();</span><br><span class="line">            InputStreamReader inputStreamReader &#x3D; new InputStreamReader(inputStream, &quot;utf-8&quot;);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">            String str &#x3D; null;</span><br><span class="line">            while ((str &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                buffer.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            &#x2F;&#x2F; 释放资源</span><br><span class="line">            inputStream.close();</span><br><span class="line">            inputStream &#x3D; null;</span><br><span class="line">            httpUrlConn.disconnect();</span><br><span class="line">            log.debug(&quot;https buffer:&quot; + buffer.toString());</span><br><span class="line">        &#125; catch (ConnectException ce) &#123;</span><br><span class="line">            log.error(&quot;Weixin server connection timed out.&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;https request error:&#123;&#125;&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【MyX509TrustManager】主要继承X509TrustManager做https证书信任管理器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.imooc.o2o.util.wechat;</span><br><span class="line"></span><br><span class="line">import java.security.cert.CertificateException;</span><br><span class="line">import java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.X509TrustManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 证书信任管理器（用于https请求）</span><br><span class="line"> * </span><br><span class="line"> * @author xiangze</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyX509TrustManager implements X509TrustManager &#123;</span><br><span class="line"></span><br><span class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后重新打包一个新的war包并发布到服务器tomcat webapps目录下<br> 发布成功后，关注你自己的测试号(即扫描测试号的那个二维码)，然后在手机微信里面或者微信开发者工具里访问相应链接：<br><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=%E6%82%A8%E7%9A%84appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect">https://open.weixin.qq.com/connect/oauth2/authorize?appid=您的appid&amp;redirect_uri=http://o2o.yitiaojieinfo.com/o2o/wechatlogin/logincheck&amp;role_type=1&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=1#wechat_redirect</a><br><img src="https://img1.sycdn.imooc.com/59da34c500012aa908650494.png" alt="图片描述"><br> 之后查看日志信息，便能发现确实能够获取到用户的信息了<br><img src="https://img1.sycdn.imooc.com/59da34de0001a64308650182.png" alt="图片描述"></p>
]]></content>
      <categories>
        <category>校园商铺项目</category>
      </categories>
      <tags>
        <tag>校园商铺1.0</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索</title>
    <url>/2021/03/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/2021/03/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2021/03/25/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>通过两个指针来实现题目要求，大大降低了空间复杂度</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle/">热题100-141. 环形链表</a></strong></p>
<p>给定一个链表，判断链表中是否有环。</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置两个指针slow和fast</p>
<p>slow每次移动一个节点，fast每次移动两个节点</p>
<p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p>
</li>
<li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p>
</li>
<li><p>当循环中满足fast==slow时，返回true结束循环，否则链表遍历结束返回false</p>
</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head.next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;<span class="comment">//遍历到一个节点时，首先这个节点不能为null，如果该节点不进行判断，就会出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">热题100-142. 环形链表 II</a></strong></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>寻找第一次相遇的点：</strong></p>
<ul>
<li><p>设置两个指针slow和fast</p>
<p>slow每次移动一个节点，fast每次移动两个节点</p>
<p>因为两个指针的移动距离不同，当链表没有环时，两个指针永远不能相遇，只有当链表中存在环时，两个指针才有可能重合</p>
</li>
<li><p>循环遍历链表，循环条件为：<code>fast!=null&amp;&amp;fast.next!=null</code>，因为慢指针在快指针后面，当快指针不为null时，慢指针一定不为null</p>
</li>
<li><p>当循环中满足fast==slow时，结束循环，判断slow和fast是否相等，不相等返回null，反之，继续执行下面的语句</p>
</li>
</ul>
<p><strong>第二次相遇的点就是环的入口：</strong></p>
<p>分析：设第一次相遇时，指针slow走过s步，fast走的步数比它多n倍的b步，所以fast走过的步数是s+nb；又因为fast一次走两步，所以s+nb=2s,所以s=nb;也就是相遇的这个点是b的倍数，环的入口满足a+xb,所以另一个指针指向头部，另一个指针不动，两个指针一次移动一个节点，第二次相遇时，走过的步数满足a+xb，就是环的入口节点。</p>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast=head.next;</span><br><span class="line">    ListNode slow=head;</span><br><span class="line">    <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast=head;</span><br><span class="line">    slow=slow.next;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>使用HashMap存储数组/字符串中的元素及其对应的下标；</li>
<li>设置左右两个指针，右指针遍历数组，每到一个元素的位置，先在HashMap中查看该元素是否存在，如果元素存在于HashMap中，更新left指针的值，另(left，right]区间内没有重复的元素；</li>
<li>将该元素及其下标存储到HashMap中；</li>
<li>更新最长无重复子串的长度；</li>
<li>返回结果。</li>
</ul>
<h3 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character,Integer&gt; hm=<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="comment">//HashMap新的键值对会覆盖原有的键值相同的键值对</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] ss=s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fast=<span class="number">0</span>;fast&lt;s.length();fast++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(ss[fast]))&#123;</span><br><span class="line">           slow=Math.max(hm.get(ss[fast]),slow);<span class="comment">//保证区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">           <span class="comment">//例：s=&quot;abcabcbb&quot;</span></span><br><span class="line">           <span class="comment">//当right指向第三个b时</span></span><br><span class="line">           <span class="comment">//假如left指向第二个c:此时显示有重复值，但是是在left之前，所以left不用变；</span></span><br><span class="line">           <span class="comment">//假如left指向第二个a:此时显示有重复值，是在left右边,所以更新left让其指向第二个b。</span></span><br><span class="line">           <span class="comment">//始终确保区间[slow+1,right]内不存在重复字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        max=Math.max(max,fast-slow);</span><br><span class="line">        hm.put(ss[fast],fast);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">热题100-19. 删除链表的倒数第 N 个结点</a></strong></p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>设置快慢指针；</li>
<li>让快指针先走n步的距离，当慢指针开始走时，应该距离快指针有n步的距离；</li>
<li>快慢指针同时移动，当快指针移动到链表尾部时，慢指针正好在倒数第n个节点；</li>
<li>为了方便删除，使用一个哑结点，让慢指针从该节点开始移动，当快指针移动到尾部时，慢指针移动到倒数第n个节点的前一个节点，直接删除倒数第n个节点。</li>
</ul>
<h3 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        ListNode second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        ListNode ans = dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><blockquote>
<p><strong><a href="https://www.nowcoder.com/practice/c3a6afee325e472386a1c4eb1ef987f3?tpId=190&tqId=35226&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey">牛客-反转字符串</a></strong></p>
<p>写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>
</blockquote>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>双指针一个从前往后，一个从后往前，直接交换就可以</p>
<h3 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">solve</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] strs=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=strs.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch=strs[left];</span><br><span class="line">            strs[left]=strs[right];</span><br><span class="line">            strs[right]=ch;</span><br><span class="line">            right--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/3sum/">热题100-15. 三数之和</a></strong></p>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>将数组排序，排序后的数组顺序为从小到大；</p>
</li>
<li><p>最外层通过for循环，遍历数组中的每一个元素，固定这个元素，再用双指针遍历右边部分的元素，看是否有三个元素和为0；</p>
</li>
<li><p>for循环内部：</p>
<p>1、每遍历到一个元素，判断是否大于0，因为该元素为最小元素，如果它大于0，以后的都大于零，直接结束for循环</p>
<p>2、每遍历到一个元素，判断它是否跟上一个元素相等，为了防止答案重复，如果元素相同向下顺延</p>
<p>3、当该元素不满足上面的两条，固定该元素，设置双指针指向余下部分的首尾元素</p>
<p>4、当left&lt;right时，执行for循环，通过sum与0的大小关系来移动双指针，同时记录满足条件的集合</p>
</li>
</ul>
<h3 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//牛客上需要自己导包，Java一般导这个就够用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        <span class="keyword">if</span>(num.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    Arrays.sort(num);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;num.length;k++)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(nums[k]+&quot;+&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(num[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;num.length&amp;&amp;num[k]==num[k-<span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=num.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">          <span class="keyword">int</span> sum=num[k]+num[i]+num[j];</span><br><span class="line">         <span class="comment">//System.out.println(sum);</span></span><br><span class="line">          <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">              temp.add(num[k]);</span><br><span class="line">              temp.add(num[i]);</span><br><span class="line">              temp.add(num[j]);</span><br><span class="line">              res.add(temp);</span><br><span class="line">              i++;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[i]==num[i-<span class="number">1</span>])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">              &#125;</span><br><span class="line">              j--;</span><br><span class="line">              <span class="keyword">while</span>(i&lt;j&amp;&amp;num[j]==num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  j--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/container-with-most-water/">热题100-11. 盛最多水的容器</a></strong></p>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置双指针，分别指向数组的首尾元素；</p>
</li>
<li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p>
<p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p>
<p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p>
</li>
</ul>
<h3 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max=Math.min(height[left],height[right])*(right-left);</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            max=Math.max(max, (right - left) * height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/trapping-rain-water/">热题100-42. 接雨水</a></strong></p>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>设置双指针，分别指向数组的首尾元素；</p>
</li>
<li><p>比较两个指针所对应的数组值，下面分析怎么移动两边的指针：</p>
<p>容器能盛多少水由容器的短边决定，当我们移动长边时，下一次得到的容器容积一定小于当前容积，因为高度还是由这个短边决定，要么由更短的边决定，但是底边长减小了，所以容积一定减小；</p>
<p>当我们移动短边时，就有可能得到更长的边，得到更大的容积，所以每次移动较长的边</p>
</li>
</ul>
<h3 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max water</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long长整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxWater</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left_max&lt;right_max)&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,left_max-arr[left]);</span><br><span class="line">                left_max=Math.max(left_max,arr[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res+=Math.max(<span class="number">0</span>,right_max-arr[right]);</span><br><span class="line">                right_max=Math.max(right_max,arr[right]);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">热题100-234. 回文链表</a></strong></p>
<p>请判断一个链表是否为回文链表。</p>
</blockquote>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li><p>找到链表的中间节点midNode：</p>
<p>创建快慢指针</p>
<p>慢指针一次走一步</p>
<p>快指针一次走两步</p>
</li>
<li><p>从中间节点的后面反转链表</p>
</li>
<li><p>这样就得到了两段链表，分别遍历判断即可</p>
</li>
<li><p>最后将链表还原</p>
</li>
</ul>
<h3 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 the head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPail</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode firstHead=head;</span><br><span class="line">        ListNode midNode=findMidNode(head);</span><br><span class="line">        ListNode secondHead=reverse(midNode.next);</span><br><span class="line">        ListNode temp=secondHead;</span><br><span class="line">        <span class="keyword">while</span>(firstHead!=<span class="keyword">null</span>&amp;&amp;secondHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(firstHead.val!=secondHead.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            firstHead=firstHead.next;</span><br><span class="line">            secondHead=secondHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        midNode.next=reverse(temp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow=<span class="keyword">null</span>;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode=fast.next;</span><br><span class="line">            fast.next=slow;</span><br><span class="line">            slow=fast;</span><br><span class="line">            fast=nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2021/03/25/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2021/03/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/03/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2021/03/25/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/03/25/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="·-链表相关的核心点"><a href="#·-链表相关的核心点" class="headerlink" title="· 链表相关的核心点"></a>· 链表相关的核心点</h1><ul>
<li>null/nil 异常处理</li>
<li>dummy node 哑巴节点</li>
<li>快慢指针</li>
<li>插入一个节点到排序链表</li>
<li>从一个链表中移除一个节点</li>
<li>翻转链表</li>
<li>合并两个链表</li>
<li>找到链表的中间节点</li>
</ul>
<h1 id="·-相关题目"><a href="#·-相关题目" class="headerlink" title="· 相关题目"></a>· 相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/"><strong>热题100-21.合并两个有序链表</strong></a></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>设置一个哑结点res，方便返回结果</li>
<li>循环比较两个链表中的节点，循环条件是两个链表指向的节点不为null，head指向数值较小的节点</li>
<li>循环结束的条件实际是有一个链表遍历结束，再让head.next指向没有遍历完的链表即可</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode res=<span class="keyword">new</span> ListNode();</span><br><span class="line">    ListNode head=res;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">           head.next=l1;</span><br><span class="line">           l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head.next=l2;</span><br><span class="line">           l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next= l1==<span class="keyword">null</span>?l2:l1;<span class="comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/">热题100-206. 反转链表</a></strong></p>
<p>输入一个链表，将它反转后返回头结点。</p>
</blockquote>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode preNode=<span class="keyword">null</span>;</span><br><span class="line">    ListNode curNode=head;</span><br><span class="line">    ListNode nextNode=head;</span><br><span class="line">    <span class="keyword">while</span>(nextNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextNode=curNode.next;</span><br><span class="line">         curNode.next=preNode;</span><br><span class="line">         preNode=curNode;</span><br><span class="line">         curNode=nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数据结构篇</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-进程、线程与协程"><a href="#1-进程、线程与协程" class="headerlink" title="1.进程、线程与协程"></a><strong>1.进程、线程与协程</strong></h1><h2 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h2><ul>
<li><strong>进程：</strong>进程是程序向操作系统申请资源的基本单位，是一个动态概念，也是竞争计算机系统资源的基本单位。</li>
<li><strong>线程：</strong>线程是比进程更小的独立运行的执行单位，一个进程中可以包含多个线程。与进程不同的是同类的多个线程共享同一块内存空间和系统资源，所以系统在产生一个线程，或者在各个线程之间进行切换时，负担比进程小很多，因此线程也被称为轻量级进程。</li>
<li><strong>协程：</strong>它就是一个函数，一个特殊的函数，可以在某个地方挂起，并且可以重新在挂起处继续运行。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方。在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。进程线程都是同步机制，而协程则是异步。协程不需要多线程的锁机制。</li>
</ul>
<h2 id="1-2进程与线程的区别与联系"><a href="#1-2进程与线程的区别与联系" class="headerlink" title="1.2进程与线程的区别与联系"></a>1.2进程与线程的区别与联系</h2><ul>
<li>进程是资源分配最小单位，线程是程序执行的最小单位；</li>
<li>进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间。线程是进程的一个实体，一个进程至少有一个线程,同一个进程的所有线程，共享所属进程的资源；</li>
<li>线程占用的资源比进程少很多，所以创建线程和切换线程的开销相对来说很小。但多进程程序更安全，生命力更强。一个进程的死亡不会对其他进程造成影响。而一个线程死掉，（可能会锁住资源）造成整个进程都死掉了。</li>
</ul>
<h2 id="1-3进程空间"><a href="#1-3进程空间" class="headerlink" title="1.3进程空间"></a>1.3进程空间</h2><p><strong>进程空间：</strong>内核态内存空间、用户态的堆栈（一般8M，从高地址向低地址增长）、数据段、进程代码段。</p>
<p><strong>线程共享的有：</strong>进程代码段、进程共有数据、文件描述符、信号处理器、进程当前目录、进程用户ID、进程组ID。</p>
<p><strong>线程私有的：</strong>线程ID、寄存器的值、线程的栈、线程优先级、错误返回码、线程信号屏蔽码。</p>
<p>1、线程ID<br>同一进程中每个线程拥有唯一的线程ID。<br>2、寄存器组的值<br>由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线 程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。<br>3、线程堆栈<br>线程可以进行函数调用，必然会使用大函数堆栈。<br>4、错误返回码<br>线程执行出错时，必须明确是哪个线程出现何种错误，因此不同的线程应该拥有自己的错误返回码变量。<br>5、信号屏蔽码<br>由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。<br>6、线程的优先级<br>由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。</p>
<h2 id="1-4线程间的通信方式"><a href="#1-4线程间的通信方式" class="headerlink" title="1.4线程间的通信方式"></a>1.4线程间的通信方式</h2><ol>
<li><p><strong>锁机制</strong></p>
<p>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</p>
<p>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</p>
<p>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。（条件变量与互斥锁的使用见CSDN收藏的文章）</p>
</li>
<li><p><strong>信号量机制</strong>：包括无名线程信号量与有名线程信号量。</p>
</li>
<li><p><strong>信号机制</strong>：类似于进程间的信号处理。</p>
</li>
</ol>
<p><strong>线程间通信的主要目的是用于线程同步</strong>，所以线程没有象进程通信中用于数据交换的通信机制。</p>
<h2 id="1-5多进程和多线程的对比"><a href="#1-5多进程和多线程的对比" class="headerlink" title="1.5多进程和多线程的对比"></a>1.5多进程和多线程的对比</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据</th>
<th align="center">共享</th>
<th align="center">同步</th>
<th align="center">内存占用</th>
<th align="center">CPU利用率</th>
<th align="center">创建、销毁、切换</th>
<th align="center">相互间影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>多线程</strong></td>
<td align="center">多个线程共享所属进程的数据</td>
<td align="center">共享复杂，需要通过IPC来共享</td>
<td align="center">困难</td>
<td align="center">少</td>
<td align="center">高</td>
<td align="center">简单且速度快</td>
<td align="center">一个线程挂掉将导致整个进程挂掉（可能会锁住资源）</td>
</tr>
<tr>
<td align="center"><strong>多进程</strong></td>
<td align="center">每个进程都有自己的数据，且互不干涉</td>
<td align="center">共享简单</td>
<td align="center">简单</td>
<td align="center">大</td>
<td align="center">低</td>
<td align="center">复杂且速度慢</td>
<td align="center">进程之间不会相互影响</td>
</tr>
</tbody></table>
<h2 id="1-6竞态"><a href="#1-6竞态" class="headerlink" title="1.6竞态"></a>1.6竞态</h2><p><strong>竞态：</strong>多线程编程中的一个问题，对于同样的输入，程序的输出有时是正确的，有时是错误的，这种计算结果的正确性与时间有关的现象被成为竞态。</p>
<h2 id="1-7线程安全和非线程安全"><a href="#1-7线程安全和非线程安全" class="headerlink" title="1.7线程安全和非线程安全"></a>1.7线程安全和非线程安全</h2><p><strong>线程安全和非线程安全：</strong> 一个类在单线程环境下能够正常运行，并且在多线程环境下，使用方不做特别处理也能运行正常，我们就称其是线程安全的。反之，一个类在单线程环境下运行正常，而在多线程环境下无法正常运行，这个类就是非线程安全的。</p>
<h2 id="1-8进程间的通信方式IPC"><a href="#1-8进程间的通信方式IPC" class="headerlink" title="1.8进程间的通信方式IPC"></a>1.8进程间的通信方式IPC</h2><h3 id="1-8-1七种通信方式"><a href="#1-8-1七种通信方式" class="headerlink" title="1.8.1七种通信方式"></a>1.8.1七种通信方式</h3><ol>
<li><strong>管道pipe：</strong>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>命名管道FIFO：</strong>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>消息队列MessageQueue：</strong>消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享存储SharedMemory：</strong>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>
<li><strong>信号量Semaphore：</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>套接字Socket：</strong>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
<li><strong>信号 ( sinal ) ：</strong> 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
</ol>
<h3 id="1-8-2详细解释"><a href="#1-8-2详细解释" class="headerlink" title="1.8.2详细解释"></a>1.8.2详细解释</h3><p><strong>1.无名管道与命名管道：</strong></p>
<p>管道分为pipe（无名管道）和fifo（命名管道）两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。他们都是通过内核缓冲区实现数据传输。</p>
<ul>
<li>无名管道pipe：用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。</li>
<li>命名管道FIFO：在磁盘上有对应的节点，但没有数据块——换言之，只是拥有一个名字和相应的访问权限，通过mknode()系统调用或者mkfifo()函数来建立的。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。</li>
</ul>
<p><strong>管道的实质是一个内核缓冲区</strong>，进程以<strong>先进先出</strong>的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。</p>
<p><strong>2.消息队列：</strong></p>
<p>消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。</p>
<p>消息队列与管道通信相比，其优势是<strong>对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</strong></p>
<p>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
<p><strong>3.共享内存：</strong></p>
<p>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</p>
<p>采用共享内存进行通信的一个主要好处是<strong>效率高</strong>，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而<strong>共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong></p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<p><strong>4.信号量：</strong></p>
<p><strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问</strong>。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p><strong>5.信号：</strong></p>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p><strong>6.套接字：</strong></p>
<p><strong>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。</strong>也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。也因为这样，套接字明确地将客户端和服务器区分开来。</p>
<h1 id="2-用户态与核心态"><a href="#2-用户态与核心态" class="headerlink" title="2.用户态与核心态"></a>2.用户态与核心态</h1><h2 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h2><p>为防止用户进程访问对操作系统的稳定运行造成破坏。对一些资源的访问进行了等级划分。<strong>内核态和用户态是操作系统的两种运行级别，内核态权限高，用户态权限低。</strong></p>
<h2 id="2-2为什么要划分用户态与核心态"><a href="#2-2为什么要划分用户态与核心态" class="headerlink" title="2.2为什么要划分用户态与核心态"></a>2.2为什么要划分用户态与核心态</h2><p><strong>操作系统的很多操作会消耗系统的物理资源，</strong>例如创建一个新进程时，要做很多底层的细致工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能随便让任何程序都可以做，<strong>于是就产生了特权级别的概念，与系统相关的一些特别关键性的操作必须由高级别的程序来完成，这样可以做到集中管理，减少有限资源的访问和使用冲突</strong></p>
<p><strong>当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，</strong>大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的<strong>内核地址空间，</strong>包括代码和数据；<strong>当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。</strong>执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。</p>
<h2 id="2-3用户态和内核态的切换："><a href="#2-3用户态和内核态的切换：" class="headerlink" title="2.3用户态和内核态的切换："></a>2.3用户态和内核态的切换：</h2><p><strong>进程大部分时间是运行在用户态下的，在其需要操作系统帮助完成一些用户态自己没有特权和能力完成的操作时就会切换到内核态。</strong></p>
<p><strong>切换到内核的方式有：</strong>系统调用、发生异常、外围设备的中断。</p>
<h1 id="3-死锁的条件及解决方法"><a href="#3-死锁的条件及解决方法" class="headerlink" title="3.死锁的条件及解决方法"></a>3.死锁的条件及解决方法</h1><h2 id="3-1死锁的产生条件"><a href="#3-1死锁的产生条件" class="headerlink" title="3.1死锁的产生条件"></a>3.1死锁的产生条件</h2><ol>
<li>死锁问题的情景</li>
</ol>
<p>例如：系统中只有一台扫描仪R1和一台刻录机R2.有两个进程P1和P2，他们都准备将扫描的文档刻录到光盘上，进程P1先请求扫描仪并获得成功，进程P2先请求刻录机并获得成功。后来P1又请求刻录机，因为刻录机被分配给了了P2而导致阻塞；P2又请求扫描仪，因为扫描仪被分配给了P1而导致阻塞。双方都希望对方能释放资源而成全自己，但是双方都不让步，然后就一直僵持下去。</p>
<p>再例如哲学家进餐问题也是死锁的问题场景。</p>
<ol start="2">
<li><strong>死锁产生的四个必要条件</strong></li>
</ol>
<p>只要其中任意一个不成立，则死锁就不会发生。</p>
<p>（1）互斥条件：即在一段时间内，一个资源只能被一个进程占用。</p>
<p>（2）请求和保持条件：进程已经获得了某种资源，但又提出了新的资源的要求，而该资源已经被其他进程占有，此时请求进程被阻塞，但对自己保持的资源不放。</p>
<p>（3）不可抢占资源：进程已获得的资源在未使用完成之前不能被其他进程抢占。</p>
<p>（4）循环等待条件：在发生死锁时，必然存在一个循环链。</p>
<h2 id="3-2解决死锁的方法"><a href="#3-2解决死锁的方法" class="headerlink" title="3.2解决死锁的方法"></a>3.2解决死锁的方法</h2><p><strong>1.预防死锁</strong></p>
<p>去破坏产生死锁的四个必要条件中的一个或几个来预防死锁的产生。</p>
<p>由于互斥条件是保护临界资源的一种措施，所以不仅不能改变，还要加以保证。所以只能破坏其他三个条件。</p>
<p>（1）破坏“请求和保持条件”</p>
<p>第一种协议：进程必须一次性的申请所需的所有资源，并且系统有足够的资源分配给他，否则就不分配。</p>
<p>这种协议的优点是简单，易行且安全，但存在很大的问题，比如资源严重浪费和是进程发生饥饿现象。</p>
<p>第二种协议：允许一个进程只获得运行初期的所需资源，在进程运行过程中，将运行完成的资源释放，然后再请求其他所需资源。</p>
<p>（2）破坏“不可抢占条件”</p>
<p>将不可抢占变成可抢占的资源，实现起来较为复杂，且需要付出很大的代价。</p>
<p>（3）破坏“循环条件”</p>
<p>将循环条件改为层次分配策略</p>
<p><strong>2.避免死锁</strong></p>
<p>在资源的动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p>
<p>安全状态：只要存在一种可以顺利完成任务的顺序就属于安全状态。</p>
<p>不安全状态：没有任意一种顺序使任务顺利完成。</p>
<p><strong>3.检测死锁</strong></p>
<p>通过检测机构检测出死锁的发生，然后采取适当的措施。</p>
<p><strong>4.解除死锁</strong></p>
<p>当检测到死锁已经发生时，撤销一些进程，回收他们的资源，将他们分配给其他需要的进程，使其继续运行。解除死锁的方法：</p>
<p>（1）抢占资源：从一个或多个进程中抢占足够数量的资源，分配给死锁进程。</p>
<p>（2）终止进程：终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。</p>
<h1 id="4-操作系统内存管理方式"><a href="#4-操作系统内存管理方式" class="headerlink" title="4.操作系统内存管理方式"></a>4.操作系统内存管理方式</h1><h2 id="4-1内存管理的概念"><a href="#4-1内存管理的概念" class="headerlink" title="4.1内存管理的概念"></a>4.1内存管理的概念</h2><h3 id="4-1-1分页存储"><a href="#4-1-1分页存储" class="headerlink" title="4.1.1分页存储"></a>4.1.1分页存储</h3><p><strong>0.思维导图</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.1.01.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.1.02.png" style="zoom:80%;">

<p><strong>1.为什么要分页</strong></p>
<p>内部碎片：</p>
<p>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p>
<p>内部碎片是处于（操作系统分配的用于装载某一进程的内存）区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p>
<p>外部碎片：</p>
<p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.1.03.png" style="zoom:80%;">

<p><strong>2.基本分页存储管理的思想</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.03.png" style="zoom:80%;">

<p><strong>3.如何实现地址的转换</strong></p>
<p>因为内存分页后，页面的大小是确定的，比如是50B；</p>
<p>假如需要访问逻辑地址为80的内存单元；</p>
<p>用80/50=1，也就是在1号页；</p>
<p>用80%50=30，也就是页内偏移量为30；</p>
<p>再加上该页面在内存中的起始地址，就能得到逻辑地址到物理地址的映射。</p>
<p><strong>4.分页存储的逻辑结构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.05.png" style="zoom:80%;">

<p><strong>5.如何知道页面在内存中的起始地址</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.06.png" style="zoom:80%;">

<p><strong>6.分页存储管理的基本地址变换结构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.07.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.1.08.png" style="zoom:80%;">

<h3 id="4-1-2快表机制"><a href="#4-1-2快表机制" class="headerlink" title="4.1.2快表机制"></a>4.1.2快表机制</h3><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.01.png" style="zoom:80%;">

<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.02.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.3.01.png"></p>
<h3 id="4-1-3二级页表的原理"><a href="#4-1-3二级页表的原理" class="headerlink" title="4.1.3二级页表的原理"></a>4.1.3二级页表的原理</h3><p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.2.02.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.3.01.png"></p>
<h3 id="4-1-4分段存储"><a href="#4-1-4分段存储" class="headerlink" title="4.1.4分段存储"></a>4.1.4分段存储</h3><p><strong>0.思维导图</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.4.01.png" style="zoom:80%;">

<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/GitHub\MyBlogs\source\_posts\2021-03-15-操作系统\4.1.4.02.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.4.03.png"></p>
<p><strong>1.什么是分段</strong></p>
<p>按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址。</p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.03.png" style="zoom:80%;">

<p><strong>2.段表</strong></p>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.4.04.png"></p>
<p><strong>3.地址变换</strong></p>
<p><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.05.png" style="zoom:80%;"><img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2021-03-15-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5C4.1.4.06.png"></p>
<p><strong>4.分段、分页管理的对比</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.07.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.06.png">

<p><strong>分段实现信息共享共享</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.08.png" style="zoom:80%;">

<p><strong>为什么分页不方便实现信息共享和保护？</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.4.09.png" style="zoom:80%;">

<p><strong>4.1.5段页式存储管理</strong></p>
<p><strong>1.分页、分段的优缺点分析</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.01.png" style="zoom:80%;">

<p><strong>2.分段+分页=段页式管理</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.02.png" style="zoom:80%;">

<p><strong>3.段页式管理的逻辑地址结构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.03.png" style="zoom:80%;">

<p><strong>4.段页式存储的段表、页表</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.1.5.04.png" style="zoom:80%;">

<h2 id="4-2虚拟内存的概念"><a href="#4-2虚拟内存的概念" class="headerlink" title="4.2虚拟内存的概念"></a>4.2虚拟内存的概念</h2><p><strong>1.传统存储管理的特征、缺点</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.01.png" style="zoom:80%;">

<p><strong>2.局部性原理</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.02.png" style="zoom:80%;">

<p><strong>3.虚拟内存的定义和特征</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.03.png" style="zoom:80%;">

<p><strong>4.如何实现虚拟内存技术</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.04.png" style="zoom:80%;">

<p><strong>4.2.1请求分页管理方式</strong></p>
<p><strong>1.知识总览</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.01.png" style="zoom:80%;">

<p><strong>2.请求页表与基本页表的区别</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.02.png" style="zoom:80%;">

<p><strong>3.缺页中断机构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.03.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.04.png" style="zoom:80%;">

<p><strong>只看这个图也可以，对上面的总结</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.05.png" style="zoom:80%;">

<p><strong>4.地址变换机构</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.07.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.08.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.2.1.09.png" style="zoom:80%;">

<h2 id="4-3页面置换算法"><a href="#4-3页面置换算法" class="headerlink" title="4.3页面置换算法"></a><strong>4.3页面置换算法</strong></h2><p><strong>0.思维导图</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.01.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.02.png" style="zoom:80%;">

<p><strong>1.最佳置换算法—OPT</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.03.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.04.png" style="zoom:80%;">

<p><strong>2.先进先出置换算法—FIFO</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.05.png" style="zoom:80%;">

<p><strong>FIFO的改进策略：</strong>即给每个页面增加一个R位，表示最近访问过，每次先从链表头开始查找，如果R置1位，清除R位并且把该页面节点放到链表结尾；如果R是0，那么就是又老又没用到，替换掉。</p>
<p><strong>3.最近最久未使用置换算法—LRU</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.06.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.07.png" style="zoom:80%;">

<p><strong>4.时钟置换算法—CLOCK</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.08.png" style="zoom:80%;">

<p><strong>5.改造型时钟置换算法</strong></p>
<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.10.png" style="zoom:80%;">

<img src="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.3.09.png" style="zoom:80%;">]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-计算机网络参考模型"><a href="#1-计算机网络参考模型" class="headerlink" title="1.计算机网络参考模型"></a>1.计算机网络参考模型</h1><h2 id="1-1OSI七层模型与TCP-IP五层模型"><a href="#1-1OSI七层模型与TCP-IP五层模型" class="headerlink" title="1.1OSI七层模型与TCP/IP五层模型"></a><strong>1.1OSI七层模型与TCP/IP五层模型</strong></h2><ul>
<li>OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层；</li>
<li>TCP/IP5层模型：物理层，数据链路层，网络层，运输层，应用层；</li>
<li>TCP/IP4层模型：网络接口层，网络层(IP)，运输层(TCP/UDP)，应用层(HTTP)。</li>
</ul>
<h2 id="1-2常见应用层、运输层和网络层协议"><a href="#1-2常见应用层、运输层和网络层协议" class="headerlink" title="1.2常见应用层、运输层和网络层协议"></a><strong>1.2常见应用层、运输层和网络层协议</strong></h2><ul>
<li>应用层：HTTP、HTTPS、FTP、SMTP、DNS</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP、ICMP、IGMP</li>
</ul>
<h2 id="1-3硬件如路由器工作在哪一层"><a href="#1-3硬件如路由器工作在哪一层" class="headerlink" title="1.3硬件如路由器工作在哪一层"></a><strong>1.3硬件如路由器工作在哪一层</strong></h2><ul>
<li>网络层</li>
</ul>
<h1 id="2-网络层"><a href="#2-网络层" class="headerlink" title="2.网络层"></a>2.网络层</h1><h2 id="2-1ARP协议"><a href="#2-1ARP协议" class="headerlink" title="2.1ARP协议"></a>2.1ARP协议</h2><ul>
<li>ARP是IP地址解析为MAC地址 ；</li>
<li>RARP 将MAC地址解析为IP地址。</li>
</ul>
<p>每台主机都设有一个ARP高速缓存，用来存放本局域网内各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP来动态维护此ARP表。</p>
<p><strong>IP数据报的传输过程（IP源、目的地址始终不变；MAC源、目的地址在变化）：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>假如主机A的某个应用程序需要发送数据到主机B的某个应用程序，IP数据报在互联网中的传输与处理大致要经历如下过程：</p>
<ol>
<li><strong>主机发送IP数据报</strong></li>
</ol>
<p>如果主机A要发送数据给互联网上的另一台主机B，那么，主机A首先要构造一个目的IP地址为主机B的IP数据报（目的IP地址=10.3.0.88），然后对数据报进行路由选择。利用路由选择算法和主机A的路由表（见表1-1）可以得到，目的主机B和主机A不在同一网络，需要将该数据报转发到默认路由器R2（IP地址10.1.0.1）。</p>
<p>尽管主机A需要将数据报首先送到它的默认路由器R2而不是目的主机B，但是它既不会修改原IP数据报的内容，也不会在原IP数据报上面附加内容（甚至不附加下一默认路由器的IP地址）。那么，主机A怎样将数据报发送给下一路由器呢？在发送数据报之前，主机A首先调用ARP地址解析软件，得到下一默认路由器IP地址与MAC地址的映射关系，然后以该MAC地址为帧的目的地址形成一个帧，并将IP数据报封装在帧的数据区，最后由具体的物理网络（以太网）完成数据报的真正传输。由此可见，在为IP数据报选路时主机A使用数据报的目的IP地址，并且得到的是默认路由器R2的IP地址。但真正的数据传输是通过将IP数据报封装成帧，并利用默认路由器R2的MAC地址实现的。</p>
<ol start="2">
<li><strong>路由器R2处理和转发IP数据报</strong></li>
</ol>
<p>路由器R2接收到主机A发送给它的帧后，去掉帧头，并把IP数据报提交给IP软件处理。由于该IP数据报的目的地并不是路由器R2，因此R2需要将它转发出去。</p>
<p>利用路由选择算法和路由器R2的路由表（见表1-3）可知，如果要到达数据报的目的地，必须将它投递到IP地址为10.2.0.2的路由器（路由器R3）。</p>
<p>通过以太网投递时，路由器R2需要调用ARP地址解析软件，得到路由器R3的IP地址与MAC地址的映射关系，并利用该MAC地址作为帧的目的地址将IP数据报封装成帧，最后由以太网完成真正的数据投递。</p>
<p>需要注意的是，路由器在转发数据之前，IP软件需要从数据报报头的“生存周期”减去一定的值。若“生存周期”小于或等于0，则抛弃该报文；否则，重新计算IP数据报的校验和并继续转发。</p>
<ol start="3">
<li><strong>路由器R3处理和转发IP数据报</strong></li>
</ol>
<p>与路由器R2相同，路由器R3接收到路由器R2发送的帧后也需要去掉帧头，并把IP数据报提交给IP软件处理。与路由器R2不同，路由器R3在路由选择过程中发现该数据报指定的目的网络与自己直接相连，可以直接投递。于是，路由器R3调用ARP地址解析软件得到主机B的IP地址与MAC地址的映射关系，利用该MAC地址作为帧的目的地址，将IP数据报封装成帧，并由以太网实现数据的真正传递。</p>
<ol start="4">
<li><strong>主机B接收IP数据报</strong></li>
</ol>
<p>当封装IP数据报的帧到达主机B后，主机B对该帧进行解封装，并将IP数据报送主机B上的IP软件处理。IP软件确认该数据报的目的IP地址10.3.0.88为自己的IP地址后，将IP数据报中封装的数据信息送交高层协议软件处理。</p>
<p>从IP数据报在互联网中被处理和传递的过程可以看到，每个路由器都是一个自治的系统，它们根据自己掌握的路由信息对每一个IP数据报进行路由选择和转发。路由表在路由选择过程中发挥着重要作用，如果一个路由器的路由表发生变化，到达目的网络所经过的路径就有可能发生变化。例如，假如主机A路由表中的默认路由不是路由表R2（10.1.0.1），而是路由器R1（10.1.0.2），那么，主机A发往主机B的IP数据报就不会沿A-R2-R3-B，它将通过R1到达主机B。</p>
<p>另外，图1-1所示的互联网是3个以太网的互联，由于它们的MTU相同，因此IP数据报在传递过程中不需要分片。如果路由器连接不同类型的网络，而这些网络的MTU又不相同，那么，路由器在转发之前可能需要对IP数据报分片。对接收到的数据报，不管它是分片后形成的IP数据报还是未分片的IP数据报，路由器都一视同仁，进行相同的路由处理和转发。</p>
<h2 id="1-TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些"><a href="#1-TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些" class="headerlink" title="1.TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些"></a><strong>1.TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些</strong></h2><h3 id="1-1TCP协议："><a href="#1-1TCP协议：" class="headerlink" title="1.1TCP协议："></a><strong>1.1TCP协议：</strong></h3><ul>
<li><strong>概述：</strong>在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接；而且在数据传递时，由于要提供可靠的面向连接的传输服务，又有确认应答、超时重传、滑动窗口、拥塞控制等机制保证传送数据的可靠性。</li>
<li><strong>应用场景：</strong>TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。</li>
<li><strong>基于TCP的协议：</strong>SMTP、HTTP、FTP</li>
</ul>
<h3 id="1-2UDP协议："><a href="#1-2UDP协议：" class="headerlink" title="1.2UDP协议："></a><strong>1.2UDP协议：</strong></h3><ul>
<li><strong>概述：</strong>UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。</li>
<li><strong>应用场景：</strong>UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。</li>
<li><strong>基于UDP的协议：</strong>RIP(路由选择协议）、DNS</li>
</ul>
<h2 id="2-TCP可靠传输的保证"><a href="#2-TCP可靠传输的保证" class="headerlink" title="2.TCP可靠传输的保证"></a><strong>2.TCP可靠传输的保证</strong></h2><p><img src="https://img-blog.csdnimg.cn/20200414234405762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-1校验"><a href="#2-1校验" class="headerlink" title="2.1校验"></a><strong>2.1校验</strong></h3><h3 id="2-2序号"><a href="#2-2序号" class="headerlink" title="2.2序号"></a><strong>2.2序号</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200414234723205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-3确认"><a href="#2-3确认" class="headerlink" title="2.3确认"></a><strong>2.3确认</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-4重传"><a href="#2-4重传" class="headerlink" title="2.4重传"></a><strong>2.4重传</strong></h3><p><strong>a.超时重传：</strong>当发送方在重传时间RTTs内没有收到接收方的确认报文，就要重传已发送的字段</p>
<p><strong>b.冗余ACK：</strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-TCP流量控制"><a href="#3-TCP流量控制" class="headerlink" title="3.TCP流量控制"></a>3.TCP流量控制</h2><ul>
<li><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率。</p>
</li>
<li><p>同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415112950253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h2 id="4-TCP拥塞控制的条件、目的和过程"><a href="#4-TCP拥塞控制的条件、目的和过程" class="headerlink" title="4.TCP拥塞控制的条件、目的和过程"></a><strong>4.TCP拥塞控制的条件、目的和过程</strong></h2><p>一条TCP连接上发送数据速度的影响因素有：服务器到客户端之间带宽瓶颈、客户端接收能力限制、服务器网卡处理能力</p>
<h3 id="4-1条件："><a href="#4-1条件：" class="headerlink" title="4.1条件："></a><strong>4.1条件：</strong></h3><p>对于资源的需求大于供应，导致网络的性能变坏，表现为网络的吞吐量随着网络负荷的增加而减小</p>
<p><strong>例如：</strong></p>
<ul>
<li>某个链路的传输速率为10Gb/s,某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。</li>
<li>但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</li>
</ul>
<h3 id="4-2目的："><a href="#4-2目的：" class="headerlink" title="4.2目的："></a><strong>4.2目的：</strong></h3><p>是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>
<h3 id="4-3过程："><a href="#4-3过程：" class="headerlink" title="4.3过程："></a><strong>4.3过程：</strong></h3><p>拥塞控制是一个全局性的过程，不止是控制发送方发送的数据量</p>
<p><img src="https://img-blog.csdnimg.cn/20200415122234339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-3-1慢开始与拥塞避免"><a href="#4-3-1慢开始与拥塞避免" class="headerlink" title="4.3.1慢开始与拥塞避免"></a><strong>4.3.1慢开始与拥塞避免</strong></h4><p><img src="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> <strong>(1)慢开始算法</strong></p>
<ul>
<li><p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加倍。用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</p>
</li>
<li><p>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</p>
<p>**例如:**A向B发送数据，发送时A的拥塞窗口为2,那么A一次可以发送两个TCP报文段，经过一个RTT后(也称一个<code>传输轮次</code>)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。</p>
</li>
</ul>
<p><strong>(2)拥塞避免算法</strong></p>
<ul>
<li>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下:<br>●当cwnd &lt; ssthresh时，使用慢开始算法。<br>●当 cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>●当cwnd = ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。</li>
</ul>
<p><strong>(3)网络拥塞的处理</strong></p>
<ul>
<li>网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</li>
<li>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></li>
</ul>
<blockquote>
<p><strong>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</strong></p>
</blockquote>
<ul>
<li><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</li>
<li><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li>
</ul>
<h4 id="4-3-2快重传和快恢复"><a href="#4-3-2快重传和快恢复" class="headerlink" title="4.3.2快重传和快恢复"></a><strong>4.3.2快重传和快恢复</strong></h4><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p>
<p> <strong>(1)快重传</strong></p>
<ul>
<li>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</li>
</ul>
<p><strong>(2)快恢复</strong></p>
<ul>
<li><code>快恢复算法</code>的原理如下:</li>
<li>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</li>
<li>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</li>
<li><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</li>
</ul>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-3-3四种拥塞控制算法的总结"><a href="#4-3-3四种拥塞控制算法的总结" class="headerlink" title="4.3.3四种拥塞控制算法的总结"></a><strong>4.3.3四种拥塞控制算法的总结</strong></h4><ul>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<h4 id="4-3-4拥塞控制与流量控制"><a href="#4-3-4拥塞控制与流量控制" class="headerlink" title="4.3.4拥塞控制与流量控制"></a><strong>4.3.4拥塞控制与流量控制</strong></h4><ul>
<li><strong>在流量控制中：</strong>发送方发送数据的量由接收方决定</li>
<li><strong>而在拥塞控制中：</strong>则由发送方自己通过检测网络状况来决定。</li>
</ul>
<blockquote>
<p><strong>注意：发送方发送窗口的实际大小由流量控制和拥塞控制共同决定</strong></p>
</blockquote>
<p>当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。</p>
<h2 id="5-TCP粘包现象"><a href="#5-TCP粘包现象" class="headerlink" title="5.TCP粘包现象"></a><strong>5.TCP粘包现象</strong></h2><p><strong>TCP粘包概念：</strong>就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。</p>
<h3 id="5-1原因及解决方法"><a href="#5-1原因及解决方法" class="headerlink" title="5.1原因及解决方法"></a>5.1原因及解决方法</h3><h4 id="5-1-1原因"><a href="#5-1-1原因" class="headerlink" title="5.1.1原因"></a>5.1.1原因</h4><ul>
<li><strong>发送方原因：</strong>TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li><strong>接收方原因：</strong>TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h4 id="5-1-2解决办法"><a href="#5-1-2解决办法" class="headerlink" title="5.1.2解决办法"></a>5.1.2解决办法</h4><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p>
<ul>
<li><p><strong>发送方：</strong>发送方关闭Nagle算法。</p>
</li>
<li><p><strong>接收方：</strong>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p>
</li>
</ul>
<h3 id="5-2为什么TCP会有粘包现象，而UDP没有"><a href="#5-2为什么TCP会有粘包现象，而UDP没有" class="headerlink" title="5.2为什么TCP会有粘包现象，而UDP没有"></a><strong>5.2为什么TCP会有粘包现象，而UDP没有</strong></h3><p><strong>TCP：</strong>为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的；</p>
<p><strong>UDP：</strong>面向消息传输，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<blockquote>
<p><strong>消息边界：</strong></p>
</blockquote>
<ul>
<li>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；</li>
<li>而面向流则是指无保护消息保护边界的,如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包。因此就会造成粘包现象</li>
</ul>
<h2 id="6-TCP三次握手"><a href="#6-TCP三次握手" class="headerlink" title="6.TCP三次握手"></a><strong>6.TCP三次握手</strong></h2><h3 id="6-1三次握手的过程及状态变化"><a href="#6-1三次握手的过程及状态变化" class="headerlink" title="6.1三次握手的过程及状态变化"></a>6.1三次握手的过程及状态变化</h3><p><img src="https://img-blog.csdnimg.cn/20200414175430736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041418134522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<blockquote>
<p><strong>NOTE：</strong></p>
</blockquote>
<ul>
<li>seq为序号字段，标明本次报文段数据部分的第一个字节的序号</li>
<li>ack是<code>确认号字段</code>，告诉对方我接下来应该接收的数据是从字节序号ack开始的数据</li>
<li>ACK是确认位,0时<code>确认号字段ack</code>无效，1时<code>确认号字段ack</code>有效</li>
<li>SYN是同步位</li>
</ul>
<h3 id="6-2为什么要三次握手，两次行不行？"><a href="#6-2为什么要三次握手，两次行不行？" class="headerlink" title="6.2为什么要三次握手，两次行不行？"></a><strong>6.2为什么要三次握手，两次行不行？</strong></h3><p>三次握手是为了建立可靠的通信信道，双方都确认自己和对方的发送和接受都是正常的。SYN=1表示这是个连接请求或连接接受报文，不携带数据。不能变成两次，已失效的连接请求报文段突然又传送到了服务端，服务端误以为是正常的连接请求，直接发送连接确认报文，导致TCP建立，浪费资源，因而产生错误。</p>
<h3 id="6-3SYN攻击"><a href="#6-3SYN攻击" class="headerlink" title="6.3SYN攻击"></a><strong>6.3SYN攻击</strong></h3><h4 id="6-3-1SYN攻击概述"><a href="#6-3-1SYN攻击概述" class="headerlink" title="6.3.1SYN攻击概述"></a>6.3.1SYN攻击概述</h4><p><img src="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<h4 id="6-3-2怎么检测是否受到了SYN攻击"><a href="#6-3-2怎么检测是否受到了SYN攻击" class="headerlink" title="6.3.2怎么检测是否受到了SYN攻击"></a>6.3.2怎么检测是否受到了SYN攻击</h4><p>检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<h4 id="6-3-3怎么解决SYN攻击"><a href="#6-3-3怎么解决SYN攻击" class="headerlink" title="6.3.3怎么解决SYN攻击"></a>6.3.3怎么解决SYN攻击</h4><ul>
<li>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</li>
<li>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li>
</ul>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<h2 id="7-TCP四次挥手"><a href="#7-TCP四次挥手" class="headerlink" title="7.TCP四次挥手"></a><strong>7.TCP四次挥手</strong></h2><h3 id="7-1四次挥手的过程及状态变化"><a href="#7-1四次挥手的过程及状态变化" class="headerlink" title="7.1四次挥手的过程及状态变化"></a>7.1四次挥手的过程及状态变化</h3><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<p><img src="https://img-blog.csdnimg.cn/2020041422283189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200414224348666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<blockquote>
<p><strong>TIME_WAIT状态为什么要等待2MSL：</strong></p>
</blockquote>
<p>因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的ACK报文。也就是说client不能立刻关闭，要等待这个TCP连接断开之后再关闭。</p>
<blockquote>
<p><strong>为什么会有CLOSE_WAIT：</strong></p>
</blockquote>
<p>因为服务器可能有数据未发送完毕，这段时间是继续发送数据的。</p>
<h3 id="7-2为什么要进行四次挥手过程"><a href="#7-2为什么要进行四次挥手过程" class="headerlink" title="7.2为什么要进行四次挥手过程"></a>7.2为什么要进行四次挥手过程</h3><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h3 id="7-3TCP连接出现故障问题"><a href="#7-3TCP连接出现故障问题" class="headerlink" title="7.3TCP连接出现故障问题"></a>7.3TCP连接出现故障问题</h3><p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<h3 id="7-4关于TIME-WAIT"><a href="#7-4关于TIME-WAIT" class="headerlink" title="7.4关于TIME_WAIT"></a>7.4关于TIME_WAIT</h3><h4 id="7-4-1TIME-WAIT存在的两个理由："><a href="#7-4-1TIME-WAIT存在的两个理由：" class="headerlink" title="7.4.1TIME_WAIT存在的两个理由："></a>7.4.1TIME_WAIT存在的两个理由：</h4><ol>
<li>可靠的实现TCP全双工连接的终止</li>
<li>允许老的重复的分节在网络上的消逝（TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝）。</li>
</ol>
<h4 id="7-4-2为什么会出现大量的TIME-WAIT状态"><a href="#7-4-2为什么会出现大量的TIME-WAIT状态" class="headerlink" title="7.4.2为什么会出现大量的TIME_WAIT状态"></a>7.4.2为什么会出现大量的TIME_WAIT状态</h4><p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和句柄被用尽，系统无法再发起新的连接！（对于一个处理大量短连接的服务器,如果由服务器主动关闭客户端的连接,将导致服务器存在大量的处于TIME_WAIT状态的socket,严重影响服务器的处理能力,甚至耗尽可用的socket）。</p>
<h4 id="7-4-3解决方法"><a href="#7-4-3解决方法" class="headerlink" title="7.4.3解决方法"></a>7.4.3解决方法</h4><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><strong>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</strong></p>
<h2 id="8-点对点与端对端的区别"><a href="#8-点对点与端对端的区别" class="headerlink" title="8.点对点与端对端的区别"></a>8.点对点与端对端的区别</h2><ul>
<li><strong>点到点通信：</strong>是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li><strong>端到端通信：</strong>是针对传输层来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。</li>
</ul>
<h1 id="4-应用层"><a href="#4-应用层" class="headerlink" title="4.应用层"></a>4.应用层</h1><h2 id="1-浏览器输入url并回车的过程以及相关协议"><a href="#1-浏览器输入url并回车的过程以及相关协议" class="headerlink" title="1.浏览器输入url并回车的过程以及相关协议"></a>1.浏览器输入url并回车的过程以及相关协议</h2><ol>
<li>根据域名进行DNS解析查询域名所对应的的IP地址</li>
<li>建立TCP连接</li>
<li>建立TCP连接的基础上发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>使用的协议：DNS(获取域名的IP的地址);TCP(与服务器建立TCP连接)；IP(建立TCP协议时，需发送数据，在网络层用到IP协议)；OPSF(IP数据包在路由之间传送，路由选择使用OPSF协议)；ARP(路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议)HTTP(TCP建立之后，使用HTTP协议访问网页)；</p>
<h2 id="2-DNS域名解析的过程"><a href="#2-DNS域名解析的过程" class="headerlink" title="2.DNS域名解析的过程"></a>2.DNS域名解析的过程</h2><p><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-HTTP1-0、HTTP1-1、HTTP2-0之间的区别"><a href="#3-HTTP1-0、HTTP1-1、HTTP2-0之间的区别" class="headerlink" title="3.HTTP1.0、HTTP1.1、HTTP2.0之间的区别"></a>3.HTTP1.0、HTTP1.1、HTTP2.0之间的区别</h2><h3 id="3-1HTTP1-1与1-0之间的区别"><a href="#3-1HTTP1-1与1-0之间的区别" class="headerlink" title="3.1HTTP1.1与1.0之间的区别:"></a><strong>3.1HTTP1.1与1.0之间的区别:</strong></h3><p><strong>1.长连接</strong></p>
<p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p>
<p><strong>2.节约带宽</strong></p>
<p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<p><strong>3.HOST域</strong></p>
<p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
<h3 id="3-2HTTP1-1与2-0之间的区别"><a href="#3-2HTTP1-1与2-0之间的区别" class="headerlink" title="3.2HTTP1.1与2.0之间的区别:"></a><strong>3.2HTTP1.1与2.0之间的区别:</strong></h3><p><strong>1.多路复用</strong></p>
<p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<p><strong>2.数据压缩</strong></p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p><strong>3.服务器推送</strong></p>
<p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p>
<p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p>
<h2 id="4-HTTP与HTTPS"><a href="#4-HTTP与HTTPS" class="headerlink" title="4.HTTP与HTTPS"></a>4.HTTP与HTTPS</h2><h3 id="4-1两者之间的区别"><a href="#4-1两者之间的区别" class="headerlink" title="4.1两者之间的区别"></a>4.1两者之间的区别</h3><p>​    1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>​    2、HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS(运行在TCP之上)之上，内容加密。</p>
<p>​    3、连接端口不一样，http是80，https是443.</p>
<p>​    4、http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，更安全。</p>
<p>HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层<strong>；</strong>采用对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。对称加密：加密和解密都是同一个密钥。非对称加密：密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<h3 id="4-2HTTPS链接建立的过程"><a href="#4-2HTTPS链接建立的过程" class="headerlink" title="4.2HTTPS链接建立的过程"></a>4.2HTTPS链接建立的过程</h3><h4 id="4-2-1加密通信过程"><a href="#4-2-1加密通信过程" class="headerlink" title="4.2.1加密通信过程"></a>4.2.1加密通信过程</h4><p> <strong>step1</strong>： “客户”向服务端发送一个通信请求</p>
<p> “客户”-&gt;“服务器”：你好</p>
<p> <strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有。</p>
<p> “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>
<p> <strong>step3</strong>： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>
<p> “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串   //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>
<p> “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>
<p> <strong>step4</strong>： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>
<p> “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>
<p> “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>
<p> “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>
<p> …… //继续其它的通信</p>
<h4 id="4-2-2HTTPS链接建立的过程"><a href="#4-2-2HTTPS链接建立的过程" class="headerlink" title="4.2.2HTTPS链接建立的过程"></a>4.2.2HTTPS链接建立的过程</h4><p>1、发送非对称加密的公钥A给浏览器</p>
<p>2、客户端(SSL/TLS)解析证书（无效会弹出警告）</p>
<p>3、生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥B。</p>
<p>4、浏览器使用服务器返回的公钥A，对自己生成的对称加密密钥B进行加密，得到密钥C。</p>
<p>5、浏览器将密钥C发送给服务器</p>
<p>6、务器使用自己的私钥D对接受的密钥C进行解密，得到对称加密密钥B。</p>
<p>7、将信息和密钥B混合在一起进行对称加密</p>
<p>8、将加密的内容发送给客户端</p>
<p>9、客户端用密钥B解密信息</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\01.png" style="zoom:80%;">

<p><strong>加密过程使用了对称加密和非对称加密。</strong></p>
<p><strong>1.对称加密与非对称加密</strong></p>
<ul>
<li><p><strong>对称加密：</strong>客户端和服务端采用相同的密钥进行加密</p>
<p>encrypt(明文，秘钥) = 密文</p>
<p>decrypt(密文，秘钥) = 明文</p>
</li>
<li><p><strong>非对称加密：</strong>客户端通过公钥加密，服务端通过私钥解密</p>
<p>encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
</li>
</ul>
<p><strong>2.验证证书</strong></p>
<p>客户端获取到了站点证书，拿到了站点的公钥</p>
<p>客户端找到其站点证书颁发者的信息</p>
<p>站点证书的颁发者验证服务端站点是否可信</p>
<p> <strong>3.几种加密算法</strong></p>
<ul>
<li>   <strong>非对称加密算法：</strong>RSA，DSA/DSS</li>
<li>   <strong>对称加密算法：</strong>AES，RC4，3DES</li>
<li>   <strong>HASH算法：</strong>MD5，SHA1，SHA256</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\02.png" style="zoom:80%;">

<h3 id="4-3HTTP请求有哪些"><a href="#4-3HTTP请求有哪些" class="headerlink" title="4.3HTTP请求有哪些"></a>4.3HTTP请求有哪些</h3><ul>
<li>get:请求特定资源</li>
<li>post:向指定资源提交数据进行处理请求</li>
<li>Put:向指定资源上传最新内容</li>
<li>Delete:请求删除资源</li>
</ul>
<h3 id="4-4get和post的差别"><a href="#4-4get和post的差别" class="headerlink" title="4.4get和post的差别"></a>4.4get和post的差别</h3><ul>
<li>Get是从指定资源请求数据，而Post是向指定资源提交要被处理的数据。</li>
<li>Get请求刷新无害，而post刷新，数据会被重复提交。</li>
<li>Get请求的数据会附加到URL中，多个参数用&amp;连接，URL编码采用ASCII编码。而POST请求会把请求的数据放到body中。因此get请求的数据会暴露在地址栏中，而post不会。又浏览器和服务器对url的长度有限制，所以get传输数据的大小受到url的限制。</li>
<li>Get请求的资源会被浏览器缓存。</li>
<li>post比get慢，因为post在发送数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。而get请求直接发送请求头和数据。</li>
</ul>
<h3 id="4-5HTTP状态码："><a href="#4-5HTTP状态码：" class="headerlink" title="4.5HTTP状态码："></a><strong>4.5HTTP状态码：</strong></h3><table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center">200</td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">请求资源在多处可得到，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">资源找不到</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">内部服务器错误</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（网关错误）</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求（网关超时）</td>
</tr>
</tbody></table>
<h3 id="4-6HTTP报文组成"><a href="#4-6HTTP报文组成" class="headerlink" title="4.6HTTP报文组成"></a>4.6HTTP报文组成</h3><ul>
<li><p><strong>HTTP请求报文</strong>主要由请求行、请求头部、请求正文3部分组成</p>
<blockquote>
<p><strong>NOTE：</strong></p>
<p>请求报文的“请求行”有三个内容:方法、请求资源的URL及HTTP的版本</p>
</blockquote>
</li>
<li><p><strong>HTTP响应报文</strong>主要由状态行、响应头部、响应正文3部分组成</p>
</li>
</ul>
<h2 id="5-转发和重定向的区别"><a href="#5-转发和重定向的区别" class="headerlink" title="5.转发和重定向的区别"></a>5.转发和重定向的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p>转发是服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。效率高，可用于用户登录之后将角色转发到相应的模块。</p>
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器到新的网址重新请求资源。地址栏url会发生改变，而且不能共享数据。效率低，可用于用户注销之后，跳转到其他网站。</p>
<table>
<thead>
<tr>
<th align="center"><strong>区别</strong></th>
<th align="center"><strong>转发forward()</strong></th>
<th align="center"><strong>重定向sendRedirect()</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>根目录</strong></td>
<td align="center">包含项目访问地址</td>
<td align="center">没有项目访问地址</td>
</tr>
<tr>
<td align="center"><strong>地址栏</strong></td>
<td align="center">不会发生变化</td>
<td align="center">会发生变化</td>
</tr>
<tr>
<td align="center"><strong>哪里跳转</strong></td>
<td align="center">服务器端进行的跳转</td>
<td align="center">浏览器端进行的跳转</td>
</tr>
<tr>
<td align="center"><strong>请求域中数据</strong></td>
<td align="center">不会丢失</td>
<td align="center">会丢失</td>
</tr>
</tbody></table>
<h2 id="6-Session和Cookie的区别"><a href="#6-Session和Cookie的区别" class="headerlink" title="6.Session和Cookie的区别"></a>6.Session和Cookie的区别</h2><p><strong>Cookie：</strong>是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端， 然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>
<ul>
<li>​    客户端发送一个http请求到服务器端</li>
<li>​    服务器端发送一个http响应到客户端，其中包含Set-Cookie头部</li>
<li>​    客户端发送一个http请求到服务器端，其中包含Cookie头部</li>
<li>​    服务器端发送一个http响应到客户端</li>
</ul>
<p><strong>Session：</strong>保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。Session在用户第一次访问服务器的时候自动创建, 创建Session的同时，服务器会为该Session生成唯一的session id,session id会以cookie的方式发送个客户端。客户端下次访问时，带上这个session id，就可以跟踪会话了。如果浏览器不支持cookie，可以用url重写的方式，将sessionId写入url传给服务器。</p>
<p><strong>Cookie的不可跨域名性</strong></p>
<p>很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<p>需要注意的是，虽然网站<a href="https://links.jianshu.com/go?to=http://images.google.com">images.google.com</a>与网站<a href="https://links.jianshu.com/go?to=http://www.google.com">www.google.com</a>同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。</p>
]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/03/16/MySQL/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="1-事务相关"><a href="#1-事务相关" class="headerlink" title="1.事务相关"></a>1.事务相关</h1><p><strong>事务</strong>：一组逻辑操作，要么全都执行，要么都不执行。</p>
<h2 id="1-1事务的四大特性（ACID）"><a href="#1-1事务的四大特性（ACID）" class="headerlink" title="1.1事务的四大特性（ACID）"></a>1.1事务的四大特性（ACID）</h2><ul>
<li><strong>原子性：</strong>事务是最小的执行单位，不可分割，保证事务要么都完成，要么都不完成；</li>
<li><strong>一致性：</strong>执行事务前后，数据保持一致，例如转账业务中，转账前后的总额应该是不变的；</li>
<li><strong>隔离性：</strong>并发访问数据库时，一个事务不被其他事务干扰；</li>
<li><strong>持久性：</strong>事务一旦提交，对数据库的改变是持久的。</li>
</ul>
<h2 id="1-2事务的隔离级别"><a href="#1-2事务的隔离级别" class="headerlink" title="1.2事务的隔离级别"></a>1.2事务的隔离级别</h2><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li> <strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产 生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p><strong>并发事务带来的问题：</strong></p>
<p>在典型的应用程序中，多个事务并发运行，经常会<strong>操作相同的数据</strong>来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须 的，但可能会导致以下的问题。 </p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问 了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据” 所做的操作可能是不正确的；</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </li>
<li>例如：事务1读取某表中的数据 A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 </li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么， 在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 </li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p>不可重复度和幻读区别： 不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p> 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 </p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的 人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<blockquote>
<p><strong>NOTE：</strong>隔离级别的设置只对当前连接有效，对于使用MYSQL命令窗口而言，一个窗口就相当于一个连接，当前窗口设置的隔离级别只对当前窗口中的事务有效</p>
</blockquote>
<h2 id="1-3MySQL隔离级别"><a href="#1-3MySQL隔离级别" class="headerlink" title="1.3MySQL隔离级别"></a>1.3MySQL隔离级别</h2><h3 id="1-3-1MySQL默认隔离级别"><a href="#1-3-1MySQL默认隔离级别" class="headerlink" title="1.3.1MySQL默认隔离级别"></a>1.3.1MySQL默认隔离级别</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>
<h3 id="1-3-2如何保证并发安全"><a href="#1-3-2如何保证并发安全" class="headerlink" title="1.3.2如何保证并发安全"></a>1.3.2如何保证并发安全</h3><p>InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下，允许应用使用 <strong>Next-Key Lock 锁算法</strong>来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。（所以说虽然 InnoDB 存储引擎的默认支持的隔离 级别是 REPEATABLE-READ（可重读），但是可以通过应用加锁读（例如 select * from table for update 语句）来保证不会产生幻读， 而这个加锁读使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 SERIALIZABLE(可串行化) 隔离级别）。</p>
<p> InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
<h2 id="1-4Innodb和Myisam的区别"><a href="#1-4Innodb和Myisam的区别" class="headerlink" title="1.4Innodb和Myisam的区别"></a>1.4Innodb和Myisam的区别</h2><ul>
<li><strong>是否支持行级锁 :</strong> MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁；</li>
<li><strong>是否支持事务和崩溃后的安全恢复：</strong> MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务 支持。但是InnoDB 提供事务支持，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表；</li>
<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持</li>
<li><strong>是否支持MVCC ：</strong>仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现;</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><strong>MyISAM适合：</strong>(1)做很多count 的计算、(2)读密集、(3)没有事务</li>
<li><strong>InnoDB适合：</strong>(1)要求事务、(2)写密集、（3）高并发</li>
</ul>
<h2 id="1-5介绍MVCC"><a href="#1-5介绍MVCC" class="headerlink" title="1.5介绍MVCC"></a>1.5介绍MVCC</h2><h3 id="1-5-1什么是MVCC"><a href="#1-5-1什么是MVCC" class="headerlink" title="1.5.1什么是MVCC"></a>1.5.1什么是MVCC</h3><p><strong>MVCC</strong>全称<code>Multi-Version Concurrency Control</code>，即<strong>多版本并发控制。</strong>MVCC在<strong>MySQL InnoDB</strong>中的实现主要是为了<strong>提高数据库并发性能</strong>，用更好的方式去处理读-写冲突。</p>
<h3 id="1-5-2什么是当前读和快照读？"><a href="#1-5-2什么是当前读和快照读？" class="headerlink" title="1.5.2什么是当前读和快照读？"></a>1.5.2什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p>
<ul>
<li><strong>当前读</strong><br>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li><strong>快照读</strong><br>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>
</ul>
<p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p>
<p><strong>当前读，快照读和MVCC的关系：</strong></p>
<ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念，仅仅是一个理想概念。</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。</li>
</ul>
<h3 id="1-5-3MVCC能解决什么问题，好处是？"><a href="#1-5-3MVCC能解决什么问题，好处是？" class="headerlink" title="1.5.3MVCC能解决什么问题，好处是？"></a>1.5.3MVCC能解决什么问题，好处是？</h3><p><strong>数据库并发场景有三种，分别为：</strong></p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p><strong>MVCC带来的好处是？</strong><br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>总结MVCC的作用：</strong><br>MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h3 id="1-5-4MVCC的实现原理"><a href="#1-5-4MVCC的实现原理" class="headerlink" title="1.5.4MVCC的实现原理"></a>1.5.4MVCC的实现原理</h3><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code>**，</strong><code>undo日志</code>** ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念：</p>
<p><strong>隐式字段：</strong>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li><strong>DB_TRX_ID</strong><br>最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong><br>回滚指针，用于配合undo日志，指向上一个旧版本（存储于rollback segment里）</li>
<li><strong>DB_ROW_ID</strong><br>隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><strong>undo日志：</strong>undo log主要分为两种</p>
<ul>
<li><strong>insert undo log</strong><br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li><strong>update undo log（最重要）</strong><br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
<p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p>
<p><strong>Read View(读视图)</strong></p>
<p><code>Read View</code>就是事务进行<code>快照读</code>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)**</p>
<p>所以我们知道 <code>Read View</code>主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p>
<p><code>Read View</code>遵循一个可见性算法，主要是将要<code>被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟<code>Read View</code>的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个<code>DB_TRX_ID</code>所在的旧记录就是当前事务能看见的最新老版本</p>
<h3 id="1-5-5MVCC工作整体流程"><a href="#1-5-5MVCC工作整体流程" class="headerlink" title="1.5.5MVCC工作整体流程"></a>1.5.5MVCC工作整体流程</h3><ul>
<li><p>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.01.png" style="zoom: 67%;">
</li>
<li><p><code>Read View</code>不仅仅会通过一个列表<code>trx_list</code>来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录<code>trx_list</code>列表中事务ID最小的ID），<code>low_limit_id</code>(记录<code>trx_list</code>列表中快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3。</p>
</li>
<li><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的<code>undo log</code>，如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和活跃事务ID列表(<code>trx_list</code>)进行比较，判断当前事务2能看到该记录的版本是哪个。</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.02.png" style="zoom: 67%;">
</li>
<li><p>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID 4去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看4是否小于<code>up_limit_id(1)</code>，所以不符合条件，继续判断 4 是否大于等于 <code>low_limit_id(5)</code>，也不符合条件，最后判断4是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p>
</li>
<li><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p>
</li>
</ul>
<h3 id="1-5-6MVCC相关问题"><a href="#1-5-6MVCC相关问题" class="headerlink" title="1.5.6MVCC相关问题"></a>1.5.6MVCC相关问题</h3><h4 id="1-5-6-1RR是如何在RC级的基础上解决不可重复读的？"><a href="#1-5-6-1RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="1.5.6.1RR是如何在RC级的基础上解决不可重复读的？"></a>1.5.6.1RR是如何在RC级的基础上解决不可重复读的？</h4><p><strong>当前读和快照读在RR级别下的区别：</strong></p>
<p><code>表1:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读(无影响)查询金额为500</td>
<td align="center">快照读查询金额为500</td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为500</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p>
<p><code>表2:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读（无影响）查询金额为500</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为400</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<h4 id="1-5-6-2RC-RR级别下的InnoDB快照读有什么不同？"><a href="#1-5-6-2RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="1.5.6.2RC,RR级别下的InnoDB快照读有什么不同？"></a>1.5.6.2RC,RR级别下的InnoDB快照读有什么不同？</h4><p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<code>Read View</code>, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个<code>Read View</code>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个<code>Read View</code>，所以对之后更新的修改不可见；</li>
<li>即RR级别下，快照读生成<code>Read View</code>时，<code>Read View</code>会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<code>Read View</code>创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因</li>
</ul>
<p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>
<h1 id="2-索引相关"><a href="#2-索引相关" class="headerlink" title="2.索引相关"></a>2.索引相关</h1><h2 id="2-1什么是索引"><a href="#2-1什么是索引" class="headerlink" title="2.1什么是索引"></a>2.1什么是索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h2 id="2-2索引的优缺点"><a href="#2-2索引的优缺点" class="headerlink" title="2.2索引的优缺点"></a>2.2索引的优缺点</h2><ul>
<li><p><strong>优点：</strong></p>
<p>**可以大大加快数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。 ** 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
</li>
<li><p><strong>缺点：</strong></p>
<p><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</p>
<p><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</p>
</li>
</ul>
<h2 id="2-3Hash索引和B-树索引的优劣分析"><a href="#2-3Hash索引和B-树索引的优劣分析" class="headerlink" title="2.3Hash索引和B+树索引的优劣分析"></a>2.3Hash索引和B+树索引的优劣分析</h2><p><strong>Hash索引定位快</strong></p>
<p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p>
<p><strong>Hash冲突问题</strong></p>
<p>知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。</strong></p>
<p>试想一种情况:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br></pre></td></tr></table></figure>

<p>B+树是有序的，在这种范围查询中，优势非常大，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。 </p>
<h2 id="2-4B树和B-树的区别"><a href="#2-4B树和B-树的区别" class="headerlink" title="2.4B树和B+树的区别"></a>2.4B树和B+树的区别</h2><ul>
<li>B树的所有节点既存放 键(key) 也存放 数据(data);而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\2.4.01.png" style="zoom:80%;">

<p><strong>B+树的优点：</strong></p>
<p>​    1、B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，IO次数更少。</p>
<p>​    2、B+树的查询必须最终找到叶子节点，而B树只需要找到匹配的元素即可。B+树性能稳定（但是查询速度并不慢）。</p>
<p>​    3、范围查询方便。B树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。</p>
<h2 id="2-5为什么相比于B树、红黑树而言，B-树更适合做索引"><a href="#2-5为什么相比于B树、红黑树而言，B-树更适合做索引" class="headerlink" title="2.5为什么相比于B树、红黑树而言，B+树更适合做索引"></a>2.5为什么相比于B树、红黑树而言，B+树更适合做索引</h2><h3 id="2-5-1红黑树的特性"><a href="#2-5-1红黑树的特性" class="headerlink" title="2.5.1红黑树的特性"></a>2.5.1红黑树的特性</h3><p>  （1）每个节点或者是黑色，或者是红色。</p>
<p>  （2）根节点是黑色。</p>
<p>  （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
<p>  （4）如果一个节点是红色的，则它的子节点必须是黑色的。（不能有两个连续的红色节点）</p>
<p>  （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。）</p>
<h3 id="2-5-2获取磁盘上数据的过程"><a href="#2-5-2获取磁盘上数据的过程" class="headerlink" title="2.5.2获取磁盘上数据的过程"></a>2.5.2获取磁盘上数据的过程</h3><p>要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的<strong>柱面</strong>，然后找到指定<strong>盘面</strong>，接着旋转盘面找到数据所在的<strong>磁道</strong>，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构尽量减少树的高度。</p>
<h3 id="2-5-3磁盘预读原理"><a href="#2-5-3磁盘预读原理" class="headerlink" title="2.5.3磁盘预读原理"></a>2.5.3磁盘预读原理</h3><p><strong>磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。这样做的理论依据是计算机科学中著名的局部性原理（该数据附近的数据有可能被经常读取）。</p>
<h3 id="2-5-4实际比较"><a href="#2-5-4实际比较" class="headerlink" title="2.5.4实际比较"></a>2.5.4实际比较</h3><p><strong>VAL树：</strong>普通的全表查询时间复杂度是O(n);如果是平衡二叉树，或者红黑树，查找时间变成O(log2N)，但他们依然不适合做索引。因为索引通常比较大，存于磁盘中，无法一次将全部的索引加载到内存中，每次只能从磁盘中读取一个页到内存中，而平衡二叉树底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，因此磁盘IO次数可能很大，平衡二叉树没能充分利用磁盘预读功能。</p>
<p><strong>红黑树：</strong>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比BTree差很多。</p>
<p><strong>B树：</strong>B树的每个节点可以存储多个关键字，<strong>它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。</strong>每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p>
<p><strong>B+树：</strong>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。</p>
<h2 id="2-6索引类型"><a href="#2-6索引类型" class="headerlink" title="2.6索引类型"></a>2.6索引类型</h2><h3 id="2-6-1主键索引-Primary-Key"><a href="#2-6-1主键索引-Primary-Key" class="headerlink" title="2.6.1主键索引(Primary Key)"></a>2.6.1主键索引(Primary Key)</h3><p><strong>数据表的主键列使用的就是主键索引。</strong> </p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p>
<p><strong>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</strong></p>
<h3 id="2-6-2二级索引-辅助索引"><a href="#2-6-2二级索引-辅助索引" class="headerlink" title="2.6.2二级索引(辅助索引)"></a>2.6.2二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>二级索引又包括：唯一索引，普通索引，前缀索引等索引。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 </li>
</ol>
<h2 id="2-6聚簇索引与非聚簇索引"><a href="#2-6聚簇索引与非聚簇索引" class="headerlink" title="2.6聚簇索引与非聚簇索引"></a>2.6聚簇索引与非聚簇索引</h2><h3 id="2-6-1聚集索引"><a href="#2-6-1聚集索引" class="headerlink" title="2.6.1聚集索引"></a>2.6.1聚集索引</h3><p><strong>1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>2.聚集索引的优点</strong></p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p><strong>3.聚集索引的缺点</strong></p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="2-6-2非聚集索引"><a href="#2-6-2非聚集索引" class="headerlink" title="2.6.2非聚集索引"></a>2.6.2非聚集索引</h3><p><strong>1.非聚集索引即索引结构和数据分开存放的索引。</strong> <strong>二级索引属于非聚集索引。</strong></p>
<p>MYISAM引擎的表的<code>.MYI</code>文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向<code>.MYD</code>文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
<p><strong>2.非聚集索引的优点</strong></p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p><strong>3.非聚集索引的缺点</strong></p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h2 id="2-7覆盖索引和回表查询"><a href="#2-7覆盖索引和回表查询" class="headerlink" title="2.7覆盖索引和回表查询"></a>2.7覆盖索引和回表查询</h2><h3 id="2-7-1非聚集索引一定回表查询吗"><a href="#2-7-1非聚集索引一定回表查询吗" class="headerlink" title="2.7.1非聚集索引一定回表查询吗?"></a>2.7.1非聚集索引一定回表查询吗?</h3><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT name FROM table WHERE username=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表，<br>因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h3 id="2-7-2覆盖索引"><a href="#2-7-2覆盖索引" class="headerlink" title="2.7.2覆盖索引"></a>2.7.2覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><strong>覆盖索引:</strong></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\2.7.01.png" style="zoom:80%;">

<h2 id="2-8创建索引的原则"><a href="#2-8创建索引的原则" class="headerlink" title="2.8创建索引的原则"></a>2.8创建索引的原则</h2><h3 id="2-8-1单列索引"><a href="#2-8-1单列索引" class="headerlink" title="2.8.1单列索引"></a>2.8.1单列索引</h3><p>单列索引即由一列属性组成的索引。</p>
<h3 id="2-8-2联合索引-多列索引"><a href="#2-8-2联合索引-多列索引" class="headerlink" title="2.8.2联合索引(多列索引)"></a>2.8.2联合索引(多列索引)</h3><p>联合索引即由多列属性组成索引。</p>
<h3 id="2-8-3最左前缀原则"><a href="#2-8-3最左前缀原则" class="headerlink" title="2.8.3最左前缀原则"></a>2.8.3最左前缀原则</h3><p>假设创建的联合索引由三个字段组成: </p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure>

<p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<h4 id="2-8-3-1深入理解最左匹配原则"><a href="#2-8-3-1深入理解最左匹配原则" class="headerlink" title="2.8.3.1深入理解最左匹配原则"></a>2.8.3.1深入理解最左匹配原则</h4><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">a <span class="built_in">int</span> ,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line">c <span class="built_in">int</span>,</span><br><span class="line">d <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">key</span> index_abc(a,b,c)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>插入1000条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> proc_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_initData()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i&lt;=10000 DO</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(a,b,c,d) <span class="keyword">VALUES</span>(i,i,i,i);</span><br><span class="line">    <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CALL</span> proc_initData();</span><br></pre></td></tr></table></figure>

<p>建立了联合索引（a，b，c）</p>
<p>验证：</p>
<ul>
<li><p>explain select * from test where a&lt;10 ;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>能不能将 a，b出现顺序换一下，a，b，c出现顺序换一下：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and a &lt;10;</p>
</li>
<li><p>explain select * from test where b&lt;10 and a &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>不是最左匹配原则吗？</p>
<p>查了下资料发现：mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。<strong>也就是说MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，不过建议 where 后的字段顺序和联合索引保持一致。</strong></p>
<p><strong>（重点）</strong>输入下面两条SQL语句：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and c &lt;10;、</p>
</li>
<li><p>explain select * from test where a&lt;10 and c &lt;10;</p>
</li>
</ul>
<p>为什么 b&lt;10 and c &lt;10,没有用到索引？而 a&lt;10 and c &lt;10用到了？</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h4 id="2-8-1-2联合索引中范围之后的索引将会失效"><a href="#2-8-1-2联合索引中范围之后的索引将会失效" class="headerlink" title="2.8.1.2联合索引中范围之后的索引将会失效"></a>2.8.1.2联合索引中范围之后的索引将会失效</h4><p>如：建立 姓名、年龄、性别的复合索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTest（</span><br><span class="line"></span><br><span class="line">        a <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        b <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        c <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">KEY</span> a（a,b,c）</span><br><span class="line"></span><br><span class="line">   ）；</span><br></pre></td></tr></table></figure>

<p><strong>索引的使用和失效情况：</strong></p>
<ul>
<li>select * from myTest  where a=3 and b=5 and c=4;   —-  abc顺序<br>abc三个索引都在where条件里面用到了，而且都发挥了作用</li>
<li>select * from myTest  where  c=4 and b=6 and a=3;<br>where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</li>
<li>select * from myTest  where a=3 and c=7;<br>a用到索引，b没有用，所以c是没有用到索引效果的</li>
<li>select * from myTest  where a=3 and b&gt;7 and c=3;     —- b范围值，断点，阻塞了c的索引<br>a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</li>
<li>select * from myTest  where b=3 and c=4;   — 联合索引必须按照顺序使用，并且需要全部使用<br>因为a索引没有使用，所以这里 bc都没有用上索引效果</li>
</ul>
<h2 id="2-9索引创建注意点"><a href="#2-9索引创建注意点" class="headerlink" title="2.9索引创建注意点"></a>2.9索引创建注意点</h2><p><strong>最左前缀原则</strong></p>
<p>但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</p>
<h3 id="2-9-1选择合适的字段"><a href="#2-9-1选择合适的字段" class="headerlink" title="2.9.1选择合适的字段"></a>2.9.1选择合适的字段</h3><p><strong>1.不为NULL的字段</strong></p>
<p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p>
<p><strong>2.被频繁查询的字段</strong></p>
<p>我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p><strong>3.被作为条件查询的字段</strong> </p>
<p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p>
<p><strong>4.被经常频繁用于连接的字段</strong></p>
<p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<h3 id="2-9-2不合适创建索引的字段"><a href="#2-9-2不合适创建索引的字段" class="headerlink" title="2.9.2不合适创建索引的字段"></a>2.9.2不合适创建索引的字段</h3><p><strong>1.被频繁更新的字段应该慎重建立索引</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。<br>如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>2.不被经常查询的字段没有必要建立索引</strong></p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong></p>
<p>冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3 id="2-9-3使用索引一定能提高查询性能吗"><a href="#2-9-3使用索引一定能提高查询性能吗" class="headerlink" title="2.9.3使用索引一定能提高查询性能吗?"></a>2.9.3使用索引一定能提高查询性能吗?</h3><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h1 id="3-MySQL中一条SQL语句的执行过程"><a href="#3-MySQL中一条SQL语句的执行过程" class="headerlink" title="3.MySQL中一条SQL语句的执行过程"></a>3.MySQL中一条SQL语句的执行过程</h1><h2 id="3-1MySQL-基础架构分析"><a href="#3-1MySQL-基础架构分析" class="headerlink" title="3.1MySQL 基础架构分析"></a>3.1MySQL 基础架构分析</h2><h3 id="3-1-1-MySQL-基本架构概览"><a href="#3-1-1-MySQL-基本架构概览" class="headerlink" title="3.1.1 MySQL 基本架构概览"></a>3.1.1 MySQL 基本架构概览</h3><p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存:</strong>  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong>  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>  按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\mysql执行.png" style="zoom:80%;">

<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="3-1-2-Server-层基本组件介绍"><a href="#3-1-2-Server-层基本组件介绍" class="headerlink" title="3.1.2 Server 层基本组件介绍"></a>3.1.2 Server 层基本组件介绍</h3><p><strong>1) 连接器</strong></p>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<p><strong>2) 查询缓存(MySQL 8.0 版本后移除)</strong></p>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<p><strong>3) 分析器</strong></p>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<p><strong>4) 优化器</strong> </p>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<p><strong>5) 执行器</strong></p>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="3-2语句分析"><a href="#3-2语句分析" class="headerlink" title="3.2语句分析"></a>3.2语句分析</h2><h3 id="3-2-1-查询语句"><a href="#3-2-1-查询语句" class="headerlink" title="3.2.1 查询语句"></a>3.2.1 查询语句</h3><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age=<span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>
<li>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>
<li>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="3-2-2-更新语句"><a href="#3-2-2-更新语句" class="headerlink" title="3.2.2 更新语句"></a>3.2.2 更新语句</h3><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age=<span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？<br>这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2 id="3-3总结"><a href="#3-3总结" class="headerlink" title="3.3总结"></a>3.3总结</h2><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）→查询缓存→分析器→优化器→权限校验→执行器→引擎</li>
<li>更新语句执行流程如下：分析器→权限校验→执行器→引擎—redo log(prepare 状态→binlog→redo log(commit状态)</li>
</ul>
<h1 id="4-数据库优化相关"><a href="#4-数据库优化相关" class="headerlink" title="4.数据库优化相关"></a>4.数据库优化相关</h1><h2 id="4-1MySQL的主从复制原理以及流程"><a href="#4-1MySQL的主从复制原理以及流程" class="headerlink" title="4.1MySQL的主从复制原理以及流程"></a>4.1MySQL的主从复制原理以及流程</h2><h4 id="4-1-1主从复制的概念及作用"><a href="#4-1-1主从复制的概念及作用" class="headerlink" title="4.1.1主从复制的概念及作用"></a>4.1.1主从复制的概念及作用</h4><p><strong>主从复制：</strong>将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<p><strong>主从复制的作用:</strong></p>
<ul>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ul>
<p><strong>MySQL主从复制解决的问题：</strong></p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h4 id="4-1-2MySQL主从复制工作原理"><a href="#4-1-2MySQL主从复制工作原理" class="headerlink" title="4.1.2MySQL主从复制工作原理"></a>4.1.2MySQL主从复制工作原理</h4><ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<p>基本原理流程，3个线程以及之间的关联</p>
<ul>
<li><p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>
</li>
<li><p>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>
</li>
<li><p>从：sql执行线程——执行relay log中的语句；</p>
</li>
</ul>
<h4 id="4-1-3主从复制流程"><a href="#4-1-3主从复制流程" class="headerlink" title="4.1.3主从复制流程"></a>4.1.3主从复制流程</h4><img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\4.1.01.png" style="zoom: 67%;">

<blockquote>
<p><strong>Binary log：</strong>主数据库的二进制日志</p>
<p><strong>Relay log：</strong>从服务器的中继日志</p>
</blockquote>
<ul>
<li><p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
</li>
<li><p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
</li>
<li><p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
</li>
</ul>
<h4 id="4-1-4读写分离有哪些解决方案？"><a href="#4-1-4读写分离有哪些解决方案？" class="headerlink" title="4.1.4读写分离有哪些解决方案？"></a>4.1.4读写分离有哪些解决方案？</h4><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读。</p>
<p><strong>方案一</strong></p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二（项目中使用的方法）</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库（slave）， 其余的有读有写的扔进写库（master）。</p>
<p><strong>方案三</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>
<h4 id="4-1-5主从复制数据不一致性问题及解决方法"><a href="#4-1-5主从复制数据不一致性问题及解决方法" class="headerlink" title="4.1.5主从复制数据不一致性问题及解决方法"></a>4.1.5主从复制数据不一致性问题及解决方法</h4><p>因为主从复制要求<code>slave</code>不能写只能读，如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>。</p>
<p><strong>问题：</strong>数据同步延迟很多，且希望重新做主从，使得主从在数据上保持完全同步。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>查看master的运行情况:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">File: mysql-bin.000014     //这个信息点要记住，下面用</span><br><span class="line">Position: 170017372        //这个信息点要记住，下面用</span><br></pre></td></tr></table></figure>
</li>
<li><p>先进入主库，进行锁表，防止数据写入</p>
</li>
<li><p>进行master数据备份（mysqldump）</p>
</li>
<li><p>打包数据(可选)</p>
</li>
<li><p>把mysql备份文件传到从库机器，进行数据恢复</p>
</li>
<li><p>更新/设置同步进度点</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[root@slave] <span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">&#x27;master.mysql.ipharmacare.org&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_port=<span class="number">3306</span>, master_password=<span class="string">&#x27;************&#x27;</span>, master_log_file=<span class="string">&#x27;mysql-bin.000014&#x27;</span>, master_log_pos=<span class="number">170017372</span>;//这里就用前面的，使从库与主库的进度点保持一致</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE：</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//(1)做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：</span><br><span class="line">[root@master] mysqldump –master-data –single-transaction –user=username –password=password dbname&gt; dumpfilename</span><br><span class="line">//这样就可以保留file和position的信息，在新搭建一个slave的时候，还原完数据库，file和position的信息也随之更新，接着再<span class="keyword">start</span> <span class="keyword">slave</span> 就可以很迅速的完成增量同步。</span><br><span class="line">//(<span class="number">2</span>) 忘记主从复制时,对从库用户密码时,可以这样去重置:</span><br><span class="line">[root@<span class="keyword">master</span>] <span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;slave.mysql.ipharmacare.org&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;slave&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-6异步模式、半同步模式和同步模式"><a href="#4-1-6异步模式、半同步模式和同步模式" class="headerlink" title="4.1.6异步模式、半同步模式和同步模式"></a>4.1.6异步模式、半同步模式和同步模式</h4><p>MySQL <strong>主从复制默认是异步的模式：</strong></p>
<p><strong>异步复制：</strong>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理；主节点不会主动push bin log到从节点；</p>
<p><strong>半同步模式：</strong>这种模式下<strong>主节点只需要接收到其中一台从节点的返回信息，就会commit</strong>；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。</p>
<p><strong>全同步模式</strong>：全同步模式是指<strong>主节点和从节点全部执行了commit并确认</strong>才会向客户端返回成功。</p>
<h1 id="5-常见的SQL语句"><a href="#5-常见的SQL语句" class="headerlink" title="5.常见的SQL语句"></a>5.常见的SQL语句</h1><h2 id="5-1基本查询关键字的使用（积累）"><a href="#5-1基本查询关键字的使用（积累）" class="headerlink" title="5.1基本查询关键字的使用（积累）"></a>5.1基本查询关键字的使用（积累）</h2><h2 id="5-2六种关联查询"><a href="#5-2六种关联查询" class="headerlink" title="5.2六种关联查询"></a>5.2六种关联查询</h2><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
</ul>
<p><strong>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录：</strong></p>
<p><code>R表</code></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p><code>S表</code></p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="5-2-1交叉连接（CROSS-JOIN）"><a href="#5-2-1交叉连接（CROSS-JOIN）" class="headerlink" title="5.2.1交叉连接（CROSS JOIN）"></a>5.2.1交叉连接（CROSS JOIN）</h3><p>交叉连接(笛卡尔积):</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r,s</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="5-2-2内连接（INNER-JOIN）"><a href="#5-2-2内连接（INNER-JOIN）" class="headerlink" title="5.2.2内连接（INNER JOIN）"></a>5.2.2内连接（INNER JOIN）</h3><ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>内连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">inner</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<h3 id="5-2-3连接（LEFT-JOIN-RIGHT-JOIN）"><a href="#5-2-3连接（LEFT-JOIN-RIGHT-JOIN）" class="headerlink" title="5.2.3连接（LEFT JOIN/RIGHT JOIN）"></a>5.2.3连接（LEFT JOIN/RIGHT JOIN）</h3><ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>左连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">left</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>右连接结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">right</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="5-2-4联合查询（UNION与UNION-ALL）"><a href="#5-2-4联合查询（UNION与UNION-ALL）" class="headerlink" title="5.2.4联合查询（UNION与UNION ALL）"></a>5.2.4联合查询（UNION与UNION ALL）</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，<code>UNION</code>前的结果为基准，需要注意的是<strong>联合查询的列数要相等</strong>，<strong>相同的记录行会合并</strong></li>
<li>如果使用<code>UNION ALL</code>，<strong>不会合并重复的记录行</strong></li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h3 id="5-2-5全连接（FULL-JOIN）"><a href="#5-2-5全连接（FULL-JOIN）" class="headerlink" title="5.2.5全连接（FULL JOIN）"></a>5.2.5全连接（FULL JOIN）</h3><ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<p>全表连接的结果（MySql不支持，Oracle支持）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">full</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h1 id="6-数据库的基础知识"><a href="#6-数据库的基础知识" class="headerlink" title="6.数据库的基础知识"></a>6.数据库的基础知识</h1><h2 id="6-1数据库三大范式是什么"><a href="#6-1数据库三大范式是什么" class="headerlink" title="6.1数据库三大范式是什么"></a>6.1数据库三大范式是什么</h2><ul>
<li>1NF：字段是原子性的，不可分;</li>
<li>2NF：有主键，非主键列完全依赖于主键，而不能是依赖于主键的一部分；</li>
<li>3NF：<strong>非主键字段不能相互依赖</strong>。 每列都与主键有<strong>直接关系</strong>，<strong>不存在传递的依赖。</strong></li>
</ul>
<p><strong>不符合第一范式的例子：</strong></p>
<p> <strong>表：</strong>字段1、 字段2、字段3 (字段3.1、字段3.2)……</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>年龄</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>19</td>
<td>湖北武汉市，电话：12345678</td>
</tr>
<tr>
<td>101</td>
<td>20</td>
<td>湖北</td>
</tr>
</tbody></table>
<p>这个表中主键重复，信息字段可以再分。</p>
<p><strong>不符合第二范式的例子:</strong></p>
<p><strong>表：</strong>学号、课程号、姓名、学分;</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程号</th>
<th>姓名</th>
<th>学分</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>003</td>
<td>小王</td>
<td>2</td>
</tr>
</tbody></table>
<p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖与学号。</p>
<p><strong>不符合第三范式的例子:</strong></p>
<p><strong>表：</strong>学号、姓名、 年龄、 所在学院、学院联系电话、学院联系电话</p>
<p>存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话)</p>
<h1 id="7-引擎"><a href="#7-引擎" class="headerlink" title="7.引擎"></a>7.引擎</h1><h2 id="7-1MyISAM索引与InnoDB索引的区别？"><a href="#7-1MyISAM索引与InnoDB索引的区别？" class="headerlink" title="7.1MyISAM索引与InnoDB索引的区别？"></a>7.1MyISAM索引与InnoDB索引的区别？</h2><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong></li>
</ul>
<h1 id="8-SQL优化"><a href="#8-SQL优化" class="headerlink" title="8.SQL优化"></a>8.SQL优化</h1><h2 id="8-1Explain语句"><a href="#8-1Explain语句" class="headerlink" title="8.1Explain语句"></a>8.1Explain语句</h2><p><strong>常见问题：</strong></p>
<ul>
<li>如何定位及优化SQL语句的性能问题？</li>
<li>创建的索引有没有被使用到?</li>
<li>或者说怎么才可以知道这条语句运行很慢的原因？</li>
</ul>
<h3 id="8-1-1Explain语句的作用"><a href="#8-1-1Explain语句的作用" class="headerlink" title="8.1.1Explain语句的作用"></a>8.1.1Explain语句的作用</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</strong></p>
<h3 id="8-1-2Explain语句的字段含义"><a href="#8-1-2Explain语句的字段含义" class="headerlink" title="8.1.2Explain语句的字段含义"></a>8.1.2Explain语句的字段含义</h3><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>id</strong> 由一组数字组成。表示一个查询中各个子查询的执行顺序：</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">不包含任何子查询或union等查询</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PRIMARY</td>
<td align="center">包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SUBQUERY</td>
<td align="center">在select或 where语句中包含的查询</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DERIVED</td>
<td align="center">from字句中包含的查询</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">UNION</td>
<td align="center">出现在union后的查询语句中</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">UNION RESULT</td>
<td align="center">从UNION中获取结果集</td>
</tr>
</tbody></table>
<p><strong>table</strong> 查询的数据表</p>
<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>key_len</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 含MySQL解决查询的<strong>详细信息</strong>，常见的有：</p>
<ul>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用where子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化</li>
<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>
</ul>
<h3 id="8-1-3实例分析"><a href="#8-1-3实例分析" class="headerlink" title="8.1.3实例分析"></a>8.1.3实例分析</h3><img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.05.png" style="zoom: 80%;">

<ul>
<li>执行顺序1：select_type为UNION，说明第四个select是UNION里的第二个select，最先执行【select name,id from t2】</li>
<li>执行顺序2：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为DERIVED【select id,name from t1 where other_column=’’】</li>
<li>执行顺序3：select列表中的子查询select_type为subquery,为整个查询中的第二个select【select id from t3】</li>
<li>执行顺序4：id列为1，表示是UNION里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<code>&lt;derived3&gt;</code>,表示查询结果来自一个衍生表，其中derived3中的3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name …】</li>
<li>执行顺序5：代表从UNION的临时表中读取行的阶段，table列的&lt; union1,4 &gt;表示用第一个和第四个select的结果进行UNION操作。【两个结果union操作】</li>
</ul>
<h2 id="8-2如何使用索引避免全表扫描"><a href="#8-2如何使用索引避免全表扫描" class="headerlink" title="8.2如何使用索引避免全表扫描"></a>8.2如何使用索引避免全表扫描</h2><ul>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引：</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h1 id="9-数据库优化"><a href="#9-数据库优化" class="headerlink" title="9.数据库优化"></a>9.数据库优化</h1><h2 id="9-1大表优化"><a href="#9-1大表优化" class="headerlink" title="9.1大表优化"></a>9.1大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ul>
<li><p><strong>垂直分区：</strong></p>
<p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指<strong>数据表列</strong>的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.01.png" style="zoom:67%;">

<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<p><strong>例：</strong>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.02.png" style="zoom:67%;">

<p><strong>适用场景:</strong></p>
<p>1、如果一个表中某些列常用，另外一些列不常用</p>
<p>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p>
<p><strong>缺点:</strong></p>
<p>1、有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p>
<p>2、对于应用层来说，逻辑算法增加开发成本</p>
<p>3、管理冗余列，查询所有数据需要join操作</p>
</li>
<li><p><strong>水平分区：</strong></p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.03.png" style="zoom:67%;">

<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储</strong>，<strong>应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<h4 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a>水平分表：</h4><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.04.png" style="zoom:80%;">

<p><strong>适用场景</strong></p>
<p>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。<br>2、需要把数据存放在多个介质上。</p>
<p><strong>水平切分的缺点</strong></p>
<p>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作<br>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业知识</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>设计</title>
    <url>/2021/03/28/%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<hr>
<!--nore-->

<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/lru-cache/">热题100-146. LRU 缓存机制</a></strong></p>
<p>实现页面置换算法中的最近最久未被使用算法（LRU）中的set和get方法</p>
</blockquote>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li>set和get方法的实现需要：</li>
<li>双端链表：存储插入的每一个节点，节点包括四个成员变量：key、value、preNode、nextNode（分别指向前后节点）；</li>
<li>HashMap：键值为节点的key值，值为节点；</li>
<li>两个哑结点：方便头部插入和尾部删除；</li>
<li>addTohead：将节点插入到双端链表的头部，set方法使用；</li>
<li>removeNode：移除一个节点；</li>
<li>removeToHead：当get方法查询一个节点时，先使用removeNode将该节点在双端链表中删除，再使用addToHead方法插入到头部；</li>
<li>removeTail：移除尾部节点；</li>
</ul>
<blockquote>
<p><strong>注意：</strong>当插入节点时，必须同时保存到HashMap中，当删除节点时，将该节点在HashMap中删除</p>
</blockquote>
<h2 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lru design</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operators int整型二维数组 the ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int整型 the k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedList pre;</span><br><span class="line">        DLinkedList next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=key;</span><br><span class="line">            <span class="keyword">this</span>.value=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        node.next.pre=node;</span><br><span class="line">        head.next=node;</span><br><span class="line">        node.pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DLinkedList <span class="title">removeToHead</span><span class="params">(DLinkedList node)</span></span>&#123;</span><br><span class="line">        DLinkedList temp=node;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedList node=tail.pre;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        hm.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node =<span class="keyword">new</span> DLinkedList(key,value);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            hm.put(key,node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(key))&#123;</span><br><span class="line">            DLinkedList node=hm.get(key);</span><br><span class="line">            <span class="keyword">return</span> removeToHead(node).value; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer,DLinkedList&gt; hm=<span class="keyword">new</span> HashMap&lt;Integer,DLinkedList&gt;();</span><br><span class="line">    DLinkedList head=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    DLinkedList tail=<span class="keyword">new</span> DLinkedList();</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LRU (<span class="keyword">int</span>[][] operators, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=k;</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span>[] nums:operators)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                 put(nums[<span class="number">1</span>],nums[<span class="number">2</span>]);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="number">2</span>)&#123;</span><br><span class="line">                 res.add(get(nums[<span class="number">1</span>]));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">            ans[i]=(<span class="keyword">int</span>)res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>广度优先遍历</title>
    <url>/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><p><strong>广度优先遍历（BFS）：</strong>如果说深度优先遍历类似于树的前序遍历，那么广度优先遍历就类似于层序遍历，从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问结点，访问完一层就进入下一层，直到没有结点可以访问为止。　</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>后序补</p>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">热题100-102. 二叉树的层序遍历</a></strong></p>
<p>给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>创建双端队列</li>
<li>如果根节点不为null，将根节点加入到队列中</li>
<li>为了实现分层打印，在while循环中，每次得到队列的长度也就是该层的节点数，通过for循环将本层的节点打印，每次打印将该节点的左右子树加入到队列中，但是由于长度限制，新加入的节点在本次不会被打印</li>
</ul>
<h3 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        dq.addLast(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode node=dq.pollFirst();</span><br><span class="line">                temp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    dq.addLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><blockquote>
<p><strong><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指 Offer-32 - III. 从上到下打印二叉树 III</a></strong></p>
<p>之字形打印二叉树</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>当二叉树的根节点1打印之后，将它的左子节点和右子节点先后保存到一个容器中，当打印二层的节点时，先打印节点3再打印节点2，看起来节点在该容器中是先进后出的，因此可以考虑这个容器用栈来实现。</li>
<li>因为是Z形遍历，所以子节点放入容器的顺序是不同的，对于奇数层，打印顺序是left→right，因为是先进后出所以存储顺序是right→left，偶数层同理。</li>
<li>两个栈可以合并成一个队列，大大节省空间，把队列想象成两个栈底对底拼接在一起，左端存取元素用addFirst（）和pollFirst（），右端存取元素用addLast（）和pollLast（）。</li>
<li>奇偶层用res的元素个数来判断。</li>
</ul>
<h3 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; zigzagLevelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; dq=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) dq.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!dq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size=dq.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; temp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollFirst();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addLast(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    TreeNode node=dq.pollLast();</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                    <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        dq.addFirst(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>基础算法篇</tag>
      </tags>
  </entry>
</search>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="数据库系统原理">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片02.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片03.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片04.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片06.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片07.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片08.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/1.5.5.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片05.png">
<meta property="article:published_time" content="2021-06-27T03:07:08.000Z">
<meta property="article:modified_time" content="2021-08-08T07:50:47.145Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="数据库系统原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片01.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库系统原理 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库系统原理
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-27 11:07:08" itemprop="dateCreated datePublished" datetime="2021-06-27T11:07:08+08:00">2021-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-08 15:50:47" itemprop="dateModified" datetime="2021-08-08T15:50:47+08:00">2021-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">数据库相关</span></a>
                </span>
            </span>

          
            <span id="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="数据库系统原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-数据库基础知识"><a href="#1-数据库基础知识" class="headerlink" title="1.数据库基础知识"></a>1.数据库基础知识</h1><h2 id="1-1什么是SQL？"><a href="#1-1什么是SQL？" class="headerlink" title="1.1什么是SQL？"></a>1.1什么是SQL？</h2><p>结构化查询语言（Structure Query Language）简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取、查询、更新和管理关系型数据库</p>
<h2 id="1-2关系型数据库与非关系型数据库"><a href="#1-2关系型数据库与非关系型数据库" class="headerlink" title="1.2关系型数据库与非关系型数据库"></a>1.2关系型数据库与非关系型数据库</h2><p><strong>关系型数据库：</strong>由数据库中的二维表及其之间的联系组成的一个数据库组织</p>
<p><strong>常见：</strong>MySQL、SQL Server、Oracle</p>
<p><strong>优点：</strong></p>
<ol>
<li>易于维护：都是表结构，格式统一</li>
<li>使用方便：SQL语言通用</li>
<li>支持复杂查询：可以使用SQL语句用于一个表以及多个表之间的查询</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>当操作海量数据时，读写性能比较差</li>
<li>表结构固定，灵活度稍差</li>
<li>对于高并发读写需求，硬盘I/O是一个很大的瓶颈</li>
</ol>
<p><strong>非关系型数据库：</strong>非关系型数据库是一种数据结构化存储方法的集合，可以是文档或者键值对</p>
<p><strong>常见：</strong>Redis</p>
<p><strong>优点：</strong></p>
<ol>
<li>格式灵活，可以是键值对的形式、文档形式、图片形式等等，而关系型数据库只支持基本的数据类型</li>
<li>速度快</li>
<li>高扩展性</li>
<li>成本低</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不提供SQL支持，学习和使用成本较高</li>
<li>无事务处理</li>
<li>数据结构相对复杂</li>
<li>复杂查询方面欠缺</li>
</ol>
<h2 id="1-3数据库三大范式是什么"><a href="#1-3数据库三大范式是什么" class="headerlink" title="1.3数据库三大范式是什么"></a>1.3数据库三大范式是什么</h2><ul>
<li><p>1NF：有主键，字段是原子性的，不可分；（保证字段的原子性）</p>
</li>
<li><p>2NF：有主键，非主键列完全依赖于主键，而不能是依赖于主键的一部分；（保证一张表只能描述一件事）</p>
<p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主键。</p>
</li>
<li><p>3NF：<strong>非主键字段不能相互依赖</strong>。 每列都与主键有<strong>直接关系</strong>，<strong>不存在传递的依赖。</strong></p>
<p>数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p>
</li>
</ul>
<p><strong>不符合第一范式的例子：</strong></p>
<p> <strong>表：</strong>字段1、 字段2、字段3 (字段3.1、字段3.2)……</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>湖北武汉市，12345678</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>山东滨州市，1234567</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>河北沧州市，123456</td>
</tr>
</tbody></table>
<p>这个表中主键重复，信息字段可以再分。</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>家庭住址</th>
<th>联系电话</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>湖北武汉市</td>
<td>12345678</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>山东滨州市</td>
<td>1234567</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>河北沧州市</td>
<td>123456</td>
</tr>
</tbody></table>
<p><strong>不符合第二范式的例子：</strong></p>
<p><strong>表：</strong></p>
<table>
<thead>
<tr>
<th>学号</th>
<th>教师编号</th>
<th>学生姓名</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>001</td>
<td>张三</td>
<td>王老师</td>
</tr>
<tr>
<td>1002</td>
<td>002</td>
<td>李四</td>
<td>张老师</td>
</tr>
<tr>
<td>1003</td>
<td>001</td>
<td>王五</td>
<td>王老师</td>
</tr>
<tr>
<td>1001</td>
<td>002</td>
<td>张三</td>
<td>张老师</td>
</tr>
</tbody></table>
<p>在这张表中，学生编号+教师编号做联合主键，复合主键（学生编号+教师编号）。</p>
<p>但是学生依赖于学生编号，教师依赖于教师编号，所以产生了部分依赖。这样张三、王老师等都重复了，也就是产生了数据冗余。可以通过分表的方式来表示多对多的关系。</p>
<p><strong>学生表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
</tr>
</tbody></table>
<p><strong>教师表：</strong></p>
<table>
<thead>
<tr>
<th>教师编号（pk）</th>
<th>教师姓名</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>王老师</td>
</tr>
<tr>
<td>002</td>
<td>张老师</td>
</tr>
</tbody></table>
<p><strong>学生教师关系表：</strong></p>
<table>
<thead>
<tr>
<th>id（pk）</th>
<th>学号（fk）</th>
<th>教师编号（fk）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1001</td>
<td>001</td>
</tr>
<tr>
<td>2</td>
<td>1002</td>
<td>002</td>
</tr>
<tr>
<td>3</td>
<td>1003</td>
<td>001</td>
</tr>
<tr>
<td>4</td>
<td>1001</td>
<td>002</td>
</tr>
</tbody></table>
<p><strong>不符合第三范式的例子:</strong></p>
<p><strong>表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
<th>班级编号</th>
<th>班级名称</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
<td>一年三班</td>
</tr>
<tr>
<td>1004</td>
<td>张三</td>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody></table>
<p>存在依赖传递: (班级名称) → (班级编号) → (学号)，产生了数据的冗余，即重复的一年三班，存在一对多的关系，仍然通过拆分表来解决。</p>
<p><strong>学生表：</strong></p>
<table>
<thead>
<tr>
<th>学号（pk）</th>
<th>学生姓名</th>
<th>班级编号（fk）</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>张三</td>
<td>01</td>
</tr>
<tr>
<td>1002</td>
<td>李四</td>
<td>02</td>
</tr>
<tr>
<td>1003</td>
<td>王五</td>
<td>03</td>
</tr>
<tr>
<td>1004</td>
<td>张三</td>
<td>03</td>
</tr>
</tbody></table>
<p><strong>班级表：</strong></p>
<table>
<thead>
<tr>
<th>班级编号（pk）</th>
<th>班级名称</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>一年一班</td>
</tr>
<tr>
<td>02</td>
<td>一年二班</td>
</tr>
<tr>
<td>03</td>
<td>一年三班</td>
</tr>
</tbody></table>
<p><strong>总结：多对多、一对多应该如何设计表</strong></p>
<p>多对多：三张表，关系表两个外键</p>
<p>一对多：两张表，多的表加外键</p>
<h1 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h1><h2 id="2-1概念"><a href="#2-1概念" class="headerlink" title="2.1概念"></a>2.1概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片01.png" alt="img" style="zoom:80%;">

<h2 id="2-2四大特性（ACID）"><a href="#2-2四大特性（ACID）" class="headerlink" title="2.2四大特性（ACID）"></a>2.2四大特性（ACID）</h2><p><strong>1. 原子性（Atomicity）</strong></p>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<ul>
<li>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
</ul>
<p><strong>2. 一致性（Consistency）</strong></p>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<blockquote>
<p>我们在理解数据库时，要把数据库想象成现实生活中的映射，如果数据库中的数据全都符合现实生活中的约束，那么这些数据就是一致的，或者说符合一致性的。</p>
</blockquote>
<p><strong>3. 隔离性（Isolation）</strong></p>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<p><strong>4. 持久性（Durability）</strong></p>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<ul>
<li>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</li>
</ul>
<p><strong>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</strong></p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片02.png" alt="img" style="zoom:80%;">

<h2 id="2-3-AUTOCOMMIT"><a href="#2-3-AUTOCOMMIT" class="headerlink" title="2.3 AUTOCOMMIT"></a>2.3 AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h1 id="3-并发一致性问题"><a href="#3-并发一致性问题" class="headerlink" title="3.并发一致性问题"></a>3.并发一致性问题</h1><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h2 id="1-丢失修改"><a href="#1-丢失修改" class="headerlink" title="1.丢失修改"></a>1.丢失修改</h2><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<h2 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2.脏读"></a>2.脏读</h2><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<h2 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3.不可重复读"></a>3.不可重复读</h2><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<h2 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4.幻读"></a>4.幻读</h2><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<h2 id="5-原因分析"><a href="#5-原因分析" class="headerlink" title="5.原因分析"></a>5.原因分析</h2><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是<strong>封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</strong></p>
<h1 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4.隔离级别"></a>4.隔离级别</h1><p>隔离级别的存在也是为了解决隔离性的问题</p>
<h2 id="1-读取未提交"><a href="#1-读取未提交" class="headerlink" title="1.读取未提交"></a>1.读取未提交</h2><p> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<h2 id="2-读取已提交"><a href="#2-读取已提交" class="headerlink" title="2.读取已提交"></a>2.读取已提交</h2><p>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
<h2 id="3-可重复读"><a href="#3-可重复读" class="headerlink" title="3.可重复读"></a>3.可重复读</h2><p>对同一字段的多次读取结果都是一致的，除非数据是被事务本身所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<h2 id="4-可串行化"><a href="#4-可串行化" class="headerlink" title="4.可串行化"></a>4.可串行化</h2><p>最高的隔离级别，所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<h1 id="5-锁机制"><a href="#5-锁机制" class="headerlink" title="5.锁机制"></a>5.锁机制</h1><h2 id="5-1锁的粒度"><a href="#5-1锁的粒度" class="headerlink" title="5.1锁的粒度"></a>5.1锁的粒度</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁、表级锁和页级锁。</p>
<p><strong>行级锁：</strong> 行级锁是 Mysql 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁：</strong> 表级锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁：</strong> 页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h2 id="5-2锁的类型"><a href="#5-2锁的类型" class="headerlink" title="5.2锁的类型"></a>5.2锁的类型</h2><p><strong>1.读写锁</strong></p>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新，即执行 INSERT、UPDATE 或 DELETE 命令时。<strong>加锁期间其它事务不能对 A 加任何锁</strong>。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行 select 读取操作，但是不能进行更新操作。<strong>加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</strong>。</li>
</ul>
<p>锁的兼容关系如下：</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片03.png" alt="img" style="zoom:80%;">

<p><strong>2.意向锁</strong></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片04.png" alt="img" style="zoom:80%;">



<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h2 id="5-3锁协议"><a href="#5-3锁协议" class="headerlink" title="5.3锁协议"></a>5.3锁协议</h2><h3 id="1-三级封锁协议"><a href="#1-三级封锁协议" class="headerlink" title="1. 三级封锁协议"></a>1. 三级封锁协议</h3><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片06.png" alt="img" style="zoom:50%;">



<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片07.png" alt="img" style="zoom:50%;">



<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片08.png" alt="img" style="zoom:50%;">

<h3 id="2-两段锁协议"><a href="#2-两段锁协议" class="headerlink" title="2. 两段锁协议"></a>2. 两段锁协议</h3><p><strong>两段锁协议：</strong> 是指所有的事务必须分两个阶段对数据项加锁和解锁。即<code>事务分两个阶段</code>，第一个阶段是<code>获得封锁</code>。事务可以获得任何数据项上的任何类型的锁，但是不能释放；第二阶段是<code>释放封锁</code>，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p>
<p>第一阶段是获得封锁的阶段，称为<code>扩展阶段</code>：其实也就是该阶段可以进入加锁操作，<code>在对任何数据进行读操作之前要申请获得S锁</code>，<code>在进行写操作之前要申请并获得X锁</code>，<code>加锁不成功，则事务进入等待状态</code>，直到加锁成功才继续执行。就是<code>加锁后就不能解锁</code>了。</p>
<p>第二阶段是释放封锁的阶段，称为<code>收缩阶段</code>：当事务释放一个封锁后，事务进入封锁阶段，在该阶段<code>只能进行解锁而不能再进行加锁操作</code>。</p>
<p><strong>加锁时机</strong></p>
<p>当对记录进行更新操作或者select for update(X锁)、lock in share mode(S锁)时，会对记录进行加锁。</p>
<p><strong>解锁时机</strong></p>
<p>commit或者rollback时。</p>
<p><strong>例：</strong></p>
<p>T1 事务：满足两段锁协议</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>T2 事务：不满足两段锁协议</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如 T1 事务满足两段锁协议，它是可串行化调度。但是 T2 事务不满足，还可以是可串行化调度。</p>
<blockquote>
<p><strong>可串行化调度：</strong>是指通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
</blockquote>
<h3 id="3-MySQL-隐式与显式锁定"><a href="#3-MySQL-隐式与显式锁定" class="headerlink" title="3. MySQL 隐式与显式锁定"></a>3. MySQL 隐式与显式锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">In</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-InnoDB-存储引擎的锁的算法"><a href="#6-InnoDB-存储引擎的锁的算法" class="headerlink" title="6. InnoDB 存储引擎的锁的算法"></a>6. InnoDB 存储引擎的锁的算法</h1><h2 id="1-Record-Locks"><a href="#1-Record-Locks" class="headerlink" title="1. Record Locks"></a>1. Record Locks</h2><p>锁直接加在索引记录上面，锁住的是key。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="2-Gap-Locks"><a href="#2-Gap-Locks" class="headerlink" title="2. Gap Locks"></a>2. Gap Locks</h2><p>在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。Gap 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<h2 id="3-Next-Key-Lock"><a href="#3-Next-Key-Lock" class="headerlink" title="3. Next-Key Lock"></a>3. Next-Key Lock</h2><p>Next-Key Lock 是行锁和间隙锁的组合，锁定索引记录两边的间隙，并锁定记录本身，对于行的查询都是采用该方法，主要是解决幻读的问题。</p>
<p><strong>间隙锁的缺点：</strong></p>
<p>间隙锁有一个缺点就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入键值锁定范围内的任何数据，在某些场景下可能会对并发性能造成较大的危害。</p>
<h1 id="7-多版本并发控制"><a href="#7-多版本并发控制" class="headerlink" title="7.多版本并发控制"></a>7.多版本并发控制</h1><h2 id="7-1什么是-MVCC"><a href="#7-1什么是-MVCC" class="headerlink" title="7.1什么是 MVCC"></a>7.1什么是 MVCC</h2><p><strong>MVCC</strong> 全称<code>Multi-Version Concurrency Control</code>，即<strong>多版本并发控制。</strong>MVCC 在 MySQL 中的实现主要是为了<strong>提高数据库并发性能</strong>，用<strong>更好的去处理读-写冲突</strong>。</p>
<p>它是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现<strong>读取已提交</strong>和<strong>可重复读</strong>这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h2 id="7-2当前读和快照读"><a href="#7-2当前读和快照读" class="headerlink" title="7.2当前读和快照读"></a>7.2当前读和快照读</h2><p>在学习 MVCC 多版本并发控制之前，我们必须先了解一下，什么是 MySQL InnoDB 下的当前读和快照读?</p>
<ul>
<li><strong>当前读</strong><br>像 select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁) 这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li><strong>快照读</strong><br>像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读（一个事务读的肯定是最新版本）；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC，可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>
</ul>
<p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p>
<p><strong>当前读，快照读和MVCC的关系：</strong></p>
<ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念，仅仅是一个理想概念。</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。</li>
</ul>
<h2 id="7-3-MVCC-能解决什么问题"><a href="#7-3-MVCC-能解决什么问题" class="headerlink" title="7.3 MVCC 能解决什么问题"></a>7.3 MVCC 能解决什么问题</h2><p><strong>数据库并发场景有三种，分别为：</strong></p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题</li>
</ul>
<p><strong>MVCC带来的好处是？</strong><br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>总结MVCC的作用：</strong><br>MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h2 id="7-4-MVCC-的实现原理"><a href="#7-4-MVCC-的实现原理" class="headerlink" title="7.4 MVCC 的实现原理"></a>7.4 MVCC 的实现原理</h2><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖<strong>数据库记录</strong>中的 <strong><code>3个隐式字段</code>**，</strong><code>undo日志</code>** ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念：</p>
<p><strong>隐式字段：</strong>  <strong>数据库表中</strong>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li><strong>DB_TRX_ID</strong><br>最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong><br>回滚指针，用于配合undo日志，指向上一个旧版本（存储于rollback segment里）</li>
<li><strong>DB_ROW_ID</strong><br>隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><strong>undo日志：</strong>undo log主要分为两种</p>
<ul>
<li><strong>insert undo log</strong><br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li><strong>update undo log（最重要）</strong><br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
<p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p>
<p><strong>Read View(读视图)</strong></p>
<p><code>Read View</code>就是事务进行<code>快照读</code>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)**</p>
<p>所以我们知道 <code>Read View</code>主要是<strong>用来做可见性判断</strong>的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p>
<p><code>Read View</code>遵循一个可见性算法，主要是将要<code>被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟<code>Read View</code>的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个<code>DB_TRX_ID</code>所在的旧记录就是当前事务能看见的最新老版本</p>
<p><strong>读视图中的字段，小的那个记录的是活跃的事务中的最小ID，还有一个记录系统分配的最新事务ID，也就是这个范围内的事务要么是活跃的，要么是结束的，结束的可以看因为是在该事务执行快照读之前提交的，还有有数据库隐式字段记录的事务ID在最小值之前，也就是与执行该快照读的事务没有交集，当前事务也能够读到，但是当隐式字段的ID是最新分配的就读不到了</strong></p>
<h2 id="7-5-MVCC-工作整体流程"><a href="#7-5-MVCC-工作整体流程" class="headerlink" title="7.5 MVCC 工作整体流程"></a>7.5 MVCC 工作整体流程</h2><ul>
<li><p>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.01.png" style="zoom: 67%;">
</li>
<li><p><code>Read View</code>不仅仅会通过一个列表<code>trx_list</code>来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录<code>trx_list</code>列表中事务ID最小的ID），<code>low_limit_id</code>(记录<code>trx_list</code>列表中快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3。</p>
</li>
<li><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的<code>undo log</code>，如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和活跃事务ID列表(<code>trx_list</code>)进行比较，判断当前事务2能看到该记录的版本是哪个。</p>
<img src="/2021/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片05.png" style="zoom: 67%;">
</li>
<li><p>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID 4去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看4是否小于<code>up_limit_id(1)</code>，所以不符合条件，继续判断 4 是否大于等于 <code>low_limit_id(5)</code>，也不符合条件，最后判断4是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p>
<p><strong>总结：</strong>这个事务是活跃的不能看，执行快照之后分配的事务ID不能看，只有在执行快照之前提交完成 的事务数据能看</p>
</li>
<li><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p>
</li>
</ul>
<h2 id="7-6-MVCC-相关问题"><a href="#7-6-MVCC-相关问题" class="headerlink" title="7.6 MVCC 相关问题"></a>7.6 MVCC 相关问题</h2><p><strong>1. RR 是如何在 RC 级的基础上解决不可重复读的？</strong></p>
<p><strong>当前读和快照读在RR级别下的区别：</strong></p>
<p><code>表1:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读(无影响)查询金额为500</td>
<td align="center">快照读查询金额为500</td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为500</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p>
<p><code>表2:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读（无影响）查询金额为500</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为400</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<p><strong>2. RC，RR 级别下的 InnoDB 快照读有什么不同？</strong></p>
<p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<code>Read View</code>, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个<code>Read View</code>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个<code>Read View</code>，所以对之后更新的修改不可见；</li>
<li>即RR级别下，快照读生成<code>Read View</code>时，<code>Read View</code>会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<code>Read View</code>创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因（不可重复读）</li>
</ul>
<p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" rel="tag"><i class="fa fa-tag"></i>  数据库系统原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/21/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="prev" title="JVM运行时数据区">
      <i class="fa fa-chevron-left"></i> JVM运行时数据区
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/30/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="next" title="Redis分布式锁">
      Redis分布式锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">1.数据库基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AFSQL%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1什么是SQL？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.2.</span> <span class="nav-text">1.2关系型数据库与非关系型数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.</span> <span class="nav-text">1.3数据库三大范式是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.</span> <span class="nav-text">2.事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2.2四大特性（ACID）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-AUTOCOMMIT"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 AUTOCOMMIT</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">3.并发一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="nav-number">3.1.</span> <span class="nav-text">1.丢失修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%84%8F%E8%AF%BB"><span class="nav-number">3.2.</span> <span class="nav-text">2.脏读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">3.3.</span> <span class="nav-text">3.不可重复读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B9%BB%E8%AF%BB"><span class="nav-number">3.4.</span> <span class="nav-text">4.幻读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-number">3.5.</span> <span class="nav-text">5.原因分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.</span> <span class="nav-text">4.隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%BB%E5%8F%96%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="nav-number">4.1.</span> <span class="nav-text">1.读取未提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%AF%BB%E5%8F%96%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">4.2.</span> <span class="nav-text">2.读取已提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">4.3.</span> <span class="nav-text">3.可重复读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">4.4.</span> <span class="nav-text">4.可串行化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">5.锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">5.1.</span> <span class="nav-text">5.1锁的粒度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">5.2锁的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.3.</span> <span class="nav-text">5.3锁协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.3.1.</span> <span class="nav-text">1. 三级封锁协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.3.2.</span> <span class="nav-text">2. 两段锁协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-MySQL-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E5%BC%8F%E9%94%81%E5%AE%9A"><span class="nav-number">5.3.3.</span> <span class="nav-text">3. MySQL 隐式与显式锁定</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6. InnoDB 存储引擎的锁的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Record-Locks"><span class="nav-number">6.1.</span> <span class="nav-text">1. Record Locks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Gap-Locks"><span class="nav-number">6.2.</span> <span class="nav-text">2. Gap Locks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Next-Key-Lock"><span class="nav-number">6.3.</span> <span class="nav-text">3. Next-Key Lock</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">7.多版本并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E4%BB%80%E4%B9%88%E6%98%AF-MVCC"><span class="nav-number">7.1.</span> <span class="nav-text">7.1什么是 MVCC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">7.2.</span> <span class="nav-text">7.2当前读和快照读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-MVCC-%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 MVCC 能解决什么问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-MVCC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 MVCC 的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-MVCC-%E5%B7%A5%E4%BD%9C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">7.5.</span> <span class="nav-text">7.5 MVCC 工作整体流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-MVCC-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">7.6.</span> <span class="nav-text">7.6 MVCC 相关问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">912k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:49</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

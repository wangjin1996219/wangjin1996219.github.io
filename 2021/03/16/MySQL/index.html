<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/03/16/MySQL/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/2.4.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/2.7.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/1.5.5.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/1.5.5.02.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/mysql执行.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/4.1.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/9.1.05.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/9.1.01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/9.1.02.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/9.1.03.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/9.1.04.png">
<meta property="article:published_time" content="2021-03-16T09:05:58.000Z">
<meta property="article:modified_time" content="2021-04-09T14:46:07.999Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/03/16/MySQL/GitHub/MyBlogs/source/_posts/2021-03-16-MySQL/2.4.01.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/03/16/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">52</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/03/16/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-16 17:05:58" itemprop="dateCreated datePublished" datetime="2021-03-16T17:05:58+08:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-09 22:46:07" itemprop="dateModified" datetime="2021-04-09T22:46:07+08:00">2021-04-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/03/16/MySQL/" class="post-meta-item leancloud_visitors" data-flag-title="MySQL" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/16/MySQL/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/16/MySQL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-数据库基础知识"><a href="#1-数据库基础知识" class="headerlink" title="1.数据库基础知识"></a>1.数据库基础知识</h1><h2 id="1-1什么是SQL？"><a href="#1-1什么是SQL？" class="headerlink" title="1.1什么是SQL？"></a>1.1什么是SQL？</h2><p>结构化查询语言（Structure Query Language）简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取、查询、更新和管理关系型数据库</p>
<h2 id="1-2关系型数据库与非关系型数据库"><a href="#1-2关系型数据库与非关系型数据库" class="headerlink" title="1.2关系型数据库与非关系型数据库"></a>1.2关系型数据库与非关系型数据库</h2><p><strong>关系型数据库：</strong>由数据库中的二维表及其之间的联系组成的一个数据库组织</p>
<p><strong>常见：</strong>MySQL、SQL Server、Oracle</p>
<p><strong>优点：</strong></p>
<ol>
<li>易于维护：都是表结构，格式统一</li>
<li>使用方便：SQL语言通用</li>
<li>支持复杂查询：可以使用SQL语句用于一个表以及多个表之间</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>当操作海量数据时，读写性能比较差</li>
<li>表结构固定，灵活度稍差</li>
<li>对于高并发读写需求，硬盘I/O是一个很大的瓶颈</li>
</ol>
<p><strong>非关系型数据库：</strong>非关系型数据库是一种数据结构化存储方法的集合，可以是文档或者键值对</p>
<p><strong>常见：</strong>Redis</p>
<p><strong>优点：</strong></p>
<ol>
<li>格式灵活，可以是键值对的形式、文档形式、图片形式等等，而关系型数据库只支持基本的数据类型</li>
<li>速度快</li>
<li>高扩展性</li>
<li>成本低</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>不提供SQL支持，学习和使用成本较高</li>
<li>无事务处理</li>
<li>数据结构相对复杂</li>
<li>复杂查询方面欠缺</li>
</ol>
<h2 id="1-3数据库三大范式是什么"><a href="#1-3数据库三大范式是什么" class="headerlink" title="1.3数据库三大范式是什么"></a>1.3数据库三大范式是什么</h2><ul>
<li>1NF：字段是原子性的，不可分;</li>
<li>2NF：有主键，非主键列完全依赖于主键，而不能是依赖于主键的一部分；</li>
<li>3NF：<strong>非主键字段不能相互依赖</strong>。 每列都与主键有<strong>直接关系</strong>，<strong>不存在传递的依赖。</strong></li>
</ul>
<p><strong>不符合第一范式的例子：</strong></p>
<p> <strong>表：</strong>字段1、 字段2、字段3 (字段3.1、字段3.2)……</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>年龄</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>19</td>
<td>湖北武汉市，电话：12345678</td>
</tr>
<tr>
<td>101</td>
<td>20</td>
<td>湖北</td>
</tr>
</tbody></table>
<p>这个表中主键重复，信息字段可以再分。</p>
<p><strong>不符合第二范式的例子:</strong></p>
<p><strong>表：</strong>学号、课程号、姓名、学分;</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程号</th>
<th>姓名</th>
<th>学分</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>003</td>
<td>小王</td>
<td>2</td>
</tr>
</tbody></table>
<p>这个表明显说明了两个事务:学生信息, 课程信息;由于非主键字段必须依赖主键，这里学分依赖课程号，姓名依赖与学号。</p>
<p><strong>不符合第三范式的例子:</strong></p>
<p><strong>表：</strong>学号、姓名、 年龄、 所在学院、学院联系电话、学院联系电话</p>
<p>存在依赖传递: (学号) → (所在学院) → (学院地点, 学院电话)</p>
<h1 id="2-引擎"><a href="#2-引擎" class="headerlink" title="2.引擎"></a>2.引擎</h1><h2 id="2-1MySQL存储引擎MyISAM与InnoDB区别"><a href="#2-1MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="2.1MySQL存储引擎MyISAM与InnoDB区别"></a>2.1MySQL存储引擎MyISAM与InnoDB区别</h2><ul>
<li><strong>MyISAM引擎：</strong>不提供事务的支持，也不支持行级锁和外键</li>
<li><strong>InnoDB引擎：</strong>提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的支持。 InnoDB 支持MVCC，应对高并发事务, MVCC比单纯的加锁更高效。</li>
</ul>
<h2 id="2-2MyISAM索引与InnoDB索引的区别？"><a href="#2-2MyISAM索引与InnoDB索引的区别？" class="headerlink" title="2.2MyISAM索引与InnoDB索引的区别？"></a>2.2MyISAM索引与InnoDB索引的区别？</h2><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<ul>
<li><strong>MyISAM:</strong> B+Tree叶节点的<strong>data域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后<strong>以 data 域的值为地址读取相应的数据记录</strong>。这被称为<strong>“非聚簇索引”</strong>。</li>
<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，其表数据文件本身就是按B+Tree组织的一个索引结构，树的<strong>叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong></li>
</ul>
<h2 id="2-3存储引擎的应用"><a href="#2-3存储引擎的应用" class="headerlink" title="2.3存储引擎的应用"></a>2.3存储引擎的应用</h2><ul>
<li>MyISAM：以读为主的应用程序，比如博客系统、新闻门户网站。</li>
<li>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</li>
</ul>
<h1 id="3-索引相关"><a href="#3-索引相关" class="headerlink" title="3.索引相关"></a>3.索引相关</h1><h2 id="3-1什么是索引"><a href="#3-1什么是索引" class="headerlink" title="3.1什么是索引"></a>3.1什么是索引</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B树， B+树和Hash。</strong></p>
<p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h2 id="3-2索引的优缺点"><a href="#3-2索引的优缺点" class="headerlink" title="3.2索引的优缺点"></a>3.2索引的优缺点</h2><ul>
<li><p><strong>优点：</strong></p>
<p>**可以大大加快数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。毕竟大部分系统的读请求总是大于写请求的。 ** 另外，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
</li>
<li><p><strong>缺点：</strong></p>
<p><strong>创建索引和维护索引需要耗费许多时间</strong>：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</p>
<p><strong>占用物理存储空间</strong> ：索引需要使用物理文件存储，也会耗费一定空间。</p>
</li>
</ul>
<h2 id="3-3Hash索引和B-树索引的优劣分析"><a href="#3-3Hash索引和B-树索引的优劣分析" class="headerlink" title="3.3Hash索引和B+树索引的优劣分析"></a>3.3Hash索引和B+树索引的优劣分析</h2><p><strong>Hash索引定位快</strong></p>
<p>Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置，这是B+树所不能比的。</p>
<p><strong>Hash冲突问题</strong></p>
<p>知道HashMap或HashTable的同学，相信都知道它们最大的缺点就是Hash冲突了。不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询是它最大的缺点。</strong></p>
<p>试想一种情况:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tb1 WHERE id &lt; 500;</span><br></pre></td></tr></table></figure>

<p><strong>B+树</strong>是有序的，在这种<strong>范围查询中，优势非常大</strong>，直接遍历比500小的叶子节点就够了。而Hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗?这就是Hash最大的缺点了。 </p>
<h2 id="3-4B树和B-树的区别"><a href="#3-4B树和B-树的区别" class="headerlink" title="3.4B树和B+树的区别"></a>3.4B树和B+树的区别</h2><ul>
<li>B树的所有节点既存放键(key) 也存放数据(data)；而B+树只有叶子节点存放 key 和 data，其他内节点只存放key。</li>
<li>B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\2.4.01.png" style="zoom:80%;">

<p><strong>B+树的优点：</strong></p>
<p>​    1、B+树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，I/O次数更少。</p>
<p>​    2、B+树的查询必须最终找到叶子节点，而B树只需要找到匹配的元素即可。B+树性能稳定（但是查询速度并不慢）。</p>
<p>​    3、范围查询方便。B树只能依靠繁琐的中序遍历，而B+树只需要在链表上遍历即可。</p>
<h2 id="3-5为什么相比于B树、红黑树而言，B-树更适合做索引"><a href="#3-5为什么相比于B树、红黑树而言，B-树更适合做索引" class="headerlink" title="3.5为什么相比于B树、红黑树而言，B+树更适合做索引"></a>3.5为什么相比于B树、红黑树而言，B+树更适合做索引</h2><h3 id="3-5-1红黑树的特性"><a href="#3-5-1红黑树的特性" class="headerlink" title="3.5.1红黑树的特性"></a>3.5.1红黑树的特性</h3><p>  （1）每个节点或者是黑色，或者是红色。</p>
<p>  （2）根节点是黑色。</p>
<p>  （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p>
<p>  （4）如果一个节点是红色的，则它的子节点必须是黑色的。（不能有两个连续的红色节点）</p>
<p>  （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（确保没有一条路径会比其他路径长出俩倍。因而，<strong>红黑树是相对是接近平衡的二叉树</strong>。）</p>
<h3 id="3-5-2获取磁盘上数据的过程"><a href="#3-5-2获取磁盘上数据的过程" class="headerlink" title="3.5.2获取磁盘上数据的过程"></a>3.5.2获取磁盘上数据的过程</h3><p>要获取磁盘上数据，必须先将磁头移动到数据所在的<strong>柱面</strong>，然后找到指定<strong>盘面</strong>，接着旋转盘面找到数据所在的<strong>磁道</strong>，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘I/O频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构尽量减少树的高度。</p>
<blockquote>
<p><strong>磁盘结构：</strong>磁盘由一层一层的盘片组成，每个盘片区分<strong>上下面</strong>，每个盘面由<strong>磁道</strong>组成，同时，各盘面相同半径的磁道组成<strong>柱面</strong>。</p>
</blockquote>
<h3 id="3-5-3磁盘预读原理"><a href="#3-5-3磁盘预读原理" class="headerlink" title="3.5.3磁盘预读原理"></a>3.5.3磁盘预读原理</h3><p><strong>磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。这样做的理论依据是计算机科学中著名的局部性原理（该数据附近的数据有可能被经常读取）。</p>
<h3 id="3-5-4实际比较"><a href="#3-5-4实际比较" class="headerlink" title="3.5.4实际比较"></a>3.5.4实际比较</h3><p><strong>VAL树：</strong>普通的全表查询时间复杂度是O(n);如果是平衡二叉树，或者红黑树，查找时间变成O(log2N)，但他们依然不适合做索引。因为索引通常比较大，存于磁盘中，无法一次将全部的索引加载到内存中，每次只能从磁盘中读取一个页到内存中，而平衡二叉树底层实现是数组，逻辑上相邻的节点在物理结构上可能相差很远，因此磁盘IO次数可能很大，平衡二叉树没能充分利用磁盘预读功能。</p>
<p><strong>红黑树：</strong>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比BTree差很多。</p>
<p><strong>B树：</strong>B树的每个节点可以存储多个关键字，<strong>它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。</strong>每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。</p>
<p><strong>B+树：</strong>B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。</p>
<h2 id="3-6索引类型"><a href="#3-6索引类型" class="headerlink" title="3.6索引类型"></a>3.6索引类型</h2><h3 id="3-6-1主键索引-Primary-Key"><a href="#3-6-1主键索引-Primary-Key" class="headerlink" title="3.6.1主键索引(Primary Key)"></a>3.6.1主键索引(Primary Key)</h3><p><strong>数据表的主键列使用的就是主键索引。</strong> </p>
<p><strong>一张数据表有只能有一个主键，并且主键不能为null，不能重复。</strong></p>
<p><strong>在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。</strong></p>
<h3 id="3-6-2二级索引-辅助索引"><a href="#3-6-2二级索引-辅助索引" class="headerlink" title="3.6.2二级索引(辅助索引)"></a>3.6.2二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>二级索引又包括：唯一索引，普通索引，前缀索引等索引。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。</strong>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 </li>
</ol>
<h2 id="3-6聚簇索引与非聚簇索引"><a href="#3-6聚簇索引与非聚簇索引" class="headerlink" title="3.6聚簇索引与非聚簇索引"></a>3.6聚簇索引与非聚簇索引</h2><h3 id="3-6-1聚集索引"><a href="#3-6-1聚集索引" class="headerlink" title="3.6.1聚集索引"></a>3.6.1聚集索引</h3><p><strong>1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 Mysql 中，InnoDB引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<p><strong>2.聚集索引的优点</strong></p>
<p>聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p>
<p><strong>3.聚集索引的缺点</strong></p>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为B+树是多路平衡树（有序），如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ol>
<h3 id="3-6-2非聚集索引"><a href="#3-6-2非聚集索引" class="headerlink" title="3.6.2非聚集索引"></a>3.6.2非聚集索引</h3><p><strong>1.非聚集索引即索引结构和数据分开存放的索引。</strong> <strong>二级索引属于非聚集索引。</strong></p>
<p>MYISAM引擎的表的<code>.MYI</code>文件包含了表的索引，该表的索引(B+树)的每个叶子非叶子节点存储索引，叶子节点存储索引和索引对应数据的指针，指向<code>.MYD</code>文件的数据。</p>
<p><strong>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p>
<p><strong>2.非聚集索引的优点</strong></p>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<p><strong>3.非聚集索引的缺点</strong></p>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ol>
<h2 id="3-7覆盖索引和回表查询"><a href="#3-7覆盖索引和回表查询" class="headerlink" title="3.7覆盖索引和回表查询"></a>3.7覆盖索引和回表查询</h2><h3 id="3-7-1非聚集索引一定回表查询吗"><a href="#3-7-1非聚集索引一定回表查询吗" class="headerlink" title="3.7.1非聚集索引一定回表查询吗?"></a>3.7.1非聚集索引一定回表查询吗?</h3><p><strong>非聚集索引不一定回表查询。</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE username=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。</p>
</blockquote>
<p><strong>即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表，<br>因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢?</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id FROM table WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h3 id="3-7-2覆盖索引"><a href="#3-7-2覆盖索引" class="headerlink" title="3.7.2覆盖索引"></a>3.7.2覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条SQL需要查询name，name字段正好有索引，<br>那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><strong>覆盖索引:</strong></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\2.7.01.png" style="zoom:80%;">

<h2 id="3-8创建索引的原则"><a href="#3-8创建索引的原则" class="headerlink" title="3.8创建索引的原则"></a>3.8创建索引的原则</h2><h3 id="3-8-1单列索引"><a href="#3-8-1单列索引" class="headerlink" title="3.8.1单列索引"></a>3.8.1单列索引</h3><p>单列索引即由一列属性组成的索引。</p>
<h3 id="3-8-2联合索引-多列索引"><a href="#3-8-2联合索引-多列索引" class="headerlink" title="3.8.2联合索引(多列索引)"></a>3.8.2联合索引(多列索引)</h3><p>联合索引即由多列属性组成索引。</p>
<h3 id="3-8-3最左前缀原则"><a href="#3-8-3最左前缀原则" class="headerlink" title="3.8.3最左前缀原则"></a>3.8.3最左前缀原则</h3><p>假设创建的联合索引由三个字段组成: </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table ADD INDEX index_name (num,name,age)</span><br></pre></td></tr></table></figure>

<p>那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。</p>
<h4 id="3-8-3-1深入理解最左匹配原则"><a href="#3-8-3-1深入理解最左匹配原则" class="headerlink" title="3 .8.3.1深入理解最左匹配原则"></a>3 .8.3.1深入理解最左匹配原则</h4><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">a <span class="built_in">int</span> ,</span><br><span class="line">b <span class="built_in">int</span>,</span><br><span class="line">c <span class="built_in">int</span>,</span><br><span class="line">d <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">key</span> index_abc(a,b,c)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>插入1000条数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> proc_initData;</span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc_initData()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE i&lt;=10000 DO</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span>(a,b,c,d) <span class="keyword">VALUES</span>(i,i,i,i);</span><br><span class="line">    <span class="keyword">SET</span> i = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CALL</span> proc_initData();</span><br></pre></td></tr></table></figure>

<p>建立了联合索引（a，b，c）</p>
<p>验证：</p>
<ul>
<li><p>explain select * from test where a&lt;10 ;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10;</p>
</li>
<li><p>explain select * from test where a&lt;10 and b &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>能不能将 a，b出现顺序换一下，a，b，c出现顺序换一下：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and a &lt;10;</p>
</li>
<li><p>explain select * from test where b&lt;10 and a &lt;10 and c&lt;10;</p>
</li>
</ul>
<p>不是最左匹配原则吗？</p>
<p>查了下资料发现：mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。<strong>也就是说MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，不过建议 where 后的字段顺序和联合索引保持一致。</strong></p>
<p><strong>（重点）</strong>输入下面两条SQL语句：</p>
<ul>
<li><p>explain select * from test where b&lt;10 and c &lt;10;、</p>
</li>
<li><p>explain select * from test where a&lt;10 and c &lt;10;</p>
</li>
</ul>
<p>为什么 b&lt;10 and c &lt;10,没有用到索引？而 a&lt;10 and c &lt;10用到了？</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h4 id="3-8-1-2联合索引中范围之后的索引将会失效"><a href="#3-8-1-2联合索引中范围之后的索引将会失效" class="headerlink" title="3.8.1.2联合索引中范围之后的索引将会失效"></a>3.8.1.2联合索引中范围之后的索引将会失效</h4><p>如：建立 姓名、年龄、性别的复合索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> myTest（</span><br><span class="line"></span><br><span class="line">        a <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        b <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        c <span class="built_in">int</span>,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">KEY</span> a（a,b,c）</span><br><span class="line"></span><br><span class="line">   ）；</span><br></pre></td></tr></table></figure>

<p><strong>索引的使用和失效情况：</strong></p>
<ul>
<li>select * from myTest  where a=3 and b=5 and c=4;   —-  abc顺序<br>abc三个索引都在where条件里面用到了，而且都发挥了作用</li>
<li>select * from myTest  where  c=4 and b=6 and a=3;<br>where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</li>
<li>select * from myTest  where a=3 and c=7;<br>a用到索引，b没有用，所以c是没有用到索引效果的</li>
<li>select * from myTest  where a=3 and b&gt;7 and c=3;     —- b范围值，断点，阻塞了c的索引<br>a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</li>
<li>select * from myTest  where b=3 and c=4;   — 联合索引必须按照顺序使用，并且需要全部使用<br>因为a索引没有使用，所以这里 bc都没有用上索引效果</li>
</ul>
<h2 id="3-9索引创建注意点"><a href="#3-9索引创建注意点" class="headerlink" title="3.9索引创建注意点"></a>3.9索引创建注意点</h2><p><strong>最左前缀原则</strong></p>
<p>但是我们仍应遵守最左前缀原则，以免版本更迭带来的麻烦。</p>
<h3 id="3-9-1选择合适的字段"><a href="#3-9-1选择合适的字段" class="headerlink" title="3.9.1选择合适的字段"></a>3.9.1选择合适的字段</h3><p><strong>1.不为NULL的字段</strong></p>
<p>索引字段的数据应该尽量不为NULL，因为对于数据为NULL的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为NULL，建议使用0,1,true,false这样语义较为清晰的短值或短字符作为替代。</p>
<p><strong>2.被频繁查询的字段</strong></p>
<p>我们创建索引的字段应该是查询操作非常频繁的字段。</p>
<p><strong>3.被作为条件查询的字段</strong> </p>
<p>被作为WHERE条件查询的字段，应该被考虑建立索引。</p>
<p><strong>4.被经常频繁用于连接的字段</strong></p>
<p>经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
<h3 id="3-9-2不合适创建索引的字段"><a href="#3-9-2不合适创建索引的字段" class="headerlink" title="3.9.2不合适创建索引的字段"></a>3.9.2不合适创建索引的字段</h3><p><strong>1.被频繁更新的字段应该慎重建立索引</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。<br>如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>2.不被经常查询的字段没有必要建立索引</strong></p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一棵B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong></p>
<p>冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。（也就是功能相同的索引）</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3 id="3-9-3使用索引一定能提高查询性能吗"><a href="#3-9-3使用索引一定能提高查询性能吗" class="headerlink" title="3.9.3使用索引一定能提高查询性能吗?"></a>3.9.3使用索引一定能提高查询性能吗?</h3><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h1 id="4-事务相关"><a href="#4-事务相关" class="headerlink" title="4.事务相关"></a>4.事务相关</h1><p><strong>事务</strong>：一组逻辑操作，要么全都执行，要么都不执行。</p>
<h2 id="4-1事务的四大特性（ACID）"><a href="#4-1事务的四大特性（ACID）" class="headerlink" title="4.1事务的四大特性（ACID）"></a>4.1事务的四大特性（ACID）</h2><ul>
<li><strong>原子性：</strong>事务是最小的执行单位，不可分割，保证事务要么都完成，要么都不完成；</li>
<li><strong>一致性：</strong>执行事务前后，数据保持一致，例如转账业务中，转账前后的总额应该是不变的；</li>
<li><strong>隔离性：</strong>并发访问数据库时，一个事务不被其他事务干扰；</li>
<li><strong>持久性：</strong>事务一旦提交，对数据库的改变是持久的。</li>
</ul>
<h2 id="4-2事务的隔离级别"><a href="#4-2事务的隔离级别" class="headerlink" title="4.2事务的隔离级别"></a>4.2事务的隔离级别</h2><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li> <strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生；</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产 生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p><strong>并发事务带来的问题：</strong></p>
<p>在典型的应用程序中，多个事务并发运行，经常会<strong>操作相同的数据</strong>来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须 的，但可能会导致以下的问题。 </p>
<ul>
<li><p><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问 了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据” 所做的操作可能是不正确的；</p>
</li>
<li><p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </p>
<p>例如：事务1读取某表中的数据 A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。 </p>
</li>
<li><p><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么， 在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 </p>
</li>
<li><p><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现<strong>多了一些原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p>不可重复度和幻读区别： 不可重复读的重点是修改，幻读的重点在于新增或者删除。</p>
<p> 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 </p>
<p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的 人，共查到4条记录，这时事务2又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p>
<blockquote>
<p><strong>NOTE：</strong>隔离级别的设置只对当前连接有效，对于使用MYSQL命令窗口而言，一个窗口就相当于一个连接，当前窗口设置的隔离级别只对当前窗口中的事务有效</p>
</blockquote>
<h2 id="4-3MySQL隔离级别"><a href="#4-3MySQL隔离级别" class="headerlink" title="4.3MySQL隔离级别"></a>4.3MySQL隔离级别</h2><h3 id="4-3-1MySQL默认隔离级别"><a href="#4-3-1MySQL默认隔离级别" class="headerlink" title="4.3.1MySQL默认隔离级别"></a>4.3.1MySQL默认隔离级别</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p>
<h3 id="4-3-2如何保证并发安全"><a href="#4-3-2如何保证并发安全" class="headerlink" title="4.3.2如何保证并发安全"></a>4.3.2如何保证并发安全</h3><p>InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下，允许应用使用 <strong>Next-Key Lock 锁算法</strong>来避免幻读的产生。这与其他数据库系统(如 SQL Server)是不同的。（所以说虽然 InnoDB 存储引擎的默认支持的隔离 级别是 REPEATABLE-READ（可重读），但是可以通过应用加锁读（例如 select * from table for update 语句）来保证不会产生幻读， 而这个加锁读使用到的机制就是 Next-Key Lock 锁算法。从而达到了 SQL 标准的 SERIALIZABLE(可串行化) 隔离级别）。</p>
<p> InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
<h1 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h1><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>
<h2 id="5-1隔离级别与锁的关系"><a href="#5-1隔离级别与锁的关系" class="headerlink" title="5.1隔离级别与锁的关系"></a>5.1隔离级别与锁的关系</h2><ul>
<li><p>在Read Uncommitted(读取未提交)级别下：读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；（能读取其它事务未提交的数据，容易造成脏读）</p>
</li>
<li><p>在Read Committed(读取已提交)级别下：读操作需要加共享锁，但是在语句执行完以后释放共享锁；（但是不是整个事务中一直保持，所以容易造成不可重复读）</p>
</li>
<li><p>在Repeatable Read(可重复读)级别下：读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。（整个事务过程中一直保持，所以不会出现不可重复读，但是不是锁定一个范围，所以还有可能出现幻读的情况）</p>
</li>
<li><p>SERIALIZABLE(可串行化)：是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
</li>
</ul>
<h2 id="5-2按照锁的粒度分数据库锁有哪些"><a href="#5-2按照锁的粒度分数据库锁有哪些" class="headerlink" title="5.2按照锁的粒度分数据库锁有哪些"></a>5.2按照锁的粒度分数据库锁有哪些</h2><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p><strong>行级锁：</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁：</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁：</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h2 id="5-3从锁的类别上分MySQL都有哪些锁"><a href="#5-3从锁的类别上分MySQL都有哪些锁" class="headerlink" title="5.3从锁的类别上分MySQL都有哪些锁"></a>5.3从锁的类别上分MySQL都有哪些锁</h2><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p><strong>共享锁（S）:</strong> 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p><strong>排他锁（X）:</strong> 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，<strong>他和其他的排他锁，共享锁都相斥</strong>。</p>
<h2 id="5-4InnoDB存储引擎的锁的算法"><a href="#5-4InnoDB存储引擎的锁的算法" class="headerlink" title="5.4InnoDB存储引擎的锁的算法"></a>5.4InnoDB存储引擎的锁的算法</h2><ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ul>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
</ul>
<h2 id="5-5意向锁"><a href="#5-5意向锁" class="headerlink" title="5.5意向锁"></a>5.5意向锁</h2><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许<code>行级锁</code>与<code>表级锁</code>共存，而<strong>意向锁</strong>就是其中的一种<code>表锁</code>。</p>
<p><strong>意向共享锁（intention shared lock, IS）：</strong>事务有意向对表中的某些行加<strong>共享锁</strong>（S锁） </p>
<p><strong>意向排他锁（intention exclusive lock, IX）：</strong>事务有意向对表中的某些行加<strong>排他锁</strong>（X锁） </p>
<p><strong>总结：</strong></p>
<ol>
<li>InnoDB 支持<strong>多粒度锁</strong>，特定场景下，行级锁可以与表级锁共存。</li>
<li><strong>意向锁之间互不排斥（兼容）</strong>，但除了 <strong>IS 与 S 兼容</strong>外，<strong>意向锁会 与 共享锁 / 排他锁 互斥</strong>。</li>
<li>IX，IS是表级锁，<strong>不会和行级的X，S锁发生冲突</strong>。只<strong>会和表级的X，S发生冲突</strong>。</li>
<li>意向锁在保证并发性的前提下，实现了<strong>行锁和表锁共存</strong>且满足事务隔离性的要求。</li>
</ol>
<h2 id="5-6介绍MVCC"><a href="#5-6介绍MVCC" class="headerlink" title="5.6介绍MVCC"></a>5.6介绍MVCC</h2><h3 id="5-6-1什么是MVCC"><a href="#5-6-1什么是MVCC" class="headerlink" title="5.6.1什么是MVCC"></a>5.6.1什么是MVCC</h3><p><strong>MVCC</strong>全称<code>Multi-Version Concurrency Control</code>，即<strong>多版本并发控制。</strong>MVCC在<strong>MySQL InnoDB</strong>中的实现主要是为了<strong>提高数据库并发性能</strong>，用<strong>更好的去处理读-写冲突</strong>。</p>
<p>应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现；</p>
<h3 id="5-6-2什么是当前读和快照读？"><a href="#5-6-2什么是当前读和快照读？" class="headerlink" title="5.6.2什么是当前读和快照读？"></a>5.6.2什么是当前读和快照读？</h3><p>在学习MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p>
<ul>
<li><strong>当前读</strong><br>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</li>
<li><strong>快照读</strong><br>像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读（一个事务读的肯定是最新版本）；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>
</ul>
<p><strong>说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</strong></p>
<p><strong>当前读，快照读和MVCC的关系：</strong></p>
<ul>
<li>准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念，仅仅是一个理想概念。</li>
<li>而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现。</li>
</ul>
<h3 id="5-6-3MVCC能解决什么问题，好处是？"><a href="#5-6-3MVCC能解决什么问题，好处是？" class="headerlink" title="5.6.3MVCC能解决什么问题，好处是？"></a>5.6.3MVCC能解决什么问题，好处是？</h3><p><strong>数据库并发场景有三种，分别为：</strong></p>
<ul>
<li><code>读-读</code>：不存在任何问题，也不需要并发控制</li>
<li><code>读-写</code>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><code>写-写</code>：有线程安全问题，可能会存在更新丢失问题</li>
</ul>
<p><strong>MVCC带来的好处是？</strong><br>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题</p>
<ul>
<li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</li>
<li>同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</li>
</ul>
<p><strong>总结MVCC的作用：</strong><br>MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：</p>
<ul>
<li><code>MVCC + 悲观锁</code><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><code>MVCC + 乐观锁</code><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题</p>
<h3 id="5-6-4MVCC的实现原理"><a href="#5-6-4MVCC的实现原理" class="headerlink" title="5.6.4MVCC的实现原理"></a>5.6.4MVCC的实现原理</h3><p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <strong><code>3个隐式字段</code>**，</strong><code>undo日志</code>** ，**<code>Read View</code>** 来实现的。所以我们先来看看这个三个point的概念：</p>
<p><strong>隐式字段：</strong>  <strong>数据库表中</strong>每行记录除了我们自定义的字段外，还有数据库隐式定义的<code>DB_TRX_ID</code>,<code>DB_ROLL_PTR</code>,<code>DB_ROW_ID</code>等字段</p>
<ul>
<li><strong>DB_TRX_ID</strong><br>最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong><br>回滚指针，用于配合undo日志，指向上一个旧版本（存储于rollback segment里）</li>
<li><strong>DB_ROW_ID</strong><br>隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li>还有一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p><strong>undo日志：</strong>undo log主要分为两种</p>
<ul>
<li><strong>insert undo log</strong><br>代表事务在<code>insert</code>新记录时产生的<code>undo log</code>, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃</li>
<li><strong>update undo log（最重要）</strong><br>事务在进行<code>update</code>或<code>delete</code>时产生的<code>undo log</code>; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除</li>
</ul>
<p>对MVCC有帮助的实质是<code>update undo log</code> ，<code>undo log</code>实际上就是存在<code>rollback segment</code>中旧记录链。</p>
<p><strong>Read View(读视图)</strong></p>
<p><code>Read View</code>就是事务进行<code>快照读</code>操作的时候生产的<code>读视图(Read View)</code>，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)**</p>
<p>所以我们知道 <code>Read View</code>主要是<strong>用来做可见性判断</strong>的, 即当我们某个事务执行快照读的时候，对该记录创建一个<code>Read View</code>读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的<code>undo log</code>里面的某个版本的数据。</p>
<p><code>Read View</code>遵循一个可见性算法，主要是将要<code>被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟<code>Read View</code>的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个<code>DB_TRX_ID</code>所在的旧记录就是当前事务能看见的最新老版本</p>
<h3 id="5-6-5MVCC工作整体流程"><a href="#5-6-5MVCC工作整体流程" class="headerlink" title="5.6.5MVCC工作整体流程"></a>5.6.5MVCC工作整体流程</h3><ul>
<li><p>当<code>事务2</code>对某行数据执行了<code>快照读</code>，数据库为该行数据生成一个<code>Read View</code>读视图，假设当前事务ID为<code>2</code>，此时还有<code>事务1</code>和<code>事务3</code>在活跃中，<code>事务4</code>在<code>事务2</code>快照读前一刻提交更新了，所以Read View记录了系统当前活跃事务1，3的ID，维护在一个列表上，假设我们称为<code>trx_list</code></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.01.png" style="zoom: 67%;">
</li>
<li><p><code>Read View</code>不仅仅会通过一个列表<code>trx_list</code>来维护事务2执行快照读那刻系统正活跃的事务ID，还会有两个属性<code>up_limit_id</code>（记录<code>trx_list</code>列表中事务ID最小的ID），<code>low_limit_id</code>(记录<code>trx_list</code>列表中快照读那刻系统尚未分配的下一个事务ID也就是目前已出现过的事务ID的最大值+1) ；所以在这里例子中up_limit_id就是1，low_limit_id就是4 + 1 = 5，trx_list集合的值是1,3。</p>
</li>
<li><p>我们的例子中，只有事务4修改过该行记录，并在事务2执行快照读前，就提交了事务，所以当前该行当前数据的<code>undo log</code>，如下图所示；我们的事务2在快照读该行记录的时候，就会拿该行记录的<code>DB_TRX_ID</code>去跟<code>up_limit_id</code>,<code>low_limit_id</code>和活跃事务ID列表(<code>trx_list</code>)进行比较，判断当前事务2能看到该记录的版本是哪个。</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\1.5.5.02.png" style="zoom: 67%;">
</li>
<li><p>所以先拿该记录<code>DB_TRX_ID</code>字段记录的事务ID 4去跟<code>Read View</code>的的<code>up_limit_id</code>比较，看4是否小于<code>up_limit_id(1)</code>，所以不符合条件，继续判断 4 是否大于等于 <code>low_limit_id(5)</code>，也不符合条件，最后判断4是否处于<code>trx_list</code>中的活跃事务, 最后发现事务ID为4的事务不在当前活跃事务列表中, 符合可见性条件，所以事务4修改后提交的最新结果对事务2快照读时是可见的，所以事务2能读到的最新数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。</p>
<p><strong>总结：</strong>这个事务是活跃的不能看，执行快照之后分配的事务ID不能看，只有在执行快照之前提交的事务数据能看</p>
</li>
<li><p>也正是Read View生成时机的不同，从而造成RC,RR级别下快照读的结果的不同。</p>
</li>
</ul>
<h3 id="5-6-6MVCC相关问题"><a href="#5-6-6MVCC相关问题" class="headerlink" title="5.6.6MVCC相关问题"></a>5.6.6MVCC相关问题</h3><h4 id="5-6-6-1RR是如何在RC级的基础上解决不可重复读的？"><a href="#5-6-6-1RR是如何在RC级的基础上解决不可重复读的？" class="headerlink" title="5.6.6.1RR是如何在RC级的基础上解决不可重复读的？"></a>5.6.6.1RR是如何在RC级的基础上解决不可重复读的？</h4><p><strong>当前读和快照读在RR级别下的区别：</strong></p>
<p><code>表1:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读(无影响)查询金额为500</td>
<td align="center">快照读查询金额为500</td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为500</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>在上表的顺序下，事务B的在事务A提交修改后的快照读是旧版本数据，而当前读是实时新数据400</p>
<p><code>表2:</code></p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启事务</td>
<td align="center">开启事务</td>
</tr>
<tr>
<td align="center">快照读（无影响）查询金额为500</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">更新金额为400</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">提交事务</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select <code>快照读</code>金额为400</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">select lock in share mode<code>当前读</code>金额为400</td>
</tr>
</tbody></table>
<p>而在<code>表2</code>这里的顺序中，事务B在事务A提交后的快照读和当前读都是实时的新数据400，这是为什么呢？</p>
<ul>
<li>这里与上表的唯一区别仅仅是表1的事务B在事务A修改金额前快照读过一次金额数据，而表2的事务B在事务A修改金额前没有进行过快照读。</li>
</ul>
<p><strong>所以我们知道事务中快照读的结果是非常依赖该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力</strong></p>
<p>我们这里测试的是更新，同时删除和更新也是一样的，如果事务B的快照读是在事务A操作之后进行的，事务B的快照读也是能读取到最新的数据的</p>
<h4 id="5-6-6-2RC-RR级别下的InnoDB快照读有什么不同？"><a href="#5-6-6-2RC-RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="5.6.6.2RC,RR级别下的InnoDB快照读有什么不同？"></a>5.6.6.2RC,RR级别下的InnoDB快照读有什么不同？</h4><p>正是<code>Read View</code>生成时机的不同，从而造成RC,RR级别下快照读的结果的不同</p>
<ul>
<li>在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及<code>Read View</code>, 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个<code>Read View</code>，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个<code>Read View</code>，所以对之后更新的修改不可见；</li>
<li>即RR级别下，快照读生成<code>Read View</code>时，<code>Read View</code>会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于<code>Read View</code>创建的事务所做的修改均是可见</li>
<li>而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因（不可重复读）</li>
</ul>
<p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</strong></p>
<h1 id="6-MySQL中一条SQL语句的执行过程"><a href="#6-MySQL中一条SQL语句的执行过程" class="headerlink" title="6.MySQL中一条SQL语句的执行过程"></a>6.MySQL中一条SQL语句的执行过程</h1><h2 id="6-1MySQL-基础架构分析"><a href="#6-1MySQL-基础架构分析" class="headerlink" title="6.1MySQL 基础架构分析"></a>6.1MySQL 基础架构分析</h2><h3 id="6-1-1-MySQL-基本架构概览"><a href="#6-1-1-MySQL-基本架构概览" class="headerlink" title="6.1.1 MySQL 基本架构概览"></a>6.1.1 MySQL 基本架构概览</h3><p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存:</strong>  执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器:</strong>  没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>  按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\mysql执行.png" style="zoom:80%;">

<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="6-1-2-Server-层基本组件介绍"><a href="#6-1-2-Server-层基本组件介绍" class="headerlink" title="6.1.2 Server 层基本组件介绍"></a>6.1.2 Server 层基本组件介绍</h3><p><strong>1) 连接器</strong></p>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<p><strong>2) 查询缓存(MySQL 8.0 版本后移除)</strong></p>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<p><strong>3) 分析器</strong></p>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<p><strong>4) 优化器</strong> </p>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<p><strong>5) 执行器</strong></p>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="6-2语句分析"><a href="#6-2语句分析" class="headerlink" title="6.2语句分析"></a>6.2语句分析</h2><h3 id="6-2-1-查询语句"><a href="#6-2-1-查询语句" class="headerlink" title="6.2.1 查询语句"></a>6.2.1 查询语句</h3><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age=<span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</li>
<li>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</li>
<li>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="6-2-2-更新语句"><a href="#6-2-2-更新语句" class="headerlink" title="6.2.2 更新语句"></a>6.2.2 更新语句</h3><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age=<span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name=<span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时<strong>主从同步</strong>也会丢失这一条数据。<strong>（主从同步是MySQL的binlog关联的）</strong></li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？<br>这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 ==redo log== 是否完整，如果判断是完整的，就立即提交。==//这里是redo log吗，如果提交了，binlog没有记录怎么办？==</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2 id="6-3总结"><a href="#6-3总结" class="headerlink" title="6.3总结"></a>6.3总结</h2><ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）→查询缓存→分析器→优化器→权限校验→执行器→引擎</li>
<li>更新语句执行流程如下：分析器→权限校验→执行器→引擎—redo log(prepare 状态→binlog→redo log(commit状态)</li>
</ul>
<h1 id="7-数据库优化相关"><a href="#7-数据库优化相关" class="headerlink" title="7.数据库优化相关"></a>7.数据库优化相关</h1><h2 id="7-1MySQL的主从复制原理以及流程"><a href="#7-1MySQL的主从复制原理以及流程" class="headerlink" title="7.1MySQL的主从复制原理以及流程"></a>7.1MySQL的主从复制原理以及流程</h2><h4 id="7-1-1主从复制的概念及作用"><a href="#7-1-1主从复制的概念及作用" class="headerlink" title="7.1.1主从复制的概念及作用"></a>7.1.1主从复制的概念及作用</h4><p><strong>主从复制：</strong></p>
<ul>
<li>将主数据库中的DDL和DML操作通过二进制日志（BIN LOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</li>
</ul>
<p><strong>主从复制的作用:</strong></p>
<ul>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ul>
<p><strong>MySQL主从复制解决的问题：</strong></p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<h4 id="7-1-2MySQL主从复制工作原理"><a href="#7-1-2MySQL主从复制工作原理" class="headerlink" title="7.1.2MySQL主从复制工作原理"></a>7.1.2MySQL主从复制工作原理</h4><ul>
<li>在主库上把数据更新记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<h4 id="7-1-3主从复制流程"><a href="#7-1-3主从复制流程" class="headerlink" title="7.1.3主从复制流程"></a>7.1.3主从复制流程</h4><img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\4.1.01.png" style="zoom: 67%;">

<blockquote>
<p><strong>Binary log：</strong>主数据库的二进制日志</p>
<p><strong>Relay log：</strong>从服务器的中继日志</p>
</blockquote>
<ul>
<li><p>第一步：master 在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
</li>
<li><p>第二步：salve 开启一个 I/O Thread，该线程在 master 打开一个普通连接，主要工作是 binlog dump process。如果读取的进度已经跟上了 master，就进入睡眠状态并等待 master 产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
</li>
<li><p>第三步：SQL Thread 会读取中继日志，并顺序执行该日志中的 SQL 事件，从而与主数据库中的数据保持一致。</p>
</li>
</ul>
<h4 id="7-1-4读写分离有哪些解决方案？"><a href="#7-1-4读写分离有哪些解决方案？" class="headerlink" title="7.1.4读写分离有哪些解决方案？"></a>7.1.4读写分离有哪些解决方案？</h4><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读。</p>
<p><strong>方案一</strong></p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二（项目中使用的方法）</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库（slave）， 其余的有读有写的扔进写库（master）。</p>
<p><strong>方案三</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>
<h4 id="7-1-5主从复制数据不一致性问题及解决方法"><a href="#7-1-5主从复制数据不一致性问题及解决方法" class="headerlink" title="7.1.5主从复制数据不一致性问题及解决方法"></a>7.1.5主从复制数据不一致性问题及解决方法</h4><p>因为主从复制要求<code>slave</code>不能写只能读，如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>。</p>
<p><strong>问题：</strong>数据同步延迟很多，且希望重新做主从，使得主从在数据上保持完全同步。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>查看master的运行情况:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File: mysql-bin.000014     //这个信息点要记住，下面用</span><br><span class="line">Position: 170017372        //这个信息点要记住，下面用</span><br></pre></td></tr></table></figure>
</li>
<li><p>先进入主库，进行锁表，防止数据写入</p>
</li>
<li><p>进行master数据备份（mysqldump）</p>
</li>
<li><p>打包数据(可选)</p>
</li>
<li><p>把mysql备份文件传到从库机器，进行数据恢复</p>
</li>
<li><p>更新/设置同步进度点</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@slave] <span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">&#x27;master.mysql.ipharmacare.org&#x27;</span>, master_user=<span class="string">&#x27;slave&#x27;</span>, master_port=<span class="number">3306</span>, master_password=<span class="string">&#x27;************&#x27;</span>, master_log_file=<span class="string">&#x27;mysql-bin.000014&#x27;</span>, master_log_pos=<span class="number">170017372</span>;//这里就用前面的，使从库与主库的进度点保持一致</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE：</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//(1)做了MySQL主从复制以后，使用mysqldump对数据备份时，一定要注意按照如下方式：</span><br><span class="line">[root@master] mysqldump –master-data –single-transaction –user=username –password=password dbname&gt; dumpfilename</span><br><span class="line">//这样就可以保留file和position的信息，在新搭建一个slave的时候，还原完数据库，file和position的信息也随之更新，接着再<span class="keyword">start</span> <span class="keyword">slave</span> 就可以很迅速的完成增量同步。</span><br><span class="line">//(<span class="number">2</span>) 忘记主从复制时,对从库用户密码时,可以这样去重置:</span><br><span class="line">[root@<span class="keyword">master</span>] <span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;slave.mysql.ipharmacare.org&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;slave&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-6异步模式、半同步模式和同步模式"><a href="#7-1-6异步模式、半同步模式和同步模式" class="headerlink" title="7.1.6异步模式、半同步模式和同步模式"></a>7.1.6异步模式、半同步模式和同步模式</h4><p>MySQL <strong>主从复制默认是异步的模式：</strong></p>
<p><strong>异步复制：</strong>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理；主节点不会主动push bin log到从节点；</p>
<p><strong>半同步模式：</strong>这种模式下<strong>主节点只需要接收到其中一台从节点的返回信息，就会commit</strong>；否则需要等待直到超时时间然后切换成异步模式再提交；这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性。半同步模式不是mysql内置的，需要装插件开启半同步模式。</p>
<p><strong>全同步模式</strong>：全同步模式是指<strong>主节点和从节点全部执行了commit并确认</strong>才会向客户端返回成功。</p>
<h1 id="8-常见的SQL语句"><a href="#8-常见的SQL语句" class="headerlink" title="8.常见的SQL语句"></a>8.常见的SQL语句</h1><h2 id="8-1基本查询关键字的使用（积累）"><a href="#8-1基本查询关键字的使用（积累）" class="headerlink" title="8.1基本查询关键字的使用（积累）"></a>8.1基本查询关键字的使用（积累）</h2><h2 id="8-2六种关联查询"><a href="#8-2六种关联查询" class="headerlink" title="8.2六种关联查询"></a>8.2六种关联查询</h2><ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
</ul>
<p><strong>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录：</strong></p>
<p><code>R表</code></p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p><code>S表</code></p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="8-2-1交叉连接（CROSS-JOIN）"><a href="#8-2-1交叉连接（CROSS-JOIN）" class="headerlink" title="8.2.1交叉连接（CROSS JOIN）"></a>8.2.1交叉连接（CROSS JOIN）</h3><p>交叉连接(笛卡尔积):</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r,s</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="8-2-2内连接（INNER-JOIN）"><a href="#8-2-2内连接（INNER-JOIN）" class="headerlink" title="8.2.2内连接（INNER JOIN）"></a>8.2.2内连接（INNER JOIN）</h3><ul>
<li>等值连接：ON A.id=B.id</li>
<li>不等值连接：ON A.id &gt; B.id</li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>内连接结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">inner</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody></table>
<h3 id="8-2-3连接（LEFT-JOIN-RIGHT-JOIN）"><a href="#8-2-3连接（LEFT-JOIN-RIGHT-JOIN）" class="headerlink" title="8.2.3连接（LEFT JOIN/RIGHT JOIN）"></a>8.2.3连接（LEFT JOIN/RIGHT JOIN）</h3><ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>左连接结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">left</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>右连接结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">right</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h3 id="8-2-4联合查询（UNION与UNION-ALL）"><a href="#8-2-4联合查询（UNION与UNION-ALL）" class="headerlink" title="8.2.4联合查询（UNION与UNION ALL）"></a>8.2.4联合查询（UNION与UNION ALL）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>就是把多个结果集集中在一起，<code>UNION</code>前的结果为基准，需要注意的是<strong>联合查询的列数要相等</strong>，<strong>相同的记录行会合并</strong></li>
<li>如果使用<code>UNION ALL</code>，<strong>不会合并重复的记录行</strong></li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h3 id="8-2-5全连接（FULL-JOIN）"><a href="#8-2-5全连接（FULL-JOIN）" class="headerlink" title="8.2.5全连接（FULL JOIN）"></a>8.2.5全连接（FULL JOIN）</h3><ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<p>全表连接的结果（MySql不支持，Oracle支持）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> r.<span class="string">`*`</span>,s.<span class="string">`*`</span> <span class="keyword">from</span> r <span class="keyword">full</span> <span class="keyword">join</span> s <span class="keyword">on</span> r.c=s.c</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody></table>
<h1 id="9-SQL优化"><a href="#9-SQL优化" class="headerlink" title="9.SQL优化"></a>9.SQL优化</h1><h2 id="9-1Explain语句"><a href="#9-1Explain语句" class="headerlink" title="9.1Explain语句"></a>9.1Explain语句</h2><p><strong>常见问题：</strong></p>
<ul>
<li>如何定位及优化SQL语句的性能问题？</li>
<li>创建的索引有没有被使用到?</li>
<li>或者说怎么才可以知道这条语句运行很慢的原因？</li>
</ul>
<h3 id="9-1-1Explain语句的作用"><a href="#9-1-1Explain语句的作用" class="headerlink" title="9.1.1Explain语句的作用"></a>9.1.1Explain语句的作用</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来<strong>查看语句的执行计划</strong>。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引。 而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</strong></p>
<h3 id="9-1-2Explain语句的字段含义"><a href="#9-1-2Explain语句的字段含义" class="headerlink" title="9.1.2Explain语句的字段含义"></a>9.1.2Explain语句的字段含义</h3><table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>id</strong> 由一组数字组成。表示一个查询中各个子查询的执行顺序：</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">select_type</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">SIMPLE</td>
<td align="center">不包含任何子查询或union等查询</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">PRIMARY</td>
<td align="center">包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SUBQUERY</td>
<td align="center">在select或 where语句中包含的查询</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">DERIVED</td>
<td align="center">from字句中包含的查询</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">UNION</td>
<td align="center">出现在union后的查询语句中</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">UNION RESULT</td>
<td align="center">从UNION中获取结果集</td>
</tr>
</tbody></table>
<p><strong>table</strong> 查询的数据表</p>
<p><strong>type</strong>(非常重要，<strong>可以看到有没有走索引</strong>) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>key_len</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 含MySQL解决查询的<strong>详细信息</strong>，常见的有：</p>
<ul>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用where子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化</li>
<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>
</ul>
<h3 id="9-1-3实例分析"><a href="#9-1-3实例分析" class="headerlink" title="9.1.3实例分析"></a>9.1.3实例分析</h3><img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.05.png" style="zoom: 80%;">

<ul>
<li>执行顺序1：select_type为UNION，说明第四个select是UNION里的第二个select，最先执行【select name,id from t2】</li>
<li>执行顺序2：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为DERIVED【select id,name from t1 where other_column=’’】</li>
<li>执行顺序3：select列表中的子查询select_type为subquery,为整个查询中的第二个select【select id from t3】</li>
<li>执行顺序4：id列为1，表示是UNION里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<code>&lt;derived3&gt;</code>,表示查询结果来自一个衍生表，其中derived3中的3代表该查询衍生自第三个select查询，即id为3的select。【select d1.name …】</li>
<li>执行顺序5：代表从UNION的临时表中读取行的阶段，table列的&lt; union1,4 &gt;表示用第一个和第四个select的结果进行UNION操作。【两个结果union操作】</li>
</ul>
<h2 id="9-2如何使用索引避免全表扫描"><a href="#9-2如何使用索引避免全表扫描" class="headerlink" title="9.2如何使用索引避免全表扫描"></a>9.2如何使用索引避免全表扫描</h2><ul>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引：</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h1 id="10-数据库优化"><a href="#10-数据库优化" class="headerlink" title="10.数据库优化"></a>10.数据库优化</h1><h2 id="10-1大表优化"><a href="#10-1大表优化" class="headerlink" title="10.1大表优化"></a>10.1大表优化</h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ul>
<li><p><strong>垂直分区：</strong></p>
<p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p>简单来说垂直拆分是指<strong>数据表列</strong>的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.01.png" style="zoom:67%;">

<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<p><strong>例：</strong>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.02.png" style="zoom:67%;">

<p><strong>适用场景:</strong></p>
<p>1、如果一个表中某些列常用，另外一些列不常用</p>
<p>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</p>
<p><strong>缺点:</strong></p>
<p>1、有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</p>
<p>2、对于应用层来说，逻辑算法增加开发成本</p>
<p>3、管理冗余列，查询所有数据需要join操作</p>
</li>
<li><p><strong>水平分区：</strong></p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.03.png" style="zoom:67%;">

<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储</strong>，<strong>应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<h4 id="水平分表："><a href="#水平分表：" class="headerlink" title="水平分表："></a>水平分表：</h4><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<img src="/2021/03/16/MySQL/GitHub\MyBlogs\source\_posts\2021-03-16-MySQL\9.1.04.png" style="zoom:80%;">

<p><strong>适用场景</strong></p>
<p>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。<br>2、需要把数据存放在多个介质上。（分布式）</p>
<p><strong>水平切分的缺点</strong></p>
<p>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作<br>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</p>
</li>
</ul>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i>  MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统">
      <i class="fa fa-chevron-left"></i> 操作系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/24/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA1.0-%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87/" rel="next" title="校园商铺1.0-开发准备">
      校园商铺1.0-开发准备 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">1.数据库基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AFSQL%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1什么是SQL？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.2.</span> <span class="nav-text">1.2关系型数据库与非关系型数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.3.</span> <span class="nav-text">1.3数据库三大范式是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%BC%95%E6%93%8E"><span class="nav-number">2.</span> <span class="nav-text">2.引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.</span> <span class="nav-text">2.1MySQL存储引擎MyISAM与InnoDB区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2MyISAM%E7%B4%A2%E5%BC%95%E4%B8%8EInnoDB%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2.2MyISAM索引与InnoDB索引的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">2.3存储引擎的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">3.索引相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.</span> <span class="nav-text">3.1什么是索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.2.</span> <span class="nav-text">3.2索引的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">3.3Hash索引和B+树索引的优劣分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.</span> <span class="nav-text">3.4B树和B+树的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5%E4%B8%BA%E4%BB%80%E4%B9%88%E7%9B%B8%E6%AF%94%E4%BA%8EB%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E8%A8%80%EF%BC%8CB-%E6%A0%91%E6%9B%B4%E9%80%82%E5%90%88%E5%81%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">3.5.</span> <span class="nav-text">3.5为什么相比于B树、红黑树而言，B+树更适合做索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1红黑树的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2%E8%8E%B7%E5%8F%96%E7%A3%81%E7%9B%98%E4%B8%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2获取磁盘上数据的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB%E5%8E%9F%E7%90%86"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3磁盘预读原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4%E5%AE%9E%E9%99%85%E6%AF%94%E8%BE%83"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.5.4实际比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.</span> <span class="nav-text">3.6索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.6.1主键索引(Primary Key)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.6.2二级索引(辅助索引)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.7.</span> <span class="nav-text">3.6聚簇索引与非聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.6.1聚集索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.6.2非聚集索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.8.</span> <span class="nav-text">3.7覆盖索引和回表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97"><span class="nav-number">3.8.1.</span> <span class="nav-text">3.7.1非聚集索引一定回表查询吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.8.2.</span> <span class="nav-text">3.7.2覆盖索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">3.9.</span> <span class="nav-text">3.8创建索引的原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">3.9.1.</span> <span class="nav-text">3.8.1单列索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-2%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">3.9.2.</span> <span class="nav-text">3.8.2联合索引(多列索引)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-3%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.8.3最左前缀原则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-1%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="nav-number">3.9.3.1.</span> <span class="nav-text">3 .8.3.1深入理解最左匹配原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-2%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%AD%E8%8C%83%E5%9B%B4%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B4%A2%E5%BC%95%E5%B0%86%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="nav-number">3.9.3.2.</span> <span class="nav-text">3.8.1.2联合索引中范围之后的索引将会失效</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.10.</span> <span class="nav-text">3.9索引创建注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">3.10.1.</span> <span class="nav-text">3.9.1选择合适的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-2%E4%B8%8D%E5%90%88%E9%80%82%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">3.10.2.</span> <span class="nav-text">3.9.2不合适创建索引的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-3%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%90%97"><span class="nav-number">3.10.3.</span> <span class="nav-text">3.9.3使用索引一定能提高查询性能吗?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">4.事务相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">4.1事务的四大特性（ACID）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text">4.2事务的隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text">4.3MySQL隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1MySQL%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1MySQL默认隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2如何保证并发安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">5.锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.1.</span> <span class="nav-text">5.1隔离级别与锁的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E6%8C%89%E7%85%A7%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">5.2.</span> <span class="nav-text">5.2按照锁的粒度分数据库锁有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E4%BB%8E%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8A%E5%88%86MySQL%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81"><span class="nav-number">5.3.</span> <span class="nav-text">5.3从锁的类别上分MySQL都有哪些锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">5.4InnoDB存储引擎的锁的算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">5.5.</span> <span class="nav-text">5.5意向锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6%E4%BB%8B%E7%BB%8DMVCC"><span class="nav-number">5.6.</span> <span class="nav-text">5.6介绍MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1%E4%BB%80%E4%B9%88%E6%98%AFMVCC"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1什么是MVCC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2什么是当前读和快照读？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-3MVCC%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A5%BD%E5%A4%84%E6%98%AF%EF%BC%9F"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3MVCC能解决什么问题，好处是？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-4MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.4.</span> <span class="nav-text">5.6.4MVCC的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-5MVCC%E5%B7%A5%E4%BD%9C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">5.6.5.</span> <span class="nav-text">5.6.5MVCC工作整体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-6MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">5.6.6.</span> <span class="nav-text">5.6.6MVCC相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-6-1RR%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8RC%E7%BA%A7%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%9A%84%EF%BC%9F"><span class="nav-number">5.6.6.1.</span> <span class="nav-text">5.6.6.1RR是如何在RC级的基础上解决不可重复读的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-6-2RC-RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84InnoDB%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">5.6.6.2.</span> <span class="nav-text">5.6.6.2RC,RR级别下的InnoDB快照读有什么不同？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">6.MySQL中一条SQL语句的执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1MySQL-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-number">6.1.</span> <span class="nav-text">6.1MySQL 基础架构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-MySQL-%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E6%A6%82%E8%A7%88"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 MySQL 基本架构概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-Server-%E5%B1%82%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 Server 层基本组件介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E8%AF%AD%E5%8F%A5%E5%88%86%E6%9E%90"><span class="nav-number">6.2.</span> <span class="nav-text">6.2语句分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 查询语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 更新语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3%E6%80%BB%E7%BB%93"><span class="nav-number">6.3.</span> <span class="nav-text">6.3总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">7.数据库优化相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">7.1MySQL的主从复制原理以及流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">7.1.0.1.</span> <span class="nav-text">7.1.1主从复制的概念及作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.0.2.</span> <span class="nav-text">7.1.2MySQL主从复制工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-3%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.0.3.</span> <span class="nav-text">7.1.3主从复制流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-4%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">7.1.0.4.</span> <span class="nav-text">7.1.4读写分离有哪些解决方案？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-5%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.0.5.</span> <span class="nav-text">7.1.5主从复制数据不一致性问题及解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-6%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E3%80%81%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.1.0.6.</span> <span class="nav-text">7.1.6异步模式、半同步模式和同步模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.</span> <span class="nav-text">8.常见的SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E7%A7%AF%E7%B4%AF%EF%BC%89"><span class="nav-number">8.1.</span> <span class="nav-text">8.1基本查询关键字的使用（积累）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E5%85%AD%E7%A7%8D%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.2.</span> <span class="nav-text">8.2六种关联查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%EF%BC%88CROSS-JOIN%EF%BC%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">8.2.1交叉连接（CROSS JOIN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%88INNER-JOIN%EF%BC%89"><span class="nav-number">8.2.2.</span> <span class="nav-text">8.2.2内连接（INNER JOIN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3%E8%BF%9E%E6%8E%A5%EF%BC%88LEFT-JOIN-RIGHT-JOIN%EF%BC%89"><span class="nav-number">8.2.3.</span> <span class="nav-text">8.2.3连接（LEFT JOIN&#x2F;RIGHT JOIN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-4%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%88UNION%E4%B8%8EUNION-ALL%EF%BC%89"><span class="nav-number">8.2.4.</span> <span class="nav-text">8.2.4联合查询（UNION与UNION ALL）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-5%E5%85%A8%E8%BF%9E%E6%8E%A5%EF%BC%88FULL-JOIN%EF%BC%89"><span class="nav-number">8.2.5.</span> <span class="nav-text">8.2.5全连接（FULL JOIN）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-SQL%E4%BC%98%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">9.SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1Explain%E8%AF%AD%E5%8F%A5"><span class="nav-number">9.1.</span> <span class="nav-text">9.1Explain语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-1Explain%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.1.1.</span> <span class="nav-text">9.1.1Explain语句的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-2Explain%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89"><span class="nav-number">9.1.2.</span> <span class="nav-text">9.1.2Explain语句的字段含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-3%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">9.1.3.</span> <span class="nav-text">9.1.3实例分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E9%81%BF%E5%85%8D%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="nav-number">9.2.</span> <span class="nav-text">9.2如何使用索引避免全表扫描</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">10.数据库优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">10.1.</span> <span class="nav-text">10.1大表优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8%EF%BC%9A"><span class="nav-number">10.1.0.1.</span> <span class="nav-text">水平分表：</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">360k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:28</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

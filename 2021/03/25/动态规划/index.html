<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-25T08:45:06.000Z">
<meta property="article:modified_time" content="2021-05-19T13:43:16.964Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="基础算法篇">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>动态规划 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          动态规划
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 16:45:06" itemprop="dateCreated datePublished" datetime="2021-03-25T16:45:06+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-19 21:43:16" itemprop="dateModified" datetime="2021-05-19T21:43:16+08:00">2021-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LeetCode%E9%A2%98%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">LeetCode题解</span></a>
                </span>
            </span>

          
            <span id="/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-meta-item leancloud_visitors" data-flag-title="动态规划" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p><strong>动态规划：</strong>是一种解决问题的思想，大规模问题的结果，是由小规模问题的结果运算得来的。动态规划可用递归来实现(Memorization Search)</p>
<p>动态规划中的最优子结构：大规模问题中包含重复的子问题，并且大规模问题的最优解可以由小规模问题的最优解得到。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>满足两个条件：</strong></p>
<ol>
<li>满足以下条件之一<ul>
<li>求最大/最小值（Maximum/Minimum ）</li>
<li>求是否可行（Yes/No ）</li>
<li>求可行个数（Count(*) ）</li>
</ul>
</li>
<li>满足不能排序或者交换（Can not sort / swap ）</li>
</ol>
<h2 id="四点要素"><a href="#四点要素" class="headerlink" title="四点要素"></a>四点要素</h2><ol>
<li><strong>状态 State</strong><ul>
<li>灵感，创造力，存储小规模问题的结果</li>
</ul>
</li>
<li><strong>方程 Function</strong><ul>
<li><strong>状态之间的联系</strong>，怎么通过小的状态，来算大的状态</li>
</ul>
</li>
<li>初始化 Intialization<ul>
<li>最极限的小状态是什么, 起点</li>
</ul>
</li>
<li>答案 Answer<ul>
<li>最大的那个状态是什么，终点</li>
</ul>
</li>
</ol>
<h2 id="常见四种类型"><a href="#常见四种类型" class="headerlink" title="常见四种类型"></a>常见四种类型</h2><ol>
<li>矩阵类型（Matrix DP ）(10%)</li>
<li>序列类型（Sequence ）(40%)</li>
<li>子序列/子串（Two Sequences DP） (40%)</li>
<li>零钱、背包问题（Backpack） (10%)</li>
</ol>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="类型一：矩阵"><a href="#类型一：矩阵" class="headerlink" title="类型一：矩阵"></a>类型一：矩阵</h2><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer-47. 礼物的最大价值</a></strong></p>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong> 设动态规划矩阵 dp ，dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j)时能拿到礼物的最大累计价值。</p>
</li>
<li><p><strong>转移方程：</strong>设 f(i,j)为从棋盘左上角走至单元格 (i,j)的礼物最大累计价值，易得到以下递推关系：f(i,j) 等于 f(i,j−1) 和 f(i−1,j) 中的较大值加上当前单元格礼物价值 grid(i,j)。<br>$$<br>f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j)<br>$$</p>
</li>
<li><p><strong>初始状态：</strong> dp[0] [0]=grid[0] [0]，即到达单元格 (0,0)时能拿到礼物的最大累计价值为 grid[0] [0] ；</p>
</li>
<li><p><strong>返回值：</strong> dp[m−1] [n−1]，m,n分别为矩阵的行高和列宽，即返回 dp矩阵右下角元素。</p>
</li>
</ul>
<h4 id="代码及注解"><a href="#代码及注解" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.max(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/">热题100-221. 最大正方形</a></strong></p>
<p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
</blockquote>
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-1"><a href="#代码及注解-1" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxSide=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          maxSide=Math.max(maxSide,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">热题100-62. 不同路径</a></strong></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-2"><a href="#代码及注解-2" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] grid=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        grid[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;m;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>;c&lt;n;c++)&#123;</span><br><span class="line">            grid[r][c]=grid[r-<span class="number">1</span>][c]+grid[r][c-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum/">热题100-64. 最小路径和</a></strong></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
</blockquote>
<h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注解-3"><a href="#代码及注解-3" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=grid.length;</span><br><span class="line">    <span class="keyword">int</span> l=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;l;i++)&#123;</span><br><span class="line">        grid[<span class="number">0</span>][i]+=grid[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;r;j++)&#123;</span><br><span class="line">        grid[j][<span class="number">0</span>]+=grid[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">            grid[i][j]=Math.min(grid[i-<span class="number">1</span>][j]+grid[i][j],grid[i][j-<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[r-<span class="number">1</span>][l-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型二：序列"><a href="#类型二：序列" class="headerlink" title="类型二：序列"></a>类型二：序列</h2><p>常见处理方式是给 0 位置占位，这样处理问题时一视同仁，初始化则在原来基础上 length+1，返回结果 f[n]</p>
<ul>
<li>状态可以为前 i 个</li>
<li>初始化 length+1</li>
<li>取值 index=i-1</li>
<li>返回值：f[n]或者 f[m][n]</li>
</ul>
<h3 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">热题100-70. 爬楼梯</a></strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p>状态定义：创建dp数组（长度为n+1），dp[i]表示跳上i阶台阶时的跳法</p>
</li>
<li><p>转移方程：跳上第i阶台阶有两种方式，一个是从i-2阶跳两个台阶，一个是从i-1阶跳一个台阶，这样就有了状态转移方程</p>
</li>
<li><p>$$<br>f(i)=f(i−1)+f(i−2)<br>$$</p>
</li>
<li><p>初始化：因为要从前两个状态得到第i个状态，所以给0,1赋值</p>
</li>
<li><p>返回值：返回dp[n]</p>
</li>
</ul>
<h4 id="代码及注解-4"><a href="#代码及注解-4" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer-10- I. 斐波那契数列</a></strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 </p>
</blockquote>
<h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><p>注意这里的首相为0，不是1</p>
<h4 id="代码及注解-5"><a href="#代码及注解-5" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">热题100-53. 最大子序和</a></strong></p>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<h4 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>状态定义：创建dp数组，设dp[i]为以i元素结尾的子数组的最大累加和子数组</li>
<li>转移方程：dp[i]状态可以由dp[i-1]状态转移过来，选取dp[i-1]+arr[i]和arr[i]的较大值，也就是当前面最大值为负数时，直接选取这个元素本身作为最大值</li>
<li>初始化：dp[i]=0</li>
<li>返回值：返回dp[n]</li>
</ul>
<blockquote>
<p><strong>Note：</strong>因为第i个状态只与前一个状态有关，可以只用一个变量preSume来代替dp数组，大大降低空间复杂度</p>
</blockquote>
<h4 id="代码及注解-6"><a href="#代码及注解-6" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> preSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        preSum=Math.max(nums[i],preSum+nums[i]);<span class="comment">//当preSum为负数时，另preSum=nums[i]，也就是index=i结尾的子串最大值为它本身</span></span><br><span class="line">        maxValue=Math.max(preSum,maxValue);<span class="comment">//用maxValue来记录第i个数结尾的连续子数组的最大和的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四-1"><a href="#题目四-1" class="headerlink" title="题目四"></a>题目四</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">热题100-152. 乘积最大子数组</a></strong></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
</blockquote>
<h4 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong>假如我们把dp[i]作为第i个元素结尾的子数组的最大乘积，那么这个状态怎么得到呢，只由i-1状态的最大值是得不到的，该题的关键是：<strong>当nums[i]为负数时，前面的最大值乘完变最小值，最小值乘完变最大值</strong>，所以还要创建一个dp数组，来保存每个元素结尾的子数组的最小乘积。</p>
</li>
<li><p><strong>转移方程：</strong></p>
<p><strong>当nums[i]&gt;=0时：</strong></p>
<ul>
<li><p>dpMax[i]=Math.max(dpMax[i-1]*nums[i],nums[i]);</p>
</li>
<li><p>dpMin[i]=Math.min(dpMin[i-1]*nums[i],nums[i]);</p>
</li>
</ul>
<p><strong>当nums[i]&lt;0时：</strong></p>
<ul>
<li>dpMax[i]=Math.max(dpMin[i-1]*nums[i],nums[i]);</li>
<li>dpMin[i]=Math.min(dpMax[i-1]*nums[i],nums[i]);</li>
</ul>
</li>
<li><p><strong>初始化：</strong>dpMax[0]=dpMin[0]=nums[0]</p>
</li>
<li><p><strong>返回值：</strong>返回最大值</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>因为第i个状态只与前一状态的最大最小值有关，所以可以用preMax和preMin两个变量代替</p>
</blockquote>
<h4 id="代码及注解-7"><a href="#代码及注解-7" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tempMax=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> tempMin=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=tempMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=tempMax;</span><br><span class="line">            tempMax=tempMin;</span><br><span class="line">            tempMin=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        tempMax=Math.max(tempMax*nums[i],nums[i]);</span><br><span class="line">        tempMin=Math.min(tempMin*nums[i],nums[i]);</span><br><span class="line"></span><br><span class="line">        max=Math.max(tempMax,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">热题100-139. 单词拆分</a></strong></p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词的列表 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
</blockquote>
<h4 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h4><p>状态定义：dp[i]表示以i结尾的子串，能否被分割</p>
<p>状态转移：dp[i]可以由前面的结果得到，需要遍历i元素前的子串，将子串分为两部分，如果有一部分已经得到&amp;另一部分在字典中能查到，则dp[i]=true</p>
<p>初始化：将dp[0]=true，表示整个子串都能在字典中查到</p>
<p>返回值：返回dp[s.length()]</p>
<h4 id="代码及注解-8"><a href="#代码及注解-8" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; Dict=<span class="keyword">new</span> HashSet&lt;String&gt;(wordDict);</span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;Dict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目六（打家劫舍）"><a href="#题目六（打家劫舍）" class="headerlink" title="题目六（打家劫舍）"></a>题目六（打家劫舍）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">热题100-198. 打家劫舍</a></strong></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<h4 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>滚动数组法：</strong></p>
<ul>
<li><p><strong>状态定义：</strong>每个房间都有偷/不偷两种选择，用dp0和dp1分别表示不偷i个房间和偷i个房间能获得的最大价值</p>
</li>
<li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p>
<p>选择偷第i个房间时：dp1=dp[0]+nums[i];</p>
<p>选择不偷第i个房间：dp0=Math.max(dp0，dp1);</p>
<p>这里可以用temp暂存前一天的一个状态</p>
</li>
<li><p><strong>初始化：</strong>dp0=0，dp1=nums[0]</p>
</li>
<li><p><strong>返回值：</strong>返回dp0和dp1的较大值</p>
</li>
</ul>
<h4 id="代码及注解-9"><a href="#代码及注解-9" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp0=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp1=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=dp0;</span><br><span class="line">        dp0=Math.max(dp0,dp1);</span><br><span class="line">        dp1=Math.max(temp+nums[i],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp0,dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目七（打家劫舍）"><a href="#题目七（打家劫舍）" class="headerlink" title="题目七（打家劫舍）"></a>题目七（打家劫舍）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a></strong></p>
<p>二叉树中不能偷取直接相连的节点</p>
</blockquote>
<h4 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong>每个节点都有偷/不偷两种选择，用temp[0]和temp[1]分别表示不偷和偷该节点能获得的最大价值</p>
</li>
<li><p><strong>转移方程：</strong>对于第i个房间的状态，可以由前一个状态得到</p>
<p>当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</p>
<p>当选择偷root节点时，只能是它的值加上左右孩子都不偷时的值</p>
<p>递归中将这两个状态装入数组返回</p>
</li>
<li><p><strong>初始化：</strong>相当于递归终止时返回的数组，也就是都是0</p>
</li>
<li><p><strong>返回值：</strong>返回res[0],res[1]的较大值</p>
</li>
</ul>
<h4 id="代码及注解-10"><a href="#代码及注解-10" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;<span class="comment">//这个方法举个例子更好理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res=robInternal(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] robInternal(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] left=robInternal(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right=robInternal(root.right);</span><br><span class="line">    temp[<span class="number">0</span>]=Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>])+Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);<span class="comment">//当选择不偷root节点时，它的左右孩子节点是可偷可不偷的，所以要选择偷/不偷时较大的那个</span></span><br><span class="line">    temp[<span class="number">1</span>]=root.val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目八（股票）"><a href="#题目八（股票）" class="headerlink" title="题目八（股票）"></a>题目八（股票）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">热题100-121. 买卖股票的最佳时机</a></strong></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
</blockquote>
<h4 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h4><p>较简单，略</p>
<h4 id="代码及注解-11"><a href="#代码及注解-11" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowprice=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        profit=Math.max(profit,prices[i]-lowprice);</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;lowprice)&#123;</span><br><span class="line">            lowprice=prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目九（股票）"><a href="#题目九（股票）" class="headerlink" title="题目九（股票）"></a>题目九（股票）</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4892d3ff304a4880b7a89ba01f48daf9?tpId=190&tqId=36950&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-股票交易的最大收益</strong></a></p>
<p>假定你知道某只股票每一天价格的变动。 </p>
<p>你最多可以同时持有一只股票。但你最多只能进行<strong>两次</strong>交易（一次买进和一次卖出记为一次交易。买进和卖出均无手续费）。 </p>
<p> 请设计一个函数，计算你所能获得的最大收益。</p>
</blockquote>
<h4 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong></p>
<p>一天结束时，可能有持股、可能未持股、可能卖出过1次、可能卖出过2次、也可能未卖出过</p>
<p>所以定义状态转移数组dp[天数] [当前是否持股] [卖出的次数]</p>
</li>
<li><p><strong>转移方程：</strong></p>
<p>第i天的状态由第i-1天的状态得到</p>
<p>具体一天结束时的5种状态：</p>
<p>未持股，未卖出过股票：说明从未进行过买卖，利润为0<br>dp[i] [0] [0]=0<br>未持股，卖出过1次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [1]=max(dp[i-1] [1] [0]+prices[i],dp[i-1] [0] [1])<br>未持股，卖出过2次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）<br>dp[i] [0] [2]=max(dp[i-1] [1] [1]+prices[i],dp[i-1] [0] [2])<br>持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [0]=max(dp[i-1] [0] [0]-prices[i],dp[i-1] [1] [0])<br>持股，卖出过1次股票：可能是今天买的，也可能是之前买的（昨天也持股）<br>dp[i] [1] [1]=max(dp[i-1] [0] [1]-prices[i],dp[i-1] [1] [1])</p>
</li>
<li><p><strong>初始化：</strong></p>
<p> dp[0] [0] [0] = 0;//第一天休息</p>
<p>dp[0] [0] [1] = dp[0] [1] [1] = MIN_VALUE;//不可能</p>
<p>dp[0] [0] [2] = MIN_VALUE;//不可能</p>
<p>dp[0] [1] [0] = -prices[0];//买股票</p>
</li>
<li><p><strong>返回值：</strong>返回最后一天，不持股的两种状态</p>
</li>
</ul>
<h4 id="代码及注解-12"><a href="#代码及注解-12" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> MIN_VALUE = Integer.MIN_VALUE / <span class="number">2</span>;<span class="comment">//因为最小值再减去1就是最大值Integer.MIN_VALUE-1=Integer.MAX_VALUE</span></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天休息</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] = MIN_VALUE;<span class="comment">//不可能</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//买股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="number">0</span>, Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十（股票）"><a href="#题目十（股票）" class="headerlink" title="题目十（股票）"></a>题目十（股票）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">热题100-309. 最佳买卖股票时机含冷冻期</a></strong></p>
<p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
</blockquote>
<h4 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><p><strong>状态定义：</strong></p>
<p><strong>一天结束时</strong>，可能有持股、不持股两种状态，并且不持股分为处于冷冻期、不处于冷冻期两种状态</p>
<p>定义状态转移数组dp[i] [0] 、dp[i] [1] 、dp[i] [2] </p>
</li>
<li><p><strong>转移方程：</strong></p>
<p>具体一天的三种状态：</p>
<p>持股的状态，要么前一天持股，要么前一天不持股在i天买入</p>
<p>dp[i] [0] =Math.max(dp[i-1] [0]，dp[i-1] [2]-prices[i])</p>
<p>不持股&amp;处于冷冻期的状态，前一天必须持股而且在第i天卖出</p>
<p>dp[i] [1]=dp[i-1] [0]+prices[i]</p>
<p>不持股&amp;不处于冷冻期，前一天就不持股，对应两种状态</p>
<p>dp[i] [2]=Math.max(dp[i-1] [1],dp[i-1] [2])</p>
</li>
<li><p><strong>初始化：</strong></p>
<p>第一天：</p>
<p>dp[0] [0]=-prices[0];买入</p>
<p>dp[0] [1]=0;不存在的状态</p>
<p>dp[0] [2]=0;什么也不干</p>
</li>
<li><p><strong>返回值：</strong>返回不持股状态的两种较大值</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>这里第i天的状态只与前一天的三种状态有关，所以可以用三个变量代替dp数组</p>
</blockquote>
<h4 id="代码及注解-13"><a href="#代码及注解-13" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;prices.length;x++)&#123;</span><br><span class="line">           <span class="keyword">int</span> ii=Math.max(i,k);</span><br><span class="line">           <span class="keyword">int</span> jj=Math.max(j,i-prices[x]);</span><br><span class="line">           <span class="keyword">int</span> kk=j+prices[x];</span><br><span class="line">           i=ii;</span><br><span class="line">           j=jj;</span><br><span class="line">           k=kk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(i,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十一（回文串）"><a href="#题目十一（回文串）" class="headerlink" title="题目十一（回文串）"></a>题目十一（回文串）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindromic-substrings/">热题100-647. 回文子串</a></strong></p>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
</blockquote>
<h4 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>两层循环，考察所有子串，判断是否是回文串。</li>
<li>时间复杂度 O(n^3)：串的长度为n，每个点的比较次数：0+1+2+……+n=（n+1）*n/2，所以是n^3</li>
<li>空间复杂度：O(n^2)：用到二维数组</li>
</ul>
<p><strong>思路：</strong></p>
<ul>
<li>大问题是一个子串是否是回文串，然后统计有几个回文子串，那规模小一点的子问题呢？</li>
<li>一个子串是回文串，刨去相同的首尾字符，剩下的子串也必须是回文串。</li>
<li>剩下的子串是否为回文串，就是规模小一点的子问题，它影响大问题的结果。</li>
</ul>
<p>用二维 Boolean 数组记录中間子问题的解，从base case出发，递推出每个子问题的解。</p>
<p><strong>s[i:j] 是回文的情况：</strong></p>
<p><strong>首先i和j元素必须相同的前提下，满足下面任意一条</strong></p>
<ul>
<li>当只有单个字符时</li>
<li>由两个字符组成</li>
<li>超过两个字符的情况，<strong>剩余的子串是一个回文串</strong>（这个要用到前面子问题的解）</li>
</ul>
<h4 id="代码及注解-14"><a href="#代码及注解-14" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">      <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//记录回文串的个数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                  <span class="keyword">if</span>(flag[j][i]=i==j||i-j==<span class="number">1</span>||flag[j+<span class="number">1</span>][i-<span class="number">1</span>])&#123;</span><br><span class="line">                      count++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十二（回文串）"><a href="#题目十二（回文串）" class="headerlink" title="题目十二（回文串）"></a>题目十二（回文串）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">热题100-5. 最长回文子串</a></strong></p>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
</blockquote>
<h4 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h4><p>同上</p>
<h4 id="代码及注解-15"><a href="#代码及注解-15" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j||flag[j+<span class="number">1</span>][i-<span class="number">1</span>]||i-j==<span class="number">1</span>)&#123;</span><br><span class="line">                    flag[j][i]=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i-j&gt;=maxLength)&#123;</span><br><span class="line">                        maxLength=i-j+<span class="number">1</span>;</span><br><span class="line">                        start=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,start+maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十三"><a href="#题目十三" class="headerlink" title="题目十三"></a>题目十三</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=/activity/oj&qru=/ta/job-code-high-rd/question-ranking&tab=answerKey"><strong>牛客-最长递增子序列</strong></a></p>
<p>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）</p>
<p><strong>这个题要用贪心+二分法，否则在牛客上不能通过</strong></p>
</blockquote>
<h4 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>动态规划：</strong></p>
<ul>
<li>通过一个maxlens数组，记录每个元素结尾的最长递增子序列的长度，通过一个maxlen来记录最大的长度</li>
<li>对于maxlens[i]，要在区间[0，i]遍历maxlens数组，找到arr[i]&gt;arr[j]时的元素，不断地更新maxlens[i]</li>
<li>这种方式的时间复杂度为n^2，会出现超时的情况</li>
</ul>
<p><strong>贪心+二分：</strong></p>
<ul>
<li>仍然用maxlens数组，记录每个元素结尾的最长递增子序列的长度，maxlen来记录最大的长度</li>
<li>不同的是还要维护一个tails数组，tail[i]表示长度为 i 的最长上升子序列的末尾元素的最小值，比如：数组 [2, 3, 1, 4, 6]中tails最终为[1,4,6]，依次表示长度为1的最长上升子序列末尾的最小元素为1，长度为2的为4，长度为3的为6，这时如果后面再加个10那最长上升子序列的长度为4时，最小的结尾元素为10，如果再多个3，那么长度为2的最长上升子序列的结尾元素就要从4换成3。</li>
<li>这样一来，我们就可以通过二分法在tails数组中查找该元素结尾的最长上升子序列的最大长度</li>
<li>这种方式的时间复杂度变成n*logn</li>
</ul>
<p><strong>最后：（按字典序输出）</strong></p>
<p>假设我们原始数组是arr1，得到的maxLen为<code>[1,2,3,1,3]</code>，最终输出结果为res（字典序最小的最长递增子序列），res的最后一个元素在arr1中位置无庸置疑是<code>maxLen[i]==3</code>对应的下标，那么到底是<code>arr1[2]</code>还是<code>arr1[4]</code>呢？如果是<code>arr1[2]</code>，那么<code>arr1[2]&lt;arr1[4]</code>，则<code>maxLen[4]==4</code>，与已知条件相悖。因此我们应该取<code>arr1[4]</code>放在res的最后一个位置。</p>
<p>因为元素对应同样长度时，后面的元素小于等于前面的元素，否则后面的长度就会大于前面的长度了</p>
<h4 id="代码及注解-16"><a href="#代码及注解-16" class="headerlink" title="代码及注解"></a>代码及注解</h4><p><strong>动态规划代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            maxlens[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                    maxlens[i]=Math.max(maxlens[i],maxlens[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=Math.max(maxlen,maxlens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>贪心+二分代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * retrun the longest increasing subsequence</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] LIS (<span class="keyword">int</span>[] arr) &#123;<span class="comment">//贪心+二分，这里的动态规划会超时</span></span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n=arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] tails=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        tails[<span class="number">0</span>]=arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxlens=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        maxlens[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;tails[maxlen-<span class="number">1</span>])&#123;</span><br><span class="line">                tails[maxlen++]=arr[i];</span><br><span class="line">                maxlens[i]=maxlen;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> right=maxlen-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tails[mid]&lt;=arr[i])&#123;</span><br><span class="line">                        left=mid+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        right=mid-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tails[left]=arr[i];</span><br><span class="line">                maxlens[i]=++left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[maxlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>,j=maxlen-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxlens[i]==maxlen)&#123;</span><br><span class="line">                res[j]=arr[i];</span><br><span class="line">                j--;</span><br><span class="line">                maxlen--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十四（股票）"><a href="#题目十四（股票）" class="headerlink" title="题目十四（股票）"></a>题目十四（股票）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">力扣主站-122. 买卖股票的最佳时机 II</a></strong></p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<h4 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h4><h4 id="代码及注释"><a href="#代码及注释" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(prices.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp0=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp1=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=dp0;</span><br><span class="line">            dp0=Math.max(dp1+prices[i],dp0);</span><br><span class="line">            dp1=Math.max(temp-prices[i],dp1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目十五"><a href="#题目十五" class="headerlink" title="题目十五"></a>题目十五</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">热题100-10. 正则表达式匹配</a></strong></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
</blockquote>
<h4 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h4><p>设主串为S，模式串为P</p>
<p>整体上来看就是关注模式串P每加进来一个字符后，能否与主串匹配，而模式串中加进来的字符有三种可能：普通字符、’ . ‘、’ * ‘，然后分情况进行讨论：</p>
<p>进一步来说，因为’ . ‘可以表示任意的字符，所以可以进一步划分，也就是是不是’ * ‘</p>
<ul>
<li><p>如果不是’ * ‘：</p>
<p>如果是普通字符，且与主串中的字符相等</p>
<p>如果是’ . ‘</p>
<p>上面两种情况之一，且模式串 j-1 前的部分可以匹配主串 i-1 前的串，这时，dp[i] [j]=true</p>
<p>其它情况为false</p>
</li>
<li><p>如果是’ * ‘</p>
<p>1、如果 S 的前 i 个字符和 P 的前 j - 2 个字符匹配，这时 P 的第 j 个字符为’*’ ，那么无论p的第j-1个字符是什么，令它出现0次，dp[i] [j]就可以为true</p>
<p>2、如果 s 的前i - 1个字符和p的前j个字符匹配，并且s的第i个字符和p的第j - 1个字符相等，那么<strong>让 p 的第 j - 1个字符多出现一次，s的前i字符和p的前j的字符就可以匹配了</strong>（看到这句话，豁然开朗）</p>
<p>3、如果 S 的前i - 1个字符和 P 的前 j 个字符匹配，因为 P 的第 j - 1个字符为’ . ‘可以匹配任意字符，那么 S 的第 i 个字符可以匹配 P 的第j - 1个字符，令 P 的第 j - 1 个字符多出现一次即可（其实与第二种是同一种情况，就是P的第 j-1 个字符换成’ . ‘，可以匹配任意字符了）</p>
</li>
</ul>
<h4 id="代码及注释-1"><a href="#代码及注释-1" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">int</span> m=p.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.charAt(i-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==s.charAt(i-<span class="number">1</span>)||p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>)&amp;&amp;(dp[i][j-<span class="number">2</span>]||((s.charAt(i-<span class="number">1</span>)==p.charAt(j-<span class="number">2</span>)||p.charAt(j-<span class="number">2</span>)==<span class="string">&#x27;.&#x27;</span>)&amp;&amp;dp[i-<span class="number">1</span>][j])))&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型三：子序列-子串"><a href="#类型三：子序列-子串" class="headerlink" title="类型三：子序列/子串"></a>类型三：子序列/子串</h2><h3 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></strong></p>
<p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
</blockquote>
<h4 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li>A 、B数组各抽出一个子数组，单看它们的末尾项，如果它们俩不一样，则公共子数组肯定不包括它们俩。</li>
<li>如果它们俩一样，则要考虑它们俩前面的子数组<strong>「能为它们俩提供多大的公共长度」</strong>。<ul>
<li>如果它们俩的前缀数组的「末尾项」不相同，由于子数组的连续性，前缀数组不能为它们俩提供公共长度</li>
<li>如果它们俩的前缀数组的「末尾项」相同，则可以为它们俩提供公共长度：<pre><code>至于提供多长的公共长度？这又取决于前缀数组的末尾项是否相同……</code></pre>
</li>
</ul>
</li>
</ul>
<p>所以得出问题的子问题在于：前缀数组的最长重复子数组</p>
<h4 id="代码及注释-2"><a href="#代码及注释-2" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n=nums1.length;</span><br><span class="line">       <span class="keyword">int</span> m=nums2.length;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">       <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=m-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums1[i]==nums2[j])&#123;</span><br><span class="line">                   <span class="keyword">if</span>(i&lt;n-<span class="number">1</span>&amp;&amp;j&lt;m-<span class="number">1</span>)&#123;</span><br><span class="line">                       dp[i][j]=dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               maxLen=Math.max(maxLen,dp[i][j]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">主站-1143. 最长公共子序列</a></strong></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<h4 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h4><ol>
<li><p><strong>状态定义</strong></p>
<p>可以定义 dp[i] [j]表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。</p>
</li>
<li><p><strong>状态转移方程</strong></p>
<ul>
<li><p><strong>当 text1[i - 1] == text2[j - 1] 时：</strong>说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i] [j] = dp[i - 1] [j - 1] + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1。</p>
</li>
<li><p><strong>当 text1[i - 1] != text2[j - 1] 时：</strong>说明两个子字符串的最后一位不相等，那么此时的状态 dp[i] [j] 应该是 dp[i - 1] [j] 和 dp[i] [j - 1] 的最大值。举个例子，比如对于 ace 和 abc 而言，他们的最长公共子序列的长度等于 ① ace 和 ab 的最长公共子序列长度1 与 ② ac 和 abc 的最长公共子序列长度2 的最大值，即 2。（也就是说当最后一位 e != c 时，我们可以认为是 ac 和 ab 的基础上将 e 加进来，也就是 ace 和 ab 这两个子串的最长公共子序列的长度，另一种情况同理）</p>
<p>那为什么不是在dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]中选择最大的呢，因为dp[i-1] [j]和dp[i] [j-1]必定&gt;=dp[i-1] [j-1]。</p>
</li>
</ul>
</li>
<li><p><strong>状态的初始化</strong></p>
<p>初始化就是要看当 i = 0 与 j = 0 时， dp[i] [j] 应该取值为多少。</p>
<ul>
<li>当 i = 0 时，dp[0] [j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0；</li>
<li>当 j = 0 时，dp[i] [0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0；</li>
</ul>
<p>综上，当 i = 0 或者 j = 0 时，dp[i] [j] 初始化为 0.</p>
</li>
<li><p><strong>返回结果</strong></p>
<p><code>dp[i][j]</code> 的含义就是 <code>text1</code> 和 <code>text2</code> 的最长公共子序列</p>
</li>
</ol>
<h4 id="代码及注释-3"><a href="#代码及注释-3" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=text1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>)==text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类型四：零钱、背包问题"><a href="#类型四：零钱、背包问题" class="headerlink" title="类型四：零钱、背包问题"></a>类型四：零钱、背包问题</h2><h3 id="题目一（零钱）"><a href="#题目一（零钱）" class="headerlink" title="题目一（零钱）"></a>题目一（零钱）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">热题100-322. 零钱兑换</a></strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
</blockquote>
<h4 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h4><ul>
<li><strong>状态定义：</strong>dp[i]表示当为i元钱时，需要的硬币最少数目</li>
<li><strong>转移方程：</strong>dp[i]状态要遍历已经得到的dp数组，选择那个硬币最少数目作为dp[i]</li>
<li><strong>初始化：</strong>dp[0]=0，然后每次的dp[i]设为i+1，用于判断该元素是否找到了最少硬币数目的组合</li>
<li><strong>返回值：</strong>根据dp[i]是否有解，确定返回解还是无解</li>
</ul>
<blockquote>
<p><strong>Note：</strong>dp[i-coins[j]] 决策coins[j]是否参与</p>
</blockquote>
<h4 id="代码及注解-17"><a href="#代码及注解-17" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        dp[i]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;=<span class="number">0</span>&amp;&amp;dp[i-coins[j]]&lt;=i-coins[j])&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]&gt;amount? -<span class="number">1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目二-3"><a href="#题目二-3" class="headerlink" title="题目二"></a>题目二</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">热题100-279. 完全平方数</a></strong></p>
<p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
</blockquote>
<h4 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h4><p>同零钱问题</p>
<h4 id="代码及注解-18"><a href="#代码及注解-18" class="headerlink" title="代码及注解"></a>代码及注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从下到上地求得每个数的完全平方数的最少个数</span></span><br><span class="line"><span class="comment">    当遍历到i时，从i中减去j的平方(j是递增的)，看当前的dp[i]和从i中减去j的平方后的数+1（因为从i中减去一个平方数j得到dp数组中索引位置index=i-j*j处，因此为dp[i-j*j]+1）哪个小选哪个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;i-j*j&gt;=<span class="number">0</span>;j++)&#123;<span class="comment">//结束条件是大于等于0，等于0也是可以的，比如4-2*2=0,说明正好正好为0，只用一个平方数就可以得到，而当大于0时，这种只用一个平方数的情况就给排除了</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目三（01背包）"><a href="#题目三（01背包）" class="headerlink" title="题目三（01背包）"></a>题目三（01背包）</h3><p><strong>总结在先：（两层循环）</strong></p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由大到小）。</li>
</ul>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></strong></p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<h4 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h4><p>作为「0-1 背包问题」，它的特点是：<strong>「每个数只能用一次」</strong>。</p>
<p>解决的基本思路是：<strong>物品一个一个选，容量也一点一点增加去考虑</strong>。</p>
<p>具体做法是：画一个 <strong>len</strong> 行，<strong>target + 1</strong> 列的表格。这里 <strong>len</strong> 是物品的个数，<strong>target</strong> 是背包的容量。<strong>len</strong> 行表示一个一个物品考虑，<strong>target + 1</strong>多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。</p>
<ol>
<li><p><strong>状态的定义：</strong>我们定义dp[i] [j]为当我们选取前 i 个物品时，能否填满容量为 j 的背包</p>
</li>
<li><p><strong>状态的转移：</strong>当我们用前 i 个物品去填满容量为 j 的背包时，看它能否填满，就要分第 i 个物品选还是不选（01）的情况</p>
<p>对于第 i 个物品，还要分能不能选的问题，也就是背包容量 j 是否能够容纳第 i 个物品，于是有：</p>
<p>当 j-nums[i]&lt;0 （不能容纳）：dp[i] [j]=dp[i-1] [j] （等于用前 i-1 个物品能否填满容量为 j 的背包状态）</p>
<p>当 j-nums[i]&gt;=0 （能容纳）：dp[i] [j]=dp[i-1] [j]||dp[i-1] [j-nums[i]]（<strong>不选：</strong>等于用前 i-1 个物品能否填满容量为 j 的背包状态，<strong>选：</strong>此时的背包容量要减去nums[i]，等于用前 i-1 个物品能否填满容量为 j-nums[i] 的背包状态）</p>
</li>
<li><p><strong>初始化：</strong>dp[0] [0] =  true，第一行，也就是背包容量与第一个元素相等时为 true</p>
</li>
<li><p><strong>返回值：</strong>返回dp[nums.length-1] [target]，中间也可以进行剪枝操作，只要发现有一种子集满足就可以返回，也就是表格的最后一列是 true 就可以返回。</p>
</li>
</ol>
<p>表格：如 nums = [1,5,11,5]，target=11时</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>0（1）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td align="center"><strong>1（5）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
<tr>
<td align="center"><strong>2（11）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T（返回）</strong></td>
</tr>
<tr>
<td align="center"><strong>3（5）</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td>F</td>
<td>F</td>
<td>F</td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
</tr>
</tbody></table>
<p>举个例子：当nums[1]=5这个元素可以选择时，背包容量增大到 5 时，当不把 5 加到背包中时，发现只用nums[0]=1这个元素填不满，选择把 5 加入到背包中时，就应该等于dp[0] [0]，也就是剩余背包容量正好是 0 ，所以状态为 true ，这也是为什么要将dp[0] [0] 初始化为 true 的原因</p>
<h4 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h4><ol>
<li><strong>（重要）</strong>在「填表格」的时候，当前行<strong>只参考了上一行的值</strong>，因此状态数组可以只设置 222 行，使用「滚动数组」的技巧「填表格」即可；</li>
<li><strong>（重要）</strong>实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，<strong>当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值</strong>。因此，我们可以只开一个一维数组，从后向前依次填表即可。</li>
<li>「从后向前」 写的过程中，一旦 nums[i] &lt;= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。</li>
</ol>
<h4 id="代码及注释（二维）"><a href="#代码及注释（二维）" class="headerlink" title="代码及注释（二维）"></a>代码及注释（二维）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target=sum/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length][target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=nums[<span class="number">0</span>]==j? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i-<span class="number">1</span>][j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][target]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="代码及注释（一维）"><a href="#代码及注释（一维）" class="headerlink" title="代码及注释（一维）"></a>代码及注释（一维）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target=sum/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">boolean</span>[] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;<span class="comment">//只对dp[0]初始化就可以，因为第一次dp[j-nums[i]]，当j-nums[i]=0时，那些位置就会为true</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=nums[i];j--)&#123;</span><br><span class="line">            dp[j]=dp[j]||dp[j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目四（01背包）"><a href="#题目四（01背包）" class="headerlink" title="题目四（01背包）"></a>题目四（01背包）</h3><blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">主站-494. 目标和</a></strong></p>
</blockquote>
<h4 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h4><p>重要的是这道题怎么转换成01背包问题：</p>
<ul>
<li>我们想要的 S = 正数和 - 负数和 = x - y</li>
<li>而已知 x 与 y 的和是数组总和：x + y = sum</li>
<li>可以求出 x = (S + sum) / 2 = target</li>
<li>也就是我们要从 nums 数组里选出几个数，令其和为 target（target 间接给出）。</li>
<li>于是转化为是否可以用 nums 中的数组合和成 target，01 背包问题，外层循环为选择池 nums，内层循环为 target。</li>
</ul>
<p>dp[i] 表示和为 i 的 num 组合有 dp[i] 种。</p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由大到小）。</li>
</ul>
<p>对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后即可得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i − num] 之和。（类似于跳台阶问题）</p>
<p>dp[i] = dp[i] + dp[i - num]</p>
<p>对于边界条件，我们定义 dp[0] = 1 表示只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。<br>最后返回 dp[target]</p>
<h4 id="代码及注释-4"><a href="#代码及注释-4" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S&gt;sum||(sum+S)%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target=(sum+S)/<span class="number">2</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=target;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目五（完全背包）"><a href="#题目五（完全背包）" class="headerlink" title="题目五（完全背包）"></a>题目五（完全背包）</h3><p><strong>总结在先：（两层循环）</strong></p>
<ul>
<li>外层遍历 nums 每个 num；</li>
<li>内层遍历 target（由小到大）。</li>
</ul>
<blockquote>
<p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">主站-518. 零钱兑换 II</a></strong></p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
</blockquote>
<h4 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>通过对比01背包和完全背包的循环，可以看到内层遍历背包容量时，一个是从大到小，一个是从小到大</strong></p>
<ul>
<li><p>01背包从大到小：因为01背包中的每个元素<strong>只能用一次</strong>，当从小到大改变每个容量对应的组合数时，后面元素参考的值不再是这个元素选与不选的问题，而是这个元素选了几次的问题。</p>
</li>
<li><p>完全背包从小到大：因为完全背包中的元素是无限的，所以一个元素可以多次使用作为组合来填满背包，需要从小到大地改变每个容量对应的组合数。</p>
<p>举个例子，数组为[2,2,3,5]，要找和为6的组合数</p>
<p>当 i = 0时，dp[4]为 [0] ，</p>
<p>当 i 自增到1，nums[i] =  2，j = 4时，dp[4] = dp[4] + dp[4 -  2]；当 i 不变，j = 6时,dp[6] = dp [6] + dp [6 - 2]，而dp[4]相当于 j = 4 容量时，已经放入了 nums[i] = 2这个物品，这样一来就重复的放入了该物品，所以不满足01背包的要求，但是换成完全背包就可以，它就是要得到一个物品多次放入的组合数</p>
</li>
</ul>
<p><strong>组合数与排列数：</strong></p>
<ul>
<li><p><strong>组合数中的方案不能使用相同元素</strong></p>
<p>当外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设：coins[0] = 1，coins[1] = 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
</li>
<li><p><strong>排列数元素相同但是顺序不同就算一种方案</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
</li>
</ul>
<h4 id="代码及注释-5"><a href="#代码及注释-5" class="headerlink" title="代码及注释"></a>代码及注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">               dp[j]+=dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%AF%87/" rel="tag"><i class="fa fa-tag"></i>  基础算法篇</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/25/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" rel="prev" title="二分搜索">
      <i class="fa fa-chevron-left"></i> 二分搜索
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="next" title="滑动窗口">
      滑动窗口 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">算法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%82%B9%E8%A6%81%E7%B4%A0"><span class="nav-number">1.2.</span> <span class="nav-text">四点要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">常见四种类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="nav-number">2.</span> <span class="nav-text">相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%80%EF%BC%9A%E7%9F%A9%E9%98%B5"><span class="nav-number">2.1.</span> <span class="nav-text">类型一：矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80"><span class="nav-number">2.1.1.</span> <span class="nav-text">题目一</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">题目二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-1"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">题目三</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-2"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B"><span class="nav-number">2.1.4.</span> <span class="nav-text">题目四</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-3"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%BA%8C%EF%BC%9A%E5%BA%8F%E5%88%97"><span class="nav-number">2.2.</span> <span class="nav-text">类型二：序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">题目一</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-4"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">题目二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-5"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89-1"><span class="nav-number">2.2.3.</span> <span class="nav-text">题目三</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-6"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B-1"><span class="nav-number">2.2.4.</span> <span class="nav-text">题目四</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-7"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%94"><span class="nav-number">2.2.5.</span> <span class="nav-text">题目五</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-8"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%85%AD%EF%BC%88%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%89"><span class="nav-number">2.2.6.</span> <span class="nav-text">题目六（打家劫舍）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-9"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-9"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%83%EF%BC%88%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%89"><span class="nav-number">2.2.7.</span> <span class="nav-text">题目七（打家劫舍）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-10"><span class="nav-number">2.2.7.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-10"><span class="nav-number">2.2.7.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%85%AB%EF%BC%88%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="nav-number">2.2.8.</span> <span class="nav-text">题目八（股票）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-11"><span class="nav-number">2.2.8.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-11"><span class="nav-number">2.2.8.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B9%9D%EF%BC%88%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="nav-number">2.2.9.</span> <span class="nav-text">题目九（股票）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-12"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-12"><span class="nav-number">2.2.9.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%EF%BC%88%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="nav-number">2.2.10.</span> <span class="nav-text">题目十（股票）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-13"><span class="nav-number">2.2.10.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-13"><span class="nav-number">2.2.10.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%E4%B8%80%EF%BC%88%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%89"><span class="nav-number">2.2.11.</span> <span class="nav-text">题目十一（回文串）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-14"><span class="nav-number">2.2.11.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-14"><span class="nav-number">2.2.11.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%E4%BA%8C%EF%BC%88%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%89"><span class="nav-number">2.2.12.</span> <span class="nav-text">题目十二（回文串）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-15"><span class="nav-number">2.2.12.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-15"><span class="nav-number">2.2.12.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%E4%B8%89"><span class="nav-number">2.2.13.</span> <span class="nav-text">题目十三</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-16"><span class="nav-number">2.2.13.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-16"><span class="nav-number">2.2.13.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%E5%9B%9B%EF%BC%88%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="nav-number">2.2.14.</span> <span class="nav-text">题目十四（股票）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-17"><span class="nav-number">2.2.14.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A"><span class="nav-number">2.2.14.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%8D%81%E4%BA%94"><span class="nav-number">2.2.15.</span> <span class="nav-text">题目十五</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-18"><span class="nav-number">2.2.15.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-1"><span class="nav-number">2.2.15.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%89%EF%BC%9A%E5%AD%90%E5%BA%8F%E5%88%97-%E5%AD%90%E4%B8%B2"><span class="nav-number">2.3.</span> <span class="nav-text">类型三：子序列&#x2F;子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">题目一</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-19"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-2"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">题目二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-20"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-3"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%9B%9B%EF%BC%9A%E9%9B%B6%E9%92%B1%E3%80%81%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">类型四：零钱、背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%80%EF%BC%88%E9%9B%B6%E9%92%B1%EF%BC%89"><span class="nav-number">2.4.1.</span> <span class="nav-text">题目一（零钱）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-21"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-17"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%8C-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">题目二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-22"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E8%A7%A3-18"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">代码及注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%B8%89%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">2.4.3.</span> <span class="nav-text">题目三（01背包）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-23"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">空间优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A%EF%BC%88%E4%BA%8C%E7%BB%B4%EF%BC%89"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">代码及注释（二维）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A%EF%BC%88%E4%B8%80%E7%BB%B4%EF%BC%89"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">代码及注释（一维）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%9B%9B%EF%BC%8801%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">题目四（01背包）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-24"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-4"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E4%BA%94%EF%BC%88%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">2.4.5.</span> <span class="nav-text">题目五（完全背包）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-25"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%B3%A8%E9%87%8A-5"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">代码及注释</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">911k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:48</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414234405762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020041418134522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414224348666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/02.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181126151900484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_86,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_50">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181126161842605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_90,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-03-13T15:35:53.000Z">
<meta property="article:modified_time" content="2021-04-06T13:54:54.284Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"><link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-13 23:35:53" itemprop="dateCreated datePublished" datetime="2021-03-13T23:35:53+08:00">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 21:54:54" itemprop="dateModified" datetime="2021-04-06T21:54:54+08:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-计算机网络参考模型"><a href="#1-计算机网络参考模型" class="headerlink" title="1.计算机网络参考模型"></a>1.计算机网络参考模型</h1><h2 id="1-1OSI七层模型与TCP-IP五层模型"><a href="#1-1OSI七层模型与TCP-IP五层模型" class="headerlink" title="1.1OSI七层模型与TCP/IP五层模型"></a>1.1OSI七层模型与TCP/IP五层模型</h2><ul>
<li>OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层；</li>
<li>TCP/IP4层模型：网络接口层，网络层(IP)，运输层(TCP/UDP)，应用层(HTTP)；</li>
<li>5层模型：物理层，数据链路层，网络层，运输层，应用层；</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<h2 id="1-2每层的功能及相关协议"><a href="#1-2每层的功能及相关协议" class="headerlink" title="1.2每层的功能及相关协议"></a>1.2每层的功能及相关协议</h2><h3 id="1-2-1应用层"><a href="#1-2-1应用层" class="headerlink" title="1.2.1应用层"></a>1.2.1应用层</h3><p><strong>应用层的任务：</strong>通过进程间的交互来完成特定的网络应用。</p>
<p><strong>应用层协议：</strong>定义的是应用进程间的通信和交互规则，对于不同的网络需要不同的应用层协议：<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p>
<h3 id="1-2-2传输层"><a href="#1-2-2传输层" class="headerlink" title="1.2.2传输层"></a>1.2.2传输层</h3><p><strong>运输层的任务：</strong>就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个进程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p><strong>运输层主要使用以下两种协议:</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<h3 id="1-2-3网络层"><a href="#1-2-3网络层" class="headerlink" title="1.2.3网络层"></a>1.2.3网络层</h3><p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。</strong></p>
<p><strong>网络层的任务：</strong>选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p><strong>网络层的相关协议：</strong></p>
<ol>
<li>IP协议</li>
<li>ICMP：为了提高IP数据报交付成功的机会，在网络层使用了<code>网际控制报文协议</code>(Internet Control Message Protocol, <code>ICMP</code>)来<code>让主机或路由器报告差错和异常情况</code>。</li>
<li>IGMP</li>
<li>OSPF：外部网关协议</li>
<li>RIP：内部网关协议</li>
<li>ARP：将IP地址解析为MAC地址</li>
</ol>
<p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p>
<p>另外像<strong>路由器</strong>这种硬件设备就工作在<strong>网络层</strong></p>
<h3 id="1-2-4数据链路层"><a href="#1-2-4数据链路层" class="headerlink" title="1.2.4数据链路层"></a>1.2.4数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。<br>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<h3 id="1-2-5物理层"><a href="#1-2-5物理层" class="headerlink" title="1.2.5物理层"></a>1.2.5物理层</h3><p>在物理层上所传送的数据单位是比特。<br> <strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h1 id="2-网络层"><a href="#2-网络层" class="headerlink" title="2.网络层"></a>2.网络层</h1><h2 id="2-1ARP协议"><a href="#2-1ARP协议" class="headerlink" title="2.1ARP协议"></a>2.1ARP协议</h2><ul>
<li>ARP是IP地址解析为MAC地址 ；</li>
<li>RARP 将MAC地址解析为IP地址。</li>
</ul>
<p>每台主机都设有一个ARP高速缓存，用来存放本局域网内各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP来动态维护此ARP表。</p>
<p><strong>IP数据报的传输过程（IP源、目的地址始终不变；MAC源、目的地址在变化）：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>假如主机A的某个应用程序需要发送数据到主机B的某个应用程序，IP数据报在互联网中的传输与处理大致要经历如下过程：</strong></p>
<ol>
<li><p><strong>主机发送IP数据报</strong></p>
<p>如果主机A要发送数据给互联网上的另一台主机B，那么，主机A首先要构造一个目的IP地址为主机B的IP数据报（目的IP地址=10.3.0.88），然后对数据报进行路由选择。利用路由选择算法和主机A的路由表（见表1-1）可以得到，目的主机B和主机A不在同一网络，需要将该数据报转发到默认路由器R2（IP地址10.1.0.1）。</p>
<p>尽管主机A需要将数据报首先送到它的默认路由器R2而不是目的主机B，但是它既不会修改原IP数据报的内容，也不会在原IP数据报上面附加内容（甚至不附加下一默认路由器的IP地址）。那么，主机A怎样将数据报发送给下一路由器呢？在发送数据报之前，主机A首先调用ARP地址解析软件，得到下一默认路由器IP地址与MAC地址的映射关系，然后以该MAC地址为帧的目的地址形成一个帧，并将IP数据报封装在帧的数据区，最后由具体的物理网络（以太网）完成数据报的真正传输。由此可见，在为IP数据报选路时主机A使用数据报的目的IP地址，并且得到的是默认路由器R2的IP地址。但真正的数据传输是通过将IP数据报封装成帧，并利用默认路由器R2的MAC地址实现的。</p>
</li>
<li><p><strong>路由器R2处理和转发IP数据报</strong></p>
<p>路由器R2接收到主机A发送给它的帧后，去掉帧头，并把IP数据报提交给IP软件处理。由于该IP数据报的目的地并不是路由器R2，因此R2需要将它转发出去。利用路由选择算法和路由器R2的路由表（见表1-3）可知，如果要到达数据报的目的地，必须将它投递到IP地址为10.2.0.2的路由器（路由器R3）。</p>
<p>通过以太网投递时，路由器R2需要调用ARP地址解析软件，得到路由器R3的IP地址与MAC地址的映射关系，并利用该MAC地址作为帧的目的地址将IP数据报封装成帧，最后由以太网完成真正的数据投递。</p>
<p>需要注意的是，路由器在转发数据之前，IP软件需要从数据报报头的“生存周期”减去一定的值。若“生存周期”小于或等于0，则抛弃该报文；否则，重新计算IP数据报的校验和并继续转发。</p>
</li>
<li><p><strong>路由器R3处理和转发IP数据报</strong></p>
<p>与路由器R2相同，路由器R3接收到路由器R2发送的帧后也需要去掉帧头，并把IP数据报提交给IP软件处理。与路由器R2不同，路由器R3在路由选择过程中发现该数据报指定的目的网络与自己直接相连，可以直接投递。于是，路由器R3调用ARP地址解析软件得到主机B的IP地址与MAC地址的映射关系，利用该MAC地址作为帧的目的地址，将IP数据报封装成帧，并由以太网实现数据的真正传递。</p>
</li>
<li><p><strong>主机B接收IP数据报</strong></p>
<p>当封装IP数据报的帧到达主机B后，主机B对该帧进行解封装，并将IP数据报送主机B上的IP软件处理。IP软件确认该数据报的目的IP地址10.3.0.88为自己的IP地址后，将IP数据报中封装的数据信息送交高层协议软件处理。</p>
<p>从IP数据报在互联网中被处理和传递的过程可以看到，每个路由器都是一个自治的系统，它们根据自己掌握的路由信息对每一个IP数据报进行路由选择和转发。路由表在路由选择过程中发挥着重要作用，如果一个路由器的路由表发生变化，到达目的网络所经过的路径就有可能发生变化。例如，假如主机A路由表中的默认路由不是路由表R2（10.1.0.1），而是路由器R1（10.1.0.2），那么，主机A发往主机B的IP数据报就不会沿A-R2-R3-B，它将通过R1到达主机B。</p>
<p>另外，图1-1所示的互联网是3个以太网的互联，由于它们的MTU相同，因此IP数据报在传递过程中不需要分片。如果路由器连接不同类型的网络，而这些网络的MTU又不相同，那么，路由器在转发之前可能需要对IP数据报分片。对接收到的数据报，不管它是分片后形成的IP数据报还是未分片的IP数据报，路由器都一视同仁，进行相同的路由处理和转发。</p>
</li>
</ol>
<p><strong>MTU：</strong><code>一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)。</code>因为IP数据报被封装在链路层数据报中，因此<code>链路层的MTU严格地限制着IP数据报的长度，而且在IP数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU</code>。例如，以太网的MTU为<code>1500B</code>，而许多广域网的MTU不超过576B。当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在两个或多个较小的IP数据报中，这些较小的数据报称为<code>片</code>。</p>
<h1 id="3-传输层"><a href="#3-传输层" class="headerlink" title="3.传输层"></a>3.传输层</h1><h2 id="3-1TCP协议"><a href="#3-1TCP协议" class="headerlink" title="3.1TCP协议"></a>3.1TCP协议</h2><h3 id="3-1-1TCP概述："><a href="#3-1-1TCP概述：" class="headerlink" title="3.1.1TCP概述："></a>3.1.1TCP概述：</h3><ul>
<li><strong>概述：</strong>在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接；而且在数据传递时，由于要提供可靠的面向连接的传输服务，又有确认应答、超时重传、滑动窗口、拥塞控制等机制保证传送数据的可靠性。</li>
<li><strong>应用场景：</strong>TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。</li>
<li><strong>基于TCP的协议：</strong>SMTP、HTTP、FTP</li>
</ul>
<h3 id="3-1-2TCP可靠传输的保证"><a href="#3-1-2TCP可靠传输的保证" class="headerlink" title="3.1.2TCP可靠传输的保证"></a>3.1.2TCP可靠传输的保证</h3><p><strong>可靠性指的是：</strong>保证接收方进程从接收缓存中读出的字节流与发送方发出的字节流是完全一样的</p>
<p><img src="https://img-blog.csdnimg.cn/20200414234405762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>校验：</strong> TCP 通过它首部的的检验和字段。目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p><strong>序号：</strong>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p><strong>确认：</strong><img src="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>重传</strong></p>
<p><strong>a.超时重传：</strong>当发送方在重传时间RTTs内没有收到接收方的确认报文，就要重传已发送的字段</p>
<p><strong>b.冗余ACK：</strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>流量控制</p>
</li>
<li><p>拥塞控制</p>
</li>
</ul>
<h3 id="3-1-3TCP流量控制"><a href="#3-1-3TCP流量控制" class="headerlink" title="3.1.3TCP流量控制"></a>3.1.3TCP流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>滑动窗口的解释：</strong></p>
<p>接收方根据自己接收缓存的大小，通过调整TCP报文段首部中的“窗口”字段值，动态地调整发送方的发送窗口大小，来限制发送方向网络注入报文的速率。这就是滑动窗口的思想。</p>
<h3 id="3-1-4TCP拥塞控制"><a href="#3-1-4TCP拥塞控制" class="headerlink" title="3.1.4TCP拥塞控制"></a>3.1.4TCP拥塞控制</h3><p>一条TCP连接上发送数据速度的影响因素有：服务器到客户端之间带宽瓶颈、客户端接收能力限制、服务器网卡处理能力</p>
<ol>
<li><p><strong>条件：</strong>对于资源的需求大于供应，导致网络的性能变坏，表现为网络的吞吐量随着网络负荷的增加而减小</p>
<p><strong>例如：</strong></p>
<ul>
<li><p>某个链路的传输速率为10Gb/s,某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。</p>
</li>
<li><p>但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>目的：</strong>是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>
</li>
<li><p><strong>过程：</strong>拥塞控制是一个<strong>全局性的过程</strong>，不止是控制发送方发送的数据量</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
</li>
<li><p><strong>四种TCP拥塞控制的算法</strong><img src="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>(1)慢开始算法</strong></p>
<p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加倍。用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</p>
<p>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</p>
<p><strong>(2)拥塞避免算法</strong></p>
<p>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
<blockquote>
<p><strong>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</strong></p>
<p><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</p>
<p><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p>
</blockquote>
<p> <strong>(1)快重传</strong></p>
<p>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</p>
<p><strong>(2)快恢复</strong></p>
<p><code>快恢复算法</code>的原理如下:</p>
<p>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</p>
<p>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</p>
<p><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</p>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程：</strong><img src="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>四种拥塞控制算法的总结</strong></p>
<ul>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<p><strong>拥塞控制与流量控制</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
</li>
</ol>
<h3 id="3-1-5TCP粘包现象"><a href="#3-1-5TCP粘包现象" class="headerlink" title="3.1.5TCP粘包现象"></a>3.1.5TCP粘包现象</h3><p><strong>TCP粘包概念：</strong>就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li><strong>发送方原因：</strong>TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li><strong>接收方原因：</strong>TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p>
<ul>
<li><p><strong>发送方：</strong>发送方关闭Nagle算法。</p>
</li>
<li><p><strong>接收方：</strong>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p>
</li>
</ul>
<h4 id="为什么TCP会有粘包现象，而UDP没有"><a href="#为什么TCP会有粘包现象，而UDP没有" class="headerlink" title="为什么TCP会有粘包现象，而UDP没有"></a>为什么TCP会有粘包现象，而UDP没有</h4><p><strong>TCP：</strong>为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的；</p>
<p><strong>UDP：</strong>面向消息传输，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<blockquote>
<p><strong>消息边界：</strong></p>
<ul>
<li>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；</li>
<li>而面向流则是指无保护消息保护边界的,如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包。因此就会造成粘包现象</li>
</ul>
</blockquote>
<h3 id="3-1-6TCP的头部报文结构"><a href="#3-1-6TCP的头部报文结构" class="headerlink" title="3.1.6TCP的头部报文结构"></a>3.1.6TCP的头部报文结构</h3><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p>
<p>（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
<p>需要注意的是：</p>
<ul>
<li>不要将确认序号ack与标志位中的ACK搞混了。</li>
<li>确认方ack=发起方seq+1，两端配对。</li>
</ul>
<h3 id="3-1-7TCP三次握手"><a href="#3-1-7TCP三次握手" class="headerlink" title="3.1.7TCP三次握手"></a><strong>3.1.7TCP三次握手</strong></h3><p><strong>1.三次握手的过程及状态变化</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020041418134522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x(比如是100)，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1（101，客户端发过来的序列号+1），随机产生一个值seq=y（300），并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1（也就是确认服务器端已经收到了seq=100的报文），如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1（301），ACK是否为1（也就是确认客户端端已经收到了seq=300的报文），如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据</li>
</ul>
<h4 id="3-1-7-1为什么要三次握手，两次可以吗"><a href="#3-1-7-1为什么要三次握手，两次可以吗" class="headerlink" title="3.1.7.1为什么要三次握手，两次可以吗"></a>3.1.7.1为什么要三次握手，两次可以吗</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>也不能变成两次，已失效的连接请求报文段突然又传送到了服务端，服务端误以为是正常的连接请求，直接发送连接确认报文，导致TCP建立，浪费资源，因而产生错误。也就是服务器并不能确认这个客户端能不能正常接收\自己能不能正常发送数据。</p>
<h4 id="3-1-7-2为什么要传回-SYN"><a href="#3-1-7-2为什么要传回-SYN" class="headerlink" title="3.1.7.2为什么要传回 SYN"></a>3.1.7.2为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h4 id="3-1-7-3传了-SYN-为啥还要传-ACK"><a href="#3-1-7-3传了-SYN-为啥还要传-ACK" class="headerlink" title="3.1.7.3传了 SYN,为啥还要传 ACK"></a>3.1.7.3传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h4 id="3-1-7-3SYN攻击"><a href="#3-1-7-3SYN攻击" class="headerlink" title="3.1.7.3SYN攻击"></a>3.1.7.3SYN攻击</h4><p><strong>1.SYN攻击概述</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p><strong>2.怎么检测是否受到了SYN攻击</strong></p>
<p>检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<p><strong>3.怎么解决SYN攻击</strong></p>
<ul>
<li>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</li>
<li>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li>
</ul>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<h3 id="3-1-8TCP四次挥手"><a href="#3-1-8TCP四次挥手" class="headerlink" title="3.1.8TCP四次挥手"></a>3.1.8TCP四次挥手</h3><p><strong>1.四次挥手的过程及状态变化</strong></p>
<p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<p><img src="https://img-blog.csdnimg.cn/20200414224348666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<strong>CLOSE_WAIT</strong>状态。<br>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>（4）第四次挥手：Client收到FIN后，Client进入<strong>TIME_WAIT状态</strong>，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<blockquote>
<p><strong>TIME_WAIT状态为什么要等待2MSL：</strong></p>
</blockquote>
<p>因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的ACK报文。也就是说client不能立刻关闭，要等待这个TCP连接断开之后再关闭。</p>
<blockquote>
<p><strong>为什么会有CLOSE_WAIT：</strong></p>
</blockquote>
<p>因为服务器可能有数据未发送完毕，这段时间是继续发送数据的。</p>
<h4 id="3-1-8-1为什么要进行四次挥手过程"><a href="#3-1-8-1为什么要进行四次挥手过程" class="headerlink" title="3.1.8.1为什么要进行四次挥手过程"></a>3.1.8.1为什么要进行四次挥手过程</h4><p>由于TCP连接是<strong>全双工的</strong>，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h4 id="3-1-8-2TCP连接出现故障问题"><a href="#3-1-8-2TCP连接出现故障问题" class="headerlink" title="3.1.8.2TCP连接出现故障问题"></a>3.1.8.2TCP连接出现故障问题</h4><p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<h3 id="3-1-8-3关于TIME-WAIT"><a href="#3-1-8-3关于TIME-WAIT" class="headerlink" title="3.1.8.3关于TIME_WAIT"></a>3.1.8.3关于TIME_WAIT</h3><p><strong>1.TIME_WAIT存在的两个理由：</strong></p>
<ol>
<li>可靠的实现TCP全双工连接的终止</li>
<li>允许老的重复的分节在网络上的消逝（TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝）。</li>
</ol>
<p><strong>2.为什么会出现大量的TIME_WAIT状态</strong></p>
<p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和句柄被用尽，系统无法再发起新的连接！（对于一个处理大量短连接的服务器,如果由服务器主动关闭客户端的连接,将导致服务器存在大量的处于TIME_WAIT状态的socket,严重影响服务器的处理能力,甚至耗尽可用的socket）。</p>
<p><strong>3.解决方法</strong></p>
<p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><strong>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</strong></p>
<h2 id="3-2UDP协议："><a href="#3-2UDP协议：" class="headerlink" title="3.2UDP协议："></a>3.2UDP协议：</h2><ul>
<li><strong>概述：</strong>UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。</li>
<li><strong>应用场景：</strong>UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。</li>
<li><strong>基于UDP的协议：</strong>RIP(路由选择协议）、DNS</li>
</ul>
<h2 id="3-3-TCP-UDP-协议的区别"><a href="#3-3-TCP-UDP-协议的区别" class="headerlink" title="3.3 TCP,UDP 协议的区别"></a>3.3 TCP,UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<ul>
<li><strong>UDP</strong> 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</li>
<li><strong>TCP</strong> 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</li>
</ul>
<h2 id="3-4点对点与端对端的区别"><a href="#3-4点对点与端对端的区别" class="headerlink" title="3.4点对点与端对端的区别"></a>3.4点对点与端对端的区别</h2><ul>
<li><strong>点到点通信：</strong>是针对<strong>数据链路层或网络层</strong>来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li><strong>端到端通信：</strong>是针对<strong>传输层</strong>来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。</li>
</ul>
<h1 id="4-应用层"><a href="#4-应用层" class="headerlink" title="4.应用层"></a>4.应用层</h1><h2 id="4-1浏览器输入url并回车的过程以及相关协议"><a href="#4-1浏览器输入url并回车的过程以及相关协议" class="headerlink" title="4.1浏览器输入url并回车的过程以及相关协议"></a>4.1浏览器输入url并回车的过程以及相关协议</h2><ol>
<li>根据域名进行DNS解析查询域名所对应的的IP地址</li>
<li>建立TCP连接</li>
<li>建立TCP连接的基础上发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>使用的协议：DNS(获取域名的IP的地址);TCP(与服务器建立TCP连接)；IP(建立TCP协议时，需发送数据，在网络层用到IP协议)；OPSF(IP数据包在路由之间传送，路由选择使用OPSF协议)；ARP(路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议)HTTP(TCP建立之后，使用HTTP协议访问网页)；</p>
<h2 id="4-2DNS域名解析的过程"><a href="#4-2DNS域名解析的过程" class="headerlink" title="4.2DNS域名解析的过程"></a>4.2DNS域名解析的过程</h2><p><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-3HTTP长连接-短连接"><a href="#4-3HTTP长连接-短连接" class="headerlink" title="4.3HTTP长连接,短连接"></a>4.3HTTP长连接,短连接</h2><p><strong>短连接：</strong>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。</p>
<p><strong>长连接：</strong>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h2 id="4-4HTTP1-0、HTTP1-1、HTTP2-0之间的区别"><a href="#4-4HTTP1-0、HTTP1-1、HTTP2-0之间的区别" class="headerlink" title="4.4HTTP1.0、HTTP1.1、HTTP2.0之间的区别"></a>4.4HTTP1.0、HTTP1.1、HTTP2.0之间的区别</h2><h3 id="4-4-1HTTP1-1与1-0之间的区别"><a href="#4-4-1HTTP1-1与1-0之间的区别" class="headerlink" title="4.4.1HTTP1.1与1.0之间的区别:"></a><strong>4.4.1HTTP1.1与1.0之间的区别:</strong></h3><p><strong>1.长连接</strong></p>
<p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</p>
<p><strong>2.节约带宽</strong></p>
<p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<p><strong>4.错误状态响应码</strong> </p>
<p>在HTTP1.1中新增了24个错误状态响应码，</p>
<p><strong>3.HOST域</strong></p>
<p>现在可以web server例如tomcat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
<h3 id="4-4-2HTTP1-1与2-0之间的区别"><a href="#4-4-2HTTP1-1与2-0之间的区别" class="headerlink" title="4.4.2HTTP1.1与2.0之间的区别:"></a><strong>4.4.2HTTP1.1与2.0之间的区别:</strong></h3><p><strong>1.多路复用</strong></p>
<p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<p><strong>2.数据压缩</strong></p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p><strong>3.服务器推送</strong></p>
<p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p>
<p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p>
<h2 id="4-5HTTP与HTTPS"><a href="#4-5HTTP与HTTPS" class="headerlink" title="4.5HTTP与HTTPS"></a>4.5HTTP与HTTPS</h2><h3 id="4-5-1两者之间的区别"><a href="#4-5-1两者之间的区别" class="headerlink" title="4.5.1两者之间的区别"></a>4.5.1两者之间的区别</h3><p>​    1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>​    2、HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS(运行在TCP之上)之上，内容加密。</p>
<p>​    3、连接端口不一样，http是80，https是443.</p>
<p>​    4、http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，更安全。</p>
<p>HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层<strong>；</strong>采用对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。</p>
<ul>
<li>对称加密：加密和解密都是同一个密钥。</li>
<li>非对称加密：密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密，私钥加密需要公钥解密。</li>
</ul>
<h3 id="4-5-2HTTPS链接建立的过程"><a href="#4-5-2HTTPS链接建立的过程" class="headerlink" title="4.5.2HTTPS链接建立的过程"></a>4.5.2HTTPS链接建立的过程</h3><h4 id="4-5-2-1加密通信过程"><a href="#4-5-2-1加密通信过程" class="headerlink" title="4.5.2.1加密通信过程"></a>4.5.2.1加密通信过程</h4><p> <strong>step1</strong>： “客户”向服务端发送一个通信请求</p>
<p> “客户”-&gt;“服务器”：你好</p>
<p> <strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有。</p>
<p> “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>
<p> <strong>step3</strong>： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>
<p> “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串  </p>
<p> “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>
<p> <strong>step4</strong>： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>
<p> “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>
<p> “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>
<p> “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>
<p> …… //继续其它的通信</p>
<h4 id="4-5-2-2HTTPS链接建立的过程"><a href="#4-5-2-2HTTPS链接建立的过程" class="headerlink" title="4.5.2.2HTTPS链接建立的过程"></a>4.5.2.2HTTPS链接建立的过程</h4><p>1、发送非对称加密的公钥A给浏览器</p>
<p>2、客户端(SSL/TLS)解析证书（无效会弹出警告）</p>
<p>3、生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥B。</p>
<p>4、浏览器使用服务器返回的公钥A，对自己生成的对称加密密钥B进行加密，得到密钥C。</p>
<p>5、浏览器将密钥C发送给服务器</p>
<p>6、务器使用自己的私钥D对接受的密钥C进行解密，得到对称加密密钥B。</p>
<p>7、将信息和密钥B混合在一起进行对称加密</p>
<p>8、将加密的内容发送给客户端</p>
<p>9、客户端用密钥B解密信息</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\01.png" style="zoom:80%;">

<p><strong>加密过程使用了对称加密和非对称加密。</strong></p>
<p><strong>1.对称加密与非对称加密</strong></p>
<ul>
<li><p><strong>对称加密：</strong>客户端和服务端采用相同的密钥进行加密</p>
<p>encrypt(明文，秘钥) = 密文</p>
<p>decrypt(密文，秘钥) = 明文</p>
</li>
<li><p><strong>非对称加密：</strong>客户端通过公钥加密，服务端通过私钥解密</p>
<p>encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
</li>
</ul>
<p><strong>2.验证证书</strong></p>
<p>客户端获取到了站点证书，拿到了站点的公钥</p>
<p>客户端找到其站点证书颁发者的信息</p>
<p><strong>站点证书的颁发者验证服务端站点是否可信</strong></p>
<p> <strong>3.几种加密算法</strong></p>
<ul>
<li>   <strong>非对称加密算法：</strong>RSA，DSA/DSS</li>
<li>   <strong>对称加密算法：</strong>AES，RC4，3DES</li>
<li>   <strong>HASH算法：</strong>MD5，SHA1，SHA256</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\02.png" style="zoom:80%;">

<h2 id="4-6HTTP请求有哪些"><a href="#4-6HTTP请求有哪些" class="headerlink" title="4.6HTTP请求有哪些"></a>4.6HTTP请求有哪些</h2><ul>
<li>get:请求特定资源</li>
<li>post:向指定资源提交数据进行处理请求</li>
<li>Put:向指定资源上传最新内容</li>
<li>Delete:请求删除资源</li>
</ul>
<h3 id="4-6-1get和post的差别"><a href="#4-6-1get和post的差别" class="headerlink" title="4.6.1get和post的差别"></a>4.6.1get和post的差别</h3><ul>
<li>Get是从指定资源请求数据，而Post是向指定资源提交要被处理的数据。</li>
<li>Get请求刷新无害，而post刷新，数据会被重复提交。</li>
<li>Get请求的数据会附加到URL中，多个参数用&amp;连接，URL编码采用ASCII编码。而POST请求会把请求的数据放到body中。因此get请求的数据会暴露在地址栏中，而post不会。又浏览器和服务器对url的长度有限制，所以get传输数据的大小受到url的限制。</li>
<li>Get请求的资源会被浏览器缓存。</li>
<li>post比get慢，因为post在发送数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据（HTTP1.1）。而get请求直接发送请求头和数据。</li>
</ul>
<h2 id="4-7HTTP状态码："><a href="#4-7HTTP状态码：" class="headerlink" title="4.7HTTP状态码："></a><strong>4.7HTTP状态码：</strong></h2><p><strong>状态码的类别：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody></table>
<p><strong>常见的状态码：</strong></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center">200</td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">请求资源在多处可得到，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">资源找不到</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">内部服务器错误</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（网关错误）</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求（网关超时）</td>
</tr>
</tbody></table>
<h2 id="4-8HTTP报文组成"><a href="#4-8HTTP报文组成" class="headerlink" title="4.8HTTP报文组成"></a>4.8HTTP报文组成</h2><ul>
<li><p><strong>HTTP请求报文</strong>主要由请求行、请求头部、请求正文3部分组成</p>
<blockquote>
<p><strong>NOTE：</strong></p>
<p>请求报文的“请求行”有三个内容:方法、请求资源的URL及HTTP的版本</p>
</blockquote>
</li>
<li><p><strong>HTTP响应报文</strong>主要由状态行、响应头部、响应正文3部分组成</p>
</li>
</ul>
<h2 id="4-9转发和重定向的区别"><a href="#4-9转发和重定向的区别" class="headerlink" title="4.9转发和重定向的区别"></a>4.9转发和重定向的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p>转发是服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。效率高，可用于用户登录之后将角色转发到相应的模块。</p>
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器到新的网址重新请求资源。地址栏url会发生改变，而且不能共享数据。效率低，可用于用户注销之后，跳转到其他网站。</p>
<table>
<thead>
<tr>
<th align="center"><strong>区别</strong></th>
<th align="center"><strong>转发forward()</strong></th>
<th align="center"><strong>重定向sendRedirect()</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>根目录</strong></td>
<td align="center">包含项目访问地址</td>
<td align="center">没有项目访问地址</td>
</tr>
<tr>
<td align="center"><strong>地址栏</strong></td>
<td align="center">不会发生变化</td>
<td align="center">会发生变化</td>
</tr>
<tr>
<td align="center"><strong>哪里跳转</strong></td>
<td align="center">服务器端进行的跳转</td>
<td align="center">浏览器端进行的跳转</td>
</tr>
<tr>
<td align="center"><strong>请求域中数据</strong></td>
<td align="center">不会丢失</td>
<td align="center">会丢失</td>
</tr>
</tbody></table>
<h2 id="4-10Session和Cookie和Token"><a href="#4-10Session和Cookie和Token" class="headerlink" title="4.10Session和Cookie和Token"></a>4.10Session和Cookie和Token</h2><h3 id="4-10-1Session和Cookie"><a href="#4-10-1Session和Cookie" class="headerlink" title="4.10.1Session和Cookie"></a>4.10.1Session和Cookie</h3><p><strong>Cookie：</strong>是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端， 然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>
<ul>
<li>客户端发送一个http请求到服务器端</li>
<li>服务器端发送一个http响应到客户端，其中包含Set-Cookie头部</li>
<li>客户端发送一个http请求到服务器端，其中包含Cookie头部</li>
<li>服务器端发送一个http响应到客户端</li>
</ul>
<p><strong>Session：</strong>保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。Session在用户第一次访问服务器的时候自动创建, 创建Session的同时，服务器会为该Session生成唯一的session id,session id会以cookie的方式发送个客户端。客户端下次访问时，带上这个session id，就可以<strong>确定用户信息并跟踪该用户的会话</strong>了。如果浏览器不支持cookie，可以用url重写的方式，将sessionId写入url传给服务器。</p>
<h3 id="4-10-2Cookie的作用是什么-和Session有什么区别？"><a href="#4-10-2Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="4.10.2Cookie的作用是什么?和Session有什么区别？"></a>4.10.2Cookie的作用是什么?和Session有什么区别？</h3><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p> <strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得<strong>用户信息</strong>，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h3 id="4-10-3Cookie的不可跨域名性"><a href="#4-10-3Cookie的不可跨域名性" class="headerlink" title="4.10.3Cookie的不可跨域名性"></a><strong>4.10.3Cookie的不可跨域名性</strong></h3><p>很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<p>需要注意的是，虽然网站<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://images.google.com">images.google.com</a>与网站<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.google.com">www.google.com</a>同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。</p>
<h3 id="4-10-4Token"><a href="#4-10-4Token" class="headerlink" title="4.10.4Token"></a>4.10.4Token</h3><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>
<p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p>
<h3 id="4-10-5session与token区别"><a href="#4-10-5session与token区别" class="headerlink" title="4.10.5session与token区别"></a>4.10.5session与token区别</h3><p><strong>session的状态保持及弊端</strong></p>
<p>当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从服务器获取session数据，然后进行用户信息查询，查询到，就会将查询到的用户信息返回，从而实现状态保持。</p>
<p><img src="https://img-blog.csdnimg.cn/20181126151900484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_86,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_50" alt="img"></p>
<p><strong>弊端：</strong></p>
<ol>
<li><p>服务器压力增大</p>
<p>通常session是存储在内存中的，每个用户通过认证之后都会将session数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。</p>
</li>
<li><p>CSRF跨站伪造请求攻击</p>
<p>session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
</li>
<li><p>扩展性不强</p>
<p>如果将来搭建了多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是session数据是保存在内存中的（不是共享的），用户第一次访问的是服务器1，当用户再次请求时可能访问的是另外一台服务器2，服务器2获取不到session信息，就判定用户没有登陆过。</p>
</li>
</ol>
<p><strong>token认证机制</strong></p>
<p>token与session的不同主要在①认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）</p>
<p>②浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）</p>
<p>③再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息（账号、密码）或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。</p>
<p><img src="https://img-blog.csdnimg.cn/20181126161842605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_90,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_70" alt="img"></p>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i>  计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/08/SpringMVC/" rel="prev" title="SpringMVC执行原理">
      <i class="fa fa-chevron-left"></i> SpringMVC执行原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">1.计算机网络参考模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1OSI七层模型与TCP&#x2F;IP五层模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E6%AF%8F%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.</span> <span class="nav-text">1.2每层的功能及相关协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1应用层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2传输层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3网络层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4数据链路层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.2.5物理层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">2.网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">2.1ARP协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">3.传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1TCP%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.</span> <span class="nav-text">3.1TCP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1TCP%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1TCP概述：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2TCP可靠传输的保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3TCP流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4TCP拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5TCP%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5TCP粘包现象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E4%BC%9A%E6%9C%89%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1%EF%BC%8C%E8%80%8CUDP%E6%B2%A1%E6%9C%89"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">为什么TCP会有粘包现象，而UDP没有</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6TCP%E7%9A%84%E5%A4%B4%E9%83%A8%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.6.</span> <span class="nav-text">3.1.6TCP的头部报文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-7TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.1.7.</span> <span class="nav-text">3.1.7TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">3.1.7.1为什么要三次握手，两次可以吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN"><span class="nav-number">3.1.7.2.</span> <span class="nav-text">3.1.7.2为什么要传回 SYN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-3%E4%BC%A0%E4%BA%86-SYN-%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ACK"><span class="nav-number">3.1.7.3.</span> <span class="nav-text">3.1.7.3传了 SYN,为啥还要传 ACK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-7-3SYN%E6%94%BB%E5%87%BB"><span class="nav-number">3.1.7.4.</span> <span class="nav-text">3.1.7.3SYN攻击</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-8TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.1.8.</span> <span class="nav-text">3.1.8TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-8-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.8.1.</span> <span class="nav-text">3.1.8.1为什么要进行四次挥手过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-8-2TCP%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.8.2.</span> <span class="nav-text">3.1.8.2TCP连接出现故障问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-8-3%E5%85%B3%E4%BA%8ETIME-WAIT"><span class="nav-number">3.1.9.</span> <span class="nav-text">3.1.8.3关于TIME_WAIT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2UDP%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">3.2UDP协议：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-TCP-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 TCP,UDP 协议的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4%E7%82%B9%E5%AF%B9%E7%82%B9%E4%B8%8E%E7%AB%AF%E5%AF%B9%E7%AB%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.</span> <span class="nav-text">3.4点对点与端对端的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">4.应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">4.1浏览器输入url并回车的过程以及相关协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2DNS域名解析的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.</span> <span class="nav-text">4.3HTTP长连接,短连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4HTTP1-0%E3%80%81HTTP1-1%E3%80%81HTTP2-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text">4.4HTTP1.0、HTTP1.1、HTTP2.0之间的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1HTTP1-1%E4%B8%8E1-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1HTTP1.1与1.0之间的区别:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2HTTP1-1%E4%B8%8E2-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2HTTP1.1与2.0之间的区别:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5HTTP%E4%B8%8EHTTPS"><span class="nav-number">4.5.</span> <span class="nav-text">4.5HTTP与HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1%E4%B8%A4%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1两者之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2HTTPS%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2HTTPS链接建立的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-1%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">4.5.2.1加密通信过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-2HTTPS%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">4.5.2.2HTTPS链接建立的过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">4.6.</span> <span class="nav-text">4.6HTTP请求有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1get%E5%92%8Cpost%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.6.1get和post的差别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A"><span class="nav-number">4.7.</span> <span class="nav-text">4.7HTTP状态码：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8HTTP%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90"><span class="nav-number">4.8.</span> <span class="nav-text">4.8HTTP报文组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.9.</span> <span class="nav-text">4.9转发和重定向的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-10Session%E5%92%8CCookie%E5%92%8CToken"><span class="nav-number">4.10.</span> <span class="nav-text">4.10Session和Cookie和Token</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-1Session%E5%92%8CCookie"><span class="nav-number">4.10.1.</span> <span class="nav-text">4.10.1Session和Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-2Cookie%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-%E5%92%8CSession%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.10.2.</span> <span class="nav-text">4.10.2Cookie的作用是什么?和Session有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-3Cookie%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%B7%A8%E5%9F%9F%E5%90%8D%E6%80%A7"><span class="nav-number">4.10.3.</span> <span class="nav-text">4.10.3Cookie的不可跨域名性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-4Token"><span class="nav-number">4.10.4.</span> <span class="nav-text">4.10.4Token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-5session%E4%B8%8Etoken%E5%8C%BA%E5%88%AB"><span class="nav-number">4.10.5.</span> <span class="nav-text">4.10.5session与token区别</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">324k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:54</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

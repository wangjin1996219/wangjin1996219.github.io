<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414234405762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414234723205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415112950253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415122234339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414175430736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020041418134522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020041422283189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414224348666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/02.png">
<meta property="article:published_time" content="2021-03-13T15:35:53.000Z">
<meta property="article:modified_time" content="2021-04-02T08:14:30.195Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">58</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-13 23:35:53" itemprop="dateCreated datePublished" datetime="2021-03-13T23:35:53+08:00">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 16:14:30" itemprop="dateModified" datetime="2021-04-02T16:14:30+08:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-计算机网络参考模型"><a href="#1-计算机网络参考模型" class="headerlink" title="1.计算机网络参考模型"></a>1.计算机网络参考模型</h1><h2 id="1-1OSI七层模型与TCP-IP五层模型"><a href="#1-1OSI七层模型与TCP-IP五层模型" class="headerlink" title="1.1OSI七层模型与TCP/IP五层模型"></a><strong>1.1OSI七层模型与TCP/IP五层模型</strong></h2><ul>
<li>OSI七层模型:物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层；</li>
<li>TCP/IP5层模型：物理层，数据链路层，网络层，运输层，应用层；</li>
<li>TCP/IP4层模型：网络接口层，网络层(IP)，运输层(TCP/UDP)，应用层(HTTP)。</li>
</ul>
<h2 id="1-2常见应用层、运输层和网络层协议"><a href="#1-2常见应用层、运输层和网络层协议" class="headerlink" title="1.2常见应用层、运输层和网络层协议"></a><strong>1.2常见应用层、运输层和网络层协议</strong></h2><ul>
<li>应用层：HTTP、HTTPS、FTP、SMTP、DNS</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP、ICMP、IGMP</li>
</ul>
<h2 id="1-3硬件如路由器工作在哪一层"><a href="#1-3硬件如路由器工作在哪一层" class="headerlink" title="1.3硬件如路由器工作在哪一层"></a><strong>1.3硬件如路由器工作在哪一层</strong></h2><ul>
<li>网络层</li>
</ul>
<h1 id="2-网络层"><a href="#2-网络层" class="headerlink" title="2.网络层"></a>2.网络层</h1><h2 id="2-1ARP协议"><a href="#2-1ARP协议" class="headerlink" title="2.1ARP协议"></a>2.1ARP协议</h2><ul>
<li>ARP是IP地址解析为MAC地址 ；</li>
<li>RARP 将MAC地址解析为IP地址。</li>
</ul>
<p>每台主机都设有一个ARP高速缓存，用来存放本局域网内各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP来动态维护此ARP表。</p>
<p><strong>IP数据报的传输过程（IP源、目的地址始终不变；MAC源、目的地址在变化）：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200329170014590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>假如主机A的某个应用程序需要发送数据到主机B的某个应用程序，IP数据报在互联网中的传输与处理大致要经历如下过程：</p>
<ol>
<li><strong>主机发送IP数据报</strong></li>
</ol>
<p>如果主机A要发送数据给互联网上的另一台主机B，那么，主机A首先要构造一个目的IP地址为主机B的IP数据报（目的IP地址=10.3.0.88），然后对数据报进行路由选择。利用路由选择算法和主机A的路由表（见表1-1）可以得到，目的主机B和主机A不在同一网络，需要将该数据报转发到默认路由器R2（IP地址10.1.0.1）。</p>
<p>尽管主机A需要将数据报首先送到它的默认路由器R2而不是目的主机B，但是它既不会修改原IP数据报的内容，也不会在原IP数据报上面附加内容（甚至不附加下一默认路由器的IP地址）。那么，主机A怎样将数据报发送给下一路由器呢？在发送数据报之前，主机A首先调用ARP地址解析软件，得到下一默认路由器IP地址与MAC地址的映射关系，然后以该MAC地址为帧的目的地址形成一个帧，并将IP数据报封装在帧的数据区，最后由具体的物理网络（以太网）完成数据报的真正传输。由此可见，在为IP数据报选路时主机A使用数据报的目的IP地址，并且得到的是默认路由器R2的IP地址。但真正的数据传输是通过将IP数据报封装成帧，并利用默认路由器R2的MAC地址实现的。</p>
<ol start="2">
<li><strong>路由器R2处理和转发IP数据报</strong></li>
</ol>
<p>路由器R2接收到主机A发送给它的帧后，去掉帧头，并把IP数据报提交给IP软件处理。由于该IP数据报的目的地并不是路由器R2，因此R2需要将它转发出去。</p>
<p>利用路由选择算法和路由器R2的路由表（见表1-3）可知，如果要到达数据报的目的地，必须将它投递到IP地址为10.2.0.2的路由器（路由器R3）。</p>
<p>通过以太网投递时，路由器R2需要调用ARP地址解析软件，得到路由器R3的IP地址与MAC地址的映射关系，并利用该MAC地址作为帧的目的地址将IP数据报封装成帧，最后由以太网完成真正的数据投递。</p>
<p>需要注意的是，路由器在转发数据之前，IP软件需要从数据报报头的“生存周期”减去一定的值。若“生存周期”小于或等于0，则抛弃该报文；否则，重新计算IP数据报的校验和并继续转发。</p>
<ol start="3">
<li><strong>路由器R3处理和转发IP数据报</strong></li>
</ol>
<p>与路由器R2相同，路由器R3接收到路由器R2发送的帧后也需要去掉帧头，并把IP数据报提交给IP软件处理。与路由器R2不同，路由器R3在路由选择过程中发现该数据报指定的目的网络与自己直接相连，可以直接投递。于是，路由器R3调用ARP地址解析软件得到主机B的IP地址与MAC地址的映射关系，利用该MAC地址作为帧的目的地址，将IP数据报封装成帧，并由以太网实现数据的真正传递。</p>
<ol start="4">
<li><strong>主机B接收IP数据报</strong></li>
</ol>
<p>当封装IP数据报的帧到达主机B后，主机B对该帧进行解封装，并将IP数据报送主机B上的IP软件处理。IP软件确认该数据报的目的IP地址10.3.0.88为自己的IP地址后，将IP数据报中封装的数据信息送交高层协议软件处理。</p>
<p>从IP数据报在互联网中被处理和传递的过程可以看到，每个路由器都是一个自治的系统，它们根据自己掌握的路由信息对每一个IP数据报进行路由选择和转发。路由表在路由选择过程中发挥着重要作用，如果一个路由器的路由表发生变化，到达目的网络所经过的路径就有可能发生变化。例如，假如主机A路由表中的默认路由不是路由表R2（10.1.0.1），而是路由器R1（10.1.0.2），那么，主机A发往主机B的IP数据报就不会沿A-R2-R3-B，它将通过R1到达主机B。</p>
<p>另外，图1-1所示的互联网是3个以太网的互联，由于它们的MTU相同，因此IP数据报在传递过程中不需要分片。如果路由器连接不同类型的网络，而这些网络的MTU又不相同，那么，路由器在转发之前可能需要对IP数据报分片。对接收到的数据报，不管它是分片后形成的IP数据报还是未分片的IP数据报，路由器都一视同仁，进行相同的路由处理和转发。</p>
<h2 id="1-TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些"><a href="#1-TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些" class="headerlink" title="1.TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些"></a><strong>1.TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些</strong></h2><h3 id="1-1TCP协议："><a href="#1-1TCP协议：" class="headerlink" title="1.1TCP协议："></a><strong>1.1TCP协议：</strong></h3><ul>
<li><strong>概述：</strong>在传输数据之前必须三次握手建立连接，数据传输结束之后，4次挥手释放连接；而且在数据传递时，由于要提供可靠的面向连接的传输服务，又有确认应答、超时重传、滑动窗口、拥塞控制等机制保证传送数据的可靠性。</li>
<li><strong>应用场景：</strong>TCP经常用于对网络通信质量有很高要求的地方，如文件传输，邮件发送，远程登录等场景。</li>
<li><strong>基于TCP的协议：</strong>SMTP、HTTP、FTP</li>
</ul>
<h3 id="1-2UDP协议："><a href="#1-2UDP协议：" class="headerlink" title="1.2UDP协议："></a><strong>1.2UDP协议：</strong></h3><ul>
<li><strong>概述：</strong>UDP在传送数据之前不需要建立连接，目的主机收到UDP报文后，不需要给出确认。</li>
<li><strong>应用场景：</strong>UDP不提供可靠交付，一般用于即时通信，如语音、视频、直播等。</li>
<li><strong>基于UDP的协议：</strong>RIP(路由选择协议）、DNS</li>
</ul>
<h2 id="2-TCP可靠传输的保证"><a href="#2-TCP可靠传输的保证" class="headerlink" title="2.TCP可靠传输的保证"></a><strong>2.TCP可靠传输的保证</strong></h2><p><img src="https://img-blog.csdnimg.cn/20200414234405762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-1校验"><a href="#2-1校验" class="headerlink" title="2.1校验"></a><strong>2.1校验</strong></h3><h3 id="2-2序号"><a href="#2-2序号" class="headerlink" title="2.2序号"></a><strong>2.2序号</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200414234723205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-3确认"><a href="#2-3确认" class="headerlink" title="2.3确认"></a><strong>2.3确认</strong></h3><p><img src="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-4重传"><a href="#2-4重传" class="headerlink" title="2.4重传"></a><strong>2.4重传</strong></h3><p><strong>a.超时重传：</strong>当发送方在重传时间RTTs内没有收到接收方的确认报文，就要重传已发送的字段</p>
<p><strong>b.冗余ACK：</strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-TCP流量控制"><a href="#3-TCP流量控制" class="headerlink" title="3.TCP流量控制"></a>3.TCP流量控制</h2><ul>
<li><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为<code>接收窗口rwnd</code>, 即<code>调整TCP报文段首部中的“窗口”字段值</code>，来限制发送方向网络注入报文的速率。</p>
</li>
<li><p>同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为<code>拥塞窗口cwnd</code>，其大小与网络的带宽和时延密切相关。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415112950253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h2 id="4-TCP拥塞控制的条件、目的和过程"><a href="#4-TCP拥塞控制的条件、目的和过程" class="headerlink" title="4.TCP拥塞控制的条件、目的和过程"></a><strong>4.TCP拥塞控制的条件、目的和过程</strong></h2><p>一条TCP连接上发送数据速度的影响因素有：服务器到客户端之间带宽瓶颈、客户端接收能力限制、服务器网卡处理能力</p>
<h3 id="4-1条件："><a href="#4-1条件：" class="headerlink" title="4.1条件："></a><strong>4.1条件：</strong></h3><p>对于资源的需求大于供应，导致网络的性能变坏，表现为网络的吞吐量随着网络负荷的增加而减小</p>
<p><strong>例如：</strong></p>
<ul>
<li>某个链路的传输速率为10Gb/s,某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。</li>
<li>但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</li>
</ul>
<h3 id="4-2目的："><a href="#4-2目的：" class="headerlink" title="4.2目的："></a><strong>4.2目的：</strong></h3><p>是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>
<h3 id="4-3过程："><a href="#4-3过程：" class="headerlink" title="4.3过程："></a><strong>4.3过程：</strong></h3><p>拥塞控制是一个全局性的过程，不止是控制发送方发送的数据量</p>
<p><img src="https://img-blog.csdnimg.cn/20200415122234339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-3-1慢开始与拥塞避免"><a href="#4-3-1慢开始与拥塞避免" class="headerlink" title="4.3.1慢开始与拥塞避免"></a><strong>4.3.1慢开始与拥塞避免</strong></h4><p><img src="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> <strong>(1)慢开始算法</strong></p>
<ul>
<li><p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加倍。用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</p>
</li>
<li><p>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</p>
<p>**例如:**A向B发送数据，发送时A的拥塞窗口为2,那么A一次可以发送两个TCP报文段，经过一个RTT后(也称一个<code>传输轮次</code>)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。</p>
</li>
</ul>
<p><strong>(2)拥塞避免算法</strong></p>
<ul>
<li>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。</li>
<li>根据cwnd的大小执行不同的算法，可归纳如下:<br>●当cwnd &lt; ssthresh时，使用慢开始算法。<br>●当 cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。<br>●当cwnd = ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法(通常做法)。</li>
</ul>
<p><strong>(3)网络拥塞的处理</strong></p>
<ul>
<li>网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生(未按时收到确认，重传计时器时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。<br>然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</li>
<li>拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。<code>拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</code></li>
</ul>
<blockquote>
<p><strong>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</strong></p>
</blockquote>
<ul>
<li><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</li>
<li><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li>
</ul>
<h4 id="4-3-2快重传和快恢复"><a href="#4-3-2快重传和快恢复" class="headerlink" title="4.3.2快重传和快恢复"></a><strong>4.3.2快重传和快恢复</strong></h4><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p>
<p> <strong>(1)快重传</strong></p>
<ul>
<li>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</li>
</ul>
<p><strong>(2)快恢复</strong></p>
<ul>
<li><code>快恢复算法</code>的原理如下:</li>
<li>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</li>
<li>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</li>
<li><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</li>
</ul>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-3-3四种拥塞控制算法的总结"><a href="#4-3-3四种拥塞控制算法的总结" class="headerlink" title="4.3.3四种拥塞控制算法的总结"></a><strong>4.3.3四种拥塞控制算法的总结</strong></h4><ul>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<h4 id="4-3-4拥塞控制与流量控制"><a href="#4-3-4拥塞控制与流量控制" class="headerlink" title="4.3.4拥塞控制与流量控制"></a><strong>4.3.4拥塞控制与流量控制</strong></h4><ul>
<li><strong>在流量控制中：</strong>发送方发送数据的量由接收方决定</li>
<li><strong>而在拥塞控制中：</strong>则由发送方自己通过检测网络状况来决定。</li>
</ul>
<blockquote>
<p><strong>注意：发送方发送窗口的实际大小由流量控制和拥塞控制共同决定</strong></p>
</blockquote>
<p>当题目中同时出现接收端窗口(rwnd) 和拥塞窗口(cwnd) 时，发送方实际的发送窗口大小是由rwnd和cwnd中较小的那一个确定的。</p>
<h2 id="5-TCP粘包现象"><a href="#5-TCP粘包现象" class="headerlink" title="5.TCP粘包现象"></a><strong>5.TCP粘包现象</strong></h2><p><strong>TCP粘包概念：</strong>就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。</p>
<h3 id="5-1原因及解决方法"><a href="#5-1原因及解决方法" class="headerlink" title="5.1原因及解决方法"></a>5.1原因及解决方法</h3><h4 id="5-1-1原因"><a href="#5-1-1原因" class="headerlink" title="5.1.1原因"></a>5.1.1原因</h4><ul>
<li><strong>发送方原因：</strong>TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li><strong>接收方原因：</strong>TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h4 id="5-1-2解决办法"><a href="#5-1-2解决办法" class="headerlink" title="5.1.2解决办法"></a>5.1.2解决办法</h4><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p>
<ul>
<li><p><strong>发送方：</strong>发送方关闭Nagle算法。</p>
</li>
<li><p><strong>接收方：</strong>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p>
</li>
</ul>
<h3 id="5-2为什么TCP会有粘包现象，而UDP没有"><a href="#5-2为什么TCP会有粘包现象，而UDP没有" class="headerlink" title="5.2为什么TCP会有粘包现象，而UDP没有"></a><strong>5.2为什么TCP会有粘包现象，而UDP没有</strong></h3><p><strong>TCP：</strong>为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的；</p>
<p><strong>UDP：</strong>面向消息传输，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<blockquote>
<p><strong>消息边界：</strong></p>
</blockquote>
<ul>
<li>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；</li>
<li>而面向流则是指无保护消息保护边界的,如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包。因此就会造成粘包现象</li>
</ul>
<h2 id="6-TCP三次握手"><a href="#6-TCP三次握手" class="headerlink" title="6.TCP三次握手"></a><strong>6.TCP三次握手</strong></h2><h3 id="6-1三次握手的过程及状态变化"><a href="#6-1三次握手的过程及状态变化" class="headerlink" title="6.1三次握手的过程及状态变化"></a>6.1三次握手的过程及状态变化</h3><p><img src="https://img-blog.csdnimg.cn/20200414175430736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/2020041418134522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<blockquote>
<p><strong>NOTE：</strong></p>
</blockquote>
<ul>
<li>seq为序号字段，标明本次报文段数据部分的第一个字节的序号</li>
<li>ack是<code>确认号字段</code>，告诉对方我接下来应该接收的数据是从字节序号ack开始的数据</li>
<li>ACK是确认位,0时<code>确认号字段ack</code>无效，1时<code>确认号字段ack</code>有效</li>
<li>SYN是同步位</li>
</ul>
<h3 id="6-2为什么要三次握手，两次行不行？"><a href="#6-2为什么要三次握手，两次行不行？" class="headerlink" title="6.2为什么要三次握手，两次行不行？"></a><strong>6.2为什么要三次握手，两次行不行？</strong></h3><p>三次握手是为了建立可靠的通信信道，双方都确认自己和对方的发送和接受都是正常的。SYN=1表示这是个连接请求或连接接受报文，不携带数据。不能变成两次，已失效的连接请求报文段突然又传送到了服务端，服务端误以为是正常的连接请求，直接发送连接确认报文，导致TCP建立，浪费资源，因而产生错误。</p>
<h3 id="6-3SYN攻击"><a href="#6-3SYN攻击" class="headerlink" title="6.3SYN攻击"></a><strong>6.3SYN攻击</strong></h3><h4 id="6-3-1SYN攻击概述"><a href="#6-3-1SYN攻击概述" class="headerlink" title="6.3.1SYN攻击概述"></a>6.3.1SYN攻击概述</h4><p><img src="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<h4 id="6-3-2怎么检测是否受到了SYN攻击"><a href="#6-3-2怎么检测是否受到了SYN攻击" class="headerlink" title="6.3.2怎么检测是否受到了SYN攻击"></a>6.3.2怎么检测是否受到了SYN攻击</h4><p>检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<h4 id="6-3-3怎么解决SYN攻击"><a href="#6-3-3怎么解决SYN攻击" class="headerlink" title="6.3.3怎么解决SYN攻击"></a>6.3.3怎么解决SYN攻击</h4><ul>
<li>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</li>
<li>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li>
</ul>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<h2 id="7-TCP四次挥手"><a href="#7-TCP四次挥手" class="headerlink" title="7.TCP四次挥手"></a><strong>7.TCP四次挥手</strong></h2><h3 id="7-1四次挥手的过程及状态变化"><a href="#7-1四次挥手的过程及状态变化" class="headerlink" title="7.1四次挥手的过程及状态变化"></a>7.1四次挥手的过程及状态变化</h3><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</p>
<p><img src="https://img-blog.csdnimg.cn/2020041422283189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200414224348666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。<br>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。<br>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<blockquote>
<p><strong>TIME_WAIT状态为什么要等待2MSL：</strong></p>
</blockquote>
<p>因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的ACK报文。也就是说client不能立刻关闭，要等待这个TCP连接断开之后再关闭。</p>
<blockquote>
<p><strong>为什么会有CLOSE_WAIT：</strong></p>
</blockquote>
<p>因为服务器可能有数据未发送完毕，这段时间是继续发送数据的。</p>
<h3 id="7-2为什么要进行四次挥手过程"><a href="#7-2为什么要进行四次挥手过程" class="headerlink" title="7.2为什么要进行四次挥手过程"></a>7.2为什么要进行四次挥手过程</h3><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h3 id="7-3TCP连接出现故障问题"><a href="#7-3TCP连接出现故障问题" class="headerlink" title="7.3TCP连接出现故障问题"></a>7.3TCP连接出现故障问题</h3><p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<h3 id="7-4关于TIME-WAIT"><a href="#7-4关于TIME-WAIT" class="headerlink" title="7.4关于TIME_WAIT"></a>7.4关于TIME_WAIT</h3><h4 id="7-4-1TIME-WAIT存在的两个理由："><a href="#7-4-1TIME-WAIT存在的两个理由：" class="headerlink" title="7.4.1TIME_WAIT存在的两个理由："></a>7.4.1TIME_WAIT存在的两个理由：</h4><ol>
<li>可靠的实现TCP全双工连接的终止</li>
<li>允许老的重复的分节在网络上的消逝（TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时候，来自连接先前化身的重复分组已经在网络中消逝）。</li>
</ol>
<h4 id="7-4-2为什么会出现大量的TIME-WAIT状态"><a href="#7-4-2为什么会出现大量的TIME-WAIT状态" class="headerlink" title="7.4.2为什么会出现大量的TIME_WAIT状态"></a>7.4.2为什么会出现大量的TIME_WAIT状态</h4><p>在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>正常的TCP客户端连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的socket端口和句柄被用尽，系统无法再发起新的连接！（对于一个处理大量短连接的服务器,如果由服务器主动关闭客户端的连接,将导致服务器存在大量的处于TIME_WAIT状态的socket,严重影响服务器的处理能力,甚至耗尽可用的socket）。</p>
<h4 id="7-4-3解决方法"><a href="#7-4-3解决方法" class="headerlink" title="7.4.3解决方法"></a>7.4.3解决方法</h4><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><strong>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</strong></p>
<h2 id="8-点对点与端对端的区别"><a href="#8-点对点与端对端的区别" class="headerlink" title="8.点对点与端对端的区别"></a>8.点对点与端对端的区别</h2><ul>
<li><strong>点到点通信：</strong>是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li><strong>端到端通信：</strong>是针对传输层来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。</li>
</ul>
<h1 id="4-应用层"><a href="#4-应用层" class="headerlink" title="4.应用层"></a>4.应用层</h1><h2 id="1-浏览器输入url并回车的过程以及相关协议"><a href="#1-浏览器输入url并回车的过程以及相关协议" class="headerlink" title="1.浏览器输入url并回车的过程以及相关协议"></a>1.浏览器输入url并回车的过程以及相关协议</h2><ol>
<li>根据域名进行DNS解析查询域名所对应的的IP地址</li>
<li>建立TCP连接</li>
<li>建立TCP连接的基础上发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>使用的协议：DNS(获取域名的IP的地址);TCP(与服务器建立TCP连接)；IP(建立TCP协议时，需发送数据，在网络层用到IP协议)；OPSF(IP数据包在路由之间传送，路由选择使用OPSF协议)；ARP(路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议)HTTP(TCP建立之后，使用HTTP协议访问网页)；</p>
<h2 id="2-DNS域名解析的过程"><a href="#2-DNS域名解析的过程" class="headerlink" title="2.DNS域名解析的过程"></a>2.DNS域名解析的过程</h2><p><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-HTTP1-0、HTTP1-1、HTTP2-0之间的区别"><a href="#3-HTTP1-0、HTTP1-1、HTTP2-0之间的区别" class="headerlink" title="3.HTTP1.0、HTTP1.1、HTTP2.0之间的区别"></a>3.HTTP1.0、HTTP1.1、HTTP2.0之间的区别</h2><h3 id="3-1HTTP1-1与1-0之间的区别"><a href="#3-1HTTP1-1与1-0之间的区别" class="headerlink" title="3.1HTTP1.1与1.0之间的区别:"></a><strong>3.1HTTP1.1与1.0之间的区别:</strong></h3><p><strong>1.长连接</strong></p>
<p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p>
<p><strong>2.节约带宽</strong></p>
<p>HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。</p>
<p>这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</p>
<p>另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p>
<p><strong>3.HOST域</strong></p>
<p>现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。</p>
<p>HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</p>
<h3 id="3-2HTTP1-1与2-0之间的区别"><a href="#3-2HTTP1-1与2-0之间的区别" class="headerlink" title="3.2HTTP1.1与2.0之间的区别:"></a><strong>3.2HTTP1.1与2.0之间的区别:</strong></h3><p><strong>1.多路复用</strong></p>
<p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p>
<p>当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p>
<p><strong>2.数据压缩</strong></p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<p><strong>3.服务器推送</strong></p>
<p>意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p>
<p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p>
<h2 id="4-HTTP与HTTPS"><a href="#4-HTTP与HTTPS" class="headerlink" title="4.HTTP与HTTPS"></a>4.HTTP与HTTPS</h2><h3 id="4-1两者之间的区别"><a href="#4-1两者之间的区别" class="headerlink" title="4.1两者之间的区别"></a>4.1两者之间的区别</h3><p>​    1、HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p>
<p>​    2、HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS(运行在TCP之上)之上，内容加密。</p>
<p>​    3、连接端口不一样，http是80，https是443.</p>
<p>​    4、http连接简单，没有状态，https是ssl加密的传输，身份认证的网络协议，更安全。</p>
<p>HTTPS在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层<strong>；</strong>采用对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。对称加密：加密和解密都是同一个密钥。非对称加密：密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<h3 id="4-2HTTPS链接建立的过程"><a href="#4-2HTTPS链接建立的过程" class="headerlink" title="4.2HTTPS链接建立的过程"></a>4.2HTTPS链接建立的过程</h3><h4 id="4-2-1加密通信过程"><a href="#4-2-1加密通信过程" class="headerlink" title="4.2.1加密通信过程"></a>4.2.1加密通信过程</h4><p> <strong>step1</strong>： “客户”向服务端发送一个通信请求</p>
<p> “客户”-&gt;“服务器”：你好</p>
<p> <strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有。</p>
<p> “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>
<p> <strong>step3</strong>： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>
<p> “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串   //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。</p>
<p> “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>
<p> <strong>step4</strong>： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>
<p> “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>
<p> “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>
<p> “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>
<p> …… //继续其它的通信</p>
<h4 id="4-2-2HTTPS链接建立的过程"><a href="#4-2-2HTTPS链接建立的过程" class="headerlink" title="4.2.2HTTPS链接建立的过程"></a>4.2.2HTTPS链接建立的过程</h4><p>1、发送非对称加密的公钥A给浏览器</p>
<p>2、客户端(SSL/TLS)解析证书（无效会弹出警告）</p>
<p>3、生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥B。</p>
<p>4、浏览器使用服务器返回的公钥A，对自己生成的对称加密密钥B进行加密，得到密钥C。</p>
<p>5、浏览器将密钥C发送给服务器</p>
<p>6、务器使用自己的私钥D对接受的密钥C进行解密，得到对称加密密钥B。</p>
<p>7、将信息和密钥B混合在一起进行对称加密</p>
<p>8、将加密的内容发送给客户端</p>
<p>9、客户端用密钥B解密信息</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\01.png" style="zoom:80%;">

<p><strong>加密过程使用了对称加密和非对称加密。</strong></p>
<p><strong>1.对称加密与非对称加密</strong></p>
<ul>
<li><p><strong>对称加密：</strong>客户端和服务端采用相同的密钥进行加密</p>
<p>encrypt(明文，秘钥) = 密文</p>
<p>decrypt(密文，秘钥) = 明文</p>
</li>
<li><p><strong>非对称加密：</strong>客户端通过公钥加密，服务端通过私钥解密</p>
<p>encrypt(明文，公钥) = 密文</p>
<p>decrypt(密文，私钥) = 明文</p>
</li>
</ul>
<p><strong>2.验证证书</strong></p>
<p>客户端获取到了站点证书，拿到了站点的公钥</p>
<p>客户端找到其站点证书颁发者的信息</p>
<p>站点证书的颁发者验证服务端站点是否可信</p>
<p> <strong>3.几种加密算法</strong></p>
<ul>
<li>   <strong>非对称加密算法：</strong>RSA，DSA/DSS</li>
<li>   <strong>对称加密算法：</strong>AES，RC4，3DES</li>
<li>   <strong>HASH算法：</strong>MD5，SHA1，SHA256</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\02.png" style="zoom:80%;">

<h3 id="4-3HTTP请求有哪些"><a href="#4-3HTTP请求有哪些" class="headerlink" title="4.3HTTP请求有哪些"></a>4.3HTTP请求有哪些</h3><ul>
<li>get:请求特定资源</li>
<li>post:向指定资源提交数据进行处理请求</li>
<li>Put:向指定资源上传最新内容</li>
<li>Delete:请求删除资源</li>
</ul>
<h3 id="4-4get和post的差别"><a href="#4-4get和post的差别" class="headerlink" title="4.4get和post的差别"></a>4.4get和post的差别</h3><ul>
<li>Get是从指定资源请求数据，而Post是向指定资源提交要被处理的数据。</li>
<li>Get请求刷新无害，而post刷新，数据会被重复提交。</li>
<li>Get请求的数据会附加到URL中，多个参数用&amp;连接，URL编码采用ASCII编码。而POST请求会把请求的数据放到body中。因此get请求的数据会暴露在地址栏中，而post不会。又浏览器和服务器对url的长度有限制，所以get传输数据的大小受到url的限制。</li>
<li>Get请求的资源会被浏览器缓存。</li>
<li>post比get慢，因为post在发送数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。而get请求直接发送请求头和数据。</li>
</ul>
<h3 id="4-5HTTP状态码："><a href="#4-5HTTP状态码：" class="headerlink" title="4.5HTTP状态码："></a><strong>4.5HTTP状态码：</strong></h3><table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center">200</td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">请求资源在多处可得到，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">资源找不到</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">内部服务器错误</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求（网关错误）</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求（网关超时）</td>
</tr>
</tbody></table>
<h3 id="4-6HTTP报文组成"><a href="#4-6HTTP报文组成" class="headerlink" title="4.6HTTP报文组成"></a>4.6HTTP报文组成</h3><ul>
<li><p><strong>HTTP请求报文</strong>主要由请求行、请求头部、请求正文3部分组成</p>
<blockquote>
<p><strong>NOTE：</strong></p>
<p>请求报文的“请求行”有三个内容:方法、请求资源的URL及HTTP的版本</p>
</blockquote>
</li>
<li><p><strong>HTTP响应报文</strong>主要由状态行、响应头部、响应正文3部分组成</p>
</li>
</ul>
<h2 id="5-转发和重定向的区别"><a href="#5-转发和重定向的区别" class="headerlink" title="5.转发和重定向的区别"></a>5.转发和重定向的区别</h2><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p>转发是服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。效率高，可用于用户登录之后将角色转发到相应的模块。</p>
<p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器到新的网址重新请求资源。地址栏url会发生改变，而且不能共享数据。效率低，可用于用户注销之后，跳转到其他网站。</p>
<table>
<thead>
<tr>
<th align="center"><strong>区别</strong></th>
<th align="center"><strong>转发forward()</strong></th>
<th align="center"><strong>重定向sendRedirect()</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>根目录</strong></td>
<td align="center">包含项目访问地址</td>
<td align="center">没有项目访问地址</td>
</tr>
<tr>
<td align="center"><strong>地址栏</strong></td>
<td align="center">不会发生变化</td>
<td align="center">会发生变化</td>
</tr>
<tr>
<td align="center"><strong>哪里跳转</strong></td>
<td align="center">服务器端进行的跳转</td>
<td align="center">浏览器端进行的跳转</td>
</tr>
<tr>
<td align="center"><strong>请求域中数据</strong></td>
<td align="center">不会丢失</td>
<td align="center">会丢失</td>
</tr>
</tbody></table>
<h2 id="6-Session和Cookie的区别"><a href="#6-Session和Cookie的区别" class="headerlink" title="6.Session和Cookie的区别"></a>6.Session和Cookie的区别</h2><p><strong>Cookie：</strong>是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端， 然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。</p>
<ul>
<li>​    客户端发送一个http请求到服务器端</li>
<li>​    服务器端发送一个http响应到客户端，其中包含Set-Cookie头部</li>
<li>​    客户端发送一个http请求到服务器端，其中包含Cookie头部</li>
<li>​    服务器端发送一个http响应到客户端</li>
</ul>
<p><strong>Session：</strong>保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。 客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。服务器一般把Session放在内存中。 每个用户都会有一个独立的Session。Session在用户第一次访问服务器的时候自动创建, 创建Session的同时，服务器会为该Session生成唯一的session id,session id会以cookie的方式发送个客户端。客户端下次访问时，带上这个session id，就可以跟踪会话了。如果浏览器不支持cookie，可以用url重写的方式，将sessionId写入url传给服务器。</p>
<p><strong>Cookie的不可跨域名性</strong></p>
<p>很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<p>需要注意的是，虽然网站<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://images.google.com">images.google.com</a>与网站<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.google.com">www.google.com</a>同属于Google，但是域名不一样，二者同样不能互相操作彼此的Cookie。</p>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i>  计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/08/SpringMVC/" rel="prev" title="SpringMVC执行原理">
      <i class="fa fa-chevron-left"></i> SpringMVC执行原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">1.计算机网络参考模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1OSI七层模型与TCP&#x2F;IP五层模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%B1%82%E3%80%81%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.2.</span> <span class="nav-text">1.2常见应用层、运输层和网络层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E7%A1%AC%E4%BB%B6%E5%A6%82%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">1.3硬件如路由器工作在哪一层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">2.网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">2.1ARP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-TCP%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%8C%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.2.</span> <span class="nav-text">1.TCP与UDP协议的区别及应用场景，基于TCP的协议有哪些，基于UDP的协议有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1TCP%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.1TCP协议：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2UDP%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2UDP协议：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="nav-number">2.3.</span> <span class="nav-text">2.TCP可靠传输的保证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E6%A0%A1%E9%AA%8C"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.1校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%BA%8F%E5%8F%B7"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.2序号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E7%A1%AE%E8%AE%A4"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E9%87%8D%E4%BC%A0"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.4重传</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">2.4.</span> <span class="nav-text">3.TCP流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%81%E7%9B%AE%E7%9A%84%E5%92%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">4.TCP拥塞控制的条件、目的和过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="nav-number">2.5.1.</span> <span class="nav-text">4.1条件：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E7%9B%AE%E7%9A%84%EF%BC%9A"><span class="nav-number">2.5.2.</span> <span class="nav-text">4.2目的：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">2.5.3.</span> <span class="nav-text">4.3过程：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">4.3.1慢开始与拥塞避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2%E5%BF%AB%E9%87%8D%E4%BC%A0%E5%92%8C%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">4.3.2快重传和快恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3%E5%9B%9B%E7%A7%8D%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">4.3.3四种拥塞控制算法的总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">2.5.3.4.</span> <span class="nav-text">4.3.4拥塞控制与流量控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-TCP%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-number">2.6.</span> <span class="nav-text">5.TCP粘包现象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.6.1.</span> <span class="nav-text">5.1原因及解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">5.1.1原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">5.1.2解决办法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E4%BC%9A%E6%9C%89%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1%EF%BC%8C%E8%80%8CUDP%E6%B2%A1%E6%9C%89"><span class="nav-number">2.6.2.</span> <span class="nav-text">5.2为什么TCP会有粘包现象，而UDP没有</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.7.</span> <span class="nav-text">6.TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">2.7.1.</span> <span class="nav-text">6.1三次握手的过程及状态变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F"><span class="nav-number">2.7.2.</span> <span class="nav-text">6.2为什么要三次握手，两次行不行？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3SYN%E6%94%BB%E5%87%BB"><span class="nav-number">2.7.3.</span> <span class="nav-text">6.3SYN攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1SYN%E6%94%BB%E5%87%BB%E6%A6%82%E8%BF%B0"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">6.3.1SYN攻击概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%8F%97%E5%88%B0%E4%BA%86SYN%E6%94%BB%E5%87%BB"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">6.3.2怎么检测是否受到了SYN攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3SYN%E6%94%BB%E5%87%BB"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">6.3.3怎么解决SYN攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.8.</span> <span class="nav-text">7.TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">2.8.1.</span> <span class="nav-text">7.1四次挥手的过程及状态变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">2.8.2.</span> <span class="nav-text">7.2为什么要进行四次挥手过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3TCP%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98"><span class="nav-number">2.8.3.</span> <span class="nav-text">7.3TCP连接出现故障问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4%E5%85%B3%E4%BA%8ETIME-WAIT"><span class="nav-number">2.8.4.</span> <span class="nav-text">7.4关于TIME_WAIT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-1TIME-WAIT%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%90%86%E7%94%B1%EF%BC%9A"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">7.4.1TIME_WAIT存在的两个理由：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F%E7%9A%84TIME-WAIT%E7%8A%B6%E6%80%81"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">7.4.2为什么会出现大量的TIME_WAIT状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">2.8.4.3.</span> <span class="nav-text">7.4.3解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%82%B9%E5%AF%B9%E7%82%B9%E4%B8%8E%E7%AB%AF%E5%AF%B9%E7%AB%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.</span> <span class="nav-text">8.点对点与端对端的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">4.应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.</span> <span class="nav-text">1.浏览器输入url并回车的过程以及相关协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">2.DNS域名解析的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP1-0%E3%80%81HTTP1-1%E3%80%81HTTP2-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">3.HTTP1.0、HTTP1.1、HTTP2.0之间的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1HTTP1-1%E4%B8%8E1-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.1HTTP1.1与1.0之间的区别:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2HTTP1-1%E4%B8%8E2-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2HTTP1.1与2.0之间的区别:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-HTTP%E4%B8%8EHTTPS"><span class="nav-number">3.4.</span> <span class="nav-text">4.HTTP与HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E4%B8%A4%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1两者之间的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2HTTPS%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2HTTPS链接建立的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">4.2.1加密通信过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2HTTPS%E9%93%BE%E6%8E%A5%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">4.2.2HTTPS链接建立的过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.3HTTP请求有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4get%E5%92%8Cpost%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">3.4.4.</span> <span class="nav-text">4.4get和post的差别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5HTTP%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A"><span class="nav-number">3.4.5.</span> <span class="nav-text">4.5HTTP状态码：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6HTTP%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90"><span class="nav-number">3.4.6.</span> <span class="nav-text">4.6HTTP报文组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.5.</span> <span class="nav-text">5.转发和重定向的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.6.</span> <span class="nav-text">6.Session和Cookie的区别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">197k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:59</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

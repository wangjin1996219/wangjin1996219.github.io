<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片02.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片03.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片04.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片05.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片06.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片07.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source_posts/2021-03-13-计算机网络/图片08.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片09.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片10.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片11.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片23.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片24.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source_posts/2021-03-13-计算机网络/图片25.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片27.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片26.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片12.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片13.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片14.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source_posts/2021-03-13-计算机网络/图片15.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片21.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片22.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片16.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181126151900484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_86,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_50">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20181126161842605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_90,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片17.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片18.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source_posts/2021-03-13-计算机网络/图片19.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source_posts/2021-03-13-计算机网络/图片20.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/03.png">
<meta property="article:published_time" content="2021-03-13T15:35:53.000Z">
<meta property="article:modified_time" content="2021-08-01T14:18:08.201Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub/MyBlogs/source/_posts/2021-03-13-计算机网络/图片01.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-13 23:35:53" itemprop="dateCreated datePublished" datetime="2021-03-13T23:35:53+08:00">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-01 22:18:08" itemprop="dateModified" datetime="2021-08-01T22:18:08+08:00">2021-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-meta-item leancloud_visitors" data-flag-title="计算机网络" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1主机之间的通信方式"><a href="#1-1主机之间的通信方式" class="headerlink" title="1.1主机之间的通信方式"></a>1.1主机之间的通信方式</h2><ul>
<li><strong>客户-服务器（C/S）：</strong>客户是服务的请求方，服务器是服务的提供方。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片01.png" alt="img" style="zoom:80%;">



<ul>
<li><strong>对等（P2P）：</strong>不区分客户和服务器。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片02.png" alt="img" style="zoom:80%;">

<h2 id="1-2电路交换与分组交换"><a href="#1-2电路交换与分组交换" class="headerlink" title="1.2电路交换与分组交换"></a>1.2电路交换与分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要<strong>建立一条专用的物理链路</strong>，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对<strong>线路的利用率很低</strong>，往往不到 10%。</p>
<h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此<strong>在同一条传输线路上允许同时传输多个分组</strong>，也就是说分组交换不需要占用传输线路，并且根据不同的目的地址交付给不同的应用进程，实现线路的复用，提高了线路的利用率。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h2 id="1-3计算机网络体系结构"><a href="#1-3计算机网络体系结构" class="headerlink" title="1.3计算机网络体系结构"></a>1.3计算机网络体系结构</h2><p>OSI：是一种开放式系统互联通信的抽象参考模型。</p>
<ul>
<li>OSI七层模型：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层；</li>
<li>TCP/IP4层模型：网络接口层，网络层，运输层，应用层；（将会话层、表示层、应用层合并为应用层，将物理层和数据链路层合并为网络接口层）</li>
<li>5层模型：物理层，数据链路层，网络层，运输层，应用层；（将会话层、表示层、应用层合并为应用层）</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="五层体系结构"></p>
<h2 id="1-4七层模型的功能及相关协议"><a href="#1-4七层模型的功能及相关协议" class="headerlink" title="1.4七层模型的功能及相关协议"></a>1.4七层模型的功能及相关协议</h2><p><strong>应用层：</strong>因为用户的需求多种多样，需要不同的应用程序来完成。而应用层就是规定各个应用之间消息传递的形式，要求应用层采用不同的协议来解决不同应用类型的需求。典型的协议有：文件传输协议 FTP、电子邮件协议 SMTP、万维网 HTTP 等</p>
<p><strong>表示层：</strong>数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
<p><strong>会话层：</strong>用于建立、管理会话</p>
<p><strong>传输层：</strong>为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议  TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议  UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
<ul>
<li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li>
<li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。</li>
</ul>
<p><strong>网络层：</strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。那网络层的作用就是将传输层传递下来的报文段封装成分组，然后选择合适的网间路由和交换结点， 确保数据及时传送。网络层的相关协议如下：</p>
<ol>
<li>IP协议</li>
<li>ICMP：为了提高IP数据报交付成功的机会，在网络层使用了<code>网际控制报文协议</code>(Internet Control Message Protocol, <code>ICMP</code>)来<code>让主机或路由器报告差错和异常情况</code>。</li>
<li>IGMP</li>
<li>OSPF：外部网关协议</li>
<li>RIP：内部网关协议</li>
<li>ARP：将IP地址解析为MAC地址</li>
</ol>
<p><strong>数据链路层：</strong>通过 Mac 地址访问媒介。在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p><strong>物理层：</strong>考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
<h2 id="1-5数据在各层的具体传输过程"><a href="#1-5数据在各层的具体传输过程" class="headerlink" title="1.5数据在各层的具体传输过程"></a>1.5数据在各层的具体传输过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<p>交换机工作在数据链路层，它内部会维护一张 Mac 表，对应着不同的端口，在通讯中会将数据帧按照它的 Mac 地址传送到不同的端口，并没有涉及到网络层的协议所以是工作在数据链路层。</p>
<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h1><h2 id="2-1通信方式"><a href="#2-1通信方式" class="headerlink" title="2.1通信方式"></a>2.1通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="2-2带通调制"><a href="#2-2带通调制" class="headerlink" title="2.2带通调制"></a>2.2带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<h1 id="3-链路层"><a href="#3-链路层" class="headerlink" title="3.链路层"></a>3.链路层</h1><p><strong>MTU：</strong><code>一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)。</code>因为IP数据报被封装在链路层数据报中，因此<code>链路层的MTU严格地限制着IP数据报的长度，而且在IP数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU</code>。例如，以太网的MTU为<code>1500B</code>，而许多广域网的MTU不超过576B。当IP数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在两个或多个较小的IP数据报中，这些较小的数据报称为<code>片</code>。</p>
<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4.网络层"></a>4.网络层</h1><h2 id="4-1概述"><a href="#4-1概述" class="headerlink" title="4.1概述"></a>4.1概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片03.png" alt="img" style="zoom: 50%;">



<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="4-2-IP-数据报格式"><a href="#4-2-IP-数据报格式" class="headerlink" title="4.2 IP 数据报格式"></a>4.2 IP 数据报格式</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片04.png" alt="img" style="zoom:67%;">



<ul>
<li><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong>   : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong>   : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片05.png" alt="img" style="zoom: 50%;">

<h2 id="4-3-IP-地址编址方式"><a href="#4-3-IP-地址编址方式" class="headerlink" title="4.3 IP 地址编址方式"></a>4.3 IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片06.png" alt="img" style="zoom:50%;">

<h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2.子网划分"></a>2.子网划分</h3><p>子网划分的好处：</p>
<ol>
<li>更高效地利用 IP 资源</li>
<li>便于管理，比如不同的部门使用不同的网段</li>
</ol>
<p>子网划分是通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码，子网掩码的作用是在所有收到的数据包中，筛选出该子网中的数据包。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3.无分类"></a>3.无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h2 id="4-4地址解析协议-ARP"><a href="#4-4地址解析协议-ARP" class="headerlink" title="4.4地址解析协议 ARP"></a>4.4地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片07.png" alt="img" style="zoom:67%;">

<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片08.png" alt="img"></p>
<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A  知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP  地址到 MAC 地址的映射。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片09.png" alt="img" style="zoom: 67%;">

<h2 id="4-5网际控制报文协议-ICMP"><a href="#4-5网际控制报文协议-ICMP" class="headerlink" title="4.5网际控制报文协议 ICMP"></a>4.5网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片10.png" alt="img" style="zoom: 67%;">

<p>ICMP 报文分为差错报告报文和询问报文。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片11.png" alt="img" style="zoom: 50%;">

<h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率</p>
<h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减  1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="4-6网络地址转换-NAT"><a href="#4-6网络地址转换-NAT" class="headerlink" title="4.6网络地址转换 NAT"></a>4.6网络地址转换 NAT</h2><p><strong>1.私有 IP 地址</strong></p>
<p>仅限于本地的局域网中使用，<strong>路由器对目的地址是私有 IP 地址的数据包一律不进行转发</strong>，也就是私有 IP 地址在网络中是无效的。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片23.png" alt="image-20210801163419306" style="zoom:80%;">

<p><strong>2.网络地址转换 NAT</strong></p>
<p>网络地址转换 NAT：在<strong>专用网</strong>连接到<strong>因特网</strong>的路由器上安装 NAT 软件，安装了 NAT 软件的路由器叫 <strong>NAT 路由器</strong>，它至少有一个有效的<strong>外部全球 IP 地址</strong>。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片24.png" alt="image-20210801165027982" style="zoom:50%;">

<p>A 主机和 C 主机（空白主机）在同一个内网中。</p>
<p><strong>A 主机与外网中的 B 主机通信的过程：</strong></p>
<ol>
<li>应用层产生一个数据报：目的地址–213.18.2.4，源地址–192.168.0.3，端口号 30000；</li>
<li>NAT 地址转换：到了 NAT 路由器这里，会按照 NAT table 将源地址替换成 172.38.1.5，端口号为 40001，也就是对外这个 IP 地址才是有效的；</li>
<li>发送数据包</li>
</ol>
<p><strong>外网中的 B 主机，向内网中 C 主机发送数据的过程：</strong></p>
<ol>
<li>应用层产生一个数据报：目的地址–172.38.1.5，端口号 30000（访问内网共用的 IP 地址），源地址–213.18.2.4；</li>
<li>NAT 地址转换：到了 NAT 路由器这里，会按照 NAT table 将源地址替换成 192.168.0.4，端口号为 30001；</li>
<li>发送数据包</li>
</ol>
<h2 id="4-7路由器"><a href="#4-7路由器" class="headerlink" title="4.7路由器"></a>4.7路由器</h2><h3 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h3><p>路由器从功能上可以划分为：路由选择部分和分组转发部分。</p>
<p><strong>路由选择部分：</strong></p>
<p>根据所选择的路由选择协议（RIP、OSPF、BGP）构造出路由表，并定期与相邻的路由器交换信息来维护路由表</p>
<p><strong>分组转发结构由三个部分组成：</strong></p>
<ol>
<li>交换结构：若收到 RIP/OSPF 分组，则把分组送往路由选择处理机，根据不同的路由选择协议来维护路由表；若是数据分组，根据转发表找到合适的输出端口，将分组发送出去</li>
<li>一组输入端口：分组输入</li>
<li>一组输出端口：找到合适的端口输出分组</li>
</ol>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片25.png" alt="img"></p>
<h3 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h3><p>路由器无论是是直接转发还是间接转发，都需要根据分组的目的IP地址和源IP地址是否属于同一网络判断。目的主机和源主机在同一网络，或者是当目的路由器向目的主机发送时，分组将直接发送。反之，则间接发送。</p>
<p>路由器在收到 IP 数据报告后执行的分组转发步骤如下：</p>
<ol>
<li>首先提取出目的主机的 IP 地址 D 得出其所在的网络 N。</li>
<li>若网络 N 与此路由器直接相连。则把数据报<strong>直接交付</strong>目的主机 D。否则是<strong>间接交付</strong>，运行(3)。</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。 否则执行（4）</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传给路由表中所指明的下一跳路由器。 否则执行（5）</li>
<li>若路由表中有一个默认路由，则把数据报传给默认路由所指明的默认路由器。否则执行（6）</li>
<li>报告转发分组出错。</li>
</ol>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片27.png" alt="img" style="zoom:80%;">

<blockquote>
<p><strong>Note：</strong></p>
<p><strong>特定主机路由：</strong>这样的路由是为<strong>特定的目的主机</strong>指明一个路由。</p>
<p><strong>默认路由：</strong>目的网络在路由表中匹配不到，就一律选择默认路由。</p>
</blockquote>
<h3 id="路由选择协议（没掌握）"><a href="#路由选择协议（没掌握）" class="headerlink" title="路由选择协议（没掌握）"></a>路由选择协议（没掌握）</h3><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<p><strong>1. 内部网关协议 RIP</strong></p>
<p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<p><strong>2. 内部网关协议 OSPF</strong></p>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法（广播）。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示（路由器收到到其它路由器的链路状态之后，再通过 Dijkstra 算法来更新自己的路由表）。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<p><strong>3. 外部网关协议 BGP</strong></p>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片26.png" alt="img" style="zoom:67%;">

<h1 id="5-传输层"><a href="#5-传输层" class="headerlink" title="5.传输层"></a>5.传输层</h1><h2 id="5-1-TCP-与-UDP-协议的对比"><a href="#5-1-TCP-与-UDP-协议的对比" class="headerlink" title="5.1 TCP 与 UDP 协议的对比"></a>5.1 TCP 与 UDP 协议的对比</h2><ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流，可能会对大数据包进行拆分，并且在接收方进行重组数据包操作，每一条 TCP 连接只能是点对点的（一对一）。</li>
</ul>
<h2 id="5-2-UDP-首部格式"><a href="#5-2-UDP-首部格式" class="headerlink" title="5.2 UDP 首部格式"></a>5.2 UDP 首部格式</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片12.png" alt="img" style="zoom:67%;">

<ul>
<li>源端口：源端口号。在需要对方回信时选用，不需要时可用全0。 </li>
<li>目的端口：目的端口号。这在终点交付报文时必须使用到。 </li>
<li>长度：UDP 数据报的长度(包括首部和数据)，其最小值是8 (仅有首部)。 </li>
<li>校验和：检测 UDP 数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全 0。</li>
</ul>
<h2 id="5-3-TCP-首部格式"><a href="#5-3-TCP-首部格式" class="headerlink" title="5.3 TCP 首部格式"></a>5.3 TCP 首部格式</h2><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom: 50%;">

<p><strong>序号（seq）：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p><strong>确认号（ack）：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
<p><strong>确认（ACK）：</strong>当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
<p><strong>同步（SYN）：</strong>在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
<p><strong>终止（FIN）：</strong>用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
<p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<h2 id="5-4-TCP-的三次握手"><a href="#5-4-TCP-的三次握手" class="headerlink" title="5.4 TCP 的三次握手"></a>5.4 TCP 的三次握手</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片13.png" alt="img" style="zoom: 50%;">

<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=x(比如是100)，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1（101，客户端发过来的序列号+1），随机产生一个值seq=y（300），并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1（也就是确认服务器端已经收到了seq=100的报文），如果正确则将标志位ACK置为1，ack=y+1，并将该数据包发送给Server，Server检查ack是否为y+1（301），ACK是否为1（也就是确认客户端端已经收到了seq=300的报文），如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据</li>
</ul>
<p>（也就是双方确认双发都具有收、发功能的过程）</p>
<h3 id="1-为什么要三次握手，两次可以吗"><a href="#1-为什么要三次握手，两次可以吗" class="headerlink" title="1.为什么要三次握手，两次可以吗"></a>1.为什么要三次握手，两次可以吗</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<p>假如只有前面 2 次握手，那么服务端来收到 SYN 并且发出 SYN+ACK 包之后就会处于工作状态。如果服务端在某一时刻突然收到了一个来自客户端的 SYN 包，在发出 ACK 之后，服务端处于工作状态。但是可能这个包是卡了很久已经被客户端给丢弃了。客户端收到 SYN+ACK 之后，表示情绪淡定不予理会，但是服务端已经处于工作状态了，会造成资源的浪费。</p>
<h3 id="2-为什么要传回-SYN"><a href="#2-为什么要传回-SYN" class="headerlink" title="2.为什么要传回 SYN"></a>2.为什么要传回 SYN</h3><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK 消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="3-传了-SYN，为啥还要传-ACK"><a href="#3-传了-SYN，为啥还要传-ACK" class="headerlink" title="3.传了 SYN，为啥还要传 ACK"></a>3.传了 SYN，为啥还要传 ACK</h3><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h3 id="4-SYN-攻击"><a href="#4-SYN-攻击" class="headerlink" title="4.SYN 攻击"></a>4.SYN 攻击</h3><p><strong>1.SYN攻击概述</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200414222617352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p><strong>2.怎么检测是否受到了SYN攻击</strong></p>
<p>检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。</p>
<p><strong>3.怎么解决SYN攻击</strong></p>
<ul>
<li>第一种是缩短SYN Timeout时间，由于SYN Flood攻击的效果取决于服务器上保持的SYN半连接数，这个值=SYN攻击的频度 x SYN Timeout，所以通过缩短从接收到SYN报文到确定这个报文无效并丢弃改连接的时间，例如设置为20秒以下（过低的SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</li>
<li>第二种方法是设置SYN Cookie，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被一概丢弃。</li>
</ul>
<p>可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。</p>
<p>net.ipv4.tcp_syncookies = 1</p>
<p>net.ipv4.tcp_max_syn_backlog = 8192</p>
<p>net.ipv4.tcp_synack_retries = 2</p>
<p>分别为启用SYN Cookie、设置SYN最大队列长度以及设置SYN+ACK最大重试次数。</p>
<p>SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。</p>
<p>net.ipv4.tcp_synack_retries是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。</p>
<p>tcp_max_syn_backlog则是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。</p>
<h2 id="5-5-TCP-的四次挥手"><a href="#5-5-TCP-的四次挥手" class="headerlink" title="5.5 TCP 的四次挥手"></a>5.5 TCP 的四次挥手</h2><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片14.png" alt="img" style="zoom:67%;">

<ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<strong>CLOSE_WAIT</strong>状态。</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</li>
<li>第四次挥手：Client收到FIN后，Client进入<strong>TIME_WAIT状态</strong>，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
<h3 id="1-为什么要进行四次挥手过程"><a href="#1-为什么要进行四次挥手过程" class="headerlink" title="1.为什么要进行四次挥手过程"></a>1.为什么要进行四次挥手过程</h3><p>由于TCP连接是<strong>全双工的</strong>，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<h3 id="2-TCP-连接出现故障问题"><a href="#2-TCP-连接出现故障问题" class="headerlink" title="2. TCP 连接出现故障问题"></a>2. TCP 连接出现故障问题</h3><p>如果建立连接之后出现故障：TCP有个保活计时器，通常设置为2小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每75s发送一次，10次之后探测报文没有反应，认为出现故障，关闭连接。</p>
<h3 id="3-关于-TIME-WAIT"><a href="#3-关于-TIME-WAIT" class="headerlink" title="3.关于 TIME_WAIT"></a>3.关于 TIME_WAIT</h3><p><strong>1.四次挥手主动方为什么需要等待 2MSL ？</strong></p>
<p>因为第四次的确认报文可能丢失，这个状态是用来重发可能丢失的 ACK 报文。也就是说 client 不能立刻关闭，要等待这个 TCP 连接断开之后再关闭。如果最后一次 ACK 没有被正确的传给被动方，被动关闭方会再次发送第三次的 FIN 信号。</p>
<p><strong>MSL表示最大报文生存周期</strong>，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p><strong>2.为什么会出现大量的TIME_WAIT状态？</strong></p>
<p>在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<p>正常的 TCP 客户端连接在关闭后，会进入一个 TIME_WAIT 的状态，持续的时间一般在1~4分钟，短时间内（例如1s内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的 socket 端口和句柄被用尽，系统无法再发起新的连接！（对于一个处理大量短连接的服务器,如果由服务器主动关闭客户端的连接,将导致服务器存在大量的处于 TIME_WAIT状态的socket，严重影响服务器的处理能力,甚至耗尽可用的 socket）。</p>
<p><strong>3.解决方法</strong></p>
<p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
<p><strong>简单来说，就是打开系统的TIMEWAIT状态的Sockets的重用和快速回收。</strong></p>
<h2 id="5-6-TCP-可靠传输"><a href="#5-6-TCP-可靠传输" class="headerlink" title="5.6 TCP 可靠传输"></a>5.6 TCP 可靠传输</h2><p><strong>可靠性指的是：</strong>保证接收方进程从接收缓存中读出的字节流与发送方发出的字节流是完全一样的</p>
<ul>
<li><p><strong>校验：</strong> TCP 通过它首部的的检验和字段。目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p><strong>序号：</strong>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p><strong>确认：</strong><img src="https://img-blog.csdnimg.cn/20200414235810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20200415000159608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>重传</strong></p>
<p><strong>a.超时重传：</strong>当发送方在重传时间RTTs内没有收到接收方的确认报文，就要重传已发送的字段</p>
<p><strong>b.冗余ACK：</strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</p>
<p><img src="https://img-blog.csdnimg.cn/20200415001005425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>流量控制</strong></p>
</li>
<li><p><strong>拥塞控制</strong></p>
</li>
</ul>
<h3 id="1-TCP-流量控制"><a href="#1-TCP-流量控制" class="headerlink" title="1. TCP 流量控制"></a>1. TCP 流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>滑动窗口的解释：</strong></p>
<p>接收方根据自己接收缓存的大小，通过调整确认报文段首部中的“窗口”字段值，动态地调整发送方的发送窗口大小，来限制发送方向网络注入报文的速率。这就是滑动窗口的思想。</p>
<h3 id="2-TCP-拥塞控制"><a href="#2-TCP-拥塞控制" class="headerlink" title="2. TCP 拥塞控制"></a>2. TCP 拥塞控制</h3><p>一条TCP连接上发送数据速度的影响因素有：服务器到客户端之间带宽瓶颈、客户端接收能力限制、服务器网卡处理能力</p>
<ol>
<li><p><strong>条件：</strong>对于资源的需求大于供应，导致网络的性能变坏，表现为网络的吞吐量随着网络负荷的增加而减小</p>
<p><strong>例如：</strong></p>
<ul>
<li><p>某个链路的传输速率为10Gb/s,某巨型机向一台PC以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。</p>
</li>
<li><p>但若有100万台PC在此链路上以1Mb/s的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。就像我们上网一样，有时候加载会很慢，提示访问请求过多，请稍后再试，就是网络产生了拥塞，带宽小，一下不能支持给多个请求终端发送数据。</p>
</li>
</ul>
</li>
<li><p><strong>目的：</strong>是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>
</li>
<li><p><strong>过程：</strong>拥塞控制是一个<strong>全局性的过程</strong>，不止是控制发送方发送的数据量</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
</li>
<li><p><strong>四种TCP拥塞控制的算法</strong><img src="https://img-blog.csdnimg.cn/20200415124537439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <strong>(1)慢开始算法</strong></p>
<p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd= 1,即一个最大报文段长度MSS.每收到一个对新报文段的确认后，将cwnd加倍。用这样的方法逐步增大发送方的拥塞窗口cwnd,可使分组注入网络的速率更加合理。</p>
<p>使用慢开始算法后，每经过一个传输轮次(即往返时延RTT)，拥塞窗口cwnd就会加倍，即cwnd的大小指数式增长。这样，慢开始一直把拥塞窗口cwnd增大到一个规定的<code>慢开始门限ssthresh(阈值)</code>，然后<code>改用拥塞避免算法</code>。</p>
<p><strong>(2)拥塞避免算法</strong></p>
<p>拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍,使cwnd按线性规律缓慢增长(即加法增大),而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh等于当前cwnd的一半(即乘法减小)。把拥塞窗口cwnd重新设置为1,执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
<blockquote>
<p><strong>在慢开始和拥塞避免算法中使用了乘法减小和加法增大方法：</strong></p>
<p><code>“乘法减小”</code>是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时(即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入网络的分组数。</p>
<p><code>“加法增大”</code>是指执行拥塞避免算法后，在收到对所有报文段的确认后(即经过一个 RTT),就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p>
</blockquote>
<p> <strong>(1)快重传</strong></p>
<p>在TCP可靠传输机制中，<code>快重传技术</code>使用了<code>冗余ACK来检测丢包的发生</code>。同样，<code>冗余ACK也用于网络拥塞的检测</code>(丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。<br>当发送方连续收到三个重复的ACK报文时，<code>直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</code>。</p>
<p><strong>(2)快恢复</strong></p>
<p><code>快恢复算法</code>的原理如下:</p>
<p>发送端收到连续三个冗余ACK (即重复确认)时，执行<code>“乘法减小”算法</code>，把慢开始门限ssthresh 设置为出现拥塞时发送方cwnd的一半。</p>
<p>与慢开始(慢开始算法将拥塞窗口cwnd设置为1)的<code>不同之处</code>是，它把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行<code>拥塞避免算法(“ 加法增大”)</code>，使拥塞窗口缓慢地线性增大。</p>
<p><code>由于跳过了cwnd从1起始的慢开始过程,所以被称为快恢复</code>。</p>
<p><strong>快恢复算法的实现过程如图所示，作为对比，虚线为慢开始的处理过程：</strong><img src="https://img-blog.csdnimg.cn/20200415144222486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>四种拥塞控制算法的总结</strong></p>
<ul>
<li>实际上，<code>慢开始、拥塞避免、快重传和快恢复几种算法</code>应是同时应用在拥塞控制机制之中的</li>
<li>当发送方检测到超时的时候，就采用慢开始和拥塞避免，</li>
<li>当发送方接收到冗余ACK时，就采用快重传和快恢复。</li>
</ul>
<p><strong>拥塞控制与流量控制</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
</li>
</ol>
<h2 id="5-7-TCP-粘包现象"><a href="#5-7-TCP-粘包现象" class="headerlink" title="5.7 TCP 粘包现象"></a>5.7 TCP 粘包现象</h2><p><strong>TCP粘包概念：</strong>就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。</p>
<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h3><ul>
<li><strong>发送方原因：</strong>TCP默认使用Nagle算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。</li>
<li><strong>接收方原因：</strong>TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li>
</ul>
<h3 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h3><p>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。</p>
<ul>
<li><p><strong>发送方：</strong>发送方关闭Nagle算法。</p>
</li>
<li><p><strong>接收方：</strong>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。</p>
</li>
</ul>
<h3 id="3-为什么TCP会有粘包现象，而UDP没有"><a href="#3-为什么TCP会有粘包现象，而UDP没有" class="headerlink" title="3.为什么TCP会有粘包现象，而UDP没有"></a>3.为什么TCP会有粘包现象，而UDP没有</h3><p><strong>TCP：</strong>为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的。如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包，因此就会造成粘包现象。</p>
<p><strong>UDP：</strong>面向消息传输，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<blockquote>
<p><strong>消息边界：</strong></p>
<ul>
<li>保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包；</li>
<li>而面向流则是指无保护消息保护边界的,如果发送端连续发送数据, 接收端有可能在一次接收动作中，会接收两个或者更多的数据包。因此就会造成粘包现象</li>
</ul>
</blockquote>
<h2 id="5-8-TCP，UDP-协议的区别"><a href="#5-8-TCP，UDP-协议的区别" class="headerlink" title="5.8 TCP，UDP 协议的区别"></a>5.8 TCP，UDP 协议的区别</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<ul>
<li>TCP协议进行数据通信之前需要三次握手建立连接，UDP协议不需要建立连接即可发送数据。 </li>
<li>TCP有确认机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。 </li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。 </li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。 </li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>TCP 一般用于文件传输、发送和接收邮件、远程登录等场景</li>
<li>虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</li>
</ul>
<h2 id="5-9点对点与端对端的区别"><a href="#5-9点对点与端对端的区别" class="headerlink" title="5.9点对点与端对端的区别"></a>5.9点对点与端对端的区别</h2><ul>
<li><strong>点到点通信：</strong>是针对<strong>数据链路层或网络层</strong>来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受ip层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。</li>
<li><strong>端到端通信：</strong>是针对<strong>传输层</strong>来说的，传输层为网络中的主机提供端到端的通信。因为无论tcp还是udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过tcp比较可靠而udp不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。</li>
</ul>
<h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="1-浏览器输入url并回车的过程以及相关协议"><a href="#1-浏览器输入url并回车的过程以及相关协议" class="headerlink" title="1.浏览器输入url并回车的过程以及相关协议"></a>1.浏览器输入url并回车的过程以及相关协议</h2><ol>
<li>DNS解析：将域名解析成对应的服务器IP地址。</li>
<li>建立TCP连接：拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</li>
<li>建立TCP连接的基础上发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束：</li>
</ol>
<p><strong>使用的协议：</strong>DNS（获取域名的IP的地址），TCP（与服务器建立 TCP 连接）、IP（建立 TCP 协议时，需发送数据，在网络层用到 IP 协议）、OPSF（IP 数据包在路由之间传送，路由选择使用 OPSF 协议）、ARP（路由器与服务器通信时，将 IP 地址转化为 MAC 地址，使用 ARP 协议）、HTTP（TCP 建立之后，使用 HTTP 协议访问网页）。</p>
<h2 id="2-DNS域名解析的过程"><a href="#2-DNS域名解析的过程" class="headerlink" title="2.DNS域名解析的过程"></a>2.DNS域名解析的过程</h2><p><strong>假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程(共使用8个UDP报文)如下:</strong></p>
<ul>
<li>①<code>客户机</code>向其<code>本地域名服务器</code>发出<code>DNS请求报文</code>。</li>
<li>②<code>本地域名服务器</code>收到请求后，查询<code>本地缓存</code>，若没有该记录，则以DNS客户的身份向<code>根域名服务器</code>发出解析请求。</li>
<li>③<code>根域名服务器</code>收到请求后，判断该域名属于.com域，将对应的<code>顶级域名服务器</code>dns.com的IP地址返回给<code>本地域名服务器</code>。</li>
<li>④<code>本地域名服务器</code>向<code>顶级域名服务器dns.com</code>发出解析<code>请求报文</code>。</li>
<li>⑤<code>顶级域名服务器dns.com</code>收到请求后，<code>判断</code>该域名<code>属于abc.com域</code>，因此将对应的<code>授权域名服务器dns.abc.com</code>的IP地址返回给<code>本地域名服务器</code>。</li>
<li>⑥<code>本地域名服务器</code>向<code>授权域名服务器dns.abc.com</code>发起解析<code>请求报文</code>。</li>
<li>⑦<code>授权域名服务器dns.abc.com</code>收到请求后，将查询<code>结果</code>返回给<code>本地域名服务器</code>。</li>
<li>⑧<code>本地域名服务器</code>将查询结果保存到<code>本地缓存</code>，同时返回给<code>客户机</code>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200417212650924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="7-HTTP"><a href="#7-HTTP" class="headerlink" title="7. HTTP"></a>7. HTTP</h1><h2 id="7-1基础概念"><a href="#7-1基础概念" class="headerlink" title="7.1基础概念"></a>7.1基础概念</h2><h3 id="1-请求和响应报文"><a href="#1-请求和响应报文" class="headerlink" title="1.请求和响应报文"></a>1.请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>
<p><strong>请求报文结构：</strong></p>
<ul>
<li>第一行是包含了请求方法、URL、协议版本；</li>
<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>
<li>一个空行用来分隔首部和内容主体 Body</li>
<li>最后是请求的内容主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.example.com&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Host: www.example.com</span><br><span class="line">If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">If-None-Match: &quot;3147526947+gzip&quot;</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 xxx</span><br><span class="line"></span><br><span class="line">param1&#x3D;1&amp;param2&#x3D;2</span><br></pre></td></tr></table></figure>

<p><strong>响应报文结构：</strong></p>
<ul>
<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li>
<li>接下来多行也是首部内容</li>
<li>一个空行分隔首部和内容主体</li>
<li>最后是响应的内容主体</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Age: 529651</span><br><span class="line">Cache-Control: max-age&#x3D;604800</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 648</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8</span><br><span class="line">Date: Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line">Etag: &quot;3147526947+ident+gzip&quot;</span><br><span class="line">Expires: Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line">Keep-Alive: timeout&#x3D;4</span><br><span class="line">Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Server: ECS (sjc&#x2F;16DF)</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Cache: HIT</span><br><span class="line"></span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Example Domain&lt;&#x2F;title&gt;</span><br><span class="line">	&#x2F;&#x2F; 省略... </span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-URL"><a href="#2-URL" class="headerlink" title="2. URL"></a>2. URL</h3><p><strong>URI 是uniform resource identifier：</strong>统一资源标识符，用来唯一的标识一个资源。</p>
<p><strong>URL 是uniform resource locator：</strong>统一资源定位器，它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
<h2 id="7-2-HTTP-方法"><a href="#7-2-HTTP-方法" class="headerlink" title="7.2 HTTP 方法"></a>7.2 HTTP 方法</h2><p>客户端发送的   <strong>请求报文</strong>   第一行为请求行，包含了方法字段。</p>
<ol>
<li><p>GET：获取资源，指定的资源经服务器解析之后，返回响应内容；</p>
</li>
<li><p>POST：用来传输实体的主体；</p>
</li>
<li><p>PUT：PUT 方法用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 的指定位置；</p>
</li>
<li><p>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分，主要用于确认 URL 的有效性以及资源更新的日期时间等；</p>
</li>
<li><p>DELETE：DELETE 方法用来删除文件，与 PUT 方法相反；</p>
</li>
<li><p>OPTIONS：查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p>
</li>
<li><p>CONNECT：要求在与代理服务器通信时建立隧道</p>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片15.png" alt="img"></p>
</li>
</ol>
<h2 id="7-3-GET-和-POST-比较"><a href="#7-3-GET-和-POST-比较" class="headerlink" title="7.3 GET 和 POST 比较"></a>7.3 GET 和 POST 比较</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><p>Get：用于获取资源</p>
<p>POST：用于传输实体主体</p>
<h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2.参数"></a>2.参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></table></figure>

<h3 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。（因为是只读的）</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。（因为会修改服务器的资源）</p>
<h3 id="4-幂等性"><a href="#4-幂等性" class="headerlink" title="4.幂等性"></a>4.幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p><strong>PUT</strong> 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。</p>
<p><strong>GET</strong> 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></table></figure>

<p><strong>DELETE</strong> 是幂等的，即使不同的请求接收到的状态码不一样，因为多次删除同一个资源效果都是资源不存在，所以符合幂等性：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<p><strong>POST</strong> 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<h3 id="5-可缓存"><a href="#5-可缓存" class="headerlink" title="5.可缓存"></a>5.可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2 id="7-4-HTTP-状态码"><a href="#7-4-HTTP-状态码" class="headerlink" title="7.4 HTTP 状态码"></a>7.4 HTTP 状态码</h2><p><strong>状态码的类别：</strong></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码） 接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码） 请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码） 需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码） 服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码） 服务器处理请求出错</td>
</tr>
</tbody></table>
<p><strong>常见的状态码：</strong></p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center"><strong>200</strong></td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">请求资源在多处可得到，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center"><strong>301</strong></td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center"><strong>302</strong></td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center"><strong>304</strong></td>
<td align="center">客户端请求一个有缓存的资源，服务器返回304告诉客户端，自上次请求后，资源并没有更新，原本的缓存可以继续使用。</td>
</tr>
<tr>
<td align="center"><strong>401</strong></td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center"><strong>403</strong></td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center"><strong>404</strong></td>
<td align="center">服务器找不到请求资源</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td align="center"><strong>500</strong></td>
<td align="center">内部服务器错误</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center"><strong>502</strong></td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求，能连接但是超时（网关错误）</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center"><strong>504</strong></td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求，不能连接且超时（网关超时）</td>
</tr>
<tr>
<td align="center">505</td>
<td align="center">服务器不支持请求中所用的HTTP协议版本</td>
</tr>
</tbody></table>
<h2 id="7-5不同-HTTP-版本比较"><a href="#7-5不同-HTTP-版本比较" class="headerlink" title="7.5不同 HTTP 版本比较"></a>7.5不同 HTTP 版本比较</h2><h3 id="1-HTTP-1-0-和-HTTP-1-1-的区别"><a href="#1-HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="1. HTTP/1.0 和 HTTP/1.1 的区别"></a>1. HTTP/1.0 和 HTTP/1.1 的区别</h3><ol>
<li><p><strong>长连接</strong></p>
<p>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</p>
<p>HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</p>
</li>
<li><p><strong>节约带宽</strong></p>
<p>HTTP1.1 支持先只发送 Header 信息，不用包含请求的 body，如果服务器认为客户端有权限请求服务器，则返回 100，这时客户端可以发送 body 到服务器，否则返回 401 ，这时客户端就不用发送请求 body 了，这样就节约了带宽。</p>
</li>
<li><p><strong>错误状态响应码</strong></p>
<p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p><strong>HOST 域</strong></p>
<p>在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname），HTTP1.0 没有 host 域。</p>
<p>随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。也就是说我们的一台虚拟机（IP：111.111.111.111）上面其实是可以放很很多网站的（不然如果只能放一个网站的话就太不合理了，虚拟机那么多资源都浪费了），我们可以把 <a target="_blank" rel="noopener" href="http://www.qiniu.com,www.taobao.com/">www.qiniu.com，www.taobao.com</a> 和 <a target="_blank" rel="noopener" href="http://www.jd.com/">www.jd.com</a> 这些网站都假设那台虚拟机上面，但是这样会有一个问题，我们每次访问这些域名其实都是解析到服务器 IP 111.111.111.111，我怎么来区分每次根据域名显示出不同的网站的内容呢，其实这就要用到请求头中 Host 的概念了（请求头中的 Host 字段），每个 Host 可以看做是我在服务器 111.111.111.111 上面的一个站点，每次我用那些域名访问的时候都是会解析同一个虚拟机没错，但是我通过不同的 Host 可以区分出我是访问这个虚拟机上的哪个站点。</p>
</li>
</ol>
<h3 id="2-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#2-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="2. HTTP/1.1 和 HTTP/2.0 的区别"></a>2. HTTP/1.1 和 HTTP/2.0 的区别</h3><p><strong>HTTP/1.x 缺陷：</strong></p>
<ul>
<li>客户端需要建立多个连接才能实现并发；</li>
<li>不会压缩请求头和响应头，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<p><strong>下面看 HTTP/2.0 的新特性：</strong></p>
<ol>
<li><p><strong>TCP 复用技术</strong></p>
<p>HTTP2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP1.1 大了好几个数量级。HTTP1.1 也可以多建立几个 TCP 连接，来支持处理更多并发的请求，但是创建 TCP 连接本身也是有开销的。</p>
<p>HTTP2.0 中将报文分成了 HEADERS 帧和 DATA 帧，每个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息，帧是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片21.png" alt="img" style="zoom:80%;">
</li>
<li><p><strong>服务端推送</strong></p>
<p>HTTP/2.0 在客户端请求一个资源时，<strong>会把相关的资源一起发送给客户端</strong>，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片22.png" alt="img" style="zoom:80%;">
</li>
<li><p><strong>首部压缩</strong></p>
<p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码技术对首部字段进行压缩。</p>
</li>
</ol>
<h2 id="7-6具体应用"><a href="#7-6具体应用" class="headerlink" title="7.6具体应用"></a>7.6具体应用</h2><h3 id="1-连接管理"><a href="#1-连接管理" class="headerlink" title="1.连接管理"></a>1.连接管理</h3><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片16.png" alt="img" style="zoom:67%;">

<p><strong>1.短连接与长连接</strong></p>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<p><strong>2.流水线</strong></p>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟</p>
<h3 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h3><blockquote>
<p><strong>有状态与无状态的区别：</strong></p>
<ul>
<li>状态化请求，服务器端一般都要保存请求的相关信息，每个请求可以默认地使用以前的请求信息。</li>
<li>无状态请求，服务器端所能够处理的过程必须全部来自于请求所携带的信息，以及其他服务器端自身所保存的、并且可以被所有请求所使用的公共信息。</li>
</ul>
</blockquote>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p><strong>1.用途</strong></p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>2.创建过程</strong></p>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<p><strong>3.分类</strong></p>
<ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<p><strong>4. JavaScript</strong></p>
<p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = &quot;yummy_cookie=choco&quot;;</span><br><span class="line">document.cookie = &quot;tasty_cookie=strawberry&quot;;</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure>

<p><strong>5. HttpOnly</strong></p>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p><strong>6. Secure</strong></p>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。                                                                                                                                                                 </p>
<p><strong>7. Cookie 的不可跨域名性</strong></p>
<p>很多网站都会使用 Cookie。例如，Google 会向客户端颁发 Cookie，Baidu 也会向客户端颁发 Cookie。那浏览器访问 Google 会不会也携带上 Baidu 颁发的Cookie 呢？或者 Google 能不能修改 Baidu 颁发的 Cookie 呢？</p>
<p>答案是否定的。<strong>Cookie 具有不可跨域名性</strong>。根据 Cookie 规范，浏览器访问 Google 只会携带 Google 的 Cookie，而不会携带 Baidu 的 Cookie。Google 也只能操作 Google 的 Cookie，而不能操作 Baidu 的 Cookie。</p>
<p>Cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 Cookie 而不会操作 Baidu 的 Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站 Cookie 的依据是域名。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 Cookie。</p>
<p>需要注意的是，虽然网站 images.google.com 与网站 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 同属于 Google，但是域名不一样，二者同样不能互相操作彼此的 Cookie。</p>
<h3 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID  值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session  管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<p><strong>1.浏览器禁用 Cookie</strong></p>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<p><strong>2. Cookie 与 Session 选择</strong></p>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h3 id="4-Token"><a href="#4-Token" class="headerlink" title="4. Token"></a>4. Token</h3><p>Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p>
<p>Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p>
<p>Token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p>
<p><strong>session 与 token 区别</strong></p>
<p><strong>session的状态保持及弊端：</strong></p>
<p>当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从服务器获取session数据，然后进行用户信息查询，查询到，就会将查询到的用户信息返回，从而实现状态保持。</p>
<p><img src="https://img-blog.csdnimg.cn/20181126151900484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_86,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_50" alt="img"></p>
<p><strong>弊端：</strong></p>
<ol>
<li><p>服务器压力增大</p>
<p>通常 session 是存储在内存中的，每个用户通过认证之后都会将 session 数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。</p>
</li>
<li><p>CSRF 跨站伪造请求攻击</p>
<p>session 是基于 cookie 进行用户识别的, cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
</li>
<li><p>扩展性不强</p>
<p>如果将来搭建了多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是 session 数据是保存在内存中的（不是共享的），用户第一次访问的是服务器1，当用户再次请求时可能访问的是另外一台服务器2，服务器2获取不到 session 信息，就判定用户没有登陆过。</p>
</li>
</ol>
<p><strong>token认证机制：</strong></p>
<p>token与session的不同主要在：</p>
<p>①认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）</p>
<p>②浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）</p>
<p>③再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它<strong>不需要在服务端去保留用户的认证信息（账号、密码）或者会话信息</strong>，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。</p>
<p>（只要每台服务器的加密规则和签名一致，因为客户端使用相同的公钥加密，所以不同服务器依然可以识别用户）</p>
<p>（<strong>token中含有用户的user id，所以状态可以从数据库中取出</strong>）</p>
<p>（session和token都是用于服务器区别用户的，只不过token不用在服务器中保存）</p>
<p><img src="https://img-blog.csdnimg.cn/20181126161842605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_90,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMzQyMjY=,size_20,color_FFFFFF,t_70" alt="img"></p>
<h2 id="7-7-HTTPS"><a href="#7-7-HTTPS" class="headerlink" title="7.7 HTTPS"></a>7.7 HTTPS</h2><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<h3 id="1-加密"><a href="#1-加密" class="headerlink" title="1.加密"></a>1.加密</h3><p><strong>对称密钥加密</strong></p>
<p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片17.png" alt="img" style="zoom: 80%;">

<p><strong>非对称密钥加密</strong></p>
<p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\图片18.png" alt="img" style="zoom:80%;">

<h3 id="2-CA-证书"><a href="#2-CA-证书" class="headerlink" title="2. CA 证书"></a>2. CA 证书</h3><p>这里 Alice 表示客户端，Bob 表示服务端，这里的 Trent 就是 CA 机构，证书的颁布者，也是对证书进行管理的人。</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片19.png" alt="在这里插入图片描述"></p>
<p>下面这个图更详细一些：</p>
<p><img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source_posts\2021-03-13-计算机网络\图片20.png" alt="在这里插入图片描述"></p>
<ol>
<li>服务器端生成密钥对，并向 CA 机构注册自己的公钥；</li>
<li>CA 机构通过自己的私钥对该公钥加数字签名，并生成数字证书；</li>
<li>仓库中保存着所有已经注册的证书；</li>
<li>客户端从 CA 仓库中获取已经注册的证书，并通过对比数字签名的方式来确定服务端的身份。</li>
</ol>
<h3 id="3-认证"><a href="#3-认证" class="headerlink" title="3.认证"></a>3.认证</h3><p>首先是使用混合加密的方式，Https 的建立过程如下：</p>
<p><strong>建立TCP连接之后：</strong>（所以说是中间加了一层SSL/TLS）</p>
<p> <strong>step1</strong>： “客户”向服务端发送一个通信请求</p>
<p> “客户”-&gt;“服务器”：你好</p>
<p> <strong>step2</strong>： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有。</p>
<p> “服务器”-&gt;“客户”：你好，我是服务器，这里是我的数字证书 </p>
<p> <strong>step3</strong>： “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。</p>
<p> “客户”-&gt;“服务器”：向我证明你就是服务器，这是一个随机字符串  </p>
<p> “服务器”-&gt;“客户”：{一个随机字符串}[私钥|RSA]</p>
<p> <strong>step4</strong>： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。</p>
<p> “服务器”-&gt;“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]</p>
<p> “客户”-&gt;“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]</p>
<p> “服务器”-&gt;“客户”：{你好，你的余额是100元}[密钥|对称加密算法]</p>
<p> …… //继续其它的通信</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\01.png" style="zoom: 67%;">

<p><strong>为什么建立连接的时候不能用对称加密的方式呢？</strong></p>
<ol>
<li>如果对称加密每个客户端拿到的秘钥都是相同的，那么黑客也能够通过截获其它客户端的秘钥来截获信息</li>
<li>如果为每个客户端都生成一个新的秘钥，那么就会占用服务器端大量的内存</li>
</ol>
<h3 id="4-完整性保护"><a href="#4-完整性保护" class="headerlink" title="4.完整性保护"></a>4.完整性保护</h3><p>MD5 是一种信息-摘要算法，它可以说是文件的“数字指纹”，不论是一个什么文件，都有一个独一无二的 MD5 信息值，假设这个文件被改动过，它的 MD5 值也将随之改变。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h3 id="5-HTTPS-的缺点"><a href="#5-HTTPS-的缺点" class="headerlink" title="5. HTTPS 的缺点"></a>5. HTTPS 的缺点</h3><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h2 id="7-8-HTTP-与-HTTPS-的区别"><a href="#7-8-HTTP-与-HTTPS-的区别" class="headerlink" title="7.8 HTTP 与 HTTPS 的区别"></a>7.8 HTTP 与 HTTPS 的区别</h2><ol>
<li>安全性：HTTP 使用明文传输，不需要验证服务端的身份，HTTPS 建立连接之前需要验证服务器的身份，使用密文传输安全性更高；</li>
<li>完整性：HTTP 不能保证报文的完整性，HTTPS 通过密文 + MD5 算法保证报文的完整性；</li>
<li>端口号：HTTP 默认的端口号是 80 端口，HTTPS 默认的端口号是 443 端口；</li>
<li>费用：HTTPS 需要 CA 证书，往往需要较高的费用；</li>
<li>效率：HTTPS 需要加密、解密等过程，因此速率比较低。</li>
</ol>
<h1 id="8-Web-安全相关"><a href="#8-Web-安全相关" class="headerlink" title="8. Web 安全相关"></a>8. Web 安全相关</h1><p>见《大型网站技术架构》</p>
<p><strong>解析：</strong>防御措施围绕着一个主题，“<strong>永远不要相信客户端</strong>”。对客户端的每次请求，我们都要做好充分的过滤，验证与授权，这样才可以尽可能的避免常见的 Web 安全漏洞，抵御来自外部世界的攻击。</p>
<h1 id="9-一个网络数据包的组成"><a href="#9-一个网络数据包的组成" class="headerlink" title="9.一个网络数据包的组成"></a>9.一个网络数据包的组成</h1><p><strong>面试官问题：一个网络数据包包括哪些有了解吗？</strong></p>
<p><strong>答：</strong>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<img src="/2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/GitHub\MyBlogs\source\_posts\2021-03-13-计算机网络\03.png" alt="图片说明" style="zoom:80%;">

<p>在UDP协议中就是UDP头部，各个头部都有其固定的格式，TCP头部最小20个字节，UDP头部最小8个字节。</p>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i>  计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/08/SpringMVC/" rel="prev" title="SpringMVC执行原理">
      <i class="fa fa-chevron-left"></i> SpringMVC执行原理
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统相关">
      操作系统相关 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1主机之间的通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.</span> <span class="nav-text">1.2电路交换与分组交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.电路交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.分组交换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">1.3计算机网络体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.</span> <span class="nav-text">1.4七层模型的功能及相关协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">1.5数据在各层的具体传输过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">2.物理层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%B8%A6%E9%80%9A%E8%B0%83%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">2.2带通调制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">3.链路层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">4.网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">4.1概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-IP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 IP 数据报格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-IP-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 IP 地址编址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.1.</span> <span class="nav-text">1.分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86"><span class="nav-number">4.3.2.</span> <span class="nav-text">2.子网划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%97%A0%E5%88%86%E7%B1%BB"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.无分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE-ARP"><span class="nav-number">4.4.</span> <span class="nav-text">4.4地址解析协议 ARP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-ICMP"><span class="nav-number">4.5.</span> <span class="nav-text">4.5网际控制报文协议 ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Ping"><span class="nav-number">4.5.1.</span> <span class="nav-text">1. Ping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Traceroute"><span class="nav-number">4.5.2.</span> <span class="nav-text">2. Traceroute</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-NAT"><span class="nav-number">4.6.</span> <span class="nav-text">4.6网络地址转换 NAT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-number">4.7.</span> <span class="nav-text">4.7路由器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">4.7.1.</span> <span class="nav-text">路由器的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">4.7.2.</span> <span class="nav-text">路由器分组转发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%EF%BC%88%E6%B2%A1%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="nav-number">4.7.3.</span> <span class="nav-text">路由选择协议（没掌握）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">5.传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-TCP-%E4%B8%8E-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 TCP 与 UDP 协议的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-UDP-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 UDP 首部格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-TCP-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 TCP 首部格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 TCP 的三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="nav-number">5.4.1.</span> <span class="nav-text">1.为什么要三次握手，两次可以吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN"><span class="nav-number">5.4.2.</span> <span class="nav-text">2.为什么要传回 SYN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%A0%E4%BA%86-SYN%EF%BC%8C%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E4%BC%A0-ACK"><span class="nav-number">5.4.3.</span> <span class="nav-text">3.传了 SYN，为啥还要传 ACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-SYN-%E6%94%BB%E5%87%BB"><span class="nav-number">5.4.4.</span> <span class="nav-text">4.SYN 攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-TCP-%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 TCP 的四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">5.5.1.</span> <span class="nav-text">1.为什么要进行四次挥手过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP-%E8%BF%9E%E6%8E%A5%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98"><span class="nav-number">5.5.2.</span> <span class="nav-text">2. TCP 连接出现故障问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%85%B3%E4%BA%8E-TIME-WAIT"><span class="nav-number">5.5.3.</span> <span class="nav-text">3.关于 TIME_WAIT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-TCP-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 TCP 可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-TCP-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">5.6.1.</span> <span class="nav-text">1. TCP 流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.6.2.</span> <span class="nav-text">2. TCP 拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-TCP-%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 TCP 粘包现象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.7.1.</span> <span class="nav-text">1.原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">5.7.2.</span> <span class="nav-text">2.解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E4%BC%9A%E6%9C%89%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1%EF%BC%8C%E8%80%8CUDP%E6%B2%A1%E6%9C%89"><span class="nav-number">5.7.3.</span> <span class="nav-text">3.为什么TCP会有粘包现象，而UDP没有</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-TCP%EF%BC%8CUDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.8.</span> <span class="nav-text">5.8 TCP，UDP 协议的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9%E7%82%B9%E5%AF%B9%E7%82%B9%E4%B8%8E%E7%AB%AF%E5%AF%B9%E7%AB%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.9.</span> <span class="nav-text">5.9点对点与端对端的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">6.</span> <span class="nav-text">6.应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.1.</span> <span class="nav-text">1.浏览器输入url并回车的过程以及相关协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">2.DNS域名解析的过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-HTTP"><span class="nav-number">7.</span> <span class="nav-text">7. HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">7.1基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">7.1.1.</span> <span class="nav-text">1.请求和响应报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-URL"><span class="nav-number">7.1.2.</span> <span class="nav-text">2. URL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-HTTP-%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 HTTP 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-GET-%E5%92%8C-POST-%E6%AF%94%E8%BE%83"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 GET 和 POST 比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="nav-number">7.3.1.</span> <span class="nav-text">1.作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0"><span class="nav-number">7.3.2.</span> <span class="nav-text">2.参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8"><span class="nav-number">7.3.3.</span> <span class="nav-text">3.安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B9%82%E7%AD%89%E6%80%A7"><span class="nav-number">7.3.4.</span> <span class="nav-text">4.幂等性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8F%AF%E7%BC%93%E5%AD%98"><span class="nav-number">7.3.5.</span> <span class="nav-text">5.可缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 HTTP 状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5%E4%B8%8D%E5%90%8C-HTTP-%E7%89%88%E6%9C%AC%E6%AF%94%E8%BE%83"><span class="nav-number">7.5.</span> <span class="nav-text">7.5不同 HTTP 版本比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-1-0-%E5%92%8C-HTTP-1-1-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.5.1.</span> <span class="nav-text">1. HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.5.2.</span> <span class="nav-text">2. HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8"><span class="nav-number">7.6.</span> <span class="nav-text">7.6具体应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="nav-number">7.6.1.</span> <span class="nav-text">1.连接管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Cookie"><span class="nav-number">7.6.2.</span> <span class="nav-text">2. Cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Session"><span class="nav-number">7.6.3.</span> <span class="nav-text">3. Session</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Token"><span class="nav-number">7.6.4.</span> <span class="nav-text">4. Token</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-HTTPS"><span class="nav-number">7.7.</span> <span class="nav-text">7.7 HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8A%A0%E5%AF%86"><span class="nav-number">7.7.1.</span> <span class="nav-text">1.加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-CA-%E8%AF%81%E4%B9%A6"><span class="nav-number">7.7.2.</span> <span class="nav-text">2. CA 证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%A4%E8%AF%81"><span class="nav-number">7.7.3.</span> <span class="nav-text">3.认证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4"><span class="nav-number">7.7.4.</span> <span class="nav-text">4.完整性保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-HTTPS-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">7.7.5.</span> <span class="nav-text">5. HTTPS 的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-HTTP-%E4%B8%8E-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.8.</span> <span class="nav-text">7.8 HTTP 与 HTTPS 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Web-%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">8.</span> <span class="nav-text">8. Web 安全相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">9.</span> <span class="nav-text">9.一个网络数据包的组成</span></a></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">912k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:49</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

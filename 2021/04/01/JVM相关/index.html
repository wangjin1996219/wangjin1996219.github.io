<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="JVM相关">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-01-JVM相关/图片01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-01-JVM相关/图片02.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-01-JVM相关/图片03.jpg">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-01-JVM相关/图片04.jpg">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-01-JVM相关/图片05.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-01-JVM相关/图片06.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-01-JVM相关/图片07.jpg">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-01-JVM相关/图片08.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-01-JVM相关/图片09.png">
<meta property="article:published_time" content="2021-04-01T14:40:45.000Z">
<meta property="article:modified_time" content="2021-08-08T07:47:37.676Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="Java虚拟机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM相关 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM相关
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 22:40:45" itemprop="dateCreated datePublished" datetime="2021-04-01T22:40:45+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-08 15:47:37" itemprop="dateModified" datetime="2021-08-08T15:47:37+08:00">2021-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
                </span>
            </span>

          
            <span id="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="JVM相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-JAVA内存区域"><a href="#1-JAVA内存区域" class="headerlink" title="1.JAVA内存区域"></a>1.JAVA内存区域</h1><h2 id="1-1JVM的主要组成部分及作用"><a href="#1-1JVM的主要组成部分及作用" class="headerlink" title="1.1JVM的主要组成部分及作用"></a>1.1JVM的主要组成部分及作用</h2><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>两个子系统：</strong></p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
</ul>
<p><strong>两个组件：</strong></p>
<ul>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码文件，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h2 id="1-2-JVM-运行时数据区"><a href="#1-2-JVM-运行时数据区" class="headerlink" title="1.2 JVM 运行时数据区"></a>1.2 JVM 运行时数据区</h2><p><strong>已经整理，见另一篇文章。</strong></p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片01.png" alt="img" style="zoom: 50%;">

<p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）</strong>：</p>
<ul>
<li><p><strong>程序计数器（Program Counter Register）：</strong>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈（被指令操作的数据）、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片02.png" alt="img" style="zoom:80%;">

<p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li>
</ul>
</li>
<li><p><strong>本地方法栈（Native Method Stack）：</strong>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 堆（Java Heap）：</strong>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例和数组都在这里分配内存；<strong>（线程共享）</strong></p>
<p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：新生代（Young Generation）、老年代（Old Generation）。在细致一点的有Eden空间、From Survivor 空间、To Survior 空间等。</p>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


</li>
</ul>
<p>​       上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。（年轻代：老年代=8:1）</p>
<ul>
<li><strong>方法区（Methed Area）：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译（ JIT 编译）后的代码等数据。<strong>（线程共享）</strong></li>
</ul>
<h2 id="1-3深拷贝与浅拷贝"><a href="#1-3深拷贝与浅拷贝" class="headerlink" title="1.3深拷贝与浅拷贝"></a>1.3深拷贝与浅拷贝</h2><blockquote>
<p><strong>注：</strong>深拷贝和浅拷贝都是对象拷贝</p>
</blockquote>
<ul>
<li><p><strong>浅拷贝：</strong>对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p>
<p>简而言之，<code>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</code></p>
</li>
<li><p><strong>深拷贝：</strong>当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>简而言之，<code>深拷贝把要复制的对象所引用的对象都复制了一遍。</code></p>
</li>
</ul>
<h2 id="1-4堆栈的区别"><a href="#1-4堆栈的区别" class="headerlink" title="1.4堆栈的区别"></a>1.4堆栈的区别</h2><ul>
<li><p><strong>物理地址</strong></p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
</li>
<li><p><strong>内存分配</strong></p>
<p>堆因为是不连续的，所以分配的内存是在<strong>运行期</strong>确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在<strong>编译期</strong>就确认，大小是固定的。</p>
</li>
<li><p><strong>存放的内容</strong></p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是<strong>数据的存储</strong></p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是<strong>程序方法的执行</strong>。</p>
</li>
<li><p>程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
</li>
</ul>
<h2 id="1-5队列和栈的区别"><a href="#1-5队列和栈的区别" class="headerlink" title="1.5队列和栈的区别"></a>1.5队列和栈的区别</h2><p>队列和栈都是被用来预存储数据的。</p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li>
</ul>
<h1 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h1><h2 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p><strong>对象创建的主要流程：</strong></p>
<p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定</strong>。</p>
<p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="2-2对象分配内存的方式"><a href="#2-2对象分配内存的方式" class="headerlink" title="2.2对象分配内存的方式"></a>2.2对象分配内存的方式</h2><p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配<strong>根据Java堆是否规整</strong>，有两种方式：</p>
<ul>
<li>指针碰撞：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<h2 id="2-3对象的访问定位"><a href="#2-3对象的访问定位" class="headerlink" title="2.3对象的访问定位"></a>2.3对象的访问定位</h2><p><code>Java</code>程序需要通过 <code>JVM</code> 栈上的引用访问堆中的具体对象。对象的访问方式取决于 <code>JVM</code> 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p>
<blockquote>
<p><strong>指针：</strong> 指向对象，代表一个对象在内存中的起始地址。</p>
<p><strong>句柄：</strong> 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<h3 id="1-句柄访问"><a href="#1-句柄访问" class="headerlink" title="1.句柄访问"></a>1.句柄访问</h3><p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p>
<p><strong>缺点：</strong>句柄地址方式不直接，访问速度较慢。</p>
<h3 id="2-直接指针"><a href="#2-直接指针" class="headerlink" title="2.直接指针"></a>2.直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么<code>Java</code>堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p>
<img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="2-4堆内存中对象的分配的基本策略"><a href="#2-4堆内存中对象的分配的基本策略" class="headerlink" title="2.4堆内存中对象的分配的基本策略"></a>2.4堆内存中对象的分配的基本策略</h2><p><strong>堆空间的基本结构：</strong></p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


<p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>另外，大对象和长期存活的对象会直接进入老年代。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg" alt="堆内存常见分配策略"></p>
<h1 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3.垃圾收集"></a>3.垃圾收集</h1><h2 id="3-1-Java-垃圾回收机制"><a href="#3-1-Java-垃圾回收机制" class="headerlink" title="3.1 Java 垃圾回收机制"></a>3.1 Java 垃圾回收机制</h2><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h2 id="3-2-GC-及作用"><a href="#3-2-GC-及作用" class="headerlink" title="3.2 GC 及作用"></a>3.2 GC 及作用</h2><p><strong>GC</strong> 是垃圾收集的意思</p>
<p><strong>作用一：</strong>Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，避免了编程人员忘记或者错误的内存回收导致程序或系统的不稳定甚至崩溃。</p>
<p><strong>作用二：</strong>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<blockquote>
<p><strong>Note：</strong></p>
<p>Java 语言没有提供释放已分配内存的显示操作方法</p>
<p><strong>内存泄漏：</strong>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
</blockquote>
<h2 id="3-3垃圾回收器的基本原理"><a href="#3-3垃圾回收器的基本原理" class="headerlink" title="3.3垃圾回收器的基本原理"></a>3.3垃圾回收器的基本原理</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>程序员也可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<blockquote>
<p><strong>Note：</strong>释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”。GC将负责回收所有”不可达”对象的内存空间。</p>
<p>比如 ：</p>
<p>class1 aa = new class();  </p>
<p>aa=null; </p>
<p>那在堆上分配的内存上的数据 就无法访问到了，就是不可达对象。</p>
</blockquote>
<h2 id="3-4-Minor-Gc和-Full-GC-有什么不同"><a href="#3-4-Minor-Gc和-Full-GC-有什么不同" class="headerlink" title="3.4 Minor Gc和 Full GC 有什么不同"></a>3.4 Minor Gc和 Full GC 有什么不同</h2><ul>
<li><strong>新生代GC（Minor GC）：</strong>回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li><strong>老年代GC（Major GC/Full GC）：</strong>:回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</li>
</ul>
<h2 id="3-5判断对象是否可以被回收"><a href="#3-5判断对象是否可以被回收" class="headerlink" title="3.5判断对象是否可以被回收"></a>3.5判断对象是否可以被回收</h2><p>等同于判定哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断：</p>
<p><strong>1. 引用计数法</strong></p>
<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p>
<p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test a = <span class="keyword">new</span> Test();</span><br><span class="line">        Test b = <span class="keyword">new</span> Test();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p>
<p><strong>2. 可达性分析算法</strong></p>
<p><strong>可达性分析算法：</strong>基本思路就是通过一系列名为 ”GC Roots” 的对象作为起始点，从这个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。以下对象会被认为是 Roots 对象：</p>
<ul>
<li><strong>栈内存中引用的对象</strong> </li>
<li><strong>方法区中静态引用和常量引用指向的对象</strong> </li>
<li>被启动类（bootstrap加载器）加载的类和创建的对象 </li>
<li>Native 方法中 JNI 引用的对象</li>
</ul>
<img src="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:90%;">

<h2 id="3-6引用类型"><a href="#3-6引用类型" class="headerlink" title="3.6引用类型"></a>3.6引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p>
<p>Java 提供了四种强度不同的引用类型。</p>
<ul>
<li><p><strong>强引用(StrongReference)</strong></p>
<p>被强引用关联的对象不会被回收，当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<p>使用 new 一个新对象的方式来创建强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>软引用(SoftReference)</strong></p>
<p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>使用 SoftReference 类来创建软引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>弱引用(WeakReference)</strong></p>
<p>在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存，也就是说它只能存活到下一次垃圾回收发生之前。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>使用 WeakReference 类来创建弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>虚引用（PhantomReference）</strong></p>
<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p>
<p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p>
<p>使用 PhantomReference 来创建虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<blockquote>
<p><strong>Note：</strong>ReferenceQueue主要是用于监听Reference所指向的对象是否已经被垃圾回收。</p>
</blockquote>
</li>
</ul>
<h2 id="3-7-JVM-中的垃圾回收算法"><a href="#3-7-JVM-中的垃圾回收算法" class="headerlink" title="3.7 JVM 中的垃圾回收算法"></a>3.7 JVM 中的垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h3><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>优点：实现简单，不需要对象进行移动。</p>
<p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。<br><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h3><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。</p>
<ul>
<li>它把内存空间划为两个相等的区域，每次只使用其中一个区域</li>
<li>垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中</li>
<li>最后将当前使用的区域的可回收的对象进行回收</li>
</ul>
<p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。<br><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h3><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为<strong>老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低</strong>。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-清除算法不同的是：</p>
<ul>
<li>在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起</li>
<li>然后对端边界以外的内存进行回收</li>
<li>回收后，已用和未用的内存都各自一边</li>
</ul>
<p>优点：解决了标记-清理算法存在的内存碎片问题。</p>
<p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。<br><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h3><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p>一般将堆分为新生代和老年代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<h2 id="3-7JVM-垃圾回收器"><a href="#3-7JVM-垃圾回收器" class="headerlink" title="3.7JVM 垃圾回收器"></a>3.7JVM 垃圾回收器</h2><p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片03.jpg" alt="img"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。<strong>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</strong></li>
</ul>
<h3 id="5-CMS-收集器"><a href="#5-CMS-收集器" class="headerlink" title="5. CMS 收集器"></a>5. CMS 收集器</h3><p>CMS 垃圾回收器是第一款并发收集器，第一次实现了让垃圾收集器线程与用户线程同时工作，它的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。延迟越低，越能提高响应速度，进而提升用户的体验。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片04.jpg" alt="img"></p>
<p><strong>CMS收集器：</strong>基于“标记-清除”算法实现，会出现 “Stop The World”。</p>
<p><strong>运作过程如下：</strong></p>
<ul>
<li><strong>初始标记：</strong> 仅仅<strong>只是标记一下 GC Roots 能直接关联到的对象</strong>，需要 “Stop The World”，但是速度很快。</li>
<li><strong>并发标记：</strong> 进行 GC Roots Tracing 的过程，<strong>从 GC Roots 能直接关联到的对象开始遍历整个对象图的过程</strong>，它在整个回收过程中耗时最长，不需要停顿。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是<strong>为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li>
<li><strong>并发清除：</strong> 该阶段<strong>清理掉标记阶段判断已经死亡的对象，释放内存空间</strong>，不需要停顿。</li>
</ul>
<p><strong>优点：</strong></p>
<p>由于在整个过程和中最耗时的并发标记和并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的，所以<strong>停顿时间比较短</strong></p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>CMS 收集器对 CPU 资源非常敏感</strong></p>
<p>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，</p>
</li>
<li><p><strong>CMS 处理器无法处理浮动垃圾</strong> </p>
<p>CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾” ， </p>
</li>
<li><p><strong>CMS 收集器会产生空间碎片</strong></p>
<p>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发 Full GC。</p>
</li>
</ul>
<h3 id="6-G1-垃圾回收器"><a href="#6-G1-垃圾回收器" class="headerlink" title="6. G1 垃圾回收器"></a>6. G1 垃圾回收器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>
<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片05.png" alt="img"></p>
<p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片06.png" alt="img"></p>
<p>通过引入 Region  的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得<strong>可预测的停顿时间模型</strong>成为可能。通过记录每个 Region  垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，<strong>优先回收价值最大的  Region</strong>。避免了在整个 Java 堆中进行全区域的垃圾收集，而是回收价值最大的区域。</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>
<p><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-01-JVM相关\图片07.jpg" alt="img"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li><strong>初始标记：</strong>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象</li>
<li><strong>并发标记：</strong>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的  Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered  Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li><strong>筛选回收：</strong>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p><strong>并行与并发</strong></p>
<p>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU或者CPU核心）来缩短 stop-The-World 停顿时间</p>
</li>
<li><p><strong>分代收集</strong></p>
<p>G1 不需要其他收集器就能独立管理整个 GC 堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次 GC 的对象。 </p>
</li>
<li><p><strong>减少空间碎片</strong></p>
<p>G1 从整体来看是基于标记-整理算法（将不需要回收的 region 压缩到一起），从局部（两个Region）上看基于复制算法实现，G1 运作期间不会产生内存空间碎片。 </p>
</li>
<li><p><strong>可预测的停顿</strong></p>
<p>这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能<strong>建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对内存和CPU要求高一些</li>
</ul>
<h1 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4.内存分配与回收策略"></a>4.内存分配与回收策略</h1><h2 id="4-1-Minor-GC-和-Full-GC"><a href="#4-1-Minor-GC-和-Full-GC" class="headerlink" title="4.1 Minor GC 和 Full GC"></a>4.1 Minor GC 和 Full GC</h2><ul>
<li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>
</ul>
<h2 id="4-2内存分配策略"><a href="#4-2内存分配策略" class="headerlink" title="4.2内存分配策略"></a>4.2内存分配策略</h2><p><strong>1. 对象优先在 Eden 分配</strong></p>
<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>
<p><strong>2. 大对象直接进入老年代</strong></p>
<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>
<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>
<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>
<p><strong>3. 长期存活的对象进入老年代</strong></p>
<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>
<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>
<p><strong>4. 动态对象年龄判定</strong></p>
<p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor  空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>
<p><strong>5. 空间分配担保</strong></p>
<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure  的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次  Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p>
<h2 id="4-3-Full-GC-的触发条件"><a href="#4-3-Full-GC-的触发条件" class="headerlink" title="4.3 Full GC 的触发条件"></a>4.3 Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<p><strong>1. 调用 System.gc()</strong></p>
<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>
<p><strong>2. 老年代空间不足</strong></p>
<p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p>
<p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn  虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold  调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>
<p><strong>3. 空间分配担保失败</strong></p>
<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p>
<p><strong>4. JDK 1.7 及以前的永久代空间不足</strong></p>
<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p>
<p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p>
<p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p>
<p><strong>5. Concurrent Mode Failure</strong></p>
<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 CMS GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="5-虚拟机类加载机制"><a href="#5-虚拟机类加载机制" class="headerlink" title="5.虚拟机类加载机制"></a>5.虚拟机类加载机制</h1><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h2 id="5-1类的生命周期"><a href="#5-1类的生命周期" class="headerlink" title="5.1类的生命周期"></a>5.1类的生命周期</h2><img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片08.png" alt="img" style="zoom:67%;">

<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<h2 id="5-2类装载的过程"><a href="#5-2类装载的过程" class="headerlink" title="5.2类装载的过程"></a>5.2类装载的过程</h2><p><strong>类装载分为以下 5 个步骤：</strong></p>
<p><strong>1.加载</strong></p>
<p>根据查找路径找到相应的 class 文件然后导入 JVM 内存中</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流。</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，最典型的应用是 Applet。</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li>
</ul>
<p><strong>2.验证</strong></p>
<p>检查加载的 class 文件的正确性，确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求。</p>
<p><strong>3.准备</strong></p>
<p>给类中的静态变量分配内存空间；</p>
<p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4.解析</strong></p>
<p>虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。</p>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<p><strong>5.初始化</strong></p>
<p>对静态变量和静态代码块执行初始化工作。</p>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;()  方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;()  是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成  &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的  &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的  &lt;clinit&gt;() 方法。</p>
<p>虚拟机会保证一个类的 &lt;clinit&gt;()  方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;()  方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;()  方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p>
<h2 id="5-3类与类加载器"><a href="#5-3类与类加载器" class="headerlink" title="5.3类与类加载器"></a>5.3类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p>
<p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p>
<h2 id="5-4类加载器的分类"><a href="#5-4类加载器的分类" class="headerlink" title="5.4类加载器的分类"></a>5.4类加载器的分类</h2><p>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 <JRE_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如  rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java  程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</JRE_HOME></li>
<li>扩展类加载器（Extension ClassLoader）这个类加载器是由  ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将  <JAVA_HOME>/lib/ext 或者被 java.ext.dir  系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</JAVA_HOME></li>
<li>应用程序类加载器（Application ClassLoader）这个类加载器是由  AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是  ClassLoader 中的 getSystemClassLoader()  方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h2 id="5-5双亲委派模型"><a href="#5-5双亲委派模型" class="headerlink" title="5.5双亲委派模型"></a>5.5双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p>
<p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation  Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p>
<img src="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-01-JVM相关\图片09.png" alt="img" style="zoom:67%;">

<p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p><strong>双亲委派模型的优势：</strong></p>
<ul>
<li><p><strong>避免重复加载</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
</li>
<li><p><strong>避免核心类篡改</strong></p>
<p>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass()  方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出  ClassNotFoundException，此时尝试自己去加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义类加载器的实现</strong></p>
<p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自  java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class  文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p>
<p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">&#x27;.&#x27;</span>, File.separatorChar) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打破双亲委派模型的方法</strong></p>
<p>继承 ClassLoader 类，重写 loadClass 和 findClass 方法</p>
<p>默认的 loadClass 方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。为了破坏双亲委派机制必须重写 loadClass 方法，先尝试交由 System 类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。</p>
<blockquote>
<p><strong>findClass方法：</strong>用户自定义类加载逻辑</p>
<p><strong>loadClass方法：</strong>双亲委派的具体逻辑实现，在该方法中，如果父类加载失败，则会调用自己的 findClass（）方法来完成加载</p>
</blockquote>
<h1 id="6-JVM调优"><a href="#6-JVM调优" class="headerlink" title="6. JVM调优"></a>6. JVM调优</h1><p>程序在上线前的测试或运行中有时会出现一些大大小小的JVM问题，比如<strong>cpu  load过高、请求延迟、tps降低</strong>等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对JVM进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。</p>
<h2 id="6-1-JVM-调优目标"><a href="#6-1-JVM-调优目标" class="headerlink" title="6.1 JVM 调优目标"></a>6.1 JVM 调优目标</h2><p>使用较小的内存占用来获得较高的吞吐量或者较低的延迟。</p>
<p>这里有几个比较重要的指标：</p>
<ul>
<li>内存占用：程序正常运行需要的内存大小。</li>
<li>延迟：由于垃圾收集而引起的程序停顿时间。</li>
<li>吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。</li>
</ul>
<p>调优的目的并不是让程序内存占用小、延迟低、高吞吐量同时具有，而是要根据明确的优化目标，找到性能的瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。</p>
<h2 id="6-2-JVM-调优工具"><a href="#6-2-JVM-调优工具" class="headerlink" title="6.2 JVM 调优工具"></a>6.2 JVM 调优工具</h2><p>调优可以依赖参考的数据有</p>
<ol>
<li><strong>系统运行日志：</strong>系统运行日志就是在程序代码中打印出的日志，描述了代码级别的系统运行轨迹（执行的方法、入参、返回值等），一般系统出现问题，系统运行日志是首先要查看的日志。</li>
<li><strong>堆栈错误信息：</strong>当系统出现异常后，可以根据堆栈信息初步定位问题所在，比如根据“java.lang.OutOfMemoryError: Java heap  space”可以判断是堆内存溢出；根据“java.lang.StackOverflowError”可以判断是栈溢出；根据“java.lang.OutOfMemoryError: PermGen space”可以判断是方法区溢出等。</li>
<li><strong>gc日志：</strong>程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:/data/jvm/gc.log  可以在程序运行时把gc的详细过程记录下来，或者直接配置“-verbose:gc”参数把gc日志打印到控制台，通过记录的gc日志可以分析每块内存区域gc的频率、时间等，从而发现问题，进行有针对性的优化。 </li>
<li><strong>线程快照：</strong>根据线程快照可以看到线程在某一时刻的状态，当系统中可能存在请求超时、死循环、死锁等情况时，可以根据线程快照来进一步确定问题。</li>
<li><strong>堆转储快照：</strong>程序启动时可以使用 “-XX:+HeapDumpOnOutOfMemory” 和  “-XX:HeapDumpPath=/data/jvm/dumpfile.hprof”，当程序发生内存溢出时，把当时的内存快照以文件形式进行转储（也可以直接用jmap命令转储程序运行时任意时刻的内存快照），事后对当时的内存使用情况进行分析。</li>
</ol>
<p><strong>JVM调优工具：</strong></p>
<p>用 jps（JVM process Status）可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数（要加上-v参数）等</p>
<p>用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息 </p>
<p>用jmap（Memory Map for Java）查看堆内存信息 </p>
<p>利用jconsole、jvisualvm分析内存信息(各个区如Eden、Survivor、Old等内存变化情况)，如果查看的是远程服务器的JVM，程序启动需要附加参数</p>
<h2 id="6-3常用-JVM-参数参考"><a href="#6-3常用-JVM-参数参考" class="headerlink" title="6.3常用 JVM 参数参考"></a>6.3常用 JVM 参数参考</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms</td>
<td align="center">初始堆大小，默认物理内存的1/64</td>
<td align="center">-Xms512M</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">最大堆大小，默认物理内存的1/4</td>
<td align="center">-Xms2G</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="center">新生代内存大小，官方推荐为整个堆的3/8</td>
<td align="center">-Xmn512M</td>
</tr>
<tr>
<td align="center">-Xss</td>
<td align="center">线程堆栈大小，jdk1.5及之后默认1M，之前默认256k</td>
<td align="center">-Xss512k</td>
</tr>
<tr>
<td align="center">-XX:NewRatio=n</td>
<td align="center">设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</td>
<td align="center">-XX:NewRatio=3</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio=n</td>
<td align="center">年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如:8，表示Eden：Survivor=8:1:1，一个Survivor区占整个年轻代的1/8</td>
<td align="center">-XX:SurvivorRatio=8</td>
</tr>
<tr>
<td align="center">-XX:PermSize=n</td>
<td align="center">永久代初始值，默认为物理内存的1/64</td>
<td align="center">-XX:PermSize=128M</td>
</tr>
<tr>
<td align="center">-XX:MaxPermSize=n</td>
<td align="center">永久代最大值，默认为物理内存的1/4</td>
<td align="center">-XX:MaxPermSize=256M</td>
</tr>
<tr>
<td align="center">-verbose:class</td>
<td align="center">在控制台打印类加载信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-verbose:gc</td>
<td align="center">在控制台打印垃圾回收日志</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGC</td>
<td align="center">打印GC日志，内容简单</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td align="center">打印GC日志，内容详细</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDateStamps</td>
<td align="center">在GC日志中添加时间戳</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-Xloggc:filename</td>
<td align="center">指定gc日志路径</td>
<td align="center">-Xloggc:/data/jvm/gc.log</td>
</tr>
<tr>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">年轻代设置串行收集器Serial</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseParallelGC</td>
<td align="center">年轻代设置并行收集器Parallel Scavenge</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:ParallelGCThreads=n</td>
<td align="center">设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。</td>
<td align="center">-XX:ParallelGCThreads=4</td>
</tr>
<tr>
<td align="center">-XX:MaxGCPauseMillis=n</td>
<td align="center">设置Parallel Scavenge回收的最大时间(毫秒)</td>
<td align="center">-XX:MaxGCPauseMillis=100</td>
</tr>
<tr>
<td align="center">-XX:GCTimeRatio=n</td>
<td align="center">设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</td>
<td align="center">-XX:GCTimeRatio=19</td>
</tr>
<tr>
<td align="center">-XX:+UseParallelOldGC</td>
<td align="center">设置老年代为并行收集器ParallelOld收集器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseConcMarkSweepGC</td>
<td align="center">设置老年代并发收集器CMS</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+CMSIncrementalMode</td>
<td align="center">设置CMS收集器为增量模式，适用于单CPU情况。</td>
<td align="center"></td>
</tr>
</tbody></table>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i>  Java虚拟机</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="prev" title="广度优先遍历">
      <i class="fa fa-chevron-left"></i> 广度优先遍历
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/02/Java%E5%9F%BA%E7%A1%80/" rel="next" title="Java基础">
      Java基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.</span> <span class="nav-text">1.JAVA内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1JVM%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.1JVM的主要组成部分及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 JVM 运行时数据区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.3.</span> <span class="nav-text">1.3深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">1.4堆栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">1.5队列和栈的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="nav-number">2.</span> <span class="nav-text">2.HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">2.1对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">2.2对象分配内存的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.3.</span> <span class="nav-text">2.3对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.句柄访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.直接指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="nav-number">2.4.</span> <span class="nav-text">2.4堆内存中对象的分配的基本策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">3.</span> <span class="nav-text">3.垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Java 垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-GC-%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 GC 及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">3.3垃圾回收器的基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Minor-Gc%E5%92%8C-Full-GC-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Minor Gc和 Full GC 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.</span> <span class="nav-text">3.5判断对象是否可以被回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.6.</span> <span class="nav-text">3.6引用类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-JVM-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 JVM 中的垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.1.</span> <span class="nav-text">1.标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.2.</span> <span class="nav-text">2.复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.7.4.</span> <span class="nav-text">4.分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.8.</span> <span class="nav-text">3.7JVM 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.8.1.</span> <span class="nav-text">5. CMS 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.8.2.</span> <span class="nav-text">6. G1 垃圾回收器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">4.</span> <span class="nav-text">4.内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Minor-GC-%E5%92%8C-Full-GC"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Minor GC 和 Full GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.</span> <span class="nav-text">4.2内存分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Full-GC-%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Full GC 的触发条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">5.虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.1.</span> <span class="nav-text">5.1类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">5.2类装载的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">5.3类与类加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">5.4类加载器的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5.5双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-JVM%E8%B0%83%E4%BC%98"><span class="nav-number">6.</span> <span class="nav-text">6. JVM调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-JVM-%E8%B0%83%E4%BC%98%E7%9B%AE%E6%A0%87"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 JVM 调优目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-JVM-%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 JVM 调优工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3%E5%B8%B8%E7%94%A8-JVM-%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83"><span class="nav-number">6.3.</span> <span class="nav-text">6.3常用 JVM 参数参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">912k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:49</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

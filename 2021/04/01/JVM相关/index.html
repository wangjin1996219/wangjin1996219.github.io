<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="JVM相关">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images.xiaozhuanlan.com/photo/2019/81ccc1600b6a2fdab98115abeea41877.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200104165551656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2021-04-01T14:40:45.000Z">
<meta property="article:modified_time" content="2021-05-15T15:42:23.508Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="JVM相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM相关 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">67</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/04/01/JVM%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM相关
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 22:40:45" itemprop="dateCreated datePublished" datetime="2021-04-01T22:40:45+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-15 23:42:23" itemprop="dateModified" datetime="2021-05-15T23:42:23+08:00">2021-05-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="JVM相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/01/JVM%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<blockquote>
<p><strong>该博客出处：</strong><a target="_blank" rel="noopener" href="https://thinkwon.blog.csdn.net/article/details/104390752">点击链接</a></p>
</blockquote>
<h1 id="1-JAVA内存区域"><a href="#1-JAVA内存区域" class="headerlink" title="1.JAVA内存区域"></a>1.JAVA内存区域</h1><h2 id="1-1JVM的主要组成部分及作用"><a href="#1-1JVM的主要组成部分及作用" class="headerlink" title="1.1JVM的主要组成部分及作用"></a>1.1JVM的主要组成部分及作用</h2><img src="https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>两个子系统：</strong></p>
<ul>
<li>Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。</li>
<li>Execution engine（执行引擎）：执行classes中的指令。</li>
</ul>
<p><strong>两个组件：</strong></p>
<ul>
<li>Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。</li>
<li>Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。</li>
</ul>
<p><strong>作用 ：</strong>首先通过编译器把 Java 代码转换成字节码文件，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h2 id="1-2类的加载过程"><a href="#1-2类的加载过程" class="headerlink" title="1.2类的加载过程"></a>1.2类的加载过程</h2><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p>
<h2 id="1-3JVM-运行时数据区"><a href="#1-3JVM-运行时数据区" class="headerlink" title="1.3JVM 运行时数据区"></a>1.3JVM 运行时数据区</h2><img src="https://img-blog.csdnimg.cn/20200103213220764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域（五个）</strong>：</p>
<ul>
<li><p><strong>程序计数器（Program Counter Register）：</strong>当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 虚拟机栈（Java Virtual Machine Stacks）：</strong>用于存储局部变量表、操作数栈、动态链接、方法出口等信息；<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>本地方法栈（Native Method Stack）：</strong>与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；<strong>（线程私有、生命周期同线程生命周期）</strong></p>
</li>
<li><p><strong>Java 堆（Java Heap）：</strong>Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；<strong>（线程共享）</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


</li>
</ul>
<p>  上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。</p>
<ul>
<li><strong>方法区（Methed Area）：</strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。<strong>（线程共享）</strong></li>
</ul>
<h2 id="1-4深拷贝与浅拷贝"><a href="#1-4深拷贝与浅拷贝" class="headerlink" title="1.4深拷贝与浅拷贝"></a>1.4深拷贝与浅拷贝</h2><blockquote>
<p><strong>注：</strong>深拷贝和浅拷贝都是对象拷贝</p>
</blockquote>
<ul>
<li><p><strong>浅拷贝：</strong>对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。</p>
<p>简而言之，<code>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</code></p>
</li>
<li><p><strong>深拷贝：</strong>当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>简而言之，<code>深拷贝把要复制的对象所引用的对象都复制了一遍。</code></p>
</li>
</ul>
<h2 id="1-5堆栈的区别"><a href="#1-5堆栈的区别" class="headerlink" title="1.5堆栈的区别"></a>1.5堆栈的区别</h2><ul>
<li><p><strong>物理地址</strong></p>
<p>堆的物理地址分配对对象是不连续的。因此性能慢些。</p>
<p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</p>
</li>
<li><p><strong>内存分配</strong></p>
<p>堆因为是不连续的，所以分配的内存是在<strong>运行期</strong>确认的，因此大小不固定。一般堆大小远远大于栈。</p>
<p>栈是连续的，所以分配的内存大小要在<strong>编译期</strong>就确认，大小是固定的。</p>
</li>
<li><p><strong>存放的内容</strong></p>
<p>堆存放的是对象的实例和数组。因此该区更关注的是<strong>数据的存储</strong></p>
<p>栈存放：局部变量，操作数栈，返回结果。该区更关注的是<strong>程序方法的执行</strong>。</p>
</li>
<li><p>程序的可见度</p>
<p>堆对于整个应用程序都是共享、可见的。</p>
<p>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</p>
</li>
</ul>
<h2 id="1-6队列和栈是什么？有什么区别？"><a href="#1-6队列和栈是什么？有什么区别？" class="headerlink" title="1.6队列和栈是什么？有什么区别？"></a>1.6队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。</p>
<ul>
<li>操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。</li>
<li>可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</li>
<li>操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</li>
</ul>
<h1 id="2-HotSpot虚拟机对象探秘"><a href="#2-HotSpot虚拟机对象探秘" class="headerlink" title="2.HotSpot虚拟机对象探秘"></a>2.HotSpot虚拟机对象探秘</h1><h2 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h2><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>使用new关键字</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Class的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用Constructor类的newInstance方法</td>
<td>调用了构造函数</td>
</tr>
<tr>
<td>使用clone方法</td>
<td>没有调用构造函数</td>
</tr>
<tr>
<td>使用反序列化</td>
<td>没有调用构造函数</td>
</tr>
</tbody></table>
<p><strong>对象创建的主要流程：</strong></p>
<p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定</strong>。</p>
<p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<p><strong>扩展：为对象分配内存的方式</strong></p>
<p>类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配<strong>根据Java堆是否规整</strong>，有两种方式：</p>
<ul>
<li>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。</li>
<li>空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</li>
</ul>
<h2 id="2-2对象的访问定位"><a href="#2-2对象的访问定位" class="headerlink" title="2.2对象的访问定位"></a>2.2对象的访问定位</h2><p><code>Java</code>程序需要通过 <code>JVM</code> 栈上的引用访问堆中的具体对象。对象的访问方式取决于 <code>JVM</code> 虚拟机的实现。目前主流的访问方式有 <strong>句柄</strong> 和 <strong>直接指针</strong> 两种方式。</p>
<blockquote>
<p><strong>指针：</strong> 指向对象，代表一个对象在内存中的起始地址。</p>
<p><strong>句柄：</strong> 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。</p>
</blockquote>
<h3 id="2-2-1句柄访问"><a href="#2-2-1句柄访问" class="headerlink" title="2.2.1句柄访问"></a>2.2.1句柄访问</h3><p><code>Java</code>堆中划分出一块内存来作为<strong>句柄池</strong>，引用中存储对象的<strong>句柄地址</strong>，而句柄中包含了<strong>对象实例数据</strong>与<strong>对象类型数据</strong>各自的<strong>具体地址</strong>信息，具体构造如下图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200103213926911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：引用中存储的是<strong>稳定</strong>的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变<strong>句柄中</strong>的<strong>实例数据指针</strong>，而<strong>引用</strong>本身不需要修改。</p>
<h3 id="2-2-2直接指针"><a href="#2-2-2直接指针" class="headerlink" title="2.2.2直接指针"></a>2.2.2直接指针</h3><p>如果使用<strong>直接指针</strong>访问，<strong>引用</strong> 中存储的直接就是<strong>对象地址</strong>，那么<code>Java</code>堆对象内部的布局中就必须考虑如何放置访问<strong>类型数据</strong>的相关信息。</p>
<img src="https://img-blog.csdnimg.cn/20200103213948956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p><strong>优势</strong>：速度更<strong>快</strong>，节省了<strong>一次指针定位</strong>的时间开销。由于对象的访问在<code>Java</code>中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="2-3堆内存中对象的分配的基本策略"><a href="#2-3堆内存中对象的分配的基本策略" class="headerlink" title="2.3堆内存中对象的分配的基本策略"></a>2.3堆内存中对象的分配的基本策略</h2><p><strong>堆空间的基本结构：</strong></p>
<div align="center">  
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3堆结构.png" width="400px">
</div>


<p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>另外，大对象和长期存活的对象会直接进入老年代。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/8b15e0786919315de03da1f92d493b8d.jpg" alt="堆内存常见分配策略"></p>
<h1 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3.垃圾收集器"></a>3.垃圾收集器</h1><h2 id="3-1Java垃圾回收机制"><a href="#3-1Java垃圾回收机制" class="headerlink" title="3.1Java垃圾回收机制"></a>3.1Java垃圾回收机制</h2><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在<strong>虚拟机空闲</strong>或者<strong>当前堆内存不足</strong>时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p>
<h2 id="3-2GC及作用"><a href="#3-2GC及作用" class="headerlink" title="3.2GC及作用"></a>3.2GC及作用</h2><p><strong>GC</strong> 是垃圾收集的意思</p>
<p><strong>作用一：</strong>Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，避免了编程人员忘记或者错误的内存回收导致程序或系统的不稳定甚至崩溃。</p>
<p><strong>作用二：</strong>垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。</p>
<blockquote>
<p><strong>Note：</strong></p>
<p>Java 语言没有提供释放已分配内存的显示操作方法</p>
<p><strong>内存泄漏：</strong>内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。</p>
<p>即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。</p>
</blockquote>
<h2 id="3-3垃圾回收器的基本原理"><a href="#3-3垃圾回收器的基本原理" class="headerlink" title="3.3垃圾回收器的基本原理"></a>3.3垃圾回收器的基本原理</h2><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p>
<p>通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。</p>
<p>程序员也可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<blockquote>
<p><strong>Note：</strong>释放对象时，只要将对象所有引用赋值为null，让程序不能够再访问到这个对象，我们称该对象为”不可达的”。GC将负责回收所有”不可达”对象的内存空间。</p>
<p>比如 ：</p>
<p>class1 aa = new class();  </p>
<p>aa=null; </p>
<p>那在堆上分配的内存上的数据 就无法访问到了，就是不可达对象。</p>
</blockquote>
<h2 id="3-4Minor-Gc和Full-GC-有什么不同"><a href="#3-4Minor-Gc和Full-GC-有什么不同" class="headerlink" title="3.4Minor Gc和Full GC 有什么不同"></a>3.4Minor Gc和Full GC 有什么不同</h2><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<ul>
<li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<h2 id="3-5判断对象是否可以被回收"><a href="#3-5判断对象是否可以被回收" class="headerlink" title="3.5判断对象是否可以被回收"></a>3.5判断对象是否可以被回收</h2><p>等同于判定哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。一般有两种方法来判断：</p>
<ul>
<li>引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<p><strong>可达性分析算法：</strong>基本思路就是通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。</p>
<img src="https://img-blog.csdnimg.cn/2019053021300934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkxMDY5NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:90%;">



<h2 id="3-6对象什么时候可以被垃圾回收"><a href="#3-6对象什么时候可以被垃圾回收" class="headerlink" title="3.6对象什么时候可以被垃圾回收"></a>3.6对象什么时候可以被垃圾回收</h2><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。</p>
<blockquote>
<p><strong>年轻代 ：</strong>年轻代用来存放新近创建的对象</p>
<p><strong>老年代：</strong>存活率更高的一些对象</p>
</blockquote>
<h2 id="3-7强引用-软引用-弱引用-虚引用"><a href="#3-7强引用-软引用-弱引用-虚引用" class="headerlink" title="3.7强引用,软引用,弱引用,虚引用"></a>3.7强引用,软引用,弱引用,虚引用</h2><ul>
<li><p><strong>强引用(StrongReference)</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
</li>
<li><p><strong>软引用(SoftReference)</strong></p>
<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
</li>
<li><p><strong>弱引用(WeakReference)</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 </p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</li>
<li><p><strong>虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>
<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 </p>
<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong>ReferenceQueue主要是用于监听Reference所指向的对象是否已经被垃圾回收。</p>
</blockquote>
<h2 id="3-6JVM-中的垃圾回收算法"><a href="#3-6JVM-中的垃圾回收算法" class="headerlink" title="3.6JVM 中的垃圾回收算法"></a>3.6JVM 中的垃圾回收算法</h2><h3 id="3-6-1标记-清除算法"><a href="#3-6-1标记-清除算法" class="headerlink" title="3.6.1标记-清除算法"></a>3.6.1标记-清除算法</h3><p>标记无用对象，然后进行清除回收。</p>
<p>标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：</p>
<ul>
<li>标记阶段：标记出可以回收的对象。</li>
<li>清除阶段：回收被标记的对象所占用的空间。</li>
</ul>
<p>优点：实现简单，不需要对象进行移动。</p>
<p>缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。<br><img src="https://img-blog.csdnimg.cn/20200104115917418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="3-6-2复制算法"><a href="#3-6-2复制算法" class="headerlink" title="3.6.2复制算法"></a>3.6.2复制算法</h3><p>为了解决标记-清除算法的效率不高的问题，产生了复制算法。</p>
<ul>
<li>它把内存空间划为两个相等的区域，每次只使用其中一个区域</li>
<li>垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中</li>
<li>最后将当前使用的区域的可回收的对象进行回收</li>
</ul>
<p>优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</p>
<p>缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。<br><img src="https://img-blog.csdnimg.cn/20200104115940771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="3-6-3标记-整理算法"><a href="#3-6-3标记-整理算法" class="headerlink" title="3.6.3标记-整理算法"></a>3.6.3标记-整理算法</h3><p>在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为<strong>老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低</strong>。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-整理算法不同的是：</p>
<ul>
<li>在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起</li>
<li>然后对端边界以外的内存进行回收</li>
<li>回收后，已用和未用的内存都各自一边</li>
</ul>
<p>优点：解决了标记-清理算法存在的内存碎片问题。</p>
<p>缺点：仍需要进行局部对象移动，一定程度上降低了效率。<br><img src="https://img-blog.csdnimg.cn/20200104120006513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;"></p>
<h3 id="3-6-4分代收集算法"><a href="#3-6-4分代收集算法" class="headerlink" title="3.6.4分代收集算法"></a>3.6.4分代收集算法</h3><p>当前商业虚拟机都采用<strong>分代收集</strong>的垃圾收集算法。分代收集算法，顾名思义是根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，如图所示：</p>
<img src="https://img-blog.csdnimg.cn/20200104120031885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<h2 id="3-7JVM-垃圾回收器"><a href="#3-7JVM-垃圾回收器" class="headerlink" title="==3.7JVM 垃圾回收器=="></a>==3.7JVM 垃圾回收器==</h2><ul>
<li><input disabled type="checkbox"> 还是对两种的区别说不明白</li>
</ul>
<h3 id="3-7-1两种垃圾回收器"><a href="#3-7-1两种垃圾回收器" class="headerlink" title="3.7.1两种垃圾回收器"></a>3.7.1两种垃圾回收器</h3><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：</strong> 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p>
<p><strong>G1(Garbage First)收集器 (标记-整理算法)：</strong> Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)。</p>
<h3 id="3-7-2CMS垃圾回收器"><a href="#3-7-2CMS垃圾回收器" class="headerlink" title="3.7.2CMS垃圾回收器"></a>3.7.2CMS垃圾回收器</h3><p><strong>CMS收集器：</strong>基于“标记-清除”算法实现</p>
<p><strong>运作过程如下：</strong></p>
<ul>
<li><p><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</p>
</li>
<li><p><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>
</li>
<li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p>
</li>
<li><p><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/81ccc1600b6a2fdab98115abeea41877.jpg" alt="CMS垃圾收集器"></p>
</li>
</ul>
<p><strong>优点：</strong></p>
<p>由于在整个过程和中最耗时的并发标记和并发清除过程收集器程序都可以和用户线程一起工作，所以总体来说，CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的，所以<strong>停顿时间比较短</strong></p>
<p><strong>缺点：</strong></p>
<ul>
<li><p><strong>CMS收集器会降低吞吐量</strong></p>
<p>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢，总吞吐量会降低，</p>
</li>
<li><p><strong>CMS处理器无法处理浮动垃圾</strong> </p>
<p>CMS在并发清理阶段线程还在运行， 伴随着程序的运行自然也会产生新的垃圾，这一部分垃圾产生在标记过程之后，CMS无法再当次过程中处理，所以只有等到下次gc时候在清理掉，这一部分垃圾就称作“浮动垃圾” ， </p>
</li>
<li><p><strong>CMS收集器会产生空间碎片</strong></p>
<p>CMS是基于“标记–清除”算法实现的，所以在收集结束的时候会有大量的空间碎片产生。空间碎片太多的时候，将会给大对象的分配带来很大的麻烦，往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象的，只能提前触发 full gc。</p>
</li>
</ul>
<h3 id="3-7-3G1垃圾回收器"><a href="#3-7-3G1垃圾回收器" class="headerlink" title="3.7.3G1垃圾回收器"></a>3.7.3G1垃圾回收器</h3><p><strong>G1回收器：</strong>整体来看基于“标记-整理”算法，局部来看基于复制算法</p>
<p><strong>运作过程如下：</strong></p>
<ul>
<li><p><strong>初始标记</strong></p>
<p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿线程，但是耗时很短。</p>
<blockquote>
<p><strong>TAMS来区分哪些对象是GC开始之后新分配的：</strong>每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。</p>
</blockquote>
</li>
<li><p><strong>并发标记</strong></p>
<p>并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段时耗时较长，但可与用户程序并发执行。</p>
</li>
<li><p><strong>最终标记；</strong></p>
<p>最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remenbered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这一阶段需要停顿线程，但是可并行执行。</p>
<blockquote>
<p><strong>已记忆集合：</strong>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</p>
</blockquote>
</li>
<li><p><strong>筛选回收</strong></p>
<p>最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li><p><strong>缩短stop-The-World停顿时间</strong></p>
<p>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间</p>
</li>
<li><p><strong>分代收集</strong></p>
<p>采用不同的方式（标记-整理、复制等）去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果</p>
</li>
<li><p><strong>减少空间碎片</strong></p>
<p>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的</p>
</li>
<li><p><strong>可预测的停顿</strong></p>
<p>这是G1相对于CMS的另一个大优势，降低停顿时间是G1和ＣＭＳ共同的关注点，但Ｇ１除了追求低停顿外，还能<strong>建立可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为M毫秒的时间片段内，</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对内存和CPU要求高一些</li>
</ul>
<h1 id="4-虚拟机类加载机制"><a href="#4-虚拟机类加载机制" class="headerlink" title="4.虚拟机类加载机制"></a>4.虚拟机类加载机制</h1><h2 id="4-1类装载的执行过程"><a href="#4-1类装载的执行过程" class="headerlink" title="4.1类装载的执行过程"></a>4.1类装载的执行过程</h2><p><strong>类装载分为以下 5 个步骤：</strong></p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>验证：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h2 id="4-2双亲委派模型"><a href="#4-2双亲委派模型" class="headerlink" title="4.2双亲委派模型"></a>4.2双亲委派模型</h2><p>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<img src="https://img-blog.csdnimg.cn/20200104165551656.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;">

<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
<p><strong>双亲委派模型：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<p><strong>双亲委派模型的优势：</strong></p>
<ul>
<li><p><strong>避免重复加载</strong></p>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
</li>
<li><p><strong>避免核心类篡改</strong></p>
<p>java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
</li>
</ul>
<p><strong>打破双亲委派模型的方法：</strong></p>
<p>继承ClassLoader类，重写loadClass和findClass方法</p>
<p>默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。为了破坏双亲委派机制必须重写loadClass方法，先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。</p>
<blockquote>
<p><strong>findClass方法：</strong>用户自定义类加载逻辑</p>
<p><strong>loadClass方法：</strong>双亲委派的具体逻辑实现，在该方法中，如果父类加载失败，则会调用自己的findClass（）方法来完成加载</p>
</blockquote>
<h1 id="5-JVM调优"><a href="#5-JVM调优" class="headerlink" title="5. JVM调优"></a>5. JVM调优</h1><p>程序在上线前的测试或运行中有时会出现一些大大小小的JVM问题，比如<strong>cpu  load过高、请求延迟、tps降低</strong>等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对JVM进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。</p>
<h2 id="5-1JVM调优目标"><a href="#5-1JVM调优目标" class="headerlink" title="5.1JVM调优目标"></a>5.1JVM调优目标</h2><p>使用较小的内存占用来获得较高的吞吐量或者较低的延迟。</p>
<p>这里有几个比较重要的指标：</p>
<ul>
<li>内存占用：程序正常运行需要的内存大小。</li>
<li>延迟：由于垃圾收集而引起的程序停顿时间。</li>
<li>吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。</li>
</ul>
<p>调优的目的并不是让程序内存占用小、延迟低、高吞吐量同时具有，而是要根据明确的优化目标，找到性能的瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。</p>
<h2 id="5-2JVM调优工具"><a href="#5-2JVM调优工具" class="headerlink" title="5.2JVM调优工具"></a>5.2JVM调优工具</h2><p>调优可以依赖参考的数据有</p>
<ol>
<li><strong>系统运行日志：</strong>系统运行日志就是在程序代码中打印出的日志，描述了代码级别的系统运行轨迹（执行的方法、入参、返回值等），一般系统出现问题，系统运行日志是首先要查看的日志。</li>
<li><strong>堆栈错误信息：</strong>当系统出现异常后，可以根据堆栈信息初步定位问题所在，比如根据“java.lang.OutOfMemoryError: Java heap  space”可以判断是堆内存溢出；根据“java.lang.StackOverflowError”可以判断是栈溢出；根据“java.lang.OutOfMemoryError: PermGen space”可以判断是方法区溢出等。</li>
<li><strong>gc日志：</strong>程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:/data/jvm/gc.log  可以在程序运行时把gc的详细过程记录下来，或者直接配置“-verbose:gc”参数把gc日志打印到控制台，通过记录的gc日志可以分析每块内存区域gc的频率、时间等，从而发现问题，进行有针对性的优化。 </li>
<li><strong>线程快照：</strong>根据线程快照可以看到线程在某一时刻的状态，当系统中可能存在请求超时、死循环、死锁等情况时，可以根据线程快照来进一步确定问题。</li>
<li><strong>堆转储快照：</strong>程序启动时可以使用 “-XX:+HeapDumpOnOutOfMemory” 和  “-XX:HeapDumpPath=/data/jvm/dumpfile.hprof”，当程序发生内存溢出时，把当时的内存快照以文件形式进行转储（也可以直接用jmap命令转储程序运行时任意时刻的内存快照），事后对当时的内存使用情况进行分析。</li>
</ol>
<p><strong>JVM调优工具：</strong></p>
<p>用 jps（JVM process Status）可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数（要加上-v参数）等</p>
<p>用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息 </p>
<p>用jmap（Memory Map for Java）查看堆内存信息 </p>
<p>利用jconsole、jvisualvm分析内存信息(各个区如Eden、Survivor、Old等内存变化情况)，如果查看的是远程服务器的JVM，程序启动需要附加参数</p>
<h2 id="5-3常用JVM参数参考"><a href="#5-3常用JVM参数参考" class="headerlink" title="5.3常用JVM参数参考"></a>5.3常用JVM参数参考</h2><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-Xms</td>
<td align="center">初始堆大小，默认物理内存的1/64</td>
<td align="center">-Xms512M</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">最大堆大小，默认物理内存的1/4</td>
<td align="center">-Xms2G</td>
</tr>
<tr>
<td align="center">-Xmn</td>
<td align="center">新生代内存大小，官方推荐为整个堆的3/8</td>
<td align="center">-Xmn512M</td>
</tr>
<tr>
<td align="center">-Xss</td>
<td align="center">线程堆栈大小，jdk1.5及之后默认1M，之前默认256k</td>
<td align="center">-Xss512k</td>
</tr>
<tr>
<td align="center">-XX:NewRatio=n</td>
<td align="center">设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</td>
<td align="center">-XX:NewRatio=3</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio=n</td>
<td align="center">年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如:8，表示Eden：Survivor=8:1:1，一个Survivor区占整个年轻代的1/8</td>
<td align="center">-XX:SurvivorRatio=8</td>
</tr>
<tr>
<td align="center">-XX:PermSize=n</td>
<td align="center">永久代初始值，默认为物理内存的1/64</td>
<td align="center">-XX:PermSize=128M</td>
</tr>
<tr>
<td align="center">-XX:MaxPermSize=n</td>
<td align="center">永久代最大值，默认为物理内存的1/4</td>
<td align="center">-XX:MaxPermSize=256M</td>
</tr>
<tr>
<td align="center">-verbose:class</td>
<td align="center">在控制台打印类加载信息</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-verbose:gc</td>
<td align="center">在控制台打印垃圾回收日志</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGC</td>
<td align="center">打印GC日志，内容简单</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDetails</td>
<td align="center">打印GC日志，内容详细</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+PrintGCDateStamps</td>
<td align="center">在GC日志中添加时间戳</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-Xloggc:filename</td>
<td align="center">指定gc日志路径</td>
<td align="center">-Xloggc:/data/jvm/gc.log</td>
</tr>
<tr>
<td align="center">-XX:+UseSerialGC</td>
<td align="center">年轻代设置串行收集器Serial</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseParallelGC</td>
<td align="center">年轻代设置并行收集器Parallel Scavenge</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:ParallelGCThreads=n</td>
<td align="center">设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。</td>
<td align="center">-XX:ParallelGCThreads=4</td>
</tr>
<tr>
<td align="center">-XX:MaxGCPauseMillis=n</td>
<td align="center">设置Parallel Scavenge回收的最大时间(毫秒)</td>
<td align="center">-XX:MaxGCPauseMillis=100</td>
</tr>
<tr>
<td align="center">-XX:GCTimeRatio=n</td>
<td align="center">设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</td>
<td align="center">-XX:GCTimeRatio=19</td>
</tr>
<tr>
<td align="center">-XX:+UseParallelOldGC</td>
<td align="center">设置老年代为并行收集器ParallelOld收集器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+UseConcMarkSweepGC</td>
<td align="center">设置老年代并发收集器CMS</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:+CMSIncrementalMode</td>
<td align="center">设置CMS收集器为增量模式，适用于单CPU情况。</td>
<td align="center"></td>
</tr>
</tbody></table>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM%E7%9B%B8%E5%85%B3/" rel="tag"><i class="fa fa-tag"></i>  JVM相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/01/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="prev" title="广度优先遍历">
      <i class="fa fa-chevron-left"></i> 广度优先遍历
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/02/Java%E5%9F%BA%E7%A1%80/" rel="next" title="Java基础">
      Java基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.</span> <span class="nav-text">1.JAVA内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1JVM%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.1JVM的主要组成部分及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">1.2类的加载过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">1.3.</span> <span class="nav-text">1.3JVM 运行时数据区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.4.</span> <span class="nav-text">1.4深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">1.5堆栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">1.6队列和栈是什么？有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="nav-number">2.</span> <span class="nav-text">2.HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">2.1对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.2.</span> <span class="nav-text">2.2对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1句柄访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2直接指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="nav-number">2.3.</span> <span class="nav-text">2.3堆内存中对象的分配的基本策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">3.垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">3.1Java垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2GC%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">3.2GC及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">3.3垃圾回收器的基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4Minor-Gc%E5%92%8CFull-GC-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">3.4.</span> <span class="nav-text">3.4Minor Gc和Full GC 有什么不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.</span> <span class="nav-text">3.5判断对象是否可以被回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.6.</span> <span class="nav-text">3.6对象什么时候可以被垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-number">3.7.</span> <span class="nav-text">3.7强引用,软引用,弱引用,虚引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6JVM-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.</span> <span class="nav-text">3.6JVM 中的垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.1.</span> <span class="nav-text">3.6.1标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.2.</span> <span class="nav-text">3.6.2复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.3.</span> <span class="nav-text">3.6.3标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.4.</span> <span class="nav-text">3.6.4分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.9.</span> <span class="nav-text">&#x3D;&#x3D;3.7JVM 垃圾回收器&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.9.1.</span> <span class="nav-text">3.7.1两种垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.9.2.</span> <span class="nav-text">3.7.2CMS垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.7.3G1垃圾回收器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">4.虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.1类装载的执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-JVM%E8%B0%83%E4%BC%98"><span class="nav-number">5.</span> <span class="nav-text">5. JVM调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1JVM%E8%B0%83%E4%BC%98%E7%9B%AE%E6%A0%87"><span class="nav-number">5.1.</span> <span class="nav-text">5.1JVM调优目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-number">5.2.</span> <span class="nav-text">5.2JVM调优工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3%E5%B8%B8%E7%94%A8JVM%E5%8F%82%E6%95%B0%E5%8F%82%E8%80%83"><span class="nav-number">5.3.</span> <span class="nav-text">5.3常用JVM参数参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">687k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">10:25</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

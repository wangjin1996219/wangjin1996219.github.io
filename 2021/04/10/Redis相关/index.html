<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Redis相关">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/集中式.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/Gossip.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/一致性hash算法.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/数据倾斜问题.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/hash-slot.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/分布式锁.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png">
<meta property="article:published_time" content="2021-04-10T07:12:13.000Z">
<meta property="article:modified_time" content="2021-04-16T03:14:17.194Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis相关 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">19</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">52</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis相关
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:12:13" itemprop="dateCreated datePublished" datetime="2021-04-10T15:12:13+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-16 11:14:17" itemprop="dateModified" datetime="2021-04-16T11:14:17+08:00">2021-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">专业知识</span></a>
                </span>
            </span>

          
            <span id="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="Redis相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1Redis简介"><a href="#1-1Redis简介" class="headerlink" title="1.1Redis简介"></a>1.1Redis简介</h2><ul>
<li>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向；</li>
<li>redis 也经常用来做分布式锁；</li>
<li>redis 提供了多种数据类型来支持不同的业务场景；</li>
<li>redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </li>
</ul>
<h2 id="1-2为什么要用-redis"><a href="#1-2为什么要用-redis" class="headerlink" title="1.2为什么要用 redis"></a>1.2为什么要用 redis</h2><p>主要依据“<strong>高性能</strong>”和“<strong>高并发</strong>”这两点</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg"></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg"></p>
<h2 id="1-3为什么用redis而不用map-guava-做缓存"><a href="#1-3为什么用redis而不用map-guava-做缓存" class="headerlink" title="1.3为什么用redis而不用map/guava 做缓存?"></a>1.3为什么用redis而不用map/guava 做缓存?</h2><p>以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错。</p>
<p>使用 redis 之类的称为<strong>分布式缓存</strong>，在多实例（进程）的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p>
<h1 id="2-数据类型和使用场景分析"><a href="#2-数据类型和使用场景分析" class="headerlink" title="2.数据类型和使用场景分析"></a>2.数据类型和使用场景分析</h1><h2 id="2-1String"><a href="#2-1String" class="headerlink" title="2.1String"></a>2.1String</h2><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 </p>
<p><strong>应用场景：</strong></p>
<ul>
<li>常规key-value缓存应用</li>
<li>常规计数：微博数，粉丝数等</li>
</ul>
<h2 id="2-2Hash"><a href="#2-2Hash" class="headerlink" title="2.2Hash"></a>2.2Hash</h2><p>hash 是一个 string 类型的 field 和 value 的映射表（值：包含键值对的无序散列表）</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
</ul>
<p>比如下面我就用 hash 类型存放了我本人的一些信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: <span class="number">1</span>,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: <span class="number">22</span>,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3List"><a href="#2-3List" class="headerlink" title="2.3List"></a>2.3List</h2><p>list 就是链表</p>
<p><strong>应用场景：</strong></p>
<p>Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p>
<p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<h2 id="2-4Set"><a href="#2-4Set" class="headerlink" title="2.4Set"></a>2.4Set</h2><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p>
<p><strong>应用场景：</strong></p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<h2 id="2-5Sorted-Set"><a href="#2-5Sorted-Set" class="headerlink" title="2.5Sorted Set"></a>2.5Sorted Set</h2><p>和set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p>
<p><strong>应用场景：</strong></p>
<p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h1><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis支持持久化支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>将数据在某个节点上的副本写入一个临时文件，持久化结束后，用该临时文件替换上次持久化的文件，达到数据恢复的目的</p>
<p><strong>优点：</strong>使用单独的子进程来持久化，主进程不会进行任何的I/O操作，保证了redis的高效性能</p>
<p><strong>缺点：</strong>RDB通常间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据的丢失，所示更适用于对数据要求不是很严谨的情况</p>
<p>项目中使用的存储机制：检测到更改的key越多，更新越频繁</p>
<table>
<thead>
<tr>
<th>更改key的数目</th>
<th>更新时间间隔</th>
</tr>
</thead>
<tbody><tr>
<td>更改了1个key</td>
<td>间隔900秒更新一次数据</td>
</tr>
<tr>
<td>更改了10个key</td>
<td>间隔300秒更新一次数据</td>
</tr>
<tr>
<td>10000</td>
<td>60秒</td>
</tr>
</tbody></table>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>将执行过的指令记录下来，数据恢复时，按照记录文件中的指令顺序，再将指令执行一遍</p>
<p>优点：可以保持更高的数据完整性，如果设置appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。且日志写入写信不完整，支持检查AOF日志来进行AOF修复，AOF没有被write之前可以删除某些指令</p>
<p>缺点：AOF文件比RDB文件大，恢复的速度比RDB慢</p>
<h1 id="4-过期键的删除策略-Redis设置过期时间"><a href="#4-过期键的删除策略-Redis设置过期时间" class="headerlink" title="4.过期键的删除策略-Redis设置过期时间"></a>4.过期键的删除策略-Redis设置过期时间</h1><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p>
<h1 id="5-内存相关"><a href="#5-内存相关" class="headerlink" title="5.内存相关"></a>5.内存相关</h1><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</p>
<h2 id="5-1Redis的内存淘汰策略"><a href="#5-1Redis的内存淘汰策略" class="headerlink" title="5.1Redis的内存淘汰策略"></a>5.1Redis的内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ol>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ol>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li>
</ol>
<h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6.线程模型"></a>6.线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p><strong>Redis 是单线程的，为什么还那么快？</strong></p>
<ol>
<li>操作完全基于内存，速度快；</li>
<li>数据结构简单，对数据的操作也简单；</li>
<li>采用单线程，避免了不必要的上下文切换开销；</li>
<li>使用非阻塞的<strong>多路IO复用模型。</strong></li>
</ol>
<p>​    I/O 多路复用模型是利用select、poll、epoll可以<strong>同时监察多个流的 I/O 事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，<strong>当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流</strong>（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 <strong>I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且<strong>Redis在内存中操作数据的速度非常快</strong>（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7.事务"></a>7.事务</h1><p>==没整完哦==</p>
<p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p>
<p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。</p>
<p><strong>隔离性</strong></p>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h1 id="8-集群方案"><a href="#8-集群方案" class="headerlink" title="8.集群方案"></a>8.集群方案</h1><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> 、<code>twemproxy</code> 有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p>
<p>现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p>
<p>Redis的官方多机部署方案，Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master  node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p>
<h2 id="8-1Redis-cluster-介绍"><a href="#8-1Redis-cluster-介绍" class="headerlink" title="8.1Redis cluster 介绍"></a>8.1Redis cluster 介绍</h2><ul>
<li>自动将数据进行分片，每个 master 上放一部分数据</li>
<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>
</ul>
<p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h2 id="8-2节点间的内部通信机制"><a href="#8-2节点间的内部通信机制" class="headerlink" title="8.2节点间的内部通信机制"></a>8.2节点间的内部通信机制</h2><p><strong>基本通信原理</strong></p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>集中式：</strong>是将集群元数据（节点信息、故障等等）几种存储在某个节点上。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\集中式.png" style="zoom:120%;">

<p><strong>Gossip 协议：</strong>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\Gossip.png" style="zoom:120%;">

<p><strong>两种通信方式对比：</strong></p>
<ul>
<li><p><strong>集中式：</strong></p>
<p>优点：元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</p>
<p>缺点：所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p>
</li>
<li><p><strong>Gossip协议：</strong></p>
<p>优点：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p>
<p>缺点：元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p>
</li>
</ul>
<blockquote>
<p><strong>数据元、元数据与数据</strong></p>
<p>数据元是组成实体数据的最小单元，或称原子数据，例如，客户联系方式中的手机号码，手机号为数据元，135****为数据元的值。</p>
<p>元数据是用来描述数据的数据，让数据更容易理解、查找、管理和使用。举个栗子“村里有个姑娘叫小芳，长得好看又善良”这首耳熟能详的歌，我们分析一下，姓名：小芳、性别：姑娘（女）、长相：好看、性格：善良，住址：村里。这里面：小芳是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。当然元数据也会被描述，例如上边我举的例子中姓名的字段长度，字段编码、定义、字段类型、默认值等是用来描述“姓名”这个数据元的。</p>
</blockquote>
<h2 id="8-3分布式寻址算法"><a href="#8-3分布式寻址算法" class="headerlink" title="8.3分布式寻址算法"></a>8.3分布式寻址算法</h2><ul>
<li><strong>hash 算法（大量缓存重建）</strong></li>
<li><strong>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</strong></li>
<li><strong>Redis cluster 的 hash slot 算法</strong></li>
</ul>
<h3 id="8-3-1hash-算法"><a href="#8-3-1hash-算法" class="headerlink" title="8.3.1hash 算法"></a>8.3.1hash 算法</h3><p>来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</p>
<h3 id="8-3-2一致性-hash-算法"><a href="#8-3-2一致性-hash-算法" class="headerlink" title="8.3.2一致性 hash 算法"></a>8.3.2一致性 hash 算法</h3><blockquote>
<p>简书文章链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/528ce5cd7e8f"><strong>点击这里</strong></a></p>
</blockquote>
<p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。</p>
<p>来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环<strong>顺时针“行走”</strong>，遇到的第一个 master 节点就是 key 所在位置。</p>
<p>在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。（因为计算出HashCode后，沿着顺时针走遇到的）</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\一致性hash算法.png" style="zoom:80%;">

<p>燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成<strong>缓存热点</strong>的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。</p>
<blockquote>
<p><strong>缓存热点又称为数据倾斜问题</strong></p>
<p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成数据倾斜（<strong>被缓存的对象大部分缓存在某一台服务器上</strong>）问题</p>
</blockquote>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\数据倾斜问题.png" style="zoom:67%;">



<p>数据定位算法不变，只需要增加一步：<strong>虚拟节点到实际点的映射</strong>。</p>
<p>所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h3 id="8-3-3Redis-cluster-的-hash-slot-算法"><a href="#8-3-3Redis-cluster-的-hash-slot-算法" class="headerlink" title="8.3.3Redis cluster 的 hash slot 算法"></a>8.3.3Redis cluster 的 hash slot 算法</h3><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 校验码值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>
<p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有  5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的  hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>
<p>任何一台机器宕机，另外两个节点，不影响的。因为 <strong>key 找的是 hash slot，不是机器</strong>。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\hash-slot.png" style="zoom:80%;">

<p>9.分区</p>
<h1 id="10-分布式问题"><a href="#10-分布式问题" class="headerlink" title="10.分布式问题"></a>10.分布式问题</h1><h2 id="10-1分布式锁"><a href="#10-1分布式锁" class="headerlink" title="10.1分布式锁"></a>10.1分布式锁</h2><p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。</p>
<p><strong>当且仅当 key 不存在</strong>，将 key 的值设为 value。 若给定的 key 已经存在，则 SETNX 不做任何动作</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>如返回1，则该客户端获得锁，把lock-key的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。<br>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\分布式锁.png" style="zoom:80%;">

<p><strong>使用SETNX完成同步锁的流程及事项如下：</strong></p>
<ul>
<li><p>使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功（如指令2、1）</p>
</li>
<li><p>为了防止获取锁后程序出现异常，导致其他线程/进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间</p>
</li>
<li><p>释放锁，使用DEL命令将锁数据删除</p>
</li>
</ul>
<h2 id="10-2如何解决Redis的并发竞争Key问题"><a href="#10-2如何解决Redis的并发竞争Key问题" class="headerlink" title="10.2如何解决Redis的并发竞争Key问题"></a>10.2如何解决Redis的并发竞争Key问题</h2><p><strong>介绍：</strong>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p>
<p>这里的并发指的是多个redis的client同时set key引起的并发问题。</p>
<p><strong>解决方案：</strong></p>
<p><strong>方案一：分布式锁+时间戳</strong></p>
<p><strong>分布式锁：</strong>传统的加锁的做法（如java的synchronized和Lock）这里没用，只适合单点。因为这是分布式环境，需要的是分布式锁。分布式锁可以基于很多种方式实现，比如zookeeper、redis等，不管哪种方式实现，基本原理是不变的：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p>
<p>利用SETNX非常简单地实现分布式锁。例如：某客户端要获得一个名字youzhi的锁，客户端使用下面的命令进行获取：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock.youzhi&lt;current Unix <span class="built_in">time</span> + lock timeout + <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如返回1，则该客户端获得锁，把lock.youzhi的键值设置为时间值表示该键已被锁定，该客户端最后可以通过DEL lock.foo来释放该锁。</p>
<p>如返回0，表明该锁已被其他客户端取得，这时我们可以先返回或进行重试等对方完成或等待锁超时。</p>
<p><strong>时间戳</strong></p>
<p>由于上面举的例子，要求key的操作需要顺序执行，所以需要在缓存中保存一个时间戳判断set顺序。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统A key <span class="number">1</span> &#123;ValueA <span class="number">7</span>:<span class="number">00</span>&#125;</span><br><span class="line">系统B key <span class="number">1</span> &#123;ValueB <span class="number">7</span>:<span class="number">05</span>&#125;</span><br></pre></td></tr></table></figure>

<p>假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了。</p>
<p><strong>方案二：利用消息队列</strong></p>
<p>在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。</p>
<p>把Redis.set操作放在队列中使其串行化,必须的一个一个执行。</p>
<p><strong>附加：zookeeper分布式锁</strong></p>
<p>分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p>
<p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p>
<h1 id="11-缓存异常"><a href="#11-缓存异常" class="headerlink" title="11.缓存异常"></a>11.缓存异常</h1><h2 id="11-1缓存雪崩"><a href="#11-1缓存雪崩" class="headerlink" title="11.1缓存雪崩"></a>11.1缓存雪崩</h2><p><strong>什么是缓存雪崩？</strong></p>
<p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>有哪些解决办法？</strong></p>
<ul>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉（通过限流来限制直接访问数据库的请求数量，当限流组件发现剩余的请求未能通过自己，便会调用自定义的降级组件，返回一些默认的友好提示：服务器忙，请稍后重试等，不让客户端继续等待）</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" style="zoom:80%;">



<h2 id="11-2缓存穿透"><a href="#11-2缓存穿透" class="headerlink" title="11.2缓存穿透"></a>11.2缓存穿透</h2><p><strong>什么是缓存穿透？</strong></p>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，造成数据库负载过大。如下图所示：</p>
<p><strong>正常缓存处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png" style="zoom:60%;">

<p><strong>缓存穿透情况处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png" style="zoom:60%;">

<p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;; </code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p>
<p><strong>有哪些解决办法？</strong></p>
<p><strong>1）参数校验</strong></p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>2）缓存无效 key</strong> </p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险（比如频繁更换key，造成大量的无效key存在于缓存中）</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png" style="zoom:60%;">



<h1 id="12-常用工具"><a href="#12-常用工具" class="headerlink" title="12.常用工具"></a>12.常用工具</h1><h2 id="12-1Redis支持的客户端"><a href="#12-1Redis支持的客户端" class="headerlink" title="12.1Redis支持的客户端"></a>12.1Redis支持的客户端</h2><p>Redisson、Jedis等</p>
<p><strong>二者的对比</strong></p>
<ul>
<li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；（Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的）</li>
<li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li>
</ul>
<h1 id="13-其他问题"><a href="#13-其他问题" class="headerlink" title="13.其他问题"></a>13.其他问题</h1><h2 id="13-1redis-和-memcached-的区别"><a href="#13-1redis-和-memcached-的区别" class="headerlink" title="13.1redis 和 memcached 的区别"></a>13.1redis 和 memcached 的区别</h2><ol>
<li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li>
<li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li>
<li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li>
<li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">对比参数</th>
<th align="center">Redis</th>
<th align="center">Memcached</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>数据存储类型</strong></td>
<td align="center">1. String 2. List 3. Set 4. Hash 5. Sort Set 【俗称ZSet】</td>
<td align="center">1. 文本型 2. 二进制类型</td>
</tr>
<tr>
<td align="center"><strong>持久化支持</strong></td>
<td align="center">1. RDB 2. AOF</td>
<td align="center">不支持</td>
</tr>
<tr>
<td align="center"><strong>集群模式</strong></td>
<td align="center">原生支持 cluster 模式，可以实现主从复制，读写分离</td>
<td align="center">没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</td>
</tr>
<tr>
<td align="center"><strong>网络IO模型</strong></td>
<td align="center">1. 单线程的多路 IO 复用模型</td>
<td align="center">1. 多线程，非阻塞IO模式</td>
</tr>
<tr>
<td align="center">内存管理机制</td>
<td align="center">在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘</td>
<td align="center">Memcached 的数据则会一直在内存中，将内存分片来解决内存碎片的问题</td>
</tr>
<tr>
<td align="center">事件库</td>
<td align="center">自封转简易事件库AeEvent</td>
<td align="center">贵族血统的LibEvent事件库</td>
</tr>
<tr>
<td align="center">类型</td>
<td align="center">1. 支持内存 2. 非关系型数据库</td>
<td align="center">1. 支持内存 2. 键值对形式 3. 缓存形式</td>
</tr>
<tr>
<td align="center">查询【操作】类型</td>
<td align="center">1. 批量操作 2. 事务支持 3. 每个类型不同的CRUD</td>
<td align="center">1.常用的CRUD 2. 少量的其他命令</td>
</tr>
<tr>
<td align="center">附加功能</td>
<td align="center">1. 发布/订阅模式 2. 主从分区 3. 序列化支持 4. 脚本支持【Lua脚本】</td>
<td align="center">1. 多线程服务支持</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">复杂数据结构，有持久化，高可用需求，value存储内容较大</td>
<td align="center">纯key-value，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<h2 id="13-2如何保证缓存与数据库双写时的数据一致性？"><a href="#13-2如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="13.2如何保证缓存与数据库双写时的数据一致性？"></a>13.2如何保证缓存与数据库双写时的数据一致性？</h2><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p><strong>读请求和写请求串行化</strong></p>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h3 id="13-2-1Cache-Aside-Pattern"><a href="#13-2-1Cache-Aside-Pattern" class="headerlink" title="13.2.1Cache Aside Pattern"></a>13.2.1Cache Aside Pattern</h3><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li>
</ul>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ul>
<li><p><strong>因为对于比较复杂的缓存数据计算场景，当被更新的缓存频繁更新、且不常被访问时，更新缓存的代价比较高</strong></p>
<p><strong>例如：</strong>一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>
</li>
</ul>
<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<h3 id="13-2-2最初级的缓存不一致问题及解决方案"><a href="#13-2-2最初级的缓存不一致问题及解决方案" class="headerlink" title="13.2.2最初级的缓存不一致问题及解决方案"></a>13.2.2最初级的缓存不一致问题及解决方案</h3><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>
<p><strong>解决思路：</strong></p>
<p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p>
<h3 id="13-2-3比较复杂的数据不一致问题分析"><a href="#13-2-3比较复杂的数据不一致问题分析" class="headerlink" title="13.2.3比较复杂的数据不一致问题分析"></a>13.2.3比较复杂的数据不一致问题分析</h3><p><strong>问题：</strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改，造成数据库和缓存中的数据不一样。</p>
<p><strong>出现场景：</strong>上亿流量高并发场景下，缓存会出现这个问题</p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p>
<p><strong>解决思路：</strong></p>
<p>更新数据的时候，根据<strong>数据的唯一标识（例如店铺ID）</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p>
<p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>
<p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>
<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<h1 id="14-五种IO模型"><a href="#14-五种IO模型" class="headerlink" title="14.五种IO模型"></a>14.五种IO模型</h1><blockquote>
<p><strong>Note：</strong></p>
<p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p>
<p> 我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p>
</blockquote>
<h2 id="14-1阻塞IO"><a href="#14-1阻塞IO" class="headerlink" title="14.1阻塞IO"></a>14.1阻塞IO</h2><p><strong>读取客户端的数据需要调用recvfrom。在默认情况下，这个调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。内核准备数据，并将数据从内核拷贝到用户内存，内核返回结果，用户进程再解除阻塞状态，重新运行起来。</strong></p>
<p>执行如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd=connect();</span><br><span class="line">write(fd);</span><br><span class="line">read(fd);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</p>
<h2 id="14-2非阻塞IO"><a href="#14-2非阻塞IO" class="headerlink" title="14.2非阻塞IO"></a>14.2非阻塞IO</h2><p>用户进程调用recvfrom之后，如果内核数据没有准备好，并不会阻塞用户进程，而是立即返回数据未准备好的信号，用户进程以后不断调用recvfrom来<strong>轮询</strong>内核是否准备好数据。</p>
<h2 id="14-3信号驱动IO"><a href="#14-3信号驱动IO" class="headerlink" title="14.3信号驱动IO"></a>14.3信号驱动IO</h2><p>用户进程调用recvfrom之后，不等待数据就绪立即返回，等内核准备好数据之后，发送信号给用户进程。</p>
<h2 id="14-4异步IO"><a href="#14-4异步IO" class="headerlink" title="14.4异步IO"></a>14.4异步IO</h2><p>读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。</p>
<p>读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>
<p>对比信号驱动IO，异步IO的主要区别在于：**信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)**。</p>
<h2 id="14-5IO多路复用IO"><a href="#14-5IO多路复用IO" class="headerlink" title="14.5IO多路复用IO"></a>14.5IO多路复用IO</h2><p>可以处理多个连接。这里的select相当于一个代理，调用select以后进程会被select阻塞，这时候在内核空间内select会监听指定的多个套接字，如果其中任意一个数据就绪了就返回。此时程序再进行数据读取操作，将数据拷贝至当前进程内。</p>
<p>由于select可以监听多个socket，我们可以用它来处理多个连接。所以称为复用。</p>
<h3 id="14-5-1常用的IO复用模型"><a href="#14-5-1常用的IO复用模型" class="headerlink" title="14.5.1常用的IO复用模型"></a>14.5.1常用的IO复用模型</h3><p>I/O多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让<strong>单个进程可以监视多个文件描述符</strong>，一旦<strong>某个描述符就绪</strong>（一般是读就绪或写就绪），能够<strong>通知程序进行相应的读写操作</strong>。与多进程和多线程技术相比，I/O多路复用技术的最大优势是<strong>系统开销小</strong>，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<p><strong>三种：select，poll，epoll</strong></p>
<ul>
<li><p><strong>select</strong>==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询所有流</strong>，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll</strong>==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.</p>
</li>
<li><p><strong>epoll</strong>==&gt;时间复杂度O(1)</p>
<p>epoll可以理解为event poll，不同于无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p>
</li>
</ul>
<p><strong>三种模型分析：</strong></p>
<p><strong>select缺点：</strong></p>
<ul>
<li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态；</li>
<li>需要在内核遍历传递进来的所有fd_set，找出能读出数据，或者写入数据的流，对他们进行操作；</li>
<li>内核对被监控的fd_set集合大小做了限制，为1024。</li>
</ul>
<p><strong>poll缺点：</strong></p>
<ul>
<li>poll没有最大文件描述符数量的限制，因为数据结构变成了链表</li>
<li>其他缺点和select一样</li>
</ul>
<p><strong>epoll：（优势）</strong></p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数</li>
<li>不需要每次都把fd_set集合从用户态拷贝到内核态</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>select、poll：连接数少并且连接都十分活跃的情况</p>
<p>epoll：连接多，并且有大量不太活跃的连接</p>
<p><strong>epoll的实现原理：</strong></p>
<ul>
<li><p><strong>epoll_create()系统调用：</strong>通过此调用建立一个epoll对象，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p>
<p><code>红黑树：</code>树中存储着所有添加到epoll中的需要监控的事件</p>
<p><code>双链表：</code>存放着将要通过epoll_wait()返回给用户的满足条件的事件（所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中）</p>
</li>
<li><p><strong>epoll_ctl()系统调用：</strong>通过此调用向epoll对象中添加、删除、修改感兴趣的事件，所以不需要每次调用epoll_wait都复制所有的事件结构</p>
</li>
<li><p><strong>epoll_wait()系统调用：</strong>通过此调用会直接返回链表中的就绪事件，效率高。</p>
</li>
</ul>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i>  Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/10/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE1-0%E6%80%BB%E7%BB%93/" rel="prev" title="校园商铺项目1.0总结">
      <i class="fa fa-chevron-left"></i> 校园商铺项目1.0总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/15/HashMap/" rel="next" title="HashMap">
      HashMap <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1Redis%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1Redis简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis"><span class="nav-number">1.2.</span> <span class="nav-text">1.2为什么要用 redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8redis%E8%80%8C%E4%B8%8D%E7%94%A8map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">1.3为什么用redis而不用map&#x2F;guava 做缓存?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">2.数据类型和使用场景分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1String"><span class="nav-number">2.1.</span> <span class="nav-text">2.1String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2Hash"><span class="nav-number">2.2.</span> <span class="nav-text">2.2Hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3List"><span class="nav-number">2.3.</span> <span class="nav-text">2.3List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4Set"><span class="nav-number">2.4.</span> <span class="nav-text">2.4Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5Sorted-Set"><span class="nav-number">2.5.</span> <span class="nav-text">2.5Sorted Set</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">3.持久化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5-Redis%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">4.</span> <span class="nav-text">4.过期键的删除策略-Redis设置过期时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">5.内存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.1.</span> <span class="nav-text">5.1Redis的内存淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">6.线程模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">7.事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="nav-number">8.</span> <span class="nav-text">8.集群方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1Redis-cluster-%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.1.</span> <span class="nav-text">8.1Redis cluster 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%86%85%E9%83%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">8.2.</span> <span class="nav-text">8.2节点间的内部通信机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">8.3分布式寻址算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1hash-%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.1.</span> <span class="nav-text">8.3.1hash 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2%E4%B8%80%E8%87%B4%E6%80%A7-hash-%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.2.</span> <span class="nav-text">8.3.2一致性 hash 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3Redis-cluster-%E7%9A%84-hash-slot-%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.3.</span> <span class="nav-text">8.3.3Redis cluster 的 hash slot 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">10.分布式问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">9.1.</span> <span class="nav-text">10.1分布式锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E7%9A%84%E5%B9%B6%E5%8F%91%E7%AB%9E%E4%BA%89Key%E9%97%AE%E9%A2%98"><span class="nav-number">9.2.</span> <span class="nav-text">10.2如何解决Redis的并发竞争Key问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="nav-number">10.</span> <span class="nav-text">11.缓存异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">10.1.</span> <span class="nav-text">11.1缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">10.2.</span> <span class="nav-text">11.2缓存穿透</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="nav-number">11.</span> <span class="nav-text">12.常用工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1Redis%E6%94%AF%E6%8C%81%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">11.1.</span> <span class="nav-text">12.1Redis支持的客户端</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="nav-number">12.</span> <span class="nav-text">13.其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.1.</span> <span class="nav-text">13.1redis 和 memcached 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">12.2.</span> <span class="nav-text">13.2如何保证缓存与数据库双写时的数据一致性？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-1Cache-Aside-Pattern"><span class="nav-number">12.2.1.</span> <span class="nav-text">13.2.1Cache Aside Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-2%E6%9C%80%E5%88%9D%E7%BA%A7%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">12.2.2.</span> <span class="nav-text">13.2.2最初级的缓存不一致问题及解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-3%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-number">12.2.3.</span> <span class="nav-text">13.2.3比较复杂的数据不一致问题分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">13.</span> <span class="nav-text">14.五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1%E9%98%BB%E5%A1%9EIO"><span class="nav-number">13.1.</span> <span class="nav-text">14.1阻塞IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">13.2.</span> <span class="nav-text">14.2非阻塞IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">13.3.</span> <span class="nav-text">14.3信号驱动IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4%E5%BC%82%E6%AD%A5IO"><span class="nav-number">13.4.</span> <span class="nav-text">14.4异步IO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO"><span class="nav-number">13.5.</span> <span class="nav-text">14.5IO多路复用IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-5-1%E5%B8%B8%E7%94%A8%E7%9A%84IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">13.5.1.</span> <span class="nav-text">14.5.1常用的IO复用模型</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">360k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">5:28</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Redis相关">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/图片01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/图片06.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/图片02.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png">
<meta property="og:image" content="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/图片03.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/图片04.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/哨兵.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/集中式.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/Gossip.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片10.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片11.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片12.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/6555006-cd54d5c30e9cad6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片13.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片14.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-06-27-数据库系统原理/图片15.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/hash-slot.png">
<meta property="og:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source/_posts/2021-04-10-Redis相关/阻塞IO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/非阻塞IO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/多路复用IO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/信号驱动IO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub/MyBlogs/source_posts/2021-04-10-Redis相关/异步IO.png">
<meta property="article:published_time" content="2021-04-10T07:12:13.000Z">
<meta property="article:modified_time" content="2021-08-08T07:57:43.255Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="Redis相关">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis相关 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/04/10/Redis%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis相关
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 15:12:13" itemprop="dateCreated datePublished" datetime="2021-04-10T15:12:13+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-08 15:57:43" itemprop="dateModified" datetime="2021-08-08T15:57:43+08:00">2021-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">数据库相关</span></a>
                </span>
            </span>

          
            <span id="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/" class="post-meta-item leancloud_visitors" data-flag-title="Redis相关" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1Redis简介"><a href="#1-1Redis简介" class="headerlink" title="1.1Redis简介"></a>1.1Redis简介</h2><p>Redis 是一款高性能的（key/value）基于内存的非关系型数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用集群方案来扩展读性能和写性能。</p>
<h2 id="1-2为什么要用-redis"><a href="#1-2为什么要用-redis" class="headerlink" title="1.2为什么要用 redis"></a>1.2为什么要用 redis</h2><p>主要依据“<strong>高性能</strong>”和“<strong>高并发</strong>”这两点</p>
<p><strong>高性能：</strong></p>
<p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg"></p>
<p><strong>高并发：</strong></p>
<p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg"></p>
<p><strong>补充一条：</strong>单线程操作，避免了线程上下文切换操作 ，采用的是<strong>多路 I/O 复用的线程模型</strong>，实现了一个线程监控多个 IO 流，及时响应请求 </p>
<h2 id="1-3为什么用redis而不用map-guava-做缓存"><a href="#1-3为什么用redis而不用map-guava-做缓存" class="headerlink" title="1.3为什么用redis而不用map/guava 做缓存?"></a>1.3为什么用redis而不用map/guava 做缓存?</h2><p>以 Java 为例，使用自带的 map 或者 guava 实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错。</p>
<p>使用 redis 之类的称为<strong>分布式缓存</strong>，在多实例（进程）的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 服务的高可用，整个程序架构上较为复杂。</p>
<h3 id="1-3-1本地缓存map-guava"><a href="#1-3-1本地缓存map-guava" class="headerlink" title="1.3.1本地缓存map/guava"></a>1.3.1本地缓存map/guava</h3><p><strong>优缺点：</strong></p>
<ol>
<li><p>访问速度快，但无法进行大数据存储</p>
<p> 本地缓存相对于分布式缓存的好处是，由于数据不需要跨网络传输，故性能更好，但是由于占用了应用进程的内存空间，如 Java 进程的 JVM 内存空间，故不能进行大数据量的数据存储。</p>
</li>
<li><p>集群的数据更新问题</p>
<p> 与此同时，本地缓存只支持被该应用进程访问，一般无法被其他应用进程访问，故在应用进程的集群部署当中，如果对应的数据库数据，存在数据更新，则需要同步更新不同部署节点的本地缓存的数据来包保证数据一致性，复杂度较高并且容易出错，如基于 Redis 的发布订阅机制来同步更新各个部署节点。</p>
</li>
<li><p>数据随应用进程的重启而丢失</p>
<p> 由于本地缓存的数据是存储在应用进程的内存空间的，所以当应用进程重启时，本地缓存的数据会丢失。所以对于需要持久化的数据，需要注意及时保存，否则可能会造成数据丢失。</p>
</li>
</ol>
<p><strong>使用场景：</strong></p>
<p>本地缓存一般适合于缓存只读数据，如统计类数据。或者每个部署节点独立的数据，如长连接服务中，每个部署节点由于都是维护了不同的连接，每个连接的数据都是独立的，并且随着连接的断开而删除。如果数据在集群的不同部署节点需要共享和保持一致，则需要使用分布式缓存来统一存储，实现应用集群的所有应用进程都在该统一的分布式缓存中进行数据存取即可。</p>
<h3 id="13-2分布式缓存redis"><a href="#13-2分布式缓存redis" class="headerlink" title="13.2分布式缓存redis"></a>13.2分布式缓存redis</h3><p><strong>优缺点：</strong></p>
<ol>
<li><p>支持大数据量存储，不受应用进程重启影响</p>
<p> 分布式缓存由于是独立部署的进程，拥有自身独立的内存空间，不会受到应用进程重启的影响，在应用进程重启时，分布式缓存的数据依然存在。同时对于数据量而言，由于不需要占用应用进程的内存空间，并且一般支持以集群的方式拓展，故可以进行大数据量的数据缓存。</p>
</li>
<li><p>数据集中存储，保证数据一致性</p>
<p> 当应用进程采用集群方式部署时，集群的每个部署节点都通过一个统一的分布式缓存进行数据存取操作，故不存在本地缓存中的数据更新问题，保证了不同节点的应用进程的数据一致性问题。</p>
</li>
<li><p>数据读写分离，高性能，高可用</p>
<p> 分布式缓存一般支持数据副本机制，可以实现读写分离，故可以解决高并发场景中的数据读写性能问题。并且由于在多个缓存节点冗余存储数据，提高了缓存数据的可用性，避免某个缓存节点宕机导致数据不可用问题。</p>
</li>
<li><p>数据跨网络传输，性能低于本地缓存</p>
<p> 由于分布式缓存是独立部署的进程，并且一般都是与应用进程位于不同的机器，故需要通过网络来进行数据传输，这样相对于本地缓存的进程内部的数据读取操作，性能会较低。</p>
</li>
</ol>
<h1 id="2-数据类型和使用场景分析"><a href="#2-数据类型和使用场景分析" class="headerlink" title="2.数据类型和使用场景分析"></a>2.数据类型和使用场景分析</h1><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">可以存储的值</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">STRING</td>
<td align="center">字符串、整数或者浮点数</td>
<td align="center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">LIST</td>
<td align="center">列表</td>
<td align="center">从两端压入或者弹出元素 <br> 对单个或者多个元素进行修剪，<br> 只保留一个范围内的元素</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">无序集合</td>
<td align="center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td>
</tr>
<tr>
<td align="center">HASH</td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td>
</tr>
<tr>
<td align="center">ZSET</td>
<td align="center">有序集合</td>
<td align="center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td>
</tr>
</tbody></table>
<h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><p>String 数据结构是简单的 key-value 类型，value 其实不仅可以是 String，也可以是数字。 </p>
<p><strong>应用场景：</strong></p>
<p>常规 key-value 缓存应用</p>
<p>常规计数：微博上的粉丝数等</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" alt="img" style="zoom: 67%;">

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">&gt; <span class="built_in">del</span> hello</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>String 的数据结构为简单动态字符串。是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片01.png" alt="image-20210630202553853"></p>
<p>如图中所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>
<h2 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2. Hash"></a>2. Hash</h2><p>hash 是一个 string 类型的 field 和 value 的映射表（值：包含键值对的无序散列表）</p>
<p><strong>应用场景：</strong></p>
<p>hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\图片06.png" alt="img" style="zoom:67%;">

<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line"><span class="number">1</span>) &quot;sub-key1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value1&quot;</span><br><span class="line"><span class="number">3</span>) &quot;sub-key2&quot;</span><br><span class="line"><span class="number">4</span>) &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">&quot;value1&quot;</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line"><span class="number">1</span>) &quot;sub-key1&quot;</span><br><span class="line"><span class="number">2</span>) &quot;value1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>底层就是 Hashtable（哈希表）</p>
<h2 id="3-List"><a href="#3-List" class="headerlink" title="3. List"></a>3. List</h2><p>list 就是链表</p>
<p><strong>应用场景：</strong></p>
<p>Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用 Redis 的 list 结构来实现。</p>
<p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">&quot;item2&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">&quot;item&quot;</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) &quot;item2&quot;</span><br><span class="line">2) &quot;item&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片02.png" alt="image-20210630202736517"></p>
<h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p>
<p><strong>应用场景：</strong></p>
<p>当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p>
<p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item2&quot;</span><br><span class="line">3) &quot;item3&quot;</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) &quot;item&quot;</span><br><span class="line">2) &quot;item3&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>Set 数据结构是 dict 字典，字典是用哈希表实现的。</p>
<p>Java 中 HashSet 的内部实现使用的是 HashMap，HashSet 中的元素都存放在 HashMap 的 key 上面，而所有的 value 都指向同一个对象。Redis 的 set 结构也是一样，它的内部也使用 hash 结构，所有的 value 都指向同一个内部值。</p>
<h2 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5. Sorted Set"></a>5. Sorted Set</h2><p>和 set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列。</p>
<p><strong>应用场景：</strong></p>
<p>在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p>
<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" alt="img" style="zoom:67%;">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line">3) &quot;member0&quot;</span><br><span class="line">4) &quot;982&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;728&quot;</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) &quot;member0&quot;</span><br><span class="line">2) &quot;982&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数据结构：</strong></p>
<p>SortedSet(zset) 是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p>
<p><strong>zset 底层使用了两个数据结构</strong></p>
<ul>
<li>hash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。</li>
<li>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</li>
</ul>
<p><strong>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表</strong></p>
<ul>
<li><p>有序链表</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片03.png" alt="image-20210630204238166"></p>
</li>
<li><p>跳跃表</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\图片04.png" alt="image-20210630204325616"></p>
<ol>
<li>从第2层开始，1节点比51节点小，向后比较。</li>
<li>21节点比51节点小，继续向后比较，后面就是 NULL 了，所以从21节点向下到第1层</li>
<li>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</li>
<li>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</li>
</ol>
</li>
</ul>
<p><strong>跳表的优势</strong></p>
<ul>
<li>相对于有序链表来说，查询和插入速率都要高</li>
<li>相对于红黑树来说，实现更简单，维护代价更低，因为不需要旋转等操作来维护平衡性</li>
</ul>
<h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h1><h2 id="3-1持久化策略"><a href="#3-1持久化策略" class="headerlink" title="3.1持久化策略"></a>3.1持久化策略</h2><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis支持持久化支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。</p>
<p><strong>快照（snapshotting）持久化（RDB）</strong></p>
<p>将数据在某个节点上的副本写入一个临时文件，持久化结束后，用该临时文件替换上次持久化的文件，达到数据恢复的目的</p>
<p><strong>触发方式：</strong>在配置文件中，可以配置执行了多少次 save 就自动触发自动持久化。 </p>
<ul>
<li><strong>优点：</strong>使用单独的子进程来持久化，主进程不会进行任何的I/O操作，保证了 redis 的高效性能</li>
<li><strong>缺点：</strong>RDB 通常间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据的丢失，所以更适用于对数据要求不是很严谨的情况</li>
</ul>
<p>项目中使用的存储机制：检测到更改的 key 越多，更新越频繁。也就是更改越少，持久化的间隔时间越长。</p>
<table>
<thead>
<tr>
<th>更改key的数目</th>
<th>更新时间间隔</th>
</tr>
</thead>
<tbody><tr>
<td>更改了1个key</td>
<td>间隔900秒更新一次数据</td>
</tr>
<tr>
<td>更改了10个key</td>
<td>间隔300秒更新一次数据</td>
</tr>
<tr>
<td>10000</td>
<td>60秒</td>
</tr>
</tbody></table>
<p><strong>AOF（append-only file）持久化</strong></p>
<p>将执行过的指令记录下来，数据恢复时，按照记录文件中的指令顺序，再将指令执行一遍</p>
<ul>
<li><strong>优点：</strong>可以保持更高的数据完整性，如果设置appendfsync everysec选项，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。且日志写入写信不完整，支持检查AOF日志来进行AOF修复，AOF没有被write之前可以删除某些指令</li>
<li><strong>缺点：</strong>AOF文件比RDB文件大，恢复的速度比RDB慢</li>
</ul>
<h2 id="3-2持久化策略的选择"><a href="#3-2持久化策略的选择" class="headerlink" title="3.2持久化策略的选择"></a>3.2持久化策略的选择</h2><ul>
<li>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。 </li>
<li>RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。 </li>
</ul>
<h1 id="4-键的过期时间"><a href="#4-键的过期时间" class="headerlink" title="4.键的过期时间"></a>4.键的过期时间</h1><p>Redis 中有个设置时间过期的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p>
<p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p>
<p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p>
<p><strong>定期删除+惰性删除。</strong></p>
<p>通过名字大概就能猜出这两个删除方式的意思了。</p>
<ul>
<li><strong>定期删除</strong>：Redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔 100ms 就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li>
<li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！也就是在获取一个 key 的时候，redis 会检查这个 key 是否已经过期，若过期，则会进行删除操作。</li>
</ul>
<p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>Redis 内存淘汰机制。</strong></p>
<h1 id="5-内存淘汰策略"><a href="#5-内存淘汰策略" class="headerlink" title="5.内存淘汰策略"></a>5.内存淘汰策略</h1><p>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?</p>
<p>可以通过设置 Redis 的缓存空间大小为热点数据占用的内存量，然后当内存不足时，Redis 会通过内存淘汰策略将对应的 key 移除内存。Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<ol>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ol>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
</ol>
<p>4.0版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu</strong>：当内存不足以容纳新写入数据时，从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<p>LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h1 id="6-线程模型"><a href="#6-线程模型" class="headerlink" title="6.线程模型"></a>6.线程模型</h1><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p><strong>Redis 是单线程的，为什么还那么快？</strong></p>
<ol>
<li>操作完全基于内存，速度快；</li>
<li>数据结构简单，对数据的操作也简单；</li>
<li>采用单线程，避免了不必要的上下文切换开销；</li>
<li>使用非阻塞的<strong>多路IO复用模型。</strong></li>
</ol>
<p>​    I/O 多路复用模型是利用select、poll、epoll可以<strong>同时监察多个流的 I/O 事件的能力</strong>，在空闲的时候，会把当前线程阻塞掉，<strong>当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流</strong>（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。<strong>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。</strong>采用多路 <strong>I/O 复用技术可以让单个线程高效的处理多个连接请求</strong>（尽量减少网络IO的时间消耗），且<strong>Redis在内存中操作数据的速度非常快</strong>（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h1 id="7-事务"><a href="#7-事务" class="headerlink" title="7.事务"></a>7.事务</h1><p><strong>支持事务的隔离性</strong></p>
<ul>
<li>Redis 是单线程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</li>
<li>Redis 将多个命令请求打包，然后按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</li>
</ul>
<p><strong>Redis 通过如下一些指令来实现事务功能：</strong></p>
<ul>
<li><strong>MULTI：</strong>标记一个事务块的开始。 </li>
<li><strong>EXEC：</strong>执行所有事务块内的命令。 </li>
<li><strong>DISCARD：</strong>取消事务，放弃执行事务块内的所有命令。 </li>
<li><strong>UNWATCH：</strong>取消 WATCH 命令对所有 key 的监视。 </li>
<li><strong>WATCH key [key …]：</strong>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 </li>
</ul>
<p>需要注意的是 <strong>Redis 的事务不支持回滚操作</strong>，Redis 以 MULTI  开始一个事务，然后将多个命令入队到事务中，最后由 EXEC 命令触发事务，  一并执行事务中的所有命令。只有当被调用的 Redis 命令有语法错误时，这条命令才会执行失败，或者对某个键执行不符合其数据类型的操作，但是应该在将命令入队列的时候就应该并且能够发现这些问题，所以 Redis 的事务不支持进行回滚操作。</p>
<h1 id="8-集群方案"><a href="#8-集群方案" class="headerlink" title="8.集群方案"></a>8.集群方案</h1><p>在前几年，Redis 如果要搞几个节点，每个节点存储一部分的数据，得<strong>借助一些中间件</strong>来实现，比如说有 <code>codis</code> 、<code>twemproxy</code> 有一些 Redis 中间件，你读写 Redis 中间件，Redis 中间件负责将你的数据分布式存储在多台机器上的 Redis 实例中。</p>
<p>现在的 Redis 集群模式，可以做到在多台机器上，部署多个 Redis 实例，每个实例存储一部分的数据，同时每个 Redis 主实例可以挂 Redis 从实例，自动确保说，如果 Redis 主实例挂了，会自动切换到 Redis 从实例上来。</p>
<p>Redis的官方多机部署方案，Redis Cluster，主要是针对<strong>海量数据+高并发+高可用</strong>的场景。Redis cluster 支撑 N 个 Redis master  node，每个 master node 都可以挂载多个 slave node。这样整个 Redis  就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p>
<h2 id="8-1Redis-cluster-介绍"><a href="#8-1Redis-cluster-介绍" class="headerlink" title="8.1Redis cluster 介绍"></a>8.1Redis cluster 介绍</h2><ul>
<li>自动将数据进行分片，每个 master 上放一部分数据</li>
<li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li>
</ul>
<p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。</p>
<p>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， <code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<h2 id="8-2哨兵模式（sentinel）"><a href="#8-2哨兵模式（sentinel）" class="headerlink" title="8.2哨兵模式（sentinel）"></a>8.2哨兵模式（sentinel）</h2><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/哨兵.png" style="zoom:80%;">

<p><strong>哨兵的介绍</strong></p>
<p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，也可以理解为是一个<strong>故障转移系统</strong>，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p><strong>哨兵用于实现 redis 集群的高可用</strong>，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。</li>
</ul>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要 3 个实例，来保证自己的健壮性。</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li>
</ul>
<h2 id="8-3节点间的内部通信机制"><a href="#8-3节点间的内部通信机制" class="headerlink" title="8.3节点间的内部通信机制"></a>8.3节点间的内部通信机制</h2><p><strong>基本通信原理</strong></p>
<p>集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。</p>
<p><strong>集中式：</strong>是将集群元数据（节点信息、故障等等）集中存储在某个节点上。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\集中式.png" style="zoom:120%;">

<p><strong>Gossip 协议：</strong>所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\Gossip.png" style="zoom:120%;">

<p><strong>两种通信方式对比：</strong></p>
<ul>
<li><p><strong>集中式：</strong></p>
<p>优点：元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</p>
<p>缺点：所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</p>
</li>
<li><p><strong>Gossip协议：</strong></p>
<p>优点：元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；</p>
<p>缺点：元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。</p>
</li>
</ul>
<blockquote>
<p><strong>数据元、元数据与数据</strong></p>
<p>数据元是组成实体数据的最小单元，或称原子数据，例如，客户联系方式中的手机号码，手机号为数据元，135****为数据元的值。</p>
<p>元数据是用来描述数据的数据，让数据更容易理解、查找、管理和使用。举个栗子“村里有个姑娘叫小芳，长得好看又善良”这首耳熟能详的歌，我们分析一下，姓名：小芳、性别：姑娘（女）、长相：好看、性格：善良，住址：村里。这里面：小芳是被描述的对象也就是我们所谓的实体数据，而姓名、性别、长相、性格、住址就是描述小芳这个人的元数据。当然元数据也会被描述，例如上边我举的例子中姓名的字段长度，字段编码、定义、字段类型、默认值等是用来描述“姓名”这个数据元的。</p>
</blockquote>
<h2 id="8-4分布式寻址算法"><a href="#8-4分布式寻址算法" class="headerlink" title="8.4分布式寻址算法"></a>8.4分布式寻址算法</h2><p>在集群方案中，我们想要获取某个数据存储在哪台服务器中，可以通过顺序遍历的方式来查找。但是这种方式无疑是耗时的，所以我们会想到按某一个字段值进行 Hash 值、取模。所以我们就看看使用 Hash 的方式是怎么进行的。</p>
<h3 id="1-hash-算法"><a href="#1-hash-算法" class="headerlink" title="1. hash 算法"></a>1. hash 算法</h3><p>来了一个 key，首先计算 hash 值，然后<strong>对节点数取模</strong>。然后打在不同的 master 节点上。</p>
<p><strong>问题：</strong></p>
<ul>
<li>Redis服务器变动时，所有缓存的位置都会发生改变；</li>
<li>一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致<strong>大部分的请求过来，全部无法拿到有效的缓存</strong>，导致大量的流量涌入数据库。</li>
</ul>
<h3 id="2-一致性-hash-算法"><a href="#2-一致性-hash-算法" class="headerlink" title="2.一致性 hash 算法"></a>2.一致性 hash 算法</h3><blockquote>
<p>简书文章链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/528ce5cd7e8f"><strong>点击这里</strong></a></p>
</blockquote>
<p>一致性 Hash 算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的 Hash 算法是对<code>2的32方</code>取模。即，一致性 Hash 算法将整个 Hash 空间组织成一个虚拟的圆环，Hash 函数的值空间为<code>0 ~ 2^32 - 1(一个32位无符号整型)</code>，整个哈希环如下：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片10.png" alt="img" style="zoom:50%;">

<p>整个圆环以<code>顺时针方向组织</code>，圆环正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推。<br> 第二步，我们将各个服务器使用 Hash 进行一个哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上，比如我们有三台机器，使用IP地址哈希后在环空间的位置如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片11.png" alt="img" style="zoom:50%;">

<p>现在，我们使用以下算法定位数据访问到相应的服务器：</p>
<blockquote>
<p>将数据Key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针查找，遇到的服务器就是其应该定位到的服务器。</p>
</blockquote>
<p>例如，现在有ObjectA，ObjectB，ObjectC三个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片12.png" alt="img" style="zoom:50%;">

<p>根据一致性算法，Object -&gt; NodeA，ObjectB -&gt; NodeB, ObjectC -&gt; NodeC</p>
<h4 id="容错性和可扩展性"><a href="#容错性和可扩展性" class="headerlink" title="容错性和可扩展性"></a>容错性和可扩展性</h4><p>现在，假设我们的Node C宕机了，我们从图中可以看到，A、B不会受到影响，只有Object C对象被重新定位到Node A。所以我们发现，在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据（这里为Node C到Node B之间的数据），其他不会受到影响。如图所示：</p>
<img src="https://upload-images.jianshu.io/upload_images/6555006-cd54d5c30e9cad6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200" alt="img" style="zoom:50%;">

<p>另外一种情况，现在我们系统增加了一台服务器Node X，如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片13.png" alt="img" style="zoom:50%;">

<p>此时对象ObjectA、ObjectB没有受到影响，只有Object C重新定位到了新的节点X上。<br> 如上所述：</p>
<blockquote>
<p>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，有很好的容错性和可扩展性。</p>
</blockquote>
<h4 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h4><p>在一致性Hash算法服务节点太少的情况下，容易因为节点分布不均匀面造成<code>数据倾斜（被缓存的对象大部分缓存在某一台服务器上）问题</code>，如图特例：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片14.png" alt="img" style="zoom:50%;">

<p>这时我们发现有大量数据集中在节点A上，而节点B只有少量数据。为了解决数据倾斜问题，一致性Hash算法引入了<code>虚拟节点机制</code>，即<strong>对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</strong></p>
<p><strong>具体操作可以为服务器IP或主机名后加入编号来实现</strong>，实现如图所示：</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-06-27-数据库系统原理\图片15.png" alt="img" style="zoom:50%;">

<p>数据定位算法不变，只需要增加一步：<strong>虚拟节点到实际点的映射。</strong><br>所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。</p>
<h3 id="3-hash-slot-算法"><a href="#3-hash-slot-算法" class="headerlink" title="3. hash slot 算法"></a>3. hash slot 算法</h3><p>Redis cluster 有固定的 <code>16384</code> 个 hash slot，对每个 <code>key</code> 计算 <code>CRC16</code> 校验码值，然后对 <code>16384</code> 取模，可以获取 key 对应的 hash slot。</p>
<p>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有  5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的  hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</p>
<p>任何一台机器宕机，另外两个节点，不影响的。因为 <strong>key 找的是 hash slot，不是机器</strong>。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\hash-slot.png" style="zoom:80%;">

<h1 id="9-分布式问题"><a href="#9-分布式问题" class="headerlink" title="9.分布式问题"></a>9.分布式问题</h1><p>见《Redis分布式锁》</p>
<h1 id="11-缓存异常"><a href="#11-缓存异常" class="headerlink" title="11.缓存异常"></a>11.缓存异常</h1><h2 id="11-1缓存雪崩"><a href="#11-1缓存雪崩" class="headerlink" title="11.1缓存雪崩"></a>11.1缓存雪崩</h2><p><strong>什么是缓存雪崩？</strong></p>
<p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>有哪些解决办法？</strong></p>
<ul>
<li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li>
<li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉（通过限流来限制直接访问数据库的请求数量，当限流组件发现剩余的请求未能通过自己，便会调用自定义的降级组件，返回一些默认的友好提示：服务器忙，请稍后重试等，不让客户端继续等待）</li>
<li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li>
</ul>
<img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" style="zoom:80%;">



<h2 id="11-2缓存穿透"><a href="#11-2缓存穿透" class="headerlink" title="11.2缓存穿透"></a>11.2缓存穿透</h2><p><strong>什么是缓存穿透？</strong></p>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库，造成数据库负载过大。如下图所示：</p>
<p><strong>正常缓存处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/正常缓存处理流程-redis.png" style="zoom:60%;">

<p><strong>缓存穿透情况处理流程：</strong></p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/缓存穿透处理流程-redis.png" style="zoom:60%;">

<p>一般MySQL 默认的最大连接数在 150 左右，这个可以通过 <code>show variables like &#39;%max_connections%&#39;; </code>命令来查看。最大连接数一个还只是一个指标，cpu，内存，磁盘，网络等无力条件都是其运行指标，这些指标都会限制其并发能力！所以，一般 3000 个并发请求就能打死大部分数据库了。</p>
<p><strong>有哪些解决办法？</strong></p>
<p><strong>1）参数校验</strong></p>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。（也就是将一些明显错误的key值，直接将错误信息返回给客户端直接报错）</p>
<p><strong>2）缓存无效 key</strong> </p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code>。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求key，会导致 redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code>。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险（比如频繁更换key，造成大量的无效key存在于缓存中）</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在与海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，我会先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-缓存穿透-redis.png" style="zoom:60%;">

<p>也就是在Redis缓存与服务端之间再加一层布隆过滤器</p>
<p><strong>布隆过滤器原理：</strong>点击这里~</p>
<h1 id="12-Redis-支持的客户端"><a href="#12-Redis-支持的客户端" class="headerlink" title="12 Redis 支持的客户端"></a>12 Redis 支持的客户端</h1><p>Redisson、Jedis等</p>
<p><strong>二者的对比</strong></p>
<ul>
<li>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；（Jedis是redis的客户端，它封装了redis的操作，用于Java和redis服务器进行通信的）</li>
<li>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</li>
</ul>
<h1 id="13-Redis-和-Memcached-的区别"><a href="#13-Redis-和-Memcached-的区别" class="headerlink" title="13 Redis 和 Memcached 的区别"></a>13 Redis 和 Memcached 的区别</h1><p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<p><strong>数据类型</strong></p>
<ul>
<li>Memcached 仅支持字符串类型。</li>
<li>Redis 支持五种不同的数据类型，可以更灵活地解决问题。</li>
</ul>
<p><strong>数据持久化</strong></p>
<ul>
<li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志。</li>
<li>Memcached 不支持持久化。</li>
</ul>
<p><strong>分布式</strong></p>
<ul>
<li>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li>
<li>Redis Cluster 实现了分布式的支持。</li>
</ul>
<p><strong>内存管理机制</strong></p>
<ul>
<li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li>
<li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li>
</ul>
<h1 id="14如何保证缓存与数据库双写时的数据一致性？"><a href="#14如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="14如何保证缓存与数据库双写时的数据一致性？"></a>14如何保证缓存与数据库双写时的数据一致性？</h1><p>一般情况下我们都是这样使用缓存的：先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。这种方式很明显会存在缓存和数据库的数据不一致的情况。只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p>
<p><strong>读请求和写请求串行化</strong></p>
<p>一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果你的系统<strong>不是严格要求</strong> “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：<strong>读请求和写请求串行化</strong>，串到一个<strong>内存队列</strong>里去。</p>
<p>串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>
<h2 id="1-Cache-Aside-Pattern"><a href="#1-Cache-Aside-Pattern" class="headerlink" title="1.Cache Aside Pattern"></a>1.Cache Aside Pattern</h2><p>最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。</p>
<ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，<strong>先更新数据库，然后再删除缓存</strong>。</li>
</ul>
<p><strong>为什么是删除缓存，而不是更新缓存？</strong></p>
<ul>
<li><p><strong>因为对于比较复杂的缓存数据计算场景，当被更新的缓存频繁更新、且不常被访问时，更新缓存的代价比较高</strong></p>
<p><strong>例如：</strong>一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。</p>
</li>
</ul>
<p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p>
<h2 id="2-最初级的缓存不一致问题"><a href="#2-最初级的缓存不一致问题" class="headerlink" title="2.最初级的缓存不一致问题"></a>2.最初级的缓存不一致问题</h2><p><strong>问题：</strong>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p>
<p><strong>解决思路：</strong></p>
<p>先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</p>
<h2 id="3-比较复杂的数据不一致问题"><a href="#3-比较复杂的数据不一致问题" class="headerlink" title="3.比较复杂的数据不一致问题"></a>3.比较复杂的数据不一致问题</h2><p><strong>问题：</strong>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，<strong>查到了修改前的旧数据</strong>，放到了缓存中。随后数据变更的程序完成了数据库的修改，造成数据库和缓存中的数据不一样。</p>
<p><strong>出现场景：</strong>上亿流量高并发场景下，缓存会出现这个问题（大量的“更新”+“读”操作&lt;其实就是时间差&gt;）</p>
<p>只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。</p>
<p><strong>解决思路：</strong></p>
<p>更新数据的时候，根据<strong>数据的唯一标识（例如店铺ID）</strong>，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。</p>
<p>一个队列对应一个工作线程，每个工作线程<strong>串行</strong>拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。</p>
<p>这里有一个<strong>优化点</strong>，一个队列中，其实<strong>多个更新缓存请求串在一起是没意义的</strong>，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。</p>
<p>待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</p>
<h1 id="15-五种IO模型"><a href="#15-五种IO模型" class="headerlink" title="15.五种IO模型"></a>15.五种IO模型</h1><blockquote>
<p><strong>Note：</strong></p>
<p> linux中， 每一个进程在内核中，都对应有一个“打开文件”数组，存放指向文件对象的指针，而 <strong>fd 是这个数组的下标</strong>。</p>
<p> 我们对文件进行操作时，系统调用，将fd传入内核，内核通过fd找到文件，对文件进行操作。</p>
</blockquote>
<p>一个IO操作其实分成了两个步骤：</p>
<ul>
<li>发起 IO请求</li>
<li>实际的 IO 操作（读/写）。</li>
</ul>
<p><strong>阻塞IO和非阻塞IO的区别：</strong>在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。 </p>
<p><strong>同步IO和异步IO的区别：</strong>在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。 </p>
<h2 id="1-阻塞IO模型"><a href="#1-阻塞IO模型" class="headerlink" title="1.阻塞IO模型"></a>1.阻塞IO模型</h2><p>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p>
<p>执行如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd=connect();</span><br><span class="line">write(fd);</span><br><span class="line">read(fd);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure>

<p>程序的read必须在write之后执行，当write阻塞住了，read就不能执行下去，一直处于等待状态。</p>
<img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source\_posts\2021-04-10-Redis相关\阻塞IO.png" style="zoom:100%;">

<h2 id="2-非阻塞IO模型"><a href="#2-非阻塞IO模型" class="headerlink" title="2.非阻塞IO模型"></a>2.非阻塞IO模型</h2><p>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\非阻塞IO.png"></p>
<p>这样会造成CPU的占有率特别高</p>
<h2 id="3-多路复用IO模型"><a href="#3-多路复用IO模型" class="headerlink" title="3.多路复用IO模型"></a>3.多路复用IO模型</h2><p>多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。</p>
<p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p>
<p>在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p>
<p>多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\多路复用IO.png"></p>
<h2 id="4-信号驱动IO模型"><a href="#4-信号驱动IO模型" class="headerlink" title="4.信号驱动IO模型"></a>4.信号驱动IO模型</h2><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接口几乎是没用的，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么事情。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\信号驱动IO.png"></p>
<h2 id="5-异步IO模型"><a href="#5-异步IO模型" class="headerlink" title="5.异步IO模型"></a>5.异步IO模型</h2><p>读取操作(aio_read)会通知内核进行读取操作并将数据拷贝至进程中，完事后通知进程整个操作全部完成（绑定一个回调函数处理数据）。</p>
<p>读取操作会立刻返回，程序可以进行其它的操作，所有的读取、拷贝工作都由内核去做，做完以后通知进程，进程调用绑定的回调函数来处理数据。</p>
<p><strong>对比信号驱动IO，异步IO的主要区别在于：</strong>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</p>
<p><img src="/2021/04/10/Redis%E7%9B%B8%E5%85%B3/GitHub\MyBlogs\source_posts\2021-04-10-Redis相关\异步IO.png"></p>
<h1 id="16-常用的IO复用模型"><a href="#16-常用的IO复用模型" class="headerlink" title="16.常用的IO复用模型"></a>16.常用的IO复用模型</h1><p>目前支持I/O多路复用的系统调用有<strong>select，poll，epoll</strong>等函数。I/O多路复用就是通过一种机制<strong>一个线程可以监视多个描述符</strong>，一旦某个描述符读就绪或者写就绪，其能够通知应用程序进行相应的读写操作。</p>
<p><strong>多路I/O复用机制</strong>与多进程和多线程技术相比系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p>
<p>常见的函数特点如下：</p>
<p><strong>三种：select，poll，epoll</strong></p>
<ul>
<li><p><strong>select</strong>==&gt;时间复杂度O(n)</p>
<p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能<strong>无差别轮询所有流</strong>，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
</li>
<li><p><strong>poll</strong>==&gt;时间复杂度O(n)</p>
<p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
</li>
<li><p><strong>epoll</strong>==&gt;时间复杂度O(1)</p>
<p>epoll可以理解为event poll，不同于无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。</p>
</li>
</ul>
<p><strong>三种模型分析：</strong></p>
<p><strong>select缺点：</strong></p>
<ul>
<li>每次调用 select，都需要把 fd_set 集合从用户态拷贝到内核空间中</li>
<li>如果任何一个 sockt(I/O stream) 出现了数据，需要在内核遍历传递进来的所有 fd_set，找出能读出数据，或者写入数据的流，对他们进行操作</li>
<li>有最大监听连接数 1024 个的限制</li>
</ul>
<p><strong>poll缺点：</strong></p>
<ul>
<li><strong>poll 没有最大监听连接数的限制（与 Select 不同）</strong></li>
<li>每次调用 poll，都需要把 fd_set 集合从用户态拷贝到内核空间中</li>
<li>如果任何一个 sock(I/O stream) 出现了数据，需要在内核遍历传递进来的所有 fd_set，找出能读出数据，或者写入数据的流，对他们进行操作</li>
</ul>
<p><strong>epoll：（优势）</strong></p>
<ul>
<li>没有最大并发连接的限制，监听连接数远大于 1024</li>
<li>效率提升，不是轮询的方式，而是信号驱动的方式，这样不会随着 fd_set 集合中元素数目的增加效率下降</li>
<li>红黑树结构使得不需要每次都把 fd_set 集合从用户态拷贝到内核态</li>
<li>减少内存拷贝，利用 mmap() 文件映射内存加速与内核空间的消息传递；即 epoll 使用 mmap 减少复制开销</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>select、poll：连接数少并且连接都十分活跃的情况</p>
<p>epoll：连接多，并且有大量不太活跃的连接</p>
<p><strong>epoll的实现原理：</strong></p>
<p>我们先看一下 epoll 和 select 和 poll 的调用接口上的不同，select 和 poll 都只提供了一个函数—— select 或者 poll 函数。而 epoll 提供了三个函数 epoll_create ，epoll_ctl 和 epoll_wait ，epoll_create 是创建一个 epoll 句柄；epoll_ctl 是注册要监听的事件类型；epoll_wait 则是等待事件的产生。</p>
<ul>
<li><p><strong>epoll_create()系统调用：</strong>通过此调用建立一个epoll对象，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。</p>
<p><code>红黑树：</code>树中存储着所有添加到epoll中的需要监控的事件</p>
<p><code>双向链表：</code>存放着将要通过epoll_wait()返回给用户的满足条件的事件（所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中）</p>
</li>
<li><p><strong>epoll_ctl()系统调用：</strong>通过此调用向 epoll 对象中添加、删除、修改感兴趣的事件，这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来，所以不需要每次调用 epoll_wait 都复制所有的事件结构。并为每个事件指定一个回调函数叫 ep_poll_callback，当设备就绪，就会调用这个回调函数，而这个回调函数会把就绪的事件加入 epoll 对象中的双向链表中。</p>
</li>
<li><p><strong>epoll_wait()系统调用：</strong>通过此调用会直接返回双向链表中的就绪事件，效率高。</p>
</li>
</ul>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis%E7%9B%B8%E5%85%B3/" rel="tag"><i class="fa fa-tag"></i>  Redis相关</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/10/%E6%A0%A1%E5%9B%AD%E5%95%86%E9%93%BA%E9%A1%B9%E7%9B%AE1-0%E6%80%BB%E7%BB%93/" rel="prev" title="校园商铺项目1.0总结">
      <i class="fa fa-chevron-left"></i> 校园商铺项目1.0总结
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/15/HashMap/" rel="next" title="HashMap">
      HashMap <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1Redis%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1Redis简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis"><span class="nav-number">1.2.</span> <span class="nav-text">1.2为什么要用 redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8redis%E8%80%8C%E4%B8%8D%E7%94%A8map-guava-%E5%81%9A%E7%BC%93%E5%AD%98"><span class="nav-number">1.3.</span> <span class="nav-text">1.3为什么用redis而不用map&#x2F;guava 做缓存?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98map-guava"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1本地缓存map&#x2F;guava</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98redis"><span class="nav-number">1.3.2.</span> <span class="nav-text">13.2分布式缓存redis</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">2.数据类型和使用场景分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-String"><span class="nav-number">2.1.</span> <span class="nav-text">1. String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Hash"><span class="nav-number">2.2.</span> <span class="nav-text">2. Hash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-List"><span class="nav-number">2.3.</span> <span class="nav-text">3. List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Set"><span class="nav-number">2.4.</span> <span class="nav-text">4. Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Sorted-Set"><span class="nav-number">2.5.</span> <span class="nav-text">5. Sorted Set</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">3.持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">3.1.</span> <span class="nav-text">3.1持久化策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">3.2.</span> <span class="nav-text">3.2持久化策略的选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">4.</span> <span class="nav-text">4.键的过期时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">5.内存淘汰策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">6.线程模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">7.事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="nav-number">8.</span> <span class="nav-text">8.集群方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1Redis-cluster-%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.1.</span> <span class="nav-text">8.1Redis cluster 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89"><span class="nav-number">8.2.</span> <span class="nav-text">8.2哨兵模式（sentinel）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E5%86%85%E9%83%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">8.3.</span> <span class="nav-text">8.3节点间的内部通信机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.</span> <span class="nav-text">8.4分布式寻址算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-hash-%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.1.</span> <span class="nav-text">1. hash 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%80%E8%87%B4%E6%80%A7-hash-%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">2.一致性 hash 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%80%A7%E5%92%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">容错性和可扩展性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">数据倾斜问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-hash-slot-%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.3.</span> <span class="nav-text">3. hash slot 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">9.分布式问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="nav-number">10.</span> <span class="nav-text">11.缓存异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">10.1.</span> <span class="nav-text">11.1缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">10.2.</span> <span class="nav-text">11.2缓存穿透</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">11.</span> <span class="nav-text">12 Redis 支持的客户端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">13 Redis 和 Memcached 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">14如何保证缓存与数据库双写时的数据一致性？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Cache-Aside-Pattern"><span class="nav-number">13.1.</span> <span class="nav-text">1.Cache Aside Pattern</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9C%80%E5%88%9D%E7%BA%A7%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">13.2.</span> <span class="nav-text">2.最初级的缓存不一致问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">13.3.</span> <span class="nav-text">3.比较复杂的数据不一致问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">15.五种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.1.</span> <span class="nav-text">1.阻塞IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.2.</span> <span class="nav-text">2.非阻塞IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.3.</span> <span class="nav-text">3.多路复用IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.4.</span> <span class="nav-text">4.信号驱动IO模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">14.5.</span> <span class="nav-text">5.异步IO模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E5%B8%B8%E7%94%A8%E7%9A%84IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">16.常用的IO复用模型</span></a></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">911k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:48</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

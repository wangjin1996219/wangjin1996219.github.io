<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Java集合">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合01.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合02.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合03.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合04.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/图片2.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合05.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/HashMap扩容.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/图片3.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/图片4.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合06.png">
<meta property="article:published_time" content="2021-04-16T03:26:29.000Z">
<meta property="article:modified_time" content="2021-08-08T07:47:13.993Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="Java容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub/MyBlogs/source_posts/2021-04-16-Java集合/集合01.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java集合 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/04/16/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java集合
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-16 11:26:29" itemprop="dateCreated datePublished" datetime="2021-04-16T11:26:29+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-08 15:47:13" itemprop="dateModified" datetime="2021-08-08T15:47:13+08:00">2021-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">JAVA基础</span></a>
                </span>
            </span>

          
            <span id="/2021/04/16/Java%E9%9B%86%E5%90%88/" class="post-meta-item leancloud_visitors" data-flag-title="Java集合" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/04/16/Java%E9%9B%86%E5%90%88/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/16/Java%E9%9B%86%E5%90%88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-三大集合接口的引出"><a href="#1-三大集合接口的引出" class="headerlink" title="1.三大集合接口的引出"></a>1.三大集合接口的引出</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h2 id="1-1-Collection"><a href="#1-1-Collection" class="headerlink" title="1.1 Collection"></a>1.1 Collection</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合01.png" alt="img"></p>
<p><strong>Set</strong></p>
<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<p><strong>List</strong></p>
<ul>
<li>ArrayList：基于动态数组实现，支持随机访问。</li>
<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h2 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合02.png" alt="img"></p>
<ul>
<li>TreeMap：基于红黑树实现。</li>
<li>HashMap：基于哈希表实现。</li>
<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable  不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<p><strong>问题：Map，List和Set都是Collection的子接口吗？</strong></p>
<p>Map是和Collection并列的集合上层接口，没有继承关系；List和Set是Collection的子接口。</p>
<p><strong>问题：能说下 List,Set,Map 三者的区别吗？</strong></p>
<ul>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key 可以引用相同的对象，但 Key 不能重复，典型的 Key 是 String 类型，但也可以是任何对象。</li>
</ul>
<h1 id="2-容器中的设计模式"><a href="#2-容器中的设计模式" class="headerlink" title="2. 容器中的设计模式"></a>2. 容器中的设计模式</h1><h2 id="2-1迭代器模式"><a href="#2-1迭代器模式" class="headerlink" title="2.1迭代器模式"></a>2.1迭代器模式</h2><p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合03.png" alt="img"></p>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2适配器模式"><a href="#2-2适配器模式" class="headerlink" title="2.2适配器模式"></a>2.2适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br></pre></td></tr></table></figure>

<p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure>

<p>也可以使用以下方式调用 asList()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-HashMap-集合"><a href="#3-HashMap-集合" class="headerlink" title="3. HashMap 集合"></a>3. HashMap 集合</h1><h2 id="3-1-底层实现"><a href="#3-1-底层实现" class="headerlink" title="3.1 底层实现"></a>3.1 底层实现</h2><p><strong>Java8之前：</strong>数组+链表（数组的查询速度快，链表的增删效率高，因此HashMap结合了两者的优势）</p>
<p>内部包含了一个 Entry 类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry  是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap  使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合04.png" alt="img"></p>
<ul>
<li>理想情况下，每个键位通过散列运算对应不同的值，这样查询的效率就是O(1)</li>
<li>当不同的键位通过散列运算总是得到相同的值，这时候就会在一个头结点后面拼接为一个很长的链表，性能就会由原来的O(1)降低为O(n)</li>
</ul>
<p>于是，<strong>Java8之后</strong>，就加入了红黑树数据结构，如下图所示：</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片2.png" style="zoom:80%;">

<p>引入一个常量TREEIFY_THRESHOLD，当链表达到一定的长度之后，就会将链表转换成红黑树，这样最坏情况就从O(n)提高到了O(logn)，解决了链表太长导致的查询速度变慢的问题。</p>
<h2 id="3-2-存取原理"><a href="#3-2-存取原理" class="headerlink" title="3.2 存取原理"></a>3.2 存取原理</h2><p><strong>调用 put() 方法传递键和值来存储时：</strong>先对键调用 hashCode() 方法，返回的 hashCode 用于<strong>找到桶位置来储存 Entry 对象</strong>，也就是找到了该元素应该被存储的<strong>桶中（数组）</strong>。当两个键的 hashCode 值相同时，桶位置发生了冲突，也就是<strong>发生了 Hash冲突</strong>，这个时候，会在每一个桶后边接上一个链表（JDK8及以后的版本中还会加上红黑树）来解决，将新存储的键值对放在表头（<strong>头插法</strong>）。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键为 null 单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 确定桶下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 插入新键值对</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private V putForNullKey(V value) &#123;</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[0]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        if (e.key &#x3D;&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(0, null, value, 0);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 头插法，链表头部指向新的键值对</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多操作都需要先确定一个键值对所在的桶下标，包含两个步骤：</p>
<ol>
<li>计算 hash 值</li>
<li>取模</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>计算 hash 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取模</p>
<p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure>

<p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure>

<p>这个性质和 y 对 x 取模效果是一样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y   : 10110010</span><br><span class="line">x   : 00010000</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure>

<p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用 get() 方法获取存储的值时：</strong>首先根据键的 hashCode 找到对应的桶，然后根据 equals() 方法来在链表和红黑树中找到对应的值。</p>
<p><strong>拉链法工作原理图：</strong></p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合05.png" alt="img"></p>
<h2 id="3-3-扩容问题"><a href="#3-3-扩容问题" class="headerlink" title="3.3 扩容问题"></a>3.3 扩容问题</h2><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<h3 id="3-3-1-初始容量、加载因子、扩容增量"><a href="#3-3-1-初始容量、加载因子、扩容增量" class="headerlink" title="3.3.1 初始容量、加载因子、扩容增量"></a>3.3.1 初始容量、加载因子、扩容增量</h3><p><strong>问题：HashMap的初始容量，加载因子，扩容增量是多少？</strong></p>
<p>HashMap的初始容量16，加载因子为0.75，扩容增量是原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。HashMap扩容是指元素个数<strong>（包括数组和链表+红黑树中）</strong>超过了16*0.75=12之后开始扩容。</p>
<p><strong>问题：HashMap的长度为什么是2的幂次方？</strong></p>
<p>我们先要看下对于一个 Entry 的键值 Key 我们是怎么求得 HashMap 中的 Index 的：index = HashCode（Key） &amp; （Length- 1）</p>
<ol>
<li>length为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与 HashCode 的二进制<strong>与操作效率会非常的快</strong>，这种情况下，index的结果等同于HashCode后几位的值</li>
<li>只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的，也就是<strong>降低了碰撞的可能性</strong></li>
</ol>
<p><strong>问题：加载因子为什么设为 0.75 ？</strong></p>
<p>如果设置太小不利于空间利用，设置太大则会导致碰撞增多，降低了查询效率，所以设置了0.75。</p>
<h3 id="3-3-2扩容步骤"><a href="#3-3-2扩容步骤" class="headerlink" title="3.3.2扩容步骤"></a>3.3.2扩容步骤</h3><p><strong>问题：HashMap 在什么情况下会触发扩容机制？</strong></p>
<p>HashMap 里面默认的负载因子大小为 0.75，也就是说，进行 put 操作时，当发现 Map 中的元素（Entry）个数<strong>（包括数组，链表和红黑树中）</strong>超过了 16*0.75=12 之后开始扩容。将会创建原来 HashMap 大小的两倍的桶数组，来重新调整 Map 的大小，并将原来的对象放入新的桶数组中。</p>
<p><strong>问题：讲一下 HashMap 的扩容过程吧。</strong></p>
<p>HashMap 的扩容过程在 JDK1.8 以前和以后是不同的，下面分别讲解下两个版本下的扩容过程。</p>
<p><strong>JDK1.7 的扩容过程：</strong>JDK1.7 的扩容过程是在 resize() 方法和 transfer() 方法中实现的。</p>
<p>resize() 方法中完成的工作：</p>
<ul>
<li>判断当前数组的大小是否达到了最大值</li>
<li>创建一个新的 Entry 数组 newTable，长度是旧数组的两倍</li>
<li>调用 transfer() 方法，将旧数组中的元素迁移到新数组中</li>
</ul>
<p>transfer() 方法中完成的工作：</p>
<ul>
<li>遍历 oldTable 迁移元素到 newTable</li>
<li>重新计算 Hash 值，找到 Entry 在 newTable 中的位置</li>
</ul>
<p><strong>但是 transfer() 方法这里容易出现问题：</strong>transfer方法的作用是把原table的Node放到新的table中，使用的是<strong>头插法</strong>，也就是说，新table中链表的顺序和旧列表中是相反的，在HashMap线程不安全的情况下，这种头插法可能会导致环状节点，出现环形链表的原因大概是这样的：线程1准备处理节点，然后被挂起，这时线程2把 HashMap 扩容成功，链表已经逆向排序，那么线程1回来继续处理节点时就可能出现环形链表。</p>
<p><strong>JDK1.8 的扩容过程：</strong>整个的扩容过程都在 resize 方法中完成</p>
<ul>
<li>创建一个新的 Entry 数组 newTable，长度是旧数组的两倍</li>
<li>遍历循环原数组，把原数组中的每个链表中的每个元素放入新数组，与 JDK1.7 不同，这里采用的是<strong>尾插法</strong>的方式，新链表中节点顺序和原链表相同，不再是 JDK1.7 的倒序了，这就解决了多线程扩容的线程安全问题（其实还是存在问题）</li>
<li>正常情况下，计算节点在旧数组中的下标的方法是：hash&amp;(oldTable.length-1)，扩容之后，数组长度翻倍，计算新数组中下标的方法是 hash&amp;(newTable.length-1) ，也就是 hash&amp;(oldTable.length*2-1) ，于是我们有了这样的结论：这新旧两次计算下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度。说白了，就是通过新增的 bit 位置上是 0 还是 1 来判断。 如果新增 bit 所在的那一位是 0，那么新 table 按位与的结果和旧 table 的结果就相同，反之如果新增 bit 所在的那一位是1，则新 table 按位与的结果就比旧 table 的结果多了10000（二进制），而这个二进制10000就是旧table的长度16。如下图所示：</li>
</ul>
<p>举个例子，假设table原长度是16，扩容后长度32，那么一个hash值在扩容前后的table下标是这么计算的：</p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\HashMap扩容.png" alt="img"></p>
<p><strong>总结：</strong>JDK1.8 改进之后，通过尾插法的方式避免了多线程扩容时出现的循环链表问题，还通过巧妙利用位运算的特性做了一个扩容时运算效率的提升。</p>
<p><strong>问题：JDK1.8 避免了循环链表后就线程安全了吗？</strong></p>
<p>在 JDK1.8 中，多线程在并发执行 put 操作时会发生数据覆盖的情况</p>
<p>假设两个线程A、B都在进行 put 操作，并且 hash 函数计算出的插入下标是相同的，当线程 A 执行完 hash 碰撞判断通过后，由于时间片耗尽导致被挂起，而线程 B 得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程 A 获得时间片，由于之前已经进行了 hash 碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程 B 插入的数据被线程 A 覆盖了，从而线程不安全。</p>
<h2 id="3-4解决-Hash-冲突的方法"><a href="#3-4解决-Hash-冲突的方法" class="headerlink" title="3.4解决 Hash 冲突的方法"></a>3.4解决 Hash 冲突的方法</h2><p><strong>问题：说一说你了解的解决 Hash 冲突的方法吧</strong></p>
<ul>
<li>拉链法 <strong>（HashMap使用的方法）</strong> </li>
<li>线性探测再散列法 </li>
<li>二次探测再散列法 </li>
<li>伪随机探测再散列法 </li>
</ul>
<p><strong>解析：HashMap 是怎么解决 Hash 冲突的？</strong></p>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p>总结来说，就是通过 <strong>扰动函数+拉链法</strong> 来解决Hash冲突的。</p>
<h2 id="3-5-HashMap-实现线程安全"><a href="#3-5-HashMap-实现线程安全" class="headerlink" title="3.5 HashMap 实现线程安全"></a>3.5 HashMap 实现线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronizedMap方法中对public方法进行了加锁，相当于把原来的HashMap对象封装在safeHashMap对象中，再通过synchronizedMap中的公共方法对HashMap对象操作时，就是线程安全的了</span></span><br><span class="line">Map hashMap=<span class="keyword">new</span> HashMap();</span><br><span class="line">Map safeHashMap=Collections.synchronizedMap(hashMap);</span><br></pre></td></tr></table></figure>

<h2 id="3-5-HashMap-和-Hashtable-的比较"><a href="#3-5-HashMap-和-Hashtable-的比较" class="headerlink" title="3.5 HashMap 和 Hashtable 的比较"></a>3.5 HashMap 和 Hashtable 的比较</h2><p><strong>HashMap和Hashtable之间的区别可以总结如下：</strong></p>
<ul>
<li><p><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>对 Null key 和 Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<p>①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</p>
<p>②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证）。也就是说 HashMap 总是使用2的幂作为哈希表的大小。</p>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<p><strong>解析：</strong>面试官会根据你的回答，考察线程安全的问题</p>
<p><strong>HashMap 与 Hashtable 的线程安全性：</strong></p>
<ul>
<li>HashMap 的线程不安全主要体现在下面两个方面：<ol>
<li>在 JDK1.7 中，当并发执行扩容操作时会造成环形链和数据丢失的情况。</li>
<li>在 JDK1.8 中，在并发执行 put 操作时会发生数据覆盖的情况。</li>
</ol>
</li>
<li>Hashtable 线程安全是由于其内部实现在 put 和 remove 等方法上使用 synchronized 进行了同步，所以对<strong>单个方法的使用是线程安全</strong>的。但是对多个方法进行<strong>复合操作时，线程安全性无法保证。</strong> 比如一个线程在进行 get 然后 put 更新的操作，这就是两个复合操作，在两个操作之间，可能别的线程已经对这个 key 做了改动，所以，你接下来的 put 操作可能会不符合预期。 </li>
</ul>
<h1 id="4-ConccurentHashMap-集合"><a href="#4-ConccurentHashMap-集合" class="headerlink" title="4. ConccurentHashMap 集合"></a>4. ConccurentHashMap 集合</h1><h2 id="4-1-JDK1-8-之前的底层实现"><a href="#4-1-JDK1-8-之前的底层实现" class="headerlink" title="4.1 JDK1.8 之前的底层实现"></a>4.1 JDK1.8 之前的底层实现</h2><p><strong>多线程的环境下，使用集合时，通常有以下几种方式：</strong></p>
<ol>
<li>使用 synchronizedHashMap 封装的线程安全的 map 集合</li>
<li>使用 Hashtable</li>
<li>使用 ConccurentHashMap</li>
</ol>
<p>由于在多线程环境下，前两种线程安全的 map 集合都是串行执行的，因此效率比较低，并发性也比 HashMap 要好，所以通常选择使用 ConccurentHashMap 集合。</p>
<p><strong>Java8 之前：</strong></p>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap  采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片3.png" style="zoom:80%;">

<p>Segment 继承自 ReentrantLock：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">// 统计该 Segment 中的键值对个数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 记得快速失败（fail—fast）么？</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 大小(size 的临界值，只要大于就得扩容)</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 负载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>默认的并发级别为 16，也就是说默认创建 16 个 Segment：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<p><strong>size 操作</strong></p>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of elements. Accessed only either within locks</span></span><br><span class="line"><span class="comment"> * or among other volatile reads that maintain visibility.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of unsynchronized retries in size and containsValue</span></span><br><span class="line"><span class="comment"> * methods before resorting to locking. This is used to avoid</span></span><br><span class="line"><span class="comment"> * unbounded retries if tables undergo continuous modification</span></span><br><span class="line"><span class="comment"> * which would make it impossible to obtain an accurate result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 超过尝试次数，则对每个 Segment 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 连续两次得到的结果一致，则认为这个结果是正确的</span></span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-JDK1-8-之后的底层实现"><a href="#4-2-JDK1-8-之后的底层实现" class="headerlink" title="4.2 JDK1.8 之后的底层实现"></a>4.2 JDK1.8 之后的底层实现</h2><p>通过 CAS+synchronized 使锁更细化，也就是说不再使用分段锁，而是对每一个头结点分别加锁，这样一来效率又有了成倍的提高。而且采用了数组+链表+红黑树的底层结构，查询效率也更高。</p>
<img src="/2021/04/16/Java%E9%9B%86%E5%90%88/图片4.png" style="zoom:80%;">

<h2 id="4-3存取原理"><a href="#4-3存取原理" class="headerlink" title="4.3存取原理"></a>4.3存取原理</h2><p><strong>Jdk1.7：put 操作</strong></p>
<p>首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><strong>JDK1.8：put 操作</strong></p>
<ol>
<li><p>根据 key 计算出 hash 值；</p>
</li>
<li><p>判断是否需要进行初始化；</p>
</li>
<li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p>
<ul>
<li><p>如果为 null ，则通过 CAS 的方式尝试添加；</p>
</li>
<li><p>如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容；</p>
</li>
<li><p>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</p>
</li>
</ul>
</li>
<li><p>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</p>
</li>
</ol>
<p><strong>Jdk1.7：get 操作</strong></p>
<p>首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p>
<p>由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p>
<p><strong>JDK1.8：get 操作</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值，判断数组是否为空；</li>
<li>如果是首节点，就直接返回；</li>
<li>如果是红黑树结构，就从红黑树里面查询；</li>
<li>如果是链表结构，循环遍历判断。</li>
</ol>
<h1 id="5-LinkedHashMap-集合"><a href="#5-LinkedHashMap-集合" class="headerlink" title="5. LinkedHashMap 集合"></a>5. LinkedHashMap 集合</h1><h2 id="5-1底层结构"><a href="#5-1底层结构" class="headerlink" title="5.1底层结构"></a>5.1底层结构</h2><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure>

<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-afterNodeAccess"><a href="#5-2-afterNodeAccess" class="headerlink" title="5.2 afterNodeAccess()"></a>5.2 afterNodeAccess()</h2><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-afterNodeInsertion"><a href="#5-3-afterNodeInsertion" class="headerlink" title="5.3 afterNodeInsertion()"></a>5.3 afterNodeInsertion()</h2><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承  LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU  的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-LRU-缓存的实现"><a href="#5-4-LRU-缓存的实现" class="headerlink" title="5.4 LRU 缓存的实现"></a>5.4 LRU 缓存的实现</h2><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<p><strong>Demo：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 1, 4]</span><br></pre></td></tr></table></figure>

<h1 id="6-WeakHashMap-集合"><a href="#6-WeakHashMap-集合" class="headerlink" title="6. WeakHashMap 集合"></a>6. WeakHashMap 集合</h1><h2 id="6-1底层结构"><a href="#6-1底层结构" class="headerlink" title="6.1底层结构"></a>6.1底层结构</h2><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-ConcurrentCache-缓存实现"><a href="#6-2-ConcurrentCache-缓存实现" class="headerlink" title="6.2 ConcurrentCache 缓存实现"></a>6.2 ConcurrentCache 缓存实现</h2><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; eden;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K, V&gt; longterm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentCache</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.eden = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">this</span>.longterm = <span class="keyword">new</span> WeakHashMap&lt;&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">        V v = <span class="keyword">this</span>.eden.get(k);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            v = <span class="keyword">this</span>.longterm.get(k);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.eden.size() &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">this</span>.longterm.putAll(<span class="keyword">this</span>.eden);</span><br><span class="line">            <span class="keyword">this</span>.eden.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.eden.put(k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-TreeMap-集合"><a href="#7-TreeMap-集合" class="headerlink" title="7. TreeMap 集合"></a>7. TreeMap 集合</h1><h2 id="7-1底层实现"><a href="#7-1底层实现" class="headerlink" title="7.1底层实现"></a>7.1底层实现</h2><p>TreeMap 底层使用<strong>红黑树</strong>实现，TreeMap中存储的键值对<strong>按照键来排序</strong>。</p>
<ul>
<li>如果Key存入的是字符串等类型，那么会按照字典默认顺序排序 </li>
<li>如果传入的是自定义引用类型，比如说User，那么该对象必须实现Comparable接口，并且覆盖其compareTo方法；或者在创建TreeMap的时候，我们必须指定使用的比较器。如下所示： </li>
</ul>
<p><strong>实现 Comparable 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student,Integer&gt; tm=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        tm.put(s1,<span class="number">1</span>);</span><br><span class="line">        tm.put(s2,<span class="number">2</span>);</span><br><span class="line">        tm.put(s3,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Student&gt; students = tm.keySet();</span><br><span class="line">        Iterator&lt;Student&gt; iterator = students.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wangjin001</span><br><span class="line">wangjin002</span><br><span class="line">wangjin003</span><br></pre></td></tr></table></figure>

<p><strong>指定比较器 Comparator：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Student,Integer&gt; tm=<span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.name.compareTo(o2.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="number">1</span>, <span class="string">&quot;wangjin001&quot;</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="number">2</span>, <span class="string">&quot;wangjin002&quot;</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="number">3</span>, <span class="string">&quot;wangjin003&quot;</span>);</span><br><span class="line">        tm.put(s1,<span class="number">1</span>);</span><br><span class="line">        tm.put(s2,<span class="number">2</span>);</span><br><span class="line">        tm.put(s3,<span class="number">3</span>);</span><br><span class="line">        Set&lt;Student&gt; students = tm.keySet();</span><br><span class="line">        Iterator&lt;Student&gt; iterator = students.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wangjin001</span><br><span class="line">wangjin002</span><br><span class="line">wangjin003</span><br></pre></td></tr></table></figure>

<h2 id="7-2-Comparable-和-Comparator-的比较"><a href="#7-2-Comparable-和-Comparator-的比较" class="headerlink" title="7.2 Comparable 和 Comparator 的比较"></a>7.2 Comparable 和 Comparator 的比较</h2><ul>
<li><strong>Comparable 接口</strong>的后缀是able大概表示可以的意思，也就是说一个类如果实现了这个接口，那么这个<strong>类就是可以比较的</strong>。类似的还有cloneable接口表示可以克隆的。</li>
<li><strong>Comparator则是一个比较器</strong>，是创建TreeMap的时候传入，用来指定比较规则。</li>
</ul>
<p><strong>二者的区别：</strong></p>
<ul>
<li>Comparable 实现比较简单，但是当需要重新定义比较规则的时候，<strong>必须修改源代码</strong>，即修改 User 类里边的 compareTo 方法 </li>
<li>Comparator 接口不需要修改源代码，只需要在创建 TreeMap 的时候<strong>重新传入一个具有指定规则的比较器</strong>即可。 </li>
</ul>
<h1 id="8-ArrayList-集合"><a href="#8-ArrayList-集合" class="headerlink" title="8. ArrayList 集合"></a>8. ArrayList 集合</h1><h2 id="8-1底层实现"><a href="#8-1底层实现" class="headerlink" title="8.1底层实现"></a>8.1底层实现</h2><p>因为 ArrayList 是<strong>基于数组实现</strong>的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>数组的默认大小为 10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="8-2扩容过程"><a href="#8-2扩容过程" class="headerlink" title="8.2扩容过程"></a>8.2扩容过程</h2><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即 oldCapacity+oldCapacity/2。其中 oldCapacity &gt;&gt; 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-3线程安全的-ArrayList"><a href="#8-3线程安全的-ArrayList" class="headerlink" title="8.3线程安全的 ArrayList"></a>8.3线程安全的 ArrayList</h2><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="9-Vector-集合"><a href="#9-Vector-集合" class="headerlink" title="9. Vector 集合"></a>9. Vector 集合</h1><h2 id="9-1同步"><a href="#9-1同步" class="headerlink" title="9.1同步"></a>9.1同步</h2><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。也就是说它是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2扩容过程"><a href="#9-2扩容过程" class="headerlink" title="9.2扩容过程"></a>9.2扩容过程</h2><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-Vector-和-ArrayList-的比较"><a href="#9-3-Vector-和-ArrayList-的比较" class="headerlink" title="9.3 Vector 和 ArrayList 的比较"></a>9.3 Vector 和 ArrayList 的比较</h2><ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li>
</ul>
<h1 id="10-CopyOnWriteArrayList-集合"><a href="#10-CopyOnWriteArrayList-集合" class="headerlink" title="10. CopyOnWriteArrayList 集合"></a>10. CopyOnWriteArrayList 集合</h1><h2 id="10-1读写分离"><a href="#10-1读写分离" class="headerlink" title="10.1读写分离"></a>10.1读写分离</h2><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2适用场景"><a href="#10-2适用场景" class="headerlink" title="10.2适用场景"></a>10.2适用场景</h2><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h1 id="11-LinkedList-集合"><a href="#11-LinkedList-集合" class="headerlink" title="11. LinkedList 集合"></a>11. LinkedList 集合</h1><h2 id="11-1底层实现"><a href="#11-1底层实现" class="headerlink" title="11.1底层实现"></a>11.1底层实现</h2><p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个链表存储了 first 和 last 指针：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>

<p><strong>如图所示：</strong></p>
<p><img src="/2021/04/16/Java%E9%9B%86%E5%90%88/GitHub\MyBlogs\source_posts\2021-04-16-Java集合\集合06.png" alt="img"></p>
<h2 id="11-2-LinkedList-和-ArrayList-的比较"><a href="#11-2-LinkedList-和-ArrayList-的比较" class="headerlink" title="11.2 LinkedList 和 ArrayList 的比较"></a>11.2 LinkedList 和 ArrayList 的比较</h2><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li>
<li>链表不支持随机访问，但插入删除只需要改变指针。</li>
</ul>
<h1 id="12-几种常见对比"><a href="#12-几种常见对比" class="headerlink" title="12.几种常见对比"></a>12.几种常见对比</h1><h2 id="12-1-Collection-和-Collections"><a href="#12-1-Collection-和-Collections" class="headerlink" title="12.1 Collection 和 Collections"></a>12.1 Collection 和 Collections</h2><ul>
<li><strong>Collection：</strong> 一个顶层集合接口，其子接口包括 List 和 Set；</li>
<li><strong>Collections：</strong> 一个集合工具类，可以操作集合，比如说排序，二分查找，拷贝集合，寻找最大最小值等。  总而言之：带s的大都是工具类。</li>
</ul>
<h2 id="12-2-HashMap-和-HashSet-的区别"><a href="#12-2-HashMap-和-HashSet-的区别" class="headerlink" title="12.2 HashMap 和 HashSet 的区别"></a>12.2 HashMap 和 HashSet 的区别</h2><p>HashSet 底层就是基于 HashMap 实现的</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了Map接口</td>
<td align="center">实现Set接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put（）</code>向map中添加元素</td>
<td align="center">调用 <code>add（）</code>方法向Set中添加元素</td>
</tr>
<tr>
<td align="center">HashMap使用键（Key）计算Hashcode</td>
<td align="center">HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，</td>
</tr>
</tbody></table>
<h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals（）</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p>
<p><strong>hashCode（）与equals（）的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<h2 id="12-3-ConcurrentHashMap-和-Hashtable-的区别"><a href="#12-3-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="12.3 ConcurrentHashMap 和 Hashtable 的区别"></a>12.3 ConcurrentHashMap 和 Hashtable 的区别</h2><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h1 id="13-Java-集合中的快速失败机制"><a href="#13-Java-集合中的快速失败机制" class="headerlink" title="13. Java 集合中的快速失败机制"></a>13. Java 集合中的快速失败机制</h1><p><strong>面试官问题：快速失败机制（fast-fail）是 HashMap 线程不安全的一种表现吗？说一下你理解的快速失败机制吧。</strong></p>
<p><strong>答：</strong>不是。Hashtable 同样也会在迭代的时候抛出该异常，可能发生快速失败。快速失败是 Java 集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，<strong>有可能</strong>会产生fail-fast。</p>
<p><strong>解析：</strong>假设存在两个线程（线程1、线程2），线程1通过 Iterator 在遍历集合 A 中的元素，在某个时候线程2<strong>修改了集合A的结构</strong>（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就<strong>可能</strong>会抛出 **ConcurrentModificationException **异常，从而产生 fast-fail 快速失败。</p>
<p><strong>底层实现：</strong>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount  变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>异常ConcurrentModificationException，JDK中是这么介绍该异常的：当检测到一个并发的修改，就可能会抛出该异常，一些迭代器的实现会抛出该异常，以便可以快速失败。但是你不可以为了便捷而依赖该异常，而应该仅仅作为一个程序的侦测。</p>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag"><i class="fa fa-tag"></i>  Java容器</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="Java多线程">
      <i class="fa fa-chevron-left"></i> Java多线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/20/SQL%E7%BC%96%E7%A8%8B/" rel="next" title="SQL编程">
      SQL编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%89%E5%A4%A7%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%95%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">1.三大集合接口的引出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Collection"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Collection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Map"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">2. 容器中的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">2.2适配器模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-HashMap-%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">3. HashMap 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 存取原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%89%A9%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 扩容问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E3%80%81%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E3%80%81%E6%89%A9%E5%AE%B9%E5%A2%9E%E9%87%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 初始容量、加载因子、扩容增量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2%E6%89%A9%E5%AE%B9%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2扩容步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4%E8%A7%A3%E5%86%B3-Hash-%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">3.4解决 Hash 冲突的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-HashMap-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 HashMap 实现线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.6.</span> <span class="nav-text">3.5 HashMap 和 Hashtable 的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-ConccurentHashMap-%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">4. ConccurentHashMap 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-JDK1-8-%E4%B9%8B%E5%89%8D%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 JDK1.8 之前的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-JDK1-8-%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 JDK1.8 之后的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">4.3存取原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-LinkedHashMap-%E9%9B%86%E5%90%88"><span class="nav-number">5.</span> <span class="nav-text">5. LinkedHashMap 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">5.1底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-afterNodeAccess"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 afterNodeAccess()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-afterNodeInsertion"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 afterNodeInsertion()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-LRU-%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 LRU 缓存的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-WeakHashMap-%E9%9B%86%E5%90%88"><span class="nav-number">6.</span> <span class="nav-text">6. WeakHashMap 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">6.1底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-ConcurrentCache-%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 ConcurrentCache 缓存实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-TreeMap-%E9%9B%86%E5%90%88"><span class="nav-number">7.</span> <span class="nav-text">7. TreeMap 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.1.</span> <span class="nav-text">7.1底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 Comparable 和 Comparator 的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-ArrayList-%E9%9B%86%E5%90%88"><span class="nav-number">8.</span> <span class="nav-text">8. ArrayList 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.1.</span> <span class="nav-text">8.1底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.</span> <span class="nav-text">8.2扩容过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-ArrayList"><span class="nav-number">8.3.</span> <span class="nav-text">8.3线程安全的 ArrayList</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Vector-%E9%9B%86%E5%90%88"><span class="nav-number">9.</span> <span class="nav-text">9. Vector 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E5%90%8C%E6%AD%A5"><span class="nav-number">9.1.</span> <span class="nav-text">9.1同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">9.2扩容过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-Vector-%E5%92%8C-ArrayList-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">9.3.</span> <span class="nav-text">9.3 Vector 和 ArrayList 的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-CopyOnWriteArrayList-%E9%9B%86%E5%90%88"><span class="nav-number">10.</span> <span class="nav-text">10. CopyOnWriteArrayList 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">10.1.</span> <span class="nav-text">10.1读写分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.2.</span> <span class="nav-text">10.2适用场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-LinkedList-%E9%9B%86%E5%90%88"><span class="nav-number">11.</span> <span class="nav-text">11. LinkedList 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.1.</span> <span class="nav-text">11.1底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-LinkedList-%E5%92%8C-ArrayList-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">11.2.</span> <span class="nav-text">11.2 LinkedList 和 ArrayList 的比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%AF%B9%E6%AF%94"><span class="nav-number">12.</span> <span class="nav-text">12.几种常见对比</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-Collection-%E5%92%8C-Collections"><span class="nav-number">12.1.</span> <span class="nav-text">12.1 Collection 和 Collections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-HashMap-%E5%92%8C-HashSet-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.2.</span> <span class="nav-text">12.2 HashMap 和 HashSet 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="nav-number">12.2.1.</span> <span class="nav-text">HashSet如何检查重复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-ConcurrentHashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">12.3.</span> <span class="nav-text">12.3 ConcurrentHashMap 和 Hashtable 的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-Java-%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">13.</span> <span class="nav-text">13. Java 集合中的快速失败机制</span></a></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">912k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:49</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

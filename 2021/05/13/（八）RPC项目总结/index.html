<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="（八）RPC项目总结">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/RPC1.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/BIO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/NIO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/Selector.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/多线程模型.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/主从多线程模型.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source_posts/2021-05-13-（八）RPC项目总结/TCP粘包.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝1.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝2.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝3.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝4.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝5.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/零拷贝6.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source_posts/2021-05-13-（八）RPC项目总结/ChannelHandler.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/ChannelPipeline.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/EventloopGroup.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/Netty执行全过程.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Users/王进/AppData/Roaming/Typora/typora-user-images/image-20210614114733880.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/NIO原理分析图.png">
<meta property="article:published_time" content="2021-05-13T07:18:02.000Z">
<meta property="article:modified_time" content="2021-07-28T06:30:19.761Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="RPC项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub/MyBlogs/source/_posts/2021-05-13-（八）RPC项目总结/RPC1.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>（八）RPC项目总结 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">89</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          （八）RPC项目总结
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 15:18:02" itemprop="dateCreated datePublished" datetime="2021-05-13T15:18:02+08:00">2021-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-28 14:30:19" itemprop="dateModified" datetime="2021-07-28T14:30:19+08:00">2021-07-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a>
                </span>
            </span>

          
            <span id="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="（八）RPC项目总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>91k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:23</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-项目模块概述"><a href="#1-项目模块概述" class="headerlink" title="1.项目模块概述"></a>1.项目模块概述</h1><ul>
<li><strong>roc-api</strong>    ——    通用接口（供消费者调用）</li>
<li><strong>rpc-common</strong>    ——    实体对象、工具类等公用类</li>
<li><strong>rpc-core</strong>    ——    框架的核心实现</li>
<li><strong>test-client</strong>    ——    服务消费侧</li>
<li><strong>test-server</strong>    ——    服务提供侧</li>
</ul>
<h2 id="1-1roc-api模块"><a href="#1-1roc-api模块" class="headerlink" title="1.1roc-api模块"></a>1.1roc-api模块</h2><blockquote>
<p>模块间添加依赖就可以导入被依赖模块的package</p>
</blockquote>
<p>这个模块下的接口可以供给消费侧调用，而在服务侧实现。</p>
<p>两个通用接口：</p>
<ol>
<li><p><strong>HelloService</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(HelloObject object)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ByeService</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bye</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="1-2test-server模块"><a href="#1-2test-server模块" class="headerlink" title="1.2test-server模块"></a>1.2test-server模块</h2><p>作为服务的提供者，完成的功能就是实现服务和向Nacos中注册服务</p>
<p><strong>一、两个服务的实现类</strong></p>
<ol>
<li><p><strong>HelloServiceImpl</strong></p>
<p>对传入的对象处理后返回处理结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(HelloObject object)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;接收到消息：&#123;&#125;&quot;</span>, object.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;这是Impl1方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ByeServiceImpl</strong></p>
<p>返回传入的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByeServiceImpl</span> <span class="keyword">implements</span> <span class="title">ByeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bye, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>二、编写服务提供者</strong></p>
<p>选用 Netty 传输方式，并且指定序列化方式为 Google Protobuf 方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>, CommonSerializer.PROTOBUF_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选用 Socket 传输方式，并且指定序列化方式为 HESSIAN 方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcServer server = <span class="keyword">new</span> SocketServer(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9998</span>, CommonSerializer.HESSIAN_SERIALIZER);</span><br><span class="line">        server.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也体现了 Java 语言中的优越性，将 RpcServer 抽象成接口，不同的实现类来实现它，创建不同的实现类对象就会得到不同的服务端</p>
<h2 id="1-3test-client模块"><a href="#1-3test-client模块" class="headerlink" title="1.3test-client模块"></a>1.3test-client模块</h2><p>服务侧主要是通过<strong>动态代理方式</strong>远程调用服务，看起来调用本地方法一样简单</p>
<p><strong>编写服务消费者</strong></p>
<p>客户端选用 Netty 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端选用 Socket 的传输方式，通过反射的方式得到服务的对象，序列化方式采用 Kryo 方式，负载均衡策略指定为轮转方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = proxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4rpc-common模块"><a href="#1-4rpc-common模块" class="headerlink" title="1.4rpc-common模块"></a>1.4rpc-common模块</h2><p>存放一些服务端和客户端都能用到的实体对象、枚举、工具类等等</p>
<h3 id="1-4-1package-entity"><a href="#1-4-1package-entity" class="headerlink" title="1.4.1package-entity"></a>1.4.1package-entity</h3><p>包括请求实体类和响应实体类</p>
<p><strong>RpcRequest 实体类：</strong>封装了请求接口的定位信息以及接口需要的参数信息</p>
<p>同时可以作为心跳包，验证客户端是否假死。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用接口名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 待调用方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法的参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是心跳包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean heartBeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcResponse 实体类：</strong>封装了调用服务后处理的结果和状态信息，其中包含了两个静态构造方法，分别是处理成功和失败的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应对应的请求号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer statusCode;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态补充信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">success</span><span class="params">(T data, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(ResponseCode.SUCCESS.getCode());</span><br><span class="line">        response.setData(data);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RpcResponse&lt;T&gt; <span class="title">fail</span><span class="params">(ResponseCode code, String requestId)</span> </span>&#123;</span><br><span class="line">        RpcResponse&lt;T&gt; response = <span class="keyword">new</span> RpcResponse&lt;&gt;();</span><br><span class="line">        response.setRequestId(requestId);</span><br><span class="line">        response.setStatusCode(code.getCode());</span><br><span class="line">        response.setMessage(code.getMessage());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2package-enumeration"><a href="#1-4-2package-enumeration" class="headerlink" title="1.4.2package-enumeration"></a>1.4.2package-enumeration</h3><p>包括包的类型、响应状态码、异常以及序列化码等的枚举类型类</p>
<p><strong>PackageType：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PackageType</span> </span>&#123;</span><br><span class="line">    REQUEST_PACK(<span class="number">0</span>),</span><br><span class="line">    RESPONSE_PACK(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ResponseCode：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line">    SUCCESS(<span class="number">200</span>, <span class="string">&quot;调用方法成功&quot;</span>),</span><br><span class="line">    FAIL(<span class="number">500</span>, <span class="string">&quot;调用方法失败&quot;</span>),</span><br><span class="line">    METHOD_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定方法&quot;</span>),</span><br><span class="line">    CLASS_NOT_FOUND(<span class="number">500</span>, <span class="string">&quot;未找到指定类&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcError：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RpcError</span> </span>&#123;</span><br><span class="line">    UNKNOWN_ERROR(<span class="string">&quot;出现未知错误&quot;</span>),</span><br><span class="line">    SERVICE_SCAN_PACKAGE_NOT_FOUND(<span class="string">&quot;启动类ServiceScan注解缺失&quot;</span>),</span><br><span class="line">    CLIENT_CONNECT_SERVER_FAILURE(<span class="string">&quot;客户端连接服务端失败&quot;</span>),</span><br><span class="line">    SERVICE_INVOCATION_FAILURE(<span class="string">&quot;服务调用出现失败&quot;</span>),</span><br><span class="line">    SERVICE_NOT_FOUND(<span class="string">&quot;找不到对应的服务&quot;</span>),</span><br><span class="line">    SERVICE_NOT_IMPLEMENT_ANY_INTERFACE(<span class="string">&quot;注册的服务未实现接口&quot;</span>),</span><br><span class="line">    UNKNOWN_PROTOCOL(<span class="string">&quot;不识别的协议包&quot;</span>),</span><br><span class="line">    UNKNOWN_SERIALIZER(<span class="string">&quot;不识别的(反)序列化器&quot;</span>),</span><br><span class="line">    UNKNOWN_PACKAGE_TYPE(<span class="string">&quot;不识别的数据包类型&quot;</span>),</span><br><span class="line">    SERIALIZER_NOT_FOUND(<span class="string">&quot;找不到序列化器&quot;</span>),</span><br><span class="line">    RESPONSE_NOT_MATCH(<span class="string">&quot;响应与请求号不匹配&quot;</span>),</span><br><span class="line">    FAILED_TO_CONNECT_TO_SERVICE_REGISTRY(<span class="string">&quot;连接注册中心失败&quot;</span>),</span><br><span class="line">    REGISTER_SERVICE_FAILED(<span class="string">&quot;注册服务失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SerializerCode：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    KRYO(<span class="number">0</span>),</span><br><span class="line">    JSON(<span class="number">1</span>),</span><br><span class="line">    HESSIAN(<span class="number">2</span>),</span><br><span class="line">    PROTOBUF(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3package-exception"><a href="#1-4-3package-exception" class="headerlink" title="1.4.3package-exception"></a>1.4.3package-exception</h3><p><strong>RpcException：</strong>根据参数选择不同的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error, String detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage() + <span class="string">&quot;: &quot;</span> + detail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcException</span><span class="params">(RpcError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(error.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SerializeException：</strong>序列化异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerializeException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-4package-factory"><a href="#1-4-4package-factory" class="headerlink" title="==1.4.4package-factory=="></a>==1.4.4package-factory==</h3><p>==这里的HashMap中是提前存好了所有类吗？==</p>
<p>包括两个工厂：创建单例对象的工厂和创建线程池的工厂</p>
<p><strong>SingletonFactory：</strong>返回一个类对应的单例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class, Object&gt; objectMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Object instance = objectMap.get(clazz);</span><br><span class="line">        <span class="keyword">synchronized</span> (clazz) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instance = clazz.newInstance();</span><br><span class="line">                    objectMap.put(clazz, instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ThreadPoolFactory：</strong>创建 ThreadPool(线程池) 的工具类，根据是否给定了线程的前缀名创建线程池</p>
<ol>
<li><p><strong>createDefaultThreadPool方法：</strong>返回一个ExecutorService对象，该对象能够执行实现 <code>Runnable</code>/<code>Callable</code>接口的对象</p>
</li>
<li><p><strong>createDefaultThreadPool方法（两个参数）：</strong>设置了是否为守护线程，都是false，也就是不会创建守护线程。通过 <code>computeIfAbsent</code> 方法判断是否已经创建了能够产生线程名的前缀为 threadNamePrefix 的线程池</p>
<blockquote>
<p><strong>computeIfAbsent：</strong>存在时返回存在的值，不存在时返回新值</p>
</blockquote>
</li>
<li><p><strong>createThreadPool方法：</strong>实际创建线程池</p>
</li>
<li><p><strong>createThreadFactory方法：</strong>线程池中线程的创建对象，如果threadNamePrefix不为空则使用自建ThreadFactory，否则使用defaultThreadFactory</p>
</li>
<li><p><strong>shutDownAll方法：</strong>关闭所有线程池</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ThreadPoolFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ExecutorService&gt; threadPollsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDefaultThreadPool(threadNamePrefix, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createDefaultThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = threadPollsMap.computeIfAbsent(threadNamePrefix, k -&gt; createThreadPool(threadNamePrefix, daemon));</span><br><span class="line">        <span class="keyword">if</span> (pool.isShutdown() || pool.isTerminated()) &#123;</span><br><span class="line">            threadPollsMap.remove(threadNamePrefix);</span><br><span class="line">            pool = createThreadPool(threadNamePrefix, daemon);</span><br><span class="line">            threadPollsMap.put(threadNamePrefix, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService <span class="title">createThreadPool</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = createThreadFactory(threadNamePrefix, daemon);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE_SIZE, KEEP_ALIVE_TIME, TimeUnit.MINUTES, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory <span class="title">createThreadFactory</span><span class="params">(String threadNamePrefix, Boolean daemon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadNamePrefix != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).setDaemon(daemon).build();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Executors.defaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutDownAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭所有线程池...&quot;</span>);</span><br><span class="line">        threadPollsMap.entrySet().parallelStream().forEach(entry -&gt; &#123;</span><br><span class="line">            ExecutorService executorService = entry.getValue();</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            logger.info(<span class="string">&quot;关闭线程池 [&#123;&#125;] [&#123;&#125;]&quot;</span>, entry.getKey(), executorService.isTerminated());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executorService.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;关闭线程池失败！&quot;</span>);</span><br><span class="line">                executorService.shutdownNow();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5package-util"><a href="#1-4-5package-util" class="headerlink" title="1.4.5package-util"></a>1.4.5package-util</h3><p>存放通用的工具类</p>
<p><strong>NacosUtil 工具类：</strong>管理Nacos连接等工具类（Nacos运行在端口8848）</p>
<p><strong>静态代码块：</strong>类只要完成加载就能连接上 Nacos</p>
<p><strong>getNacosNamingService方法：</strong>通过 NamingFactory 连接 Nacos 并返回 NamingService 对象</p>
<p><strong>registerService方法：</strong>通过 namingService 向 Nacos 中注册服务，分别是服务名、地址和端口号，并将服务名保存在 Set 集合中</p>
<p><strong>getAllInstance方法：</strong>通过 namingService 获取所有服务的名称</p>
<p><strong>clearRegistry方法：</strong>从 Nacos 中清空服务，也就是防止服务器关闭时，服务仍然保存在 Nacos 中（其实 Nacos 本身是有保活机制的，一小段时间联系不上服务器就会自动注销），一般将这个方法称为钩子，当 JVM 关闭时执行该方法，这样 Nacos 就会清空服务列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NamingService namingService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; serviceNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InetSocketAddress address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ADDR = <span class="string">&quot;127.0.0.1:8848&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        namingService = getNacosNamingService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamingService <span class="title">getNacosNamingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> NamingFactory.createNamingService(SERVER_ADDR);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接到Nacos时有错误发生: &quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.FAILED_TO_CONNECT_TO_SERVICE_REGISTRY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, InetSocketAddress address)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        namingService.registerInstance(serviceName, address.getHostName(), address.getPort());</span><br><span class="line">        NacosUtil.address = address;</span><br><span class="line">        serviceNames.add(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Instance&gt; <span class="title">getAllInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> namingService.getAllInstances(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!serviceNames.isEmpty() &amp;&amp; address != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String host = address.getHostName();</span><br><span class="line">            <span class="keyword">int</span> port = address.getPort();</span><br><span class="line">            Iterator&lt;String&gt; iterator = serviceNames.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                String serviceName = iterator.next();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    namingService.deregisterInstance(serviceName, host, port);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;注销服务 &#123;&#125; 失败&quot;</span>, serviceName, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReflectUtil 类：</strong></p>
<p><strong>getStackTrace 方法：</strong>StackTraceElement存储了java代码堆栈调用轨迹，通过这个对象可以获取调用栈中的调用过程信息，包括类名、方法名、文件名、调用行数等，main 方法是第一个被加入栈中的，所以是最后一个</p>
<p><strong>getClasses 方法：</strong>传入一个包名，用于扫描该包及其子包下所有的类，并将其 Class 对象放入一个 Set 中返回<strong>（ReflectUtil中最重要的方法）</strong></p>
<p><strong>findAndAddClassesInPackageByFile 方法：</strong>以文件的方式扫描整个包下的文件 并添加到集合中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过调用栈来获取main方法所在的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StackTraceElement[] stack = <span class="keyword">new</span> Throwable().getStackTrace();</span><br><span class="line">        <span class="keyword">return</span> stack[stack.length - <span class="number">1</span>].getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClasses(String packageName) &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> recursive = <span class="keyword">true</span>;</span><br><span class="line">        String packageDirName = packageName.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        Enumeration&lt;URL&gt; dirs;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dirs = Thread.currentThread().getContextClassLoader().getResources(</span><br><span class="line">                    packageDirName);</span><br><span class="line">            <span class="comment">// 循环迭代下去</span></span><br><span class="line">            <span class="keyword">while</span> (dirs.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 获取下一个元素</span></span><br><span class="line">                URL url = dirs.nextElement();</span><br><span class="line">                <span class="comment">// 得到协议的名称</span></span><br><span class="line">                String protocol = url.getProtocol();</span><br><span class="line">                <span class="comment">// 如果是以文件的形式保存在服务器上</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;file&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 获取包的物理路径</span></span><br><span class="line">                    String filePath = URLDecoder.decode(url.getFile(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                    <span class="comment">// 以文件的方式扫描整个包下的文件 并添加到集合中</span></span><br><span class="line">                    findAndAddClassesInPackageByFile(packageName, filePath,</span><br><span class="line">                            recursive, classes);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;jar&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">                    <span class="comment">// 如果是jar包文件</span></span><br><span class="line">                    <span class="comment">// 定义一个JarFile</span></span><br><span class="line">                    JarFile jar;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取jar</span></span><br><span class="line">                        jar = ((JarURLConnection) url.openConnection())</span><br><span class="line">                                .getJarFile();</span><br><span class="line">                        <span class="comment">// 从此jar包 得到一个枚举类</span></span><br><span class="line">                        Enumeration&lt;JarEntry&gt; entries = jar.entries();</span><br><span class="line">                        <span class="comment">// 同样的进行循环迭代</span></span><br><span class="line">                        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">                            <span class="comment">// 获取jar里的一个实体 可以是目录 和一些jar包里的其他文件 如META-INF等文件</span></span><br><span class="line">                            JarEntry entry = entries.nextElement();</span><br><span class="line">                            String name = entry.getName();</span><br><span class="line">                            <span class="comment">// 如果是以/开头的</span></span><br><span class="line">                            <span class="keyword">if</span> (name.charAt(<span class="number">0</span>) == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 获取后面的字符串</span></span><br><span class="line">                                name = name.substring(<span class="number">1</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 如果前半部分和定义的包名相同</span></span><br><span class="line">                            <span class="keyword">if</span> (name.startsWith(packageDirName)) &#123;</span><br><span class="line">                                <span class="keyword">int</span> idx = name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                                <span class="comment">// 如果以&quot;/&quot;结尾 是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> (idx != -<span class="number">1</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 获取包名 把&quot;/&quot;替换成&quot;.&quot;</span></span><br><span class="line">                                    packageName = name.substring(<span class="number">0</span>, idx)</span><br><span class="line">                                            .replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果可以迭代下去 并且是一个包</span></span><br><span class="line">                                <span class="keyword">if</span> ((idx != -<span class="number">1</span>) || recursive) &#123;</span><br><span class="line">                                    <span class="comment">// 如果是一个.class文件 而且不是目录</span></span><br><span class="line">                                    <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.class&quot;</span>)</span><br><span class="line">                                            &amp;&amp; !entry.isDirectory()) &#123;</span><br><span class="line">                                        <span class="comment">// 去掉后面的&quot;.class&quot; 获取真正的类名</span></span><br><span class="line">                                        String className = name.substring(</span><br><span class="line">                                                packageName.length() + <span class="number">1</span>, name</span><br><span class="line">                                                        .length() - <span class="number">6</span>);</span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            <span class="comment">// 添加到classes</span></span><br><span class="line">                                            classes.add(Class</span><br><span class="line">                                                    .forName(packageName + <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                                                            + className));</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                            <span class="comment">// log</span></span><br><span class="line">                                            <span class="comment">// .error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                                            e.printStackTrace();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// log.error(&quot;在扫描用户定义视图时从jar包获取文件出错&quot;);</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findAndAddClassesInPackageByFile</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         String packagePath, <span class="keyword">final</span> <span class="keyword">boolean</span> recursive, Set&lt;Class&lt;?&gt;&gt; classes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取此包的目录 建立一个File</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(packagePath);</span><br><span class="line">        <span class="comment">// 如果不存在或者也不是目录就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!dir.exists() || !dir.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// log.warn(&quot;用户定义包名 &quot; + packageName + &quot; 下没有任何文件&quot;);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在 就获取包下的所有文件 包括目录</span></span><br><span class="line">        File[] dirfiles = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="comment">// 自定义过滤规则 如果可以循环(包含子目录) 或则是以.class结尾的文件(编译好的java类文件)</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (recursive &amp;&amp; file.isDirectory())</span><br><span class="line">                        || (file.getName().endsWith(<span class="string">&quot;.class&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 循环所有文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : dirfiles) &#123;</span><br><span class="line">            <span class="comment">// 如果是目录 则继续扫描</span></span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                findAndAddClassesInPackageByFile(packageName + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + file.getName(), file.getAbsolutePath(), recursive,</span><br><span class="line">                        classes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是java类文件 去掉后面的.class 只留下类名</span></span><br><span class="line">                String className = file.getName().substring(<span class="number">0</span>,</span><br><span class="line">                        file.getName().length() - <span class="number">6</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 添加到集合中去</span></span><br><span class="line">                    <span class="comment">//classes.add(Class.forName(packageName + &#x27;.&#x27; + className));</span></span><br><span class="line">                    <span class="comment">//经过回复同学的提醒，这里用forName有一些不好，会触发static方法，没有使用classLoader的load干净</span></span><br><span class="line">                    classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + <span class="string">&#x27;.&#x27;</span> + className));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// log.error(&quot;添加用户自定义视图类错误 找不到此类的.class文件&quot;);</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>RpcMessageChecker 工具类：</strong>检查响应与请求</p>
<p>主要是检验响应数据包是否正确：是否为空值，是否与请求包的 Id 一致等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcMessageChecker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTERFACE_NAME = <span class="string">&quot;interfaceName&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcMessageChecker.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RpcMessageChecker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(RpcRequest rpcRequest, RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rpcRequest.getRequestId().equals(rpcResponse.getRequestId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.RESPONSE_NOT_MATCH, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || !rpcResponse.getStatusCode().equals(ResponseCode.SUCCESS.getCode())) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用服务失败,serviceName:&#123;&#125;,RpcResponse:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, INTERFACE_NAME + <span class="string">&quot;:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5rpc-core模块（核心）"><a href="#1-5rpc-core模块（核心）" class="headerlink" title="1.5rpc-core模块（核心）"></a>1.5rpc-core模块（核心）</h2><p>框架的核心实现</p>
<h3 id="1-5-1package-transport"><a href="#1-5-1package-transport" class="headerlink" title="==1.5.1package-transport=="></a>==1.5.1package-transport==</h3><p>本项目中主要有两种传输方式：Netty 和 Socket </p>
<p><strong>我们将客户端和服务端抽象成两个接口，在接口中定义客户端和服务端要实现的功能</strong></p>
<p><strong>RpcClient接口：</strong>客户端类通用接口，只有一个方法发送请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcServer接口：</strong>服务器类通用接口</p>
<p>**<code>start 方法：</code>**启动服务端</p>
<p>**<code>publishService 方法：</code>**发布服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> DEFAULT_SERIALIZER = CommonSerializer.KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcClientProxy 类（工厂类，用于获取代理对象）：</strong>RPC客户端动态代理类，通过动态代理类来屏蔽网络传输的细节。当我们去调用一个远程方法的时候，实际上是通过代理对象调用的。</p>
<p>其实也好理解，就是代理模式能够在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，那么扩展的这些功能其实就是实际的网络传输细节，当被代理的对象方法被调用时，实际上是按照我们重写的 invoke 方法中的逻辑执行的。</p>
<p><code>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</code></p>
<p><code>Proxy</code> 类中使用频率最高的方法是： <code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<p>这个方法一共有 3 个参数： </p>
<ol>
<li>loader :类加载器，用于加载代理对象；</li>
<li>interfaces : 代理需要实现的接口，可指定多个； </li>
<li>h : 实现了 InvocationHandler 接口的对象；</li>
</ol>
<p><code>InvocationHandler</code> 接口的实现主要是来自定义处理逻辑。当我们的动态代 理对象调用一个方法时候，这个方法的调用就会被转发到实现 InvocationHandler 接口类的 invoke 方法来调用。当你使用代理对象调用方法的时候实际会调用到这个 invoke 方法。</p>
<p>这个方法一共有 3 个参数： </p>
<ol>
<li>proxy :动态生成的代理类 </li>
<li>method : 与代理类对象调用的方法相对应 </li>
<li>args : 当前 method 方法的参数</li>
</ol>
<p><strong>getProxy 方法：</strong>RpcClientProxy就是一个工厂类，该方法就是用于获取代理对象</p>
<p><strong>invoke 方法：</strong>当调用一个代理对象的方法时，按照该方法中的逻辑执行，该方法的逻辑主要是：</p>
<p>生成 RpcRequest 对象，根据不同的传输方式选择不同的逻辑来接收响应对象 RpcResponse ，调用 RpcMessageChecker 工具类来检验数据的正确性，通过检验后，将返回数据提取，返回给用户</p>
<p> ==CompletableFuture怎么用？==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(UUID.randomUUID().toString(), method.getDeclaringClass().getName(),method.getName(), args, method.getParameterTypes(), <span class="keyword">false</span>);</span><br><span class="line">        RpcResponse rpcResponse = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> NettyClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CompletableFuture&lt;RpcResponse&gt; completableFuture = (CompletableFuture&lt;RpcResponse&gt;) client.sendRequest(rpcRequest);</span><br><span class="line">                rpcResponse = completableFuture.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;方法调用请求发送失败&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> SocketClient) &#123;</span><br><span class="line">            rpcResponse = (RpcResponse) client.sendRequest(rpcRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理对象在客户端的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(CommonSerializer.KRYO_SERIALIZER);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        ByeService byeService = rpcClientProxy.getProxy(ByeService.class);</span><br><span class="line">        System.out.println(byeService.bye(<span class="string">&quot;Netty&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AbstractRpcServer 抽象类：</strong>因为项目中使用了注解功能，无论使用 Netty 传输还是 Socket 传输方式，都要用到 <code>scanServices</code> 这个公共方法，所以通过抽象类 AbstractRpcServer 实现了 RpcServer 接口，而 NettyServer 和 SocketServer 继承自  AbstractRpcServer，将 scanServices 方法放在抽象类中，而 start 方法则由具体实现类来实现。</p>
<blockquote>
<p><strong>Note：</strong></p>
<ul>
<li>抽象类实现某个接口，可以不实现所有接口的方法，可以由它的子类实现；</li>
<li>而普通类即非抽象类则必须实现接口里的全部方法。 </li>
</ul>
</blockquote>
<p><strong>scanServices 方法：</strong>扫描启动类所在包下所有的有Service注解的类，通过反射创建对象，并向Nacos中注册服务</p>
<p>通过调用 ReflectUtil 工具类中的 getStackTrace 的方法来获取栈底的 main 方法的类，并判断 main 方法所在类的注解值，当确定是加了 ServiceScan 注解后，获取 ServiceScan 注解的值，并获取启动类所在的包，然后就是扫描这个包下所有类的注解，只要是 Service 注解的类通过反射创建该对象，并且调 publishService 注册即可</p>
<p><strong>publishService 方法：</strong>向Nacos中注册服务，包括服务名还有服务所在的地址信息</p>
<p>向本地服务表中添加服务名和服务实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRpcServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String host;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ServiceRegistry serviceRegistry;</span><br><span class="line">    <span class="keyword">protected</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取启动类，也就是main方法所在的类</span></span><br><span class="line">        String mainClassName = ReflectUtil.getStackTrace();</span><br><span class="line">        Class&lt;?&gt; startClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Class.forName(xxx.xx.xx) 返回具体类</span></span><br><span class="line">            startClass = Class.forName(mainClassName);</span><br><span class="line">            <span class="keyword">if</span>(!startClass.isAnnotationPresent(ServiceScan.class)) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;启动类缺少 @ServiceScan 注解&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_SCAN_PACKAGE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;出现未知错误&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解的值</span></span><br><span class="line">        String basePackage = startClass.getAnnotation(ServiceScan.class).value();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(basePackage)) &#123;</span><br><span class="line">            basePackage = mainClassName.substring(<span class="number">0</span>, mainClassName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到所有的 Class ，逐个判断是否有 Service 注解</span></span><br><span class="line">        <span class="comment">//如果有的话，通过反射创建该对象，并且调用 publishService 注册即可</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = ReflectUtil.getClasses(basePackage);</span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : classSet) &#123;</span><br><span class="line">            <span class="keyword">if</span>(clazz.isAnnotationPresent(Service.class)) &#123;</span><br><span class="line">                String serviceName = clazz.getAnnotation(Service.class).name();</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    obj = clazz.newInstance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;创建 &quot;</span> + clazz + <span class="string">&quot; 时有错误发生&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(serviceName)) &#123;</span><br><span class="line">                    Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; oneInterface: interfaces)&#123;</span><br><span class="line">                        publishService(obj, oneInterface.getCanonicalName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    publishService(obj, serviceName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">publishService</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        serviceProvider.addServiceProvider(service, serviceName);</span><br><span class="line">        serviceRegistry.register(serviceName, <span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-1package-netty-client"><a href="#1-5-1-1package-netty-client" class="headerlink" title="1.5.1.1package-netty-client"></a>1.5.1.1package-netty-client</h4><p>Netty 客户端的实现</p>
<p><strong>NettyClient 类：</strong>主要是重写sendRequest的代码逻辑，通过 CompletableFuture 异步获取 Netty 请求的响应结果，并将 CompletableFuture 实例返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;RpcResponse&gt; <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">            Channel channel = ChannelProvider.get(inetSocketAddress, serializer);</span><br><span class="line">            <span class="keyword">if</span> (!channel.isActive()) &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unprocessedRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener((ChannelFutureListener) future1 -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future1.isSuccess()) &#123;</span><br><span class="line">                    logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    future1.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future1.cause());</span><br><span class="line">                    logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            unprocessedRequests.remove(rpcRequest.getRequestId());</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ChannelProvider 类：</strong>将客户端创建 channel 的逻辑分离出来，按照自定义的逻辑创建 Channel</p>
<p>这里有一个属性是 Map ，这里以服务提供者的地址和序列化器编码作为键， Channel 作为键值，只要已经有这样一个 Channel 并且是活跃状态就直接返回，否则按照自定义的方案来创建一个 Channel ，并放到 Map 中。如果 Map 中 Key 对应的 Channel 失效了，就将 Key 移除，并重新创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelProvider.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bootstrap bootstrap = initializeBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">(InetSocketAddress inetSocketAddress, CommonSerializer serializer)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String key = inetSocketAddress.toString() + serializer.getCode();</span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            Channel channel = channels.get(key);</span><br><span class="line">            <span class="keyword">if</span>(channels != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*自定义序列化编解码器*/</span></span><br><span class="line">                <span class="comment">// RpcResponse -&gt; ByteBuf</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                        .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                        .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = connect(bootstrap, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;连接客户端时有错误发生&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Channel <span class="title">connect</span><span class="params">(Bootstrap bootstrap, InetSocketAddress inetSocketAddress)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;客户端连接成功!&quot;</span>);</span><br><span class="line">                completableFuture.complete(future.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> completableFuture.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Bootstrap <span class="title">initializeBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//连接的超时时间，超过这个时间还是建立不上的话则代表连接失败</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">//是否开启 TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> bootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler 类：</strong></p>
<p>与NettyServerHandler类似，不做介绍，只不过由于客户端没有设置读超时时间，所以不用对服务端的心跳包做识别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UnprocessedRequests unprocessedRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unprocessedRequests = SingletonFactory.getInstance(UnprocessedRequests.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            unprocessedRequests.complete(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">                Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">                RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">                rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UnprocessedRequests 类：</strong>将每个请求对应的CompletableFuture实例都保存在一个Map中，key为请求ID，value为创建的CompletableFuture实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnprocessedRequests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, CompletableFuture&lt;RpcResponse&gt;&gt; unprocessedResponseFutures = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&gt; future)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.put(requestId, future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String requestId)</span> </span>&#123;</span><br><span class="line">        unprocessedResponseFutures.remove(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse rpcResponse)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; future = unprocessedResponseFutures.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) &#123;</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-2package-netty-server"><a href="#1-5-1-2package-netty-server" class="headerlink" title="1.5.1.2package-netty-server"></a>1.5.1.2package-netty-server</h4><p><strong>NettyServer 类：</strong></p>
<p>主要的步骤为：</p>
<ol>
<li>创建 ServerBootstrap 实例</li>
<li>设置并绑定 Reactor 线程池</li>
<li>设置并绑定服务端 Channel</li>
<li>创建并初始化 ChannelPipeline</li>
<li>添加并设置 ChannelHandler</li>
<li>绑定并启动监听端口</li>
</ol>
<p>下面通过注释的方式来说明整个流程：</p>
<blockquote>
<p>其中ServerBootStrap提供的方法有：</p>
<p>group：设置 ServerBootstrap 要用的 EventLoopGroup</p>
<p>channel：设置将要被实例化的 ServerChannel 类</p>
<p>attr：可以给服务端的 channel，也就是NioServerSocketChannel指定一些自定义属性，然后我们可以通过channel.attr()取出这个属性，比如，上面的代码我们指定我们服务端channel的一个serverName属性，属性值为nettyServer，其实说白了就是给NioServerSocketChannel维护一个map而已</p>
<p>childAttr：可以给每一条连接指定自定义属性，然后后续我们可以通过 channel.attr() 取出该属性</p>
<p>childOption：给每条连接设置一些TCP底层相关的属性</p>
<p>option：给服务端channel设置一些属性</p>
<p>handler：用于指定在服务端启动过程中的一些逻辑</p>
<p>childHandler：指定处理新连接数据的读写处理逻辑</p>
<p>bind：绑定 ServerChannel</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在服务器启动时，注册一个钩子，用于自动注销服务</span></span><br><span class="line">        ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">        <span class="comment">// 创建Netty服务端的两个线程组： boos 和 worker</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ServerBootStrap实例</span></span><br><span class="line">            <span class="comment">// ServerBootstrap 用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 给ServerBootstrap绑定两个线程组，这样Netty的线程模型就确定了</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 设置服务端Channel的IO模型,指定使用的NIO传输的Channel</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 打印服务端启动过程的日志信息</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// BACKLOG用于构造服务端套接字ServerSocket对象，标识当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度为256</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    <span class="comment">// 启用心跳保活机制。在双方TCP套接字建立连接后（即都进入ESTABLISHED状态）并且在两个小时左右上层没有任何数据传输的情况下，这套机制才会被激活。</span></span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// TCP_NODELAY就是用于启用或关于Nagle算法</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">// 处理新连接数据的读写处理逻辑</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 为Channel绑定ChannelPipeline</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 将用于数据处理的Handler添加到ChannelPipeline中</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                    .addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定服务器端的端口，同步等待成功</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(host, port).sync();</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 优雅地关闭两个线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyServerHandler 类：</strong></p>
<p>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，当读取完成后会调用方法 <code>fireChannelReadComplete()</code> 通知 pipline 读取完成，然后触发 <code>channelRead</code> 方法，在 <code>channelRead</code> 方法中对读取到的数据进行消息类型检验，判断当前的 <code>message</code> 是否需要传递到下一个 <code>Handler</code> ，（如果需要传递到下一个Handler，执行的语句是：ctx.fireChannelRead(msg); ），不需要就调用 <code>channelRead0</code> 方法。</p>
<p><strong>channelRead0 方法：</strong>这里我们通过重写 <code>channelRead0</code> 方法来自定义我们对消息的处理逻辑：当消息是心跳包时，不用处理，当消息是其它请求包时，要调用<code>requestHandler</code> 中的 <code>handle</code> 方法对消息进行处理，其实就是通过方法名反射调用方法，然后获取结果。获取结果后通过语句 <code>ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()</code> 来判断channel是否正常的可写状态，调用 <code>writeAndFlush</code> 方法来将结果和消息ID写入 <code>ChannelHandlerContext</code> 中。</p>
<p><strong>userEventTriggered 方法：</strong>超过读超时时间被调用，实现心跳机制，来判断客户端是否假死状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = SingletonFactory.getInstance(RequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(msg.getHeartBeat()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;接收到客户端心跳包...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            Object result = requestHandler.handle(msg);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) &#123;</span><br><span class="line">                ctx.writeAndFlush(RpcResponse.success(result, msg.getRequestId()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;通道不可写&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-3package-socket-client"><a href="#1-5-1-3package-socket-client" class="headerlink" title="1.5.1.3package-socket-client"></a>1.5.1.3package-socket-client</h4><p><strong>SocketClient 类：</strong>Socket 的客户端类，完成的任务也是发送一条请求数据，包括了建立 Socket 连接，将请求包按照 ObjectWriter 定义的方法进行编码，获取收到的数据，并对数据进行解码，返回给用户。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketClient.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_SERIALIZER, loadBalancer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serializer, <span class="keyword">new</span> RandomLoadBalancer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(Integer serializer, LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = <span class="keyword">new</span> NacosServiceDiscovery(loadBalancer);</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;未设置序列化器&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERIALIZER_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">            socket.connect(inetSocketAddress);</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            ObjectWriter.writeObject(outputStream, rpcRequest, serializer);</span><br><span class="line">            Object obj = ObjectReader.readObject(inputStream);</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) obj;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            RpcMessageChecker.check(rpcRequest, rpcResponse);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-4package-socket-server"><a href="#1-5-1-4package-socket-server" class="headerlink" title="1.5.1.4package-socket-server"></a>1.5.1.4package-socket-server</h4><p><strong>SocketServer 类：</strong>通过注解自动将服务注册到 Nacos 上，然后将钩子注册到 JVM 中，监听客户端的请求信息，若是发现请求时，将该请求分配线程池中的一个线程并按照 SocketRequestHandlerThread Socket传输方式自定义的消息处理方式，对数据进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">extends</span> <span class="title">AbstractRpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(host, port, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(String host, <span class="keyword">int</span> port, Integer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        threadPool = ThreadPoolFactory.createDefaultThreadPool(<span class="string">&quot;socket-rpc-server&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = <span class="keyword">new</span> NacosServiceRegistry();</span><br><span class="line">        <span class="keyword">this</span>.serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">        <span class="keyword">this</span>.serializer = CommonSerializer.getByCode(serializer);</span><br><span class="line">        scanServices();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket()) &#123;</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            ShutdownHook.getShutdownHook().addClearAllHook();</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> SocketRequestHandlerThread(socket, requestHandler, serializer));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketRequestHandlerThread 类：</strong>自定义的消息处理逻辑，包括将消息处理完后，返回给 Socket 客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketRequestHandlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketRequestHandlerThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketRequestHandlerThread</span><span class="params">(Socket socket, RequestHandler requestHandler, CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream inputStream = socket.getInputStream();</span><br><span class="line">             OutputStream outputStream = socket.getOutputStream()) &#123;</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) ObjectReader.readObject(inputStream);</span><br><span class="line">            Object result = requestHandler.handle(rpcRequest);</span><br><span class="line">            RpcResponse&lt;Object&gt; response = RpcResponse.success(result, rpcRequest.getRequestId());</span><br><span class="line">            ObjectWriter.writeObject(outputStream, response, serializer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用或发送时有错误发生：&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-5package-socket-util"><a href="#1-5-1-5package-socket-util" class="headerlink" title="1.5.1.5package-socket-util"></a>1.5.1.5package-socket-util</h4><p>我们希望让 Socket 与 Netty 使用的传输协议保持一致，也就是按照我们自定义的传输协议来对数据包进行封装和拆包，这意味着Socket也要用到序列化器。</p>
<p><strong>ObjectReader 类：</strong>类似于 Netty 中自定义的解码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ObjectReader.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">readObject</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] numberBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> magic = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">if</span> (magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> packageCode = bytesToInt(numberBytes);</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> serializerCode = bytesToInt(numberBytes);</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span> (serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        in.read(numberBytes);</span><br><span class="line">        <span class="keyword">int</span> length = bytesToInt(numberBytes);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.read(bytes);</span><br><span class="line">        <span class="keyword">return</span> serializer.deserialize(bytes, packageClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytesToInt</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        value = ((src[<span class="number">0</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">24</span>)</span><br><span class="line">                |((src[<span class="number">1</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">16</span>)</span><br><span class="line">                |((src[<span class="number">2</span>] &amp; <span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">                |(src[<span class="number">3</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ObjectWriter 类：</strong>类似于 Netty 中自定义的编码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(OutputStream outputStream, Object object, CommonSerializer serializer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.write(intToBytes(MAGIC_NUMBER));</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.REQUEST_PACK.getCode()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream.write(intToBytes(PackageType.RESPONSE_PACK.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.write(intToBytes(serializer.getCode()));</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(object);</span><br><span class="line">        outputStream.write(intToBytes(bytes.length));</span><br><span class="line">        outputStream.write(bytes);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToBytes(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] src = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        src[<span class="number">0</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">1</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">16</span>)&amp; <span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">2</span>] = (<span class="keyword">byte</span>) ((value&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">        src[<span class="number">3</span>] = (<span class="keyword">byte</span>) (value &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2package-annotation"><a href="#1-5-2package-annotation" class="headerlink" title="1.5.2package-annotation"></a>1.5.2package-annotation</h3><p>定义的两个注解类：ServiceScan 和 Service</p>
<p><strong>ServiceScan 注解类：</strong>@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Service 注解类：</strong>@Service 放在一个类上，标识这个类提供一个服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设注解的值都为空的字符串即可</p>
<h3 id="1-5-3package-codec"><a href="#1-5-3package-codec" class="headerlink" title="1.5.3package-codec"></a>1.5.3package-codec</h3><p>存放的是编码器和解码器类，对请求包和发送包进行编码和解码工作（与序列化区分开，这里是我们自定义的传输协议的数据包，数据部分才是序列化的内容）</p>
<h4 id="传输协议（MRF）"><a href="#传输协议（MRF）" class="headerlink" title="传输协议（MRF）"></a>传输协议（MRF）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Magic Number</td>
<td>魔数，表识一个 MRF 协议包，0xCAFEBABE</td>
</tr>
<tr>
<td>Package Type</td>
<td>包类型，标明这是一个调用请求还是调用响应</td>
</tr>
<tr>
<td>Serializer Type</td>
<td>序列化器类型，标明这个包的数据的序列化方式</td>
</tr>
<tr>
<td>Data Length</td>
<td>数据字节的长度</td>
</tr>
<tr>
<td>Data Bytes</td>
<td>传输的对象，通常是一个<code>RpcRequest</code>或<code>RpcClient</code>对象，取决于<code>Package Type</code>字段，对象的序列化方式取决于<code>Serializer Type</code>字段。</td>
</tr>
</tbody></table>
<p><strong>CommonEncoder 类：</strong>将数据包转换成自定义协议的数据包，继承了MessageToByteEncoder，顾名思义就是将数据包转化成字节数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CommonDecoder 类：</strong>将字节数组解码成对象</p>
<p>通过魔数来判断是不是符合我们自定义协议的数据包，下面获取包的类型，获取数据部分使用的序列化器，通过相应的序列化器将数据部分按照对应的类型反序列化为相应的实体类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4package-exception"><a href="#1-5-4package-exception" class="headerlink" title="1.5.4package-exception"></a>1.5.4package-exception</h3><p>自定义的一些异常信息（略）</p>
<h3 id="1-5-5package-handler"><a href="#1-5-5package-handler" class="headerlink" title="1.5.5package-handler"></a>1.5.5package-handler</h3><p><strong>RequestHandler 类：</strong>运行过程中，服务端调用 invoke 方法，通过方法名反射调用相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        serviceProvider = <span class="keyword">new</span> ServiceProviderImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        Object service = serviceProvider.getServiceProvider(rpcRequest.getInterfaceName());</span><br><span class="line">        <span class="keyword">return</span> invokeTargetMethod(rpcRequest, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">invokeTargetMethod</span><span class="params">(RpcRequest rpcRequest, Object service)</span> </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = service.getClass().getMethod(rpcRequest.getMethodName(), rpcRequest.getParamTypes());</span><br><span class="line">            result = method.invoke(service, rpcRequest.getParameters());</span><br><span class="line">            logger.info(<span class="string">&quot;服务:&#123;&#125; 成功调用方法:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcRequest.getMethodName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcResponse.fail(ResponseCode.METHOD_NOT_FOUND, rpcRequest.getRequestId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-6package-hook"><a href="#1-5-6package-hook" class="headerlink" title="1.5.6package-hook"></a>1.5.6package-hook</h3><p>由于我们的服务会一直存在于Nacos中（实际Nacos有超时机制，会过期删除），如果我们将服务端关闭后，但是服务名还存在于Nacos中，当客户端调用时就会出错，所以我们要在服务端关闭时，自动注销服务。</p>
<p>但是由于我们并不知道服务端何时关闭，这时我们就要使用钩子（钩子就是一个方法）。</p>
<p><strong>ShutdownHook 构子类：</strong></p>
<p><strong>addClearAllHook 方法：</strong>方法中有一句语句：**<code>Runtime.getRuntime().addShutdownHook();</code>**这个方法的意思就是在jvm中增加一个关闭的钩子，当jvm关闭的时候，会执行系统中已经设置的所有通过方法addShutdownHook添加的钩子，当系统执行完这些钩子后，jvm才会关闭。</p>
<p>在这里的意思就是在JVM关闭前，开启一个新线程调用钩子方法，来实现服务的自动注销。</p>
<blockquote>
<p>项目中我们是在服务器启动的时候就将钩子类的对象并调用 <code>addClearAllHook</code> 方法，将钩子注册到了 JVM中，在关闭时执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ShutdownHook.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ShutdownHook shutdownHook = <span class="keyword">new</span> ShutdownHook();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShutdownHook <span class="title">getShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClearAllHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;关闭后将自动注销所有服务&quot;</span>);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            NacosUtil.clearRegistry();</span><br><span class="line">            ThreadPoolFactory.shutDownAll();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-7package-loadbalancer"><a href="#1-5-7package-loadbalancer" class="headerlink" title="1.5.7package-loadbalancer"></a>1.5.7package-loadbalancer</h3><p>实现负载均衡的接口和类</p>
<p>因为我们在Nacos获取服务提供者时可能不止一个，如果多个客户端总是访问一个服务端的话会造成服务端的压力过大，通过简单的算法可以实现均匀选择服务器，也就实现了服务器端的负载均衡。</p>
<p><strong>LoadBalancer 接口：</strong>只有一个方法，从获取到的服务器列表中选择一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现两个比较经典的算法：随机和转轮</p>
<p><strong>随机算法：</strong>顾名思义，就是随机选一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instances.get(<span class="keyword">new</span> Random().nextInt(instances.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>转轮算法：</strong>按照顺序依次选择第一个、第二个、第三个……这里就需要一个变量来表示当前选到了第几个：</p>
<p>index 就表示当前选到了第几个服务器，并且每次选择后都会自增一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instance <span class="title">select</span><span class="params">(List&lt;Instance&gt; instances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= instances.size()) &#123;</span><br><span class="line">            index %= instances.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instances.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-8package-provider"><a href="#1-5-8package-provider" class="headerlink" title="1.5.8package-provider"></a>1.5.8package-provider</h3><p><strong>ServiceProvider 接口：</strong>保存和提供服务实例对象</p>
<p><strong>addServiceProvider 方法：</strong>将一个服务注册进注册表</p>
<p><strong>getServiceProvider 方法：</strong>根据服务名称获取服务实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceProviderImpl 实现类：</strong>每个服务提供者维护一个Map和一个Set</p>
<ul>
<li><strong>Map</strong> 来存放服务名称和服务实体的键值对</li>
<li><strong>Set</strong> 用来存放服务名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ServiceProviderImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addServiceProvider</span><span class="params">(T service, String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (registeredService.contains(serviceName)) <span class="keyword">return</span>;</span><br><span class="line">        registeredService.add(serviceName);</span><br><span class="line">        serviceMap.put(serviceName, service);</span><br><span class="line">        logger.info(<span class="string">&quot;向接口: &#123;&#125; 注册服务: &#123;&#125;&quot;</span>, service.getClass().getInterfaces(), serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getServiceProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        Object service = serviceMap.get(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-5-9package-registry"><a href="#1-5-9package-registry" class="headerlink" title="1.5.9package-registry"></a>1.5.9package-registry</h3><p>主要是向 Nacos 注册服务，和从 Nacos 中获取服务的接口和实现类</p>
<p> <strong>ServiceRegistry 接口：</strong>服务注册中心通用接口，将服务名称和提供服务的地址注册进服务中心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ServiceDiscovery 接口：</strong>根据服务名查找服务的提供者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceRegistry 实现类：</strong>实现了 ServiceRegistry 接口，服务注册功能的具体实现</p>
<p>基本就是调用NacosUtil工具类中的方法实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceRegistry.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String serviceName, InetSocketAddress inetSocketAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            NacosUtil.registerService(serviceName, inetSocketAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;注册服务时有错误发生:&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.REGISTER_SERVICE_FAILED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NacosServiceDiscovery 实现类：</strong>实现了 ServiceDiscovery 接口，主要用于发现服务</p>
<p>这里调用 NacosUtil 工具类中的 getAllInstance 方法得到所有的服务实例，然后根据所选的负载均衡算法，找到一个实例并返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosServiceDiscovery</span> <span class="keyword">implements</span> <span class="title">ServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NacosServiceDiscovery.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NacosServiceDiscovery</span><span class="params">(LoadBalancer loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(loadBalancer == <span class="keyword">null</span>) <span class="keyword">this</span>.loadBalancer = <span class="keyword">new</span> RandomLoadBalancer();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">lookupService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Instance&gt; instances = NacosUtil.getAllInstance(serviceName);</span><br><span class="line">            <span class="keyword">if</span>(instances.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;找不到对应的服务: &quot;</span> + serviceName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">            Instance instance = loadBalancer.select(instances);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InetSocketAddress(instance.getIp(), instance.getPort());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;获取服务时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-10package-serializer"><a href="#1-5-10package-serializer" class="headerlink" title="1.5.10package-serializer"></a>1.5.10package-serializer</h3><p>序列化器的相关接口和类，本项目共引用了四个序列化器：Kryo、Json、Hessian、Protobuf</p>
<p><strong>CommonSerializer 接口：</strong>通用的序列化反序列化接口</p>
<p>主要是根据不同的序列化器所对应的编码来选择合适的序列化器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer KRYO_SERIALIZER = <span class="number">0</span>;</span><br><span class="line">    Integer JSON_SERIALIZER = <span class="number">1</span>;</span><br><span class="line">    Integer HESSIAN_SERIALIZER = <span class="number">2</span>;</span><br><span class="line">    Integer PROTOBUF_SERIALIZER = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    Integer DEFAULT_SERIALIZER = KRYO_SERIALIZER;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KryoSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HessianSerializer();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProtobufSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有就是序列化器的实现类，这里不做介绍，基本就是实现了序列化与反序列化的两个方法。主要是对常见序列化器作比较：</p>
<ul>
<li><p><strong>JDK自带的序列化方式：</strong></p>
<p><strong>优点：</strong>使用简单，只需实现 java.io.Serializable 接口即可。</p>
<blockquote>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候serialVersionUID也会被写入二级制序列，当反序列化时会检查serialVersionUID是否和当前类的serialVersionUID一 致。如果serialVersionUID不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID ，如果不手动指定，那么编译器会动态生成默认的序列化号</p>
</blockquote>
<p><strong>缺点：</strong></p>
<ol>
<li>不支持跨语言调用 : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li>性能差 ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
</li>
<li><p><strong>JSON序列化方式：</strong></p>
<p><strong>优点：</strong>JSON 是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似 xml，Json 比 xml更小、更快更容易解析。</p>
<p><strong>缺点：</strong>JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。（所以通常借助类的参数信息来反序列化）</p>
</li>
</ul>
<p>下面是基于字节的序列化方式</p>
<ul>
<li><p><strong>Kryo ：</strong>是一个快速高效的 Java 序列化框架，旨在提供快速、高效和易用的 API。无论文件、数据库或网络数据 Kryo 都可以随时完成序列化。 Kryo 还可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象-&gt;字节-&gt;对象的拷贝。kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。</p>
<p>（Kryo解决了Json反序列化要借助类参数信息的问题，因为它在序列化的时候会记录对象的类型信息）</p>
</li>
<li><p><strong>Hessian ：</strong>是一个基于二进制的协议，Hessian 支持很多种语言，例如 Java、python、<a href>c++</a>,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效。速度较慢，序列化后的体积较大。</p>
</li>
<li><p><strong>protobuf（<a href>Proto</a>col Buffers）：</strong>是由 Google 发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。性能主要消耗在文件的预编译上。序列化反序列化性能较高，平台无关。</p>
</li>
</ul>
<h1 id="2-项目相关问题"><a href="#2-项目相关问题" class="headerlink" title="2.项目相关问题"></a>2.项目相关问题</h1><h2 id="2-1RPC相关"><a href="#2-1RPC相关" class="headerlink" title="2.1RPC相关"></a>2.1RPC相关</h2><h3 id="2-1-1什么是RPC"><a href="#2-1-1什么是RPC" class="headerlink" title="2.1.1什么是RPC"></a>2.1.1什么是RPC</h3><p><strong>RPC（Remote Procedure Call）</strong>—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 <code>HTTP请求</code> 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p><strong>最终解决的问题：</strong><code>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单</code>。</p>
<h3 id="2-1-2RPC原理是什么"><a href="#2-1-2RPC原理是什么" class="headerlink" title="2.1.2RPC原理是什么"></a>2.1.2RPC原理是什么</h3><p>首先是服务提供者启动，并向注册中心注册服务，客户端通过 Nacos 提供的 API 发现服务，获取服务的地址，然后发送调用服务的请求，将请求数据序列化，通过自定义的通信协议封装成数据包，通过 Netty 框架发送消息，到达服务器之后拆包，取出数据部分，反序列化，调用本地服务获得处理结果，然后再将结果进行序列化，装包，再到客户端进行拆包，取数据，反序列化，获得请求的结果。而 RPC 框架的目标就是让客户端，也就是服务的调用者只能看到请求数据并接受结果的过程，将其它的过程封装起来。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\RPC1.png" style="zoom:100%;">

<p><strong>一次完整的RPC调用流程（同步调用，异步另说）如下：</strong></p>
<p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>
<p><strong>RPC框架的目标就是要2~8这些步骤都封装起来，这些细节对用户来说是透明的，不可见的。</strong></p>
<p><strong>RPC实现的基本流程：</strong></p>
<p>客户端和服务端都可以访问到通用的接口，但是只有服务端有这个接口的实现类，客户端调用这个接口的方式，是通过网络传输，告诉服务端我要调用这个接口，服务端收到之后找到这个接口的实现类，并且执行，将执行的结果返回给客户端，作为客户端调用接口方法的返回值。</p>
<h3 id="2-1-3常见的RPC框架"><a href="#2-1-3常见的RPC框架" class="headerlink" title="2.1.3常见的RPC框架"></a>2.1.3常见的RPC框架</h3><p>我们这里说的 RPC 框架指的是可以让客户端直接调用服务端方法，就像调用本地方法一样简单的框架，比如我下面介绍的 Dubbo、 Motan、gRPC这些。  如果需要和 HTTP 协议打交道，解析和封装 HTTP 请求和响应。这类框架并不能算是“RPC 框架”，比如Feign。</p>
<ul>
<li><strong>Dubbo:</strong> Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。它提供了三大核心能力：<ol>
<li>面向接口的远程方法调用 </li>
<li>智能容错和负载均衡 </li>
<li>服务自动注册和发现。</li>
</ol>
</li>
<li><strong>Motan：</strong>motan 更像是一个精简版的 dubbo，可能是借鉴了 Dubbo 的思想，motan 的设计更加精简，功能更加纯粹。</li>
<li><strong>gRPC：</strong>gRPC 是 Google 开源的一个高性能、通用的开源 RPC 框架。其由主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf  序列化协议开发，并且支持众多开发语言。</li>
<li><strong>Hessian：</strong> Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 相比 WebService，Hessian 更简单、快捷。采用的是二进制 RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 </li>
</ul>
<h3 id="2-1-4为什么要用RPC，不是HTTP"><a href="#2-1-4为什么要用RPC，不是HTTP" class="headerlink" title="2.1.4为什么要用RPC，不是HTTP"></a>2.1.4为什么要用RPC，不是HTTP</h3><p>首先需要指正，这两个并不是并行概念。RPC 是一种<strong>设计</strong>，就是为了解决<strong>不同服务之间的调用问题</strong>，完整的 RPC 实现一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。</p>
<p>使用 TCP 和使用 HTTP 各有优势：</p>
<p><strong>传输效率</strong>：</p>
<ul>
<li>TCP，通常自定义上层协议，可以让请求报文体积更小 </li>
<li>HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容 </li>
</ul>
<p><strong>性能消耗</strong>，主要在于序列化和反序列化的耗时</p>
<ul>
<li>TCP，可以基于各种序列化框架进行，效率比较高 </li>
<li>HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能 </li>
</ul>
<p><strong>跨平台</strong>：</p>
<ul>
<li>TCP：通常要求客户端和服务器为统一平台 </li>
<li>HTTP：可以在各种异构系统上运行 </li>
</ul>
<p><strong>总结</strong>：<br>  RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p>
<h2 id="2-2Java相关"><a href="#2-2Java相关" class="headerlink" title="2.2Java相关"></a>2.2Java相关</h2><h3 id="2-2-1动态代理与静态代理（客户端无感调用）"><a href="#2-2-1动态代理与静态代理（客户端无感调用）" class="headerlink" title="2.2.1动态代理与静态代理（客户端无感调用）"></a>2.2.1动态代理与静态代理（客户端无感调用）</h3><h4 id="明确静态代理和动态代理的区别："><a href="#明确静态代理和动态代理的区别：" class="headerlink" title="明确静态代理和动态代理的区别："></a>明确静态代理和动态代理的区别：</h4><ul>
<li><strong>静态代理：</strong>程序运行前，代理类的.class文件就已经存在了，也就是写死了代理对象；</li>
<li><strong>动态代理：</strong>在程序运行期间，运用反射机制动态创建需要代理的对象，也就是说要代理的对象是在运行期间确定的。</li>
</ul>
<p><strong>为什么要用动态代理？</strong></p>
<ol>
<li>由于静态代理中的代理类是针对某一个类去做代理的，那么假设一个系统中有100个Service，则需要创建100个代理类</li>
<li>如果一个Service中有很多方法需要事务（增强动作），发现代理对象的方法中还是有很多重复的代码</li>
</ol>
<p>由第一点和第二点可以得出：静态代理的重用性不强</p>
<h4 id="动态代理：JDK-动态代理和-CGlib-动态代理"><a href="#动态代理：JDK-动态代理和-CGlib-动态代理" class="headerlink" title="==动态代理：JDK 动态代理和 CGlib 动态代理=="></a>==动态代理：JDK 动态代理和 CGlib 动态代理==</h4><p><strong>二者区别：</strong>JDK动态代理产生的代理类和目标类实现了相同的接口；cglib动态代理产生的代理类是目标对象的子类。</p>
<p><strong>1. JDK动态代理</strong>：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 中的 invoke 方法来处理。</p>
<p><strong>动态代理步骤：</strong></p>
<ol>
<li>创建一个实现接口InvocationHandler的类作为拦截器，它必须实现invoke方法，让每个被代理类的方法执行时，都必须执行 invoke 方法体中的逻辑</li>
<li>创建被代理的类以及接口</li>
<li>通过Proxy的静态方法<br>newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理</li>
<li>通过代理调用方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">savePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;保存成功！&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;修改&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTransaction</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;开启事务 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在动态代理在生成代理对象的时候需要一个拦截器 InvocationHandler 因此咱们需要写一个拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">//目标类</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="comment">//增强类</span></span><br><span class="line">	<span class="keyword">private</span> MyTransaction myTransaction;</span><br><span class="line">	<span class="comment">//构造函数注入目标类和增强类</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PersonServiceInterceptor</span><span class="params">(Object target,MyTransaction myTransaction)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">		<span class="keyword">this</span>.myTransaction = myTransaction;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//代理类的每一个方法被调用的时候都会调用下边的这个invoke方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.myTransaction.beginTransaction();</span><br><span class="line">		Object returnValue = method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">		<span class="keyword">this</span>.myTransaction.commit();</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、当客户端执行代理对象.方法时，进入到了拦截器的invoke方法体</p>
<p>2、拦截器中invoke方法体的内容就是代理对象方法体的内容</p>
<p>3、拦截器中invoke方法的method参数是在调用的时候赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Object target = <span class="keyword">new</span> PersonServiceImpl();</span><br><span class="line">		MyTransaction myTransaction = <span class="keyword">new</span> MyTransaction();</span><br><span class="line">		PersonServiceInterceptor interceptor = <span class="keyword">new</span> PersonServiceInterceptor(target, myTransaction);</span><br><span class="line">		PersonService personService = (PersonService)Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),interceptor);</span><br><span class="line">		String returnValue = (String)personService.savePerson();</span><br><span class="line">		System.out.println(returnValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>2.CGlib动态代理</strong>：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。（没看懂）==</p>
<h3 id="2-2-2序列化"><a href="#2-2-2序列化" class="headerlink" title="2.2.2序列化"></a>2.2.2序列化</h3><p>上面有</p>
<h2 id="2-3Netty相关"><a href="#2-3Netty相关" class="headerlink" title="2.3Netty相关"></a>2.3Netty相关</h2><h3 id="2-3-1Netty-是什么"><a href="#2-3-1Netty-是什么" class="headerlink" title="2.3.1Netty 是什么"></a>2.3.1Netty 是什么</h3><ol>
<li>Netty 本质是一个 <strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好。</li>
<li><strong>支持多种应用层协议</strong>，如 FTP，SMTP，HTTP 以及自定义协议。</li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h3 id="2-3-2特点和优势"><a href="#2-3-2特点和优势" class="headerlink" title="2.3.2特点和优势"></a>2.3.2特点和优势</h3><p>因为 Netty 具有下面这些优点，并且相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。</p>
<ul>
<li>使用简单：封装了 NIO 的很多细节，使用更简单。 </li>
<li>功能强大：预置了多种编解码功能，支持多种主流协议。 （支持多种应用层协议）</li>
<li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。 </li>
<li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li>
</ul>
<h3 id="2-3-3为什么-Netty-性能高"><a href="#2-3-3为什么-Netty-性能高" class="headerlink" title="2.3.3为什么 Netty 性能高"></a>2.3.3为什么 Netty 性能高</h3><ul>
<li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。 </li>
<li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。 </li>
<li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。 </li>
<li>串行化处理读写：避免使用锁带来的性能开销。 </li>
<li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h3 id="2-3-4BIO、NIO和AIO"><a href="#2-3-4BIO、NIO和AIO" class="headerlink" title="2.3.4BIO、NIO和AIO"></a>2.3.4BIO、NIO和AIO</h3><p><strong>I/O 模型简单的理解：</strong>用什么样的通道将数据发送给对方，I/O 模型在很大程度上决定了框架的性能。Java 共支持 3 种网络编程模型/IO模式：  BIO、NIO 或者 AIO。</p>
<h4 id="BIO模型介绍"><a href="#BIO模型介绍" class="headerlink" title="BIO模型介绍"></a>BIO模型介绍</h4><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个 ServerSocket，然后在客户端启动 Socket 来对服务端进行通信。由于 ServerSocket 的 accept() 方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>这种方式下有一个问题：每个请求都需要独立的线程完成数据 read，业务处理，数据 write 的完整操作。 如下图所示：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\BIO.png" style="zoom:80%;">

<p><strong>问题：</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p>
<p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p>
<h4 id="NIO模型介绍"><a href="#NIO模型介绍" class="headerlink" title="NIO模型介绍"></a>NIO模型介绍</h4><p>NIO 基于 Reactor（事件驱动思想），当 Socket 有流可读或可写入 Socket 时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>BIO 与 NIO 一个比较重要的不同：<strong>我们使用 BIO 的时候往往会引入多线程，每个连接一个单独的线程；而 NIO 则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong>通俗一点的理解就是，NIO 能够做到用一个线程来处理多个操作，假设有 10000 个请求过来，根据实际情况，可以分配 50 或者 100 个线程来处理。不像 BIO 那样，非得分配 10000 个。这样就大大节省了资源的开销。</p>
<p>NIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\NIO.png" style="zoom:80%;">

<p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p>
<p><strong>NIO 中一个重要的组件：Selector</strong></p>
<p><strong>Selector</strong>  能够检测多个注册的通道上是否有事件发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\Selector.png" alt="image-20210614102612508" style="zoom: 110%;">

<h4 id="AIO模型介绍"><a href="#AIO模型介绍" class="headerlink" title="AIO模型介绍"></a>AIO模型介绍</h4><p>与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为， read 或 write 方法都是异步的，完成后会主动调用回调函数。 </p>
<p>相比于 NIO，AIO 才是完全的异步 IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p>
<h4 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h4><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p>
<p>伪异步 IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p>
<p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，[客户端]的 I/O 请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>但是由于使用同步非阻塞的 I/O 模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p>
<h3 id="2-3-5Netty的线程模型"><a href="#2-3-5Netty的线程模型" class="headerlink" title="2.3.5Netty的线程模型"></a>2.3.5Netty的线程模型</h3><p>Netty 通过 Reactor 模型基于多路复用器（Selector）接收并处理用户请求。我们实现服务端的时候，一般会初始化两个线程组：</p>
<ol>
<li><strong><code>bossGroup</code></strong> :接收连接。</li>
<li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li>
</ol>
<p>其它的线程模型：</p>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a><strong>单线程模型</strong></h4><p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件，即多路复用、事件分发和处理都是在一个Reactor 线程上完成的。一个NIO 线程同时处理成百上千的链路，对于高负载、高并发，并且对性能要求比较高的场景不适用。</p>
<p>对应到 Netty 代码是下面这样的</p>
<blockquote>
<p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a><strong>多线程模型</strong></h4><p>一个 NIO 线程（Acceptor ）线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p>
<p>对应到 Netty 代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;">

<h4 id="主从多线程模型"><a href="#主从多线程模型" class="headerlink" title="主从多线程模型"></a>主从多线程模型</h4><p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;">

<h3 id="2-3-6解决-TCP-的粘包拆包问题"><a href="#2-3-6解决-TCP-的粘包拆包问题" class="headerlink" title="2.3.6解决 TCP 的粘包拆包问题"></a>2.3.6解决 TCP 的粘包拆包问题</h3><p>TCP 是以流的方式来处理数据，一个完整的包可能会被 TCP 拆分成多个包进行发送，也可能把小的封装成一个大的数据包发送。</p>
<p><strong>TCP 粘包/分包的原因：</strong>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为<strong>面向流的通信是无消息保护边界</strong>的。由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题，看一张图：</p>
<p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source_posts\2021-05-13-（八）RPC项目总结\TCP粘包.png" alt="image-20210615223634724"></p>
<p>假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2 ，没有粘包和拆包。</li>
<li>服务端一次接受到了两个数据包，D1 和 D2 粘合在一起，称之为<strong>TCP粘包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容；</li>
<li>服务端分两次读取到了数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余部分内容 D1_2 和完整的 D2 包，这称之为<strong>TCP拆包</strong>。</li>
</ol>
<p><strong>解决方式：</strong></p>
<p>关键就是要解决<strong>服务器端每次读取数据长度的问题</strong>, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 TCP 粘包、拆包 。</p>
<p>1.Netty 自带解决方式：</p>
<ul>
<li>消息定长：FixedLengthFrameDecoder 类，固定长度解码器，它能够按照指定的长度对消息进行相应的拆包。</li>
<li>包尾增加特殊字符分割：<ul>
<li>行分隔符类：LineBasedFrameDecoder ，<code>LineBasedFrameDecoder</code> 的工作原理是它依次遍历 <code>ByteBuf</code> 中的可读字节，判断是否有换行符，然后进行相应的截取。</li>
<li>自定义分隔符类 ：DelimiterBasedFrameDecoder ，**<code>LineBasedFrameDecoder</code>** 实际上是一种特殊的 <code>DelimiterBasedFrameDecoder</code> 解码器。</li>
</ul>
</li>
<li>将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。</li>
</ul>
<p>2.自定义序列化编解码器：</p>
<p>自定义协议，其中有字段标明包长度。</p>
<h3 id="2-3-7Netty长连接、心跳机制"><a href="#2-3-7Netty长连接、心跳机制" class="headerlink" title="2.3.7Netty长连接、心跳机制"></a>2.3.7Netty长连接、心跳机制</h3><h4 id="Netty长连接与短连接"><a href="#Netty长连接与短连接" class="headerlink" title="Netty长连接与短连接"></a>Netty长连接与短连接</h4><p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p>
<p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p>
<p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p>
<h4 id="Netty中的心跳机制"><a href="#Netty中的心跳机制" class="headerlink" title="Netty中的心跳机制"></a>Netty中的心跳机制</h4><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入 <strong>心跳机制</strong> 。</p>
<p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互时, 即处于 idle 状态时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 PING-PONG 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性.</p>
<p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<code>SO_KEEPALIVE</code>。<code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 keepAlive 设置。</p>
<p>但是，TCP 协议层面的长连接灵活性不够。所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 <code>IdleStateHandler</code> 。</p>
<p><code>IdleStateHandler</code> 的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,TimeUnit unit)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是隔多久检查一下读事件是否发生，如果 <code>channelRead()</code> 方法超过 readerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第二个参数是隔多久检查一下写事件是否发生，writerIdleTime 写空闲超时时间设定，如果 <code>write()</code> 方法超过 writerIdleTime 时间未被调用则会触发超时事件调用 <code>userEventTrigger()</code> 方法；</p>
<p>第三个参数是全能型参数，隔多久检查读写事件；</p>
<p>第四个参数表示当前的时间单位。</p>
<p>所以这里可以分别控制读，写，读写超时的时间，单位为秒，如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。</p>
<p><strong>项目中的使用：</strong></p>
<p>通过服务器端的空闲检测，也就是服务器端每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可。</p>
<p>在一段时间之内没有读到客户端的数据，是否一定能判断连接假死呢？并不能，如果在这段时间之内客户端确实是没有发送数据过来，但是连接是 ok 的，那么这个时候服务端也是不能关闭这条连接的，为了防止服务端误判，我们还需要在客户端做点什么。</p>
<p>所以我们需要在客户端定期发送数据到服务端，通常这个数据包称为心跳数据包。</p>
<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> CommonEncoder(serializer))</span><br><span class="line">             .addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure>

<p>当客户端超过 5 秒没有写事件时，也就是 <code>write</code> 方法超过给定时间没被调用时，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p>
<p>方法逻辑主要就是看是否超过了 <strong>写空闲超时时间设定</strong> ，如果是就获取Channel创建一个心跳包并发送给服务器端。（这里主要是通过ctx中的事件是否为IdleStateEvent事件，再通过事件的状态来实现定时发送）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;发送心跳包 [&#123;&#125;]&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            Channel channel = ChannelProvider.get((InetSocketAddress) ctx.channel().remoteAddress(), CommonSerializer.getByCode(CommonSerializer.DEFAULT_SERIALIZER));</span><br><span class="line">            RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">            rpcRequest.setHeartBeat(<span class="keyword">true</span>);</span><br><span class="line">            channel.writeAndFlush(rpcRequest).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS))</span><br></pre></td></tr></table></figure>

<p>当服务端超过 30 秒没有读到数据时，表示连接假死，就会触发超时时间调用 <code>userEventTrigger()</code> 方法。</p>
<p>方法逻辑主要就是看是否超过了 <strong>读空闲超时时间设定</strong> ，如果是就判定客户端为假死状态，断开连接，不是的话不予响应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;长时间未收到心跳包，断开连接...&quot;</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==这里其实还有一个提升，就是双方都开始读写超时参数，这样两边假死状态都能判定。==</p>
<h3 id="2-3-8Netty-的零拷贝"><a href="#2-3-8Netty-的零拷贝" class="headerlink" title="2.3.8Netty 的零拷贝"></a>2.3.8Netty 的零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>内部工作流程：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝1.png" alt="image-20210526152344320" style="zoom:80%;">

<ol>
<li><p>Java 本身不具有 IO 读写能力，因此在 read 方法调用后，要从<strong>用户态切换至内核态</strong>，去调用系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程会被阻塞，操作系统使用 <strong>DMA</strong> 来实现文件读，也不会使用 CPU；</p>
<blockquote>
<p>DMA 是在磁盘和内核缓冲区之间建立起一个通道，可以<strong>解放 CPU 直接进行数据交换</strong></p>
</blockquote>
</li>
<li><p><strong>内核态切换回用户态</strong>，将数据从内核缓冲区读入用户缓冲区，这期间 CPU 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时<strong>将数据从用户缓冲区，写入 Socket 缓冲区</strong>，CPU 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这时 Java 同样不具备写的能力，因此<strong>又得从用户态切换至内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡。</p>
</li>
</ol>
<p>可以看到这个过程中，Java 并不具备物理设备级别的读写能力，而是缓存的复制，底层的真正读写是由操作系统完成的：</p>
<ol>
<li>用户态与内核态切换发生了3次</li>
<li>数据拷贝发生了4次</li>
</ol>
<h4 id="NIO优化（mmap）"><a href="#NIO优化（mmap）" class="headerlink" title="NIO优化（mmap）"></a>NIO优化（mmap）</h4><p>通过 DirectByteBuf ：使用的是操作系统内存（而且这块内存 Java 和操作系统都能访问）</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝2.png" alt="image-20210526154313921" style="zoom:80%;">

<p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuf 将堆外内存（系统内存）映射到 jvm 内存中来直接访问使用，省去了这一步的拷贝工作。</strong></p>
<ol>
<li><p>这块内存不受 jvm 垃圾回收机制影响，因此内存地址固定，有助于 IO 读写</p>
</li>
<li><p>Java 中的 DirectByteBuf 对象仅维护了该内存的虚引用，内存回收分为两部分：</p>
<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门的线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li><p>减少了一次数据拷贝，但是由于还是有 Java 参与数据拷贝，没有减少用户态与内核态的切换次数</p>
</li>
</ol>
<h4 id="进一步优化（Linux2-1、sendFile）"><a href="#进一步优化（Linux2-1、sendFile）" class="headerlink" title="进一步优化（Linux2.1、sendFile）"></a>进一步优化（Linux2.1、sendFile）</h4><p>在上面的优化中，都需要通过 Java 提供一个 xxByte 来作为媒介，将数据从操作系统的内核缓冲区复制到 socket 缓冲区，也就是需要 Java 参与的，这样就多了两次用户态与内核态的切换。</p>
<p>（底层采用了Linux 2.1 后提供的 sendFile 方法），Java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝3.png" alt="image-20210526160129569" style="zoom:80%;">

<ol>
<li>Java 调用 transferTo 方法后，要从 Java程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入内核缓冲区，不会使用 CPU</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>Socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ol>
<p>可以看到：</p>
<ul>
<li><p>只发生了一次用户态与内核态的切换（不需要 Java 参与）</p>
</li>
<li><p>数据拷贝了 3 次</p>
</li>
</ul>
<h4 id="进一步优化（Linux2-4，sendFile-优化）"><a href="#进一步优化（Linux2-4，sendFile-优化）" class="headerlink" title="进一步优化（Linux2.4，sendFile 优化）"></a>进一步优化（Linux2.4，sendFile 优化）</h4><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝4.png" alt="image-20210526161411076" style="zoom:80%;">

<ol>
<li>Java调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>只会将一些 offset 和 length 信息拷贝到 Socket 缓存</li>
<li>也就是使用 DMA 将内核缓冲区的数据写入网卡，不会使用 CPU</li>
</ol>
<p>整个过程只发生了一次用户态与内核态的切换，数据拷贝了两次。所谓的<strong>零拷贝</strong>，不是不需要拷贝，而是不会拷贝重复数据到 JVM 内存中。零拷贝的优势有：</p>
<ol>
<li>更少的用户态和内核态的切换</li>
<li>不利用 CPU 计算</li>
<li>零拷贝适合小文件传输（因为太大了会占满缓存，影响其它文件的传输）</li>
</ol>
<h4 id="Netty的零拷贝"><a href="#Netty的零拷贝" class="headerlink" title="Netty的零拷贝"></a>Netty的零拷贝</h4><blockquote>
<p>1.传统的 IO 就有使用 DMA 的方式优化了  </p>
<p>2.传统零拷贝的概念是数据buffer不用再复制到用户空间，但是从内核缓存复制到 socket  buffer，但还是有一次多余的复制（因此需要 CPU 参与复制），于是出现了优化后的零拷贝，去掉在内核中那次多余的复制。 </p>
<p>3.<strong>netty 使用了优化后的零拷贝的 IO 方式，但是 netty 特性中的零拷贝主要是指复制方式与一般复制方式不同</strong>，因此API也不同了。netty 可以将多个ByteBuf 直接组装成一个 Netty ByteBuf，不用自己一个个添加到 buffer 里，还可以不需要拷贝地将一个 buffer 分割成多个小的 buffer 并且提供了更灵活的操作 buffer 的 API。</p>
</blockquote>
<p><strong>体现一：slice</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝5.png" alt="image-20210526162556972" style="zoom:80%;">

<p>对原始的 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原来的 ByteBuf 的内存，只是切片后的 ByteBuf 维护独立的 read 和 write 指针。（也就是通过索引访问原来的 ByteBuf ，并没有申请新的内存来存放分片的 ByteBuf）</p>
<p><strong>体现二：duplicate</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\零拷贝6.png" alt="image-20210526171439539" style="zoom:80%;">

<p>与 slice 不同，这个是拷贝了原始 ByteBuf 的所有内容，也是与原始的 ByteBuf 使用同一块内存，只是读写指针是独立的。</p>
<p><strong>体现三：composite</strong></p>
<p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。（我认为传统的方式是申请一块更大的内存来存放多个小的 Buffer）</p>
<h3 id="2-3-9核心组件"><a href="#2-3-9核心组件" class="headerlink" title="2.3.9核心组件"></a>2.3.9核心组件</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等</p>
<p>比较常用的<code>Channel</code>接口实现类（或者说Channel类型）是：</p>
<ul>
<li><code>NioServerSocketChannel</code>（异步的服务器端 TCP Socket 连接）</li>
<li><code>NioSocketChannel</code>（异步的客户端 TCP Socket 连接）</li>
</ul>
<p>这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty 所有的 I/O 操作都为异步的。因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。</p>
<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p>
<h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p><code>ChannelHandler</code> 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p>
<p><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler用于处理入站I / O事件，对从客户端发往服务器的报文进行处理，一般用来执行解码、读取客户端数据、进行业务处理等</li>
<li>ChannelOutboundHandler用于处理出站I / O操作，对从服务器发往客户端的报文进行处理，一般用来进行编码、发送报文到客户端</li>
</ul>
<p><strong>执行顺序：</strong> <strong>ChannelInboundHandler按照注册的先后顺序执行；ChannelOutboundHandler按照注册的先后顺序逆序执行</strong></p>
<blockquote>
<p><strong>附：ChannelHandler的类继承体系</strong></p>
</blockquote>
<p><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source_posts\2021-05-13-（八）RPC项目总结\ChannelHandler.png"></p>
<p>下面一一对上述类做一个简单的介绍：</p>
<ul>
<li><p><strong>ChannelHandler</strong><br>Netty Channel事件的基础接口，只定义与 Handler 的管理接口相关，具体如下：</p>
<ol>
<li>void handlerAdded(ChannelHandlerContext ctx)<br> 在调用 DefaultChannelPipeline 的 addLast(add) 将事件监听器添加到事件处理链条时调用。</li>
<li>void handlerRemoved(ChannelHandlerContext ctx)<br> 在调用DefaultChannelPipeline 的 addLast(add) 发生异常时被调用；当通道关闭后，通道取消注册后，同时会触发通道移除事件，具体调用入口：DefaultChannelPipeline 的内部类 HeadContext 的 channelUnregistered。</li>
</ol>
</li>
<li><p><strong>ChannelInboundHandler</strong><br>入端类型的事件处理器。</p>
<ol>
<li><p>void channelRegistered(ChannelHandlerContext ctx)<br>通道注册到 Selector 时触发。客户端在调用 connect 方法，通过 TCP 建立连接后，获取 SocketChannel 后将该通道注册在 Selector 时或服务端在调用bind 方法后创建 ServerSocketChannel，通过将通道注册到 Selector 时监听客户端连接上时被调用。</p>
</li>
<li><p>void channelUnregistered(ChannelHandlerContext ctx)<br>通道取消注册到Selector时被调用，通常在通道关闭时触发，首先触发channelInactive 事件，然后再触发 channelUnregistered 事件。</p>
</li>
<li><p>void channelActive(ChannelHandlerContext ctx)<br>通道处于激活的事件，在 Netty 中，处于激活状态表示底层 Socket 的isOpen() 方法与 isConnected() 方法返回 true。</p>
</li>
<li><p>void channelInactive(ChannelHandlerContext ctx)<br>通道处于非激活（关闭），调用了 close 方法时，会触发该事件，然后触发channelUnregistered 事件。</p>
</li>
<li><p>void channelRead(ChannelHandlerContext ctx, Object msg)<br>通道从对端读取数据，当事件轮询到读事件，调用底层 SocketChannel 的 read 方法后，将读取的字节通过事件链进行处理，NIO 的触发入口为AbstractNioByteChannel 的内部类 NioByteUnsafe 的 read 方法。</p>
</li>
<li><p>void channelReadComplete(ChannelHandlerContext ctx)<br>处理完一次通道读事件后触发，在 Netty 中一次读事件处理中，会多次调用SocketChannel 的 read方法。触发入口为AbstractNioByteChannel 的内部类NioByteUnsafe 的 read 方法。</p>
</li>
<li><p>void userEventTriggered(ChannelHandlerContext ctx, Object evt)<br>触发用户自定义的事件，目前只定义了ChannelInputShutdownEvent（如果允许半关闭（输入端关闭而服务端不关闭））事件。</p>
</li>
<li><p>void channelWritabilityChanged(ChannelHandlerContext ctx)<br>Netty 写缓存区可写状态变更事件（可写–》不可写、不可写–》可写），入口消息发送缓存区ChannelOutboundBuffer。</p>
</li>
<li><p>void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)<br>异常事件。</p>
</li>
</ol>
</li>
<li><p><strong>ChannelOutboundHandler</strong><br> 出端类型的事件处理器。</p>
<ol>
<li>void bind(ChannelHandlerContext ctx, SocketAddress add, ChannelPromise p)<br>调用ServerBootstrap 的 bind 方法的处理逻辑。绑定操作，服务端在启动时调用bind方法时触发（手动调用bind）。</li>
<li>void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,SocketAddress localAddress, ChannelPromise promise)<br>连接操作，客户端启动时调用connect方法时触发（手动调用connect）。</li>
<li>void disconnect(ChannelHandlerContext ctx, ChannelPromise promise)<br>断开连接操作（手动调用disconnect）</li>
<li>void close(ChannelHandlerContext ctx, ChannelPromise promise)<br>关闭通道，手动调用Channel#close方法时触发。(手动调用close)</li>
<li>void deregister(ChannelHandlerContext ctx, ChannelPromise promise)<br>调用Channel#deregister时触发。（手动调用deregister)。</li>
<li>void read(ChannelHandlerContext ctx) throws Exception<br>注册读事件，并不是触发网络读写事件。</li>
<li>void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception<br>调用调用 Channel 的 write(底层 SocketChannel 的 write)时触发。</li>
<li>void flush(ChannelHandlerContext ctx)<br>调用调用Channel#flush(SocketChannel#flush)时触发。</li>
</ol>
</li>
<li><p><strong>ChannelDuplexHandler</strong><br>双向 Handler，包含 Inbound 和 outbound 事件。 </p>
</li>
<li><p><strong>ByteToMessageDecoder</strong><br>解码器：字节流解码成一条一条的消息(Message、协议对象)。</p>
</li>
<li><p><strong>MessageToByteEncoder</strong><br>编码器：消息（协议对象）编码成二进制字节流。</p>
</li>
<li><p><strong>AbstractTrafficShapingHandler</strong><br>流量整形，将在后续章节中详细介绍。</p>
</li>
</ul>
<p>上述详细的介绍了NettyChannel的类继承体系，并重点介绍了ChannelInboundHandler 与 ChannelOutboundHandler 每个方法的含义已经触发时机，接下来再谈一点我对这两个 Handler 的一些理解。</p>
<p><strong>ChannelInboundHandler：</strong>入端操作，可以看出基本上是都是由事件选择器(NIO Selector事件就绪选择)进行触发,事件名称以 channel 开头，例如channelRead。</p>
<p><strong>ChannelOutboundHanlder：</strong>出端操作，其触发点除了 read 事件外都是通过调用api(例如bind、connect、close、write)。</p>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>。</p>
<p>我们可以在 <code>ChannelPipeline</code> 上通过 <code>addLast()</code> 方法添加一个或者多个<code>ChannelHandler</code> ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code> 。</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\ChannelPipeline.png" style="zoom:80%;">

<p>在 <code>Netty</code> 整个框架里面，一条连接对应着一个 <code>Channel</code>，这条 <code>Channel</code> 所有的处理逻辑都在一个叫做 <code>ChannelPipeline</code> 的对象里面，<code>ChannelPipeline</code> 是一个双向链表结构，他和 <code>Channel</code> 之间是一对一的关系。</p>
<p><code>ChannelPipeline</code> 里面每个节点都是一个 <code>ChannelHandlerContext</code> 对象，这个对象能够拿到和 <code>Channel</code> 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 <code>ChannelHandler</code>。入站事件和出站事件在一个双向链表中，入站事件会从链表 <code>head</code> 往后传递到最后一个入站的 <code>handler</code> ，出站事件会从链表 <code>tail</code> 往前传递到最前一个出站的 <code>handler</code> ，两种类型的 <code>handler</code> 互不干扰。</p>
<h3 id="2-3-10其它组件"><a href="#2-3-10其它组件" class="headerlink" title="2.3.10其它组件"></a>2.3.10其它组件</h3><h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>上下文对象：保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象，比如：管道 pipeline、通道 channel、地址等相关信息。换句话说，只要我们在定义 Handler 时，只要我们想拿数据就从 ChannelHandlerContext 中获取，也可以通过提供的方法将数据处理完写入到 ChannelHandlerContext 中的管道 Channel 中去。</p>
<h4 id="EventloopGroup"><a href="#EventloopGroup" class="headerlink" title="EventloopGroup"></a>EventloopGroup</h4><p>下图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\EventloopGroup.png" style="zoom:80%;">

<p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>bossGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>workerGroup</code> 来处理，然后 <code>workerGroup</code> 负责处理其 IO 相关操作。</p>
<p><code>EventLoopGroup</code> 为 <code>Netty</code> 线程池，它实际上就是 <code>EventLoop</code> 的数组容器。<code>EventLoop</code> 的职责是处理所有注册到本线程多路复用器 <code>Selector</code> 上的 <code>Channel</code>，<code>Selector</code> 的轮询操作由绑定的 <code>EventLoop</code> 线程 <code>run</code> 方法驱动，在一个循环体内循环执行。通俗点讲就是一个死循环，不断的检测 I/O 事件、处理 I/O 事件。</p>
<h4 id="Bootstrap-和-ServerBootstrap"><a href="#Bootstrap-和-ServerBootstrap" class="headerlink" title="Bootstrap 和 ServerBootstrap"></a>Bootstrap 和 ServerBootstrap</h4><p><strong>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件</strong></p>
<p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrap</code> 客户端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li>
</ol>
<h4 id="EventLoopGroup-默认的构造函数会起多少线程"><a href="#EventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="EventLoopGroup 默认的构造函数会起多少线程"></a>EventLoopGroup 默认的构造函数会起多少线程</h4><p>回顾我们在上面写的服务器端的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 <strong><code>CPU核心数*2</code>**。</strong>（两倍的CPU数目）**</p>
<p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p>
<h3 id="2-3-11Netty执行全过程"><a href="#2-3-11Netty执行全过程" class="headerlink" title="2.3.11Netty执行全过程"></a>2.3.11Netty执行全过程</h3><img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\Netty执行全过程.png" style="zoom:80%;">

<ol>
<li><p>ServerBootStrap作为Netty的服务端入口，会对BossGroup和WorkGroup进行相关初始化操作，在BossGroup中，主要是对客户端的新连接请求进行处理（即OP_ACCEPT事件，但其实OP_ACCEPT事件的具体处理也会涉及到读写事件，因为数据不是读就是写），在WorkGroup中，则负责处理IO读写、编解码、业务逻辑等（即OP_READ事件、OP_WRITE事件）。服务端启动的时候会绑定一个端口，作为后续客户端连接入口，绑定端口的时候会在BossGroup(由NioEventLoopGroup类创建的对象）的其中一个NioEventLoop的Selector（多路复用器）上注册一条NioServerSocketChannel通道，后面的连接处理就是在通道中进行的。</p>
</li>
<li><p>BootStrap则作为Netty的客户端入口，会对ClientGroup进行相关初始化操作，在ClientGroup中，第一就是创建与服务端的连接（即OP_CONNECT事件），第二就是进行IO读写、编解码、业务逻辑等操作（即OP_READ事件、OP_WRITE事件）。</p>
</li>
<li><p>服务端和客户端启动之后，当服务端收到客户端发来的连接请求，由于属于OP_ACCEPT事件，在BossGroup中处理。BossGroup(由NioEventLoopGroup类创建的对象）管理着若干个NioEventLoop，每个NioEventLoop持有一个线程（就好比线程池中的一组线程并发处理若干个连接请求），每个NioEventLoop上会创建一个Selector，一个Selector上可以注册多个通道（所以叫多路复用器），且它会以不断轮询的方式同时监听每个通道上是否有IO事件发生，每个通道里都会有个ChannelPipeline管道，管道里全是Handler，包括管道头Head和管道尾Tail，以及进行IO读写、编解码，业务处理的若干个Handler，Handler也可以自定义，把需要的Handler注册进管道就可以执行了。当请求到达Head时，代表“请求数据”已准备好，OP_ACCEPT事件已就绪，Selector监听到事件已就绪，就会让持有的线程对事件进行处理，处理过程是在Handler中进行。首先会创建一个NioSocketChannel实例，然后交给ServerBootStrapAcceptor这个Handler，它是Netty底层代码注册的，Acceptor具体操作就是向WorkGroup中的某个Selector注册刚才创建好的NioSocketChannel，自此客户端连接请求处理结束。</p>
</li>
<li><p>客户端发出连接请求的同时会自己创建一条NioSocketChannel通道与服务端NioSocketChannel进行互通，连接完之后就是WorkGroup的事了，不需要BossGroup管了，一个客户端连接对应一条服务端NioSocketChannel。比如现在客户端要进行一个远程方法的调用，将方法参数传给服务端后，服务端处理完将结果返回给客户端。首先请求从客户端通道传输到WorkGroup中的对应通道，然后Head会申请一块堆外内存来缓冲请求内容，缓冲完之后，代表数据已准备好，OP_READ事件已就绪，selector监听到就绪事件之后，让持有的线程对事件进行处理，这里我定义了Decode解码，Compute方法调用处理和Encode编码三个Handler进行操作，其中Inbound入站Handler包括Decode和Compute（从Head到Tail就是入站），Outbound出站Handler包括Encode（从Tail到Head就是出站），每一个Handler被注册到Pipeline中的时候都会创建一个与之对应的ChannelHandlerContext，它包含着Handler的上下文信息，主要负责管理和其他在同一管道里的Handler之间的交互，它有一个前指针和后指针，可以与其他ChannelHandlerContext关联，这样Handler处理就变得更加灵活，比如这次请求需要三个Handler，而下次请求只涉及到Decode和Encode，那下次就可以执行完Decode然后指针直接指向Encode，next指针具体指向谁是依靠ChannelHandlerContext中的数据类型与其他Handler类型进行匹配得出的。在处理完读事件之后，接着处理Handler中涉及到的写事件，将处理结果写到ByteBuf中，回到Head，执行flush操作将ByteBuf内容写到SocketBuffer中，然后再到网卡buffer，通过互联网把结果传回给客户端，客户端拿到结果之后同样要进行解码，反序列化等操作，那么回过头发现客户端在发送调用请求之前在Pipeline中也进行了Encode处理的。（Head的主要作用：从SocketBuffer读请求内容到ByteBuf，从ByteBuf写返回结果到SocketBuffer）</p>
</li>
<li><p>假设又有另外一个客户端连接了服务端，且和之前那个NioSocketChannel注册到了同一个Selector上，当线程正在处理另一个通道上的事件的时候，这时该客户端也发起了一个处理请求，请求到达服务端通道之后会被Head读到堆外内存中缓冲着，此时OP_READ事件已就绪，Selector监听到了就绪事件，但由于线程正在处理另外一个通道上的事件，所以就要等当前通道的事件处理完，下一轮循环监听再处理了（这也是堆外内存的作用体现之一，数据可以先在缓冲区放着）。当两个通道被注册在不同的Selector上的时候就互不影响了，因为是在不同的线程中并行处理的。另外补充两点，第一个TaskQueue任务队列中的任务都是非IO任务，从性能上来考虑，千万不要将一个需要长时间来运行的任务放入到任务队列中，因为事件任务在一个线程中是串行执行的，这样会阻塞其他任务。解决方案是使用一个专门的EventExecutor来执行它（ChannelPipeline提供了带有EventExecutorGroup参数的addXXX()方法，该方法可以将传入的ChannelHandler绑定到你传入的EventExecutor之中），这样它就会在另一条线程中执行，与其他任务隔离。第二个Channel注册到Selector后返回的是一个SelectionKey，这个SelectionKey有以下几个重要属性：</p>
<ul>
<li>interest set，通道感兴趣的事件集，就是会把该通道可能执行的事件类型都告诉Selector</li>
<li>ready set，感兴趣的事件集中的“就绪事件集”</li>
<li>保存着的Channel</li>
<li>保存着的Selector</li>
</ul>
</li>
</ol>
<p>IO事件类型：</p>
<ul>
<li>SelectionKey.OP_READ </li>
<li>SelectionKey.OP_WRITE </li>
<li>SelectionKey.OP_ACCEPT </li>
<li>SelectionKey.OP_CONNECT </li>
</ul>
<p>因此Selector每次循环监听的其实就是SelectionKey中的就绪事件集，看是否存在已就绪的事件，存在就进行处理。SelectionKey相当于是Selector和Channel之间的桥梁。</p>
<h3 id="2-3-12从-BIO-演进到-NIO，再到-Netty"><a href="#2-3-12从-BIO-演进到-NIO，再到-Netty" class="headerlink" title="2.3.12从 BIO 演进到 NIO，再到 Netty"></a>2.3.12从 BIO 演进到 NIO，再到 Netty</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>BIO 是阻塞 IO ，也称之为传统 IO ，在 Java 的网络编程中，指的就是 ServerSocket、Socket 套接字实现的网络通信，这也是我们最开始学 Java 时接触到的网络编程相关的类。<strong>服务端在有新连接接入时或者在读取网络消息时，它会对主线程进行阻塞</strong>。下面是通过 BIO 来实现上面场景的代码。</p>
<p><strong>服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            InputStream inputStream = accept.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="comment">// read()方法是一个阻塞方法，当没有数据可读时，线程会一直阻塞在read()方法上</span></span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务端的代码中，创建了一个 ServerSocket 套接字，并绑定端口 8080 ，然后在 while 死循环中，调用 ServerSocket 的 accept() 方法，让其不停的接收客户端连接。accept() 方法是一个阻塞方法，当没有客户端来连接时，main 线程会一直阻塞在 accept() 方法上（现象：程序一直停在 accept() 方法这一行，不往下执行）。当有客户端连接时，main 线程解阻塞，程序继续向下运行。接着调用 read() 方法来从客户端读取数据，read() 方法也是一个阻塞方法，如果客户端发送来数据，则 read() 能读取到数据；如果没有数据可读，那么 main 线程就又会一直停留在 read() 方法这一行。</p>
<p>这里使用了两个 while 循环，外层的 while 循环是为了保证能不停的接收连接，内层的 while 循环是为了保证不停的从客户端中读取数据。</p>
<p><strong>客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 采用具有定时执行任务的线程池，来模拟客户端每隔一段时间来向服务端发送消息</span></span><br><span class="line">        <span class="comment">// 这里是每隔3秒钟向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="comment">// 向服务端发送消息（消息内容为：客户端的ip+端口+Hello World，示例：/127.0.0.1:999999 Hello World）</span></span><br><span class="line">                String message = socket.getLocalSocketAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                outputStream.write(message.getBytes());</span><br><span class="line">                outputStream.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端的代码中，创建了一个 Socket 套接字，并指定要连接的服务器地址和端口号。然后通过使用一个具有定时执行任务功能的线程池，让客户端每隔3秒钟向服务端发送一条数据。</p>
<p>然后我们分别启动服务端和一个客户端，从服务端的控制台就可以看到，每个3秒钟就会打印一行 <code>客户端的ip+端口+Hello World</code>的日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br></pre></td></tr></table></figure>

<p>为了模拟多个客户端的接入，然后我们再启动一个客户端，这个时候我们期待在服务端的控制台，会打印出两个客户端的<code>ip+端口+Hello World</code>，由于服务端和两个客户端都是在同一台机器上，因此这个时候打印出来的两个客户端的ip是相同的，但是端口口应该是不一样的。我们期望的日志输出应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure>

<p>然而，这只是我们期望的，实际现象，并非如此，当我们再启动一个客户端后，发现控制台始终只会出现一个客户端的端口号，并非两个。</p>
<p>那么为什么呢？原因就在于服务端的代码中，read() 方法是一个阻塞方法，当第一个客户端连接后，读取完第一个客户端的数据，由于第一个客户端一直不释放连接，因此服务端也不知道它还有没有数据要发送过来，这个时候服务端的 main 线程就一直等在 read() 方法处，当有第二个客户端接入时，由于 main 线程一直阻塞在 read() 方法处，因此它无法执行到 accept() 方法来处理新的连接，所以此时我们看到的现象就是，只会打印一个客户端发送来的消息。</p>
<p>那么我们该怎么办呢？既然知道了问题出现 main 线程阻塞在 read() 方法处，也就是在读数据的时候出现了阻塞。而要解决阻塞的问题，最直接的方式就是利用多线程技术了，因此我们就在读数据的时候新开启一条线程来进行数据的读取。升级之后的服务端代码如下。</p>
<p><strong>服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServerV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           <span class="comment">// accept()方法是个阻塞方法，如果没有客户端来连接，线程就会一直阻塞在这儿</span></span><br><span class="line">          Socket accept = serverSocket.accept();</span><br><span class="line">           <span class="comment">// 用另外一个线程来读写数据</span></span><br><span class="line">            handleMessage(accept);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新创建一个线程来读取数据</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的代码不变，依然使用 BioClient 。在服务端的代码 BioServerV2 中，读数据的操作我们提取到了 handleMessage() 方法中进行处理，在该方法中，会新创建一个线程来读取数据，这样就不会造成main线程阻塞在 read() 方法上了。启动服务端和两个客户端进行验证。控制台打印结果如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">2 &#x2F;127.0.0.1:88888 Hello World</span><br><span class="line">3 &#x2F;127.0.0.1:99999 Hello World</span><br><span class="line">4 &#x2F;127.0.0.1:88888 Hello World</span><br></pre></td></tr></table></figure>

<p>虽然解决了多个客户端同时接入的问题，但是其中的缺点我们也很容易发现：<strong>每当有一个新的客户端来连接服务端时，我们都需要为这个客户端创建一个线程来处理读数据的操作，当并发度很高时，我们就需要创建很多的线程，这显然这是不可取的。</strong>线程是服务器的宝贵资源，创建和销毁都需要花费很长时间，当线程过多时，CPU 的上线文切换也更加频繁，这样就会造成服务响应缓慢。当线程过多时，甚至还会出现句柄溢出、OOM 等异常，最终导致服务宕机。另外，我们在读取数据时，是基于 IO 流来读取数据的，每次只能读取一个或者多个字节，性能较差。</p>
<p>因此BIO的服务端，适用于并发度不高的应用场景，但是对于高并发，服务负载较重的场景，使用 BIO 显然是不适合的。</p>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>为了解决 BIO 无法应对高并发的问题，JDK 从1.4开始，提供了一种新的网络 IO，即 NIO，通常称它为非阻塞 IO。然而 NIO 的代码极为复杂和难懂，下面简单介绍写 NIO 中的组件。</p>
<p><strong>三大组件：</strong>Selector、Channel 和 Buffer</p>
<p><strong>Selector：</strong>Selector 能够检测多个注册的通道上是否有事件发生（注意：多个 Channel 以事件的方式可以注册到同一个 Selector），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。（不同的操作系统有不同的实现方式，在 windows 平台底层实现是 select，在 linux内核中采用 epoll 实现，在 MacOS 中采用 poll 实现。）</p>
<p><em>Selector 会根据不同的事件，在各个通道上切换</em></p>
<p><strong>Buffer（缓冲区）：</strong>Buffer 就是一个内存块 ，底层是有一个数组并提供了一组方法，可以更轻松的使用内存块。NIO 数据的读取写入是通过 Buffer，BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。如图所示：</p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/Users\王进\AppData\Roaming\Typora\typora-user-images\image-20210614114733880.png" alt="image-20210614114733880" style="zoom:80%;">

<p><strong>Channel：</strong>NIO 的通道类似于流，但有些区别如下：</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
<p><strong>NIO 中相关的类</strong></p>
<p>NIO 相关的类均在<code>java.nio</code>包下。与 BIO 中 ServerSocket、Socket 对应，NIO 中提供了 ServerSocketChannle、SocketChannel 分别表示服务端 Channel 和客户端 Channel。</p>
<p>看看如何用 NIO 来实现上面的场景：</p>
<p><strong>NIO 服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 轮询器，不同的操作系统对应不同的实现类</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">       serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">       serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 将服务端channel注册到轮询器上，并告诉轮询器，自己感兴趣的事件是ACCEPT事件</span></span><br><span class="line">       serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用轮询器的select()方法，是让轮询器从操作系统上获取所有的事件（例如：新客户端的接入、数据的写入、数据的写出等事件）</span></span><br><span class="line">           selector.select(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">// 调用select()方法后，轮询器将查询到的事件全部放入到了selectedKeys中</span></span><br><span class="line">           Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">           <span class="comment">// 遍历所有事件</span></span><br><span class="line">           Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">           <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果是新连接接入</span></span><br><span class="line">               <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                   SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                   System.out.println(<span class="string">&quot;有新客户端来连接&quot;</span>);</span><br><span class="line">                   socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                   <span class="comment">// 有新的客户端接入后，就样将客户端对应的channel所感兴趣的时间是可读事件</span></span><br><span class="line">                   socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 如果是可读事件</span></span><br><span class="line">               <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                   <span class="comment">// 从channel中读取数据</span></span><br><span class="line">                   SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                   ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                   channel.read(byteBuffer);</span><br><span class="line">                   byteBuffer.flip();</span><br><span class="line">                   System.out.println(Charset.defaultCharset().decode(byteBuffer));</span><br><span class="line">                   <span class="comment">// 读完了以后，再次将channel所感兴趣的时间设置为读事件，方便下次继续读。当如果后面要想往客户端写数据，那就注册写时间：SelectionKey.OP_WRITE</span></span><br><span class="line">                   channel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 将SelectionKey从集合中移除，</span></span><br><span class="line">               <span class="comment">// 这一步很重要，如果不移除，那么下次调用selectKeys()方法时，又会遍历到该SelectionKey，这就造成重复处理了，而且最终selectionKeys这个集合的大小会越来越大。</span></span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ul>
<li><p>首先通过<code>ServerSocketChannel.open()</code>这行代码创建了一个服务端的 Channel ，也就是服务端的 Socket 。（在计算机网路的7层模型或者TCP/IP模型中，上层的应用程序通过Socket来和底层沟通）</p>
</li>
<li><p>通过<code>Selector.open()</code>创建了一个轮询器，这个轮询器就是后续用来从操作系统中，遍历有哪些 Socket 准备好了。这么说有点抽象，举个栗子。坐火车时，通常都会有补票环节。每过一站后，乘务员就会在车厢中吼一嗓子，哪些人需要补票的？需要补票的人去几号车厢办理。这个乘务员就对应 NIO 中轮询器，定时去车厢中吼一嗓子（也就是去操作系统中“吼一嗓子”），这个时候如果有人需要补票（有新的客户端接入或者读写事件发生），那么它就会去对应的车厢办理<strong>（这些接入事件或者读写事件就会跑到 selectKeys 集合中）</strong>。而对应 BIO，每对应一个新客户端，都需要新建一个线程，也就是说每出现一个乘客，我们都要为它配备一个乘务员，这显然是不合理的，不可能有那么多的乘务员。因此这就是 NIO 对 BIO 的一个巨大优势。</p>
</li>
<li><p>然后为服务端绑定端口号，并设置为非阻塞模式。我们使用 NIO 的目的就是为了使用它的非阻塞特性，因此这里需要调用 <code>serverSocketChannel.configureBlocking(false)</code>设置为非阻塞</p>
</li>
<li><p>然后将 ServerSocketChannel 注册到轮询器 Selector 上，并告诉轮询器，它感兴趣的事件是 ACCEPT 事件（服务端的 Channel 就是用来处理客户端接入的，因此它感兴趣的事件就是 ACCEPT 事件。为什么要把它注册到轮询器上呢？前面已经说到了，轮询器会定期去操作系统中“吼一嗓子，谁要补票”，如果不注册到轮询器上（不上火车），轮询器吼一嗓子的时候，你怎么听得见呢？）</p>
</li>
<li><p>接着就是在一个 while 循环中，每过一段时间让轮询器去操作系统中轮询有哪些事件发生。select() 方法就是去操作系统中轮询（吼一嗓子），它可以传入一个参数，表示在操作系统中等多少毫秒，如果在这段时间中没有事件发生（没有人要补票），那么就从操作系统中返回。如果有事件发生，那么就将这些事件方法放到轮询器的<code>publicSelectedKeys</code>属性中，当调用<code>selector.selectedKeys()</code>方法时，就将这些事件返回。</p>
</li>
<li><p>接下来就是判断事件是哪种事件，是接收事件还是读事件，亦或是写事件，然后针对每种不同的事件做不同的处理。</p>
</li>
<li><p>最后将 Key 从集合中移除。为什么移除，见代码注释。</p>
</li>
</ul>
<p>上面是服务端 NIO 的写法，这个时候，可以直接利用 BIO 的客户端去进行测试。当然 NIO 也有客户端写法。虽然 NIO 的写法很复杂，但一回生，二回熟，多见几回就习惯了，所以下面还是贴出了 NIO 客户端的写法。</p>
<p><strong>NIO 客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">       socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">boolean</span> connect = socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">       <span class="comment">// 因为连接是一个异步操作，所以需要在下面一行判断连接有没有完成。如果连接还没有完成，就进行后面的操作，会出现异常</span></span><br><span class="line">       <span class="keyword">if</span>(!connect)&#123;</span><br><span class="line">           <span class="comment">// 如果连接未完成，就等待连接完成</span></span><br><span class="line">            socketChannel.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 每个3秒向服务端发送一条消息</span></span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               String message = socketChannel.getLocalAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                <span class="comment">// 使用ByteBuffer进行数据发送</span></span><br><span class="line">               ByteBuffer byteBuffer = ByteBuffer.wrap(message.getBytes());</span><br><span class="line">               socketChannel.write(byteBuffer);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO 客户端的写法相对比较简单，利用 SocketChannel 进行 IP 和端口的绑定，然后调用 connect() 方法进行连接到服务端。最后利用 ByteBuffer 装载数据，通过 SocketChannel 将数据写出去。</p>
<p><strong>NIO 原理分析图：</strong></p>
<img src="/2021/05/13/%EF%BC%88%E5%85%AB%EF%BC%89RPC%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/GitHub\MyBlogs\source\_posts\2021-05-13-（八）RPC项目总结\NIO原理分析图.png" alt="image-20210614121139284" style="zoom: 110%;">

<p><strong>执行流程：</strong></p>
<p>当客户端连接时，会通过 ServerSocketChannel 得到 ServerSocketChannel 得到服务端的 Channel ；</p>
<p>将 ServerSocketChannel 注册到 Selector 上，一个轮询器上可以注册多个 Channel ;</p>
<p>注册后返回一个 SelectionKeys 关联集合，通过 SelectionKey 反向获取相应的 SocketChannel ，完成业务处理逻辑；</p>
<p>服务器端通过 Selector 进行监听，调用 select 方法返回有事件发生的通道个数。</p>
<h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><p>相比BIO而言，NIO不需要为每个连接去创建一个线程，它是通过轮询器，定期的从操作系统中获取到准备好的事件，然后进行批量处理。同时NIO是通过ByteBuffer来读写数据，相比于BIO中通过流来一个字节或多个字节的对数据，NIO的效率更高。但是ByteBuffer的数据结构设计，有点反人类，一不小心就会出BUG。</p>
<p>BIO在高并发下不适合用，而NIO虽然可以应对高并发的场景，但是它一方面因为写法复杂，掌握难度大，更重要的是还存在空轮询的BUG（产生空轮询的原因是操作系统的缘故），因此Netty出现了。Netty是目前应该使用最广泛的一款网络框架，用官方术语讲就是：它是一款基于事件驱动的高性能的网络框架。实际上它是一款将NIO包装了的框架，同时它规避了JDK中空轮训的BUG。虽然它是对NIO的包装，但是它对很多操作进行了优化，其性能更好。目前在很多Java流行框架中，底层都采用了Netty进行网络通信，比如RPC框架中Dubbo、Motan，Spring5的异步编程，消息队列RocketMQ等等都使用了Netty进行网络通信。</p>
<p>接下来就用Netty实现上面的场景：</p>
<p><strong>Netty 服务端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责处理连接的线程组</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 负责处理IO和业务逻辑的线程组</span></span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 添加日志打印，用来观察Netty的启动日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">// 添加用来处理客户端channel的处理器handler</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 字符串解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    <span class="comment">// 自定义的handler，用来打印接收到的消息</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            System.out.println(message);</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                            <span class="keyword">super</span>.channelRegistered(ctx);</span><br><span class="line">                                            System.out.println(<span class="string">&quot;有新客户端连接&quot;</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，并启动</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程组</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码虽然看起来也很长，但是这段代码几乎是不变的，它几乎适用于所有场景，我们只需要修改childHandler()这一行相关的方法即可。这里面的代码才是处理我们自定义的业务逻辑的。</p>
<p>启动NettyServer，可以直接使用BioClient或者NioClient来测试NettyServer。当然，Netty也有客户端的写法。代码如下。</p>
<p><strong>Netty 客户端代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个线程组即可</span></span><br><span class="line">        NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 采用Bootstrap而不是ServerBootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(nioEventLoopGroup)</span><br><span class="line">                    <span class="comment">// 设置客户端的SocketChannel</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = nioSocketChannel.pipeline();</span><br><span class="line">                            <span class="comment">// 添加一个字符串编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line"></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">            executorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">                String message = channel.localAddress().toString() + <span class="string">&quot; Hello World&quot;</span>;</span><br><span class="line">                channel.writeAndFlush(message);</span><br><span class="line">            &#125;,<span class="number">0</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            nioEventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端的代码也几乎是固定的，所有场景都可以复用这段代码，唯一需要修改的就是handler()方法这一块，需要针对自己的业务逻辑去添加不同的处理器。</p>
<p>相比于NIO的写法，Netty的写法更加简洁，代码量相对更少，几行简单的代码就搞定了服务的启动，新连接接入，数据读写，编解码等问题。这也是为什么Netty使用这么广泛的原因。相比于NIO，Netty有如下几点优点：</p>
<ul>
<li>JDK的NIO存在空轮询的BUG，而Netty则巧妙的规避了这一点；</li>
<li>JDK的API复杂，开发人员使用起来比较困难，更重要的是，很容易写出BUG；而Netty的API简单，容易上手。</li>
<li>Netty的性能更高，它在JDK的基础上做了很多性能优化，例如将selector中的<code>publicSelectedKeys</code>属性的数据结构由Set集合改成了数组。</li>
<li>Netty底层对IO模型可以随意切换，针对Reactor三种线程模型，只需要通过修改参数就可以实现IO模型的切换。</li>
<li>Netty经过了众多高并发场景的考验，如Dubbo等RPC框架的验证。</li>
<li>Netty帮助我们解决了TCP的粘包拆包等问题，开发人员不用去关心这些问题，只需专注于业务逻辑开发即可。</li>
<li>Netty支持很多协议栈。JDK自带的对象序列化性能很差，序列化后码流较大，而是用其他方式的序列化则性能较高，例如protobuf等。</li>
<li>优点还有很多…</li>
</ul>

    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RPC%E9%A1%B9%E7%9B%AE/" rel="tag"><i class="fa fa-tag"></i>  RPC项目</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/12/%EF%BC%88%E4%B8%83%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1/" rel="prev" title="（七）RPC实现服务端自动注册服务">
      <i class="fa fa-chevron-left"></i> （七）RPC实现服务端自动注册服务
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/27/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0SpringIOC/" rel="next" title="手写实现SpringIOC">
      手写实现SpringIOC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.项目模块概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1roc-api%E6%A8%A1%E5%9D%97"><span class="nav-number">1.1.</span> <span class="nav-text">1.1roc-api模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2test-server%E6%A8%A1%E5%9D%97"><span class="nav-number">1.2.</span> <span class="nav-text">1.2test-server模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3test-client%E6%A8%A1%E5%9D%97"><span class="nav-number">1.3.</span> <span class="nav-text">1.3test-client模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4rpc-common%E6%A8%A1%E5%9D%97"><span class="nav-number">1.4.</span> <span class="nav-text">1.4rpc-common模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1package-entity"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1package-entity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2package-enumeration"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2package-enumeration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3package-exception"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3package-exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-4package-factory"><span class="nav-number">1.4.4.</span> <span class="nav-text">&#x3D;&#x3D;1.4.4package-factory&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-5package-util"><span class="nav-number">1.4.5.</span> <span class="nav-text">1.4.5package-util</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5rpc-core%E6%A8%A1%E5%9D%97%EF%BC%88%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">1.5rpc-core模块（核心）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1package-transport"><span class="nav-number">1.5.1.</span> <span class="nav-text">&#x3D;&#x3D;1.5.1package-transport&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-1package-netty-client"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">1.5.1.1package-netty-client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-2package-netty-server"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">1.5.1.2package-netty-server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-3package-socket-client"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">1.5.1.3package-socket-client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-4package-socket-server"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">1.5.1.4package-socket-server</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-5package-socket-util"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">1.5.1.5package-socket-util</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2package-annotation"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2package-annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3package-codec"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3package-codec</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%EF%BC%88MRF%EF%BC%89"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">传输协议（MRF）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4package-exception"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4package-exception</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5package-handler"><span class="nav-number">1.5.5.</span> <span class="nav-text">1.5.5package-handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-6package-hook"><span class="nav-number">1.5.6.</span> <span class="nav-text">1.5.6package-hook</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-7package-loadbalancer"><span class="nav-number">1.5.7.</span> <span class="nav-text">1.5.7package-loadbalancer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-8package-provider"><span class="nav-number">1.5.8.</span> <span class="nav-text">1.5.8package-provider</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-9package-registry"><span class="nav-number">1.5.9.</span> <span class="nav-text">1.5.9package-registry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-10package-serializer"><span class="nav-number">1.5.10.</span> <span class="nav-text">1.5.10package-serializer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">2.项目相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1RPC%E7%9B%B8%E5%85%B3"><span class="nav-number">2.1.</span> <span class="nav-text">2.1RPC相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1%E4%BB%80%E4%B9%88%E6%98%AFRPC"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1什么是RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2RPC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2RPC原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3%E5%B8%B8%E8%A7%81%E7%9A%84RPC%E6%A1%86%E6%9E%B6"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3常见的RPC框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8RPC%EF%BC%8C%E4%B8%8D%E6%98%AFHTTP"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4为什么要用RPC，不是HTTP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2Java%E7%9B%B8%E5%85%B3"><span class="nav-number">2.2.</span> <span class="nav-text">2.2Java相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%84%9F%E8%B0%83%E7%94%A8%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1动态代理与静态代理（客户端无感调用）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">明确静态代理和动态代理的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9AJDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGlib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">&#x3D;&#x3D;动态代理：JDK 动态代理和 CGlib 动态代理&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2序列化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3Netty%E7%9B%B8%E5%85%B3"><span class="nav-number">2.3.</span> <span class="nav-text">2.3Netty相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1Netty-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1Netty 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2特点和优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3%E4%B8%BA%E4%BB%80%E4%B9%88-Netty-%E6%80%A7%E8%83%BD%E9%AB%98"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3为什么 Netty 性能高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4BIO%E3%80%81NIO%E5%92%8CAIO"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4BIO、NIO和AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">BIO模型介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">NIO模型介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">AIO模型介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">三者比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5Netty的线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">单线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">多线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">主从多线程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6%E8%A7%A3%E5%86%B3-TCP-%E7%9A%84%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6解决 TCP 的粘包拆包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-7Netty%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%81%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.7.</span> <span class="nav-text">2.3.7Netty长连接、心跳机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.3.7.1.</span> <span class="nav-text">Netty长连接与短连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.7.2.</span> <span class="nav-text">Netty中的心跳机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-8Netty-%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.3.8.</span> <span class="nav-text">2.3.8Netty 的零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.8.1.</span> <span class="nav-text">传统 IO 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO%E4%BC%98%E5%8C%96%EF%BC%88mmap%EF%BC%89"><span class="nav-number">2.3.8.2.</span> <span class="nav-text">NIO优化（mmap）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%EF%BC%88Linux2-1%E3%80%81sendFile%EF%BC%89"><span class="nav-number">2.3.8.3.</span> <span class="nav-text">进一步优化（Linux2.1、sendFile）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%EF%BC%88Linux2-4%EF%BC%8CsendFile-%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">2.3.8.4.</span> <span class="nav-text">进一步优化（Linux2.4，sendFile 优化）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">2.3.8.5.</span> <span class="nav-text">Netty的零拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-9%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.9.</span> <span class="nav-text">2.3.9核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel"><span class="nav-number">2.3.9.1.</span> <span class="nav-text">Channel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EventLoop"><span class="nav-number">2.3.9.2.</span> <span class="nav-text">EventLoop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelFuture"><span class="nav-number">2.3.9.3.</span> <span class="nav-text">ChannelFuture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelHandler"><span class="nav-number">2.3.9.4.</span> <span class="nav-text">ChannelHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelPipeline"><span class="nav-number">2.3.9.5.</span> <span class="nav-text">ChannelPipeline</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-10%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.10.</span> <span class="nav-text">2.3.10其它组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelHandlerContext"><span class="nav-number">2.3.10.1.</span> <span class="nav-text">ChannelHandlerContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EventloopGroup"><span class="nav-number">2.3.10.2.</span> <span class="nav-text">EventloopGroup</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bootstrap-%E5%92%8C-ServerBootstrap"><span class="nav-number">2.3.10.3.</span> <span class="nav-text">Bootstrap 和 ServerBootstrap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EventLoopGroup-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BC%9A%E8%B5%B7%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.10.4.</span> <span class="nav-text">EventLoopGroup 默认的构造函数会起多少线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-11Netty%E6%89%A7%E8%A1%8C%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.11.</span> <span class="nav-text">2.3.11Netty执行全过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-12%E4%BB%8E-BIO-%E6%BC%94%E8%BF%9B%E5%88%B0-NIO%EF%BC%8C%E5%86%8D%E5%88%B0-Netty"><span class="nav-number">2.3.12.</span> <span class="nav-text">2.3.12从 BIO 演进到 NIO，再到 Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO"><span class="nav-number">2.3.12.1.</span> <span class="nav-text">BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO"><span class="nav-number">2.3.12.2.</span> <span class="nav-text">NIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty"><span class="nav-number">2.3.12.3.</span> <span class="nav-text">Netty</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">911k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:48</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

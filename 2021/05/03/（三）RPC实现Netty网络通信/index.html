<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangjin1996219.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="（三）RPC实现Netty网络通信">
<meta property="og:url" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Wj-Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/BIO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/NIO.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/eventloop.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/ChannelPipeline.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/多线程模型.png">
<meta property="og:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/主从多线程模型.png">
<meta property="article:published_time" content="2021-05-03T12:09:43.000Z">
<meta property="article:modified_time" content="2021-05-21T14:13:34.992Z">
<meta property="article:author" content="老王家的小王呀">
<meta property="article:tag" content="RPC项目">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub/MyBlogs/source/_posts/2021-05-03-（三）RPC实现Netty网络通信/BIO.png">

<link rel="canonical" href="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>（三）RPC实现Netty网络通信 | Wj-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wj-Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wj-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">90</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangjin1996219.github.io/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="老王家的小王呀">
      <meta itemprop="description" content="及时当勉励，岁月不待人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wj-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          （三）RPC实现Netty网络通信
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-03 20:09:43" itemprop="dateCreated datePublished" datetime="2021-05-03T20:09:43+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-21 22:13:34" itemprop="dateModified" datetime="2021-05-21T22:13:34+08:00">2021-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a>
                </span>
            </span>

          
            <span id="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" class="post-meta-item leancloud_visitors" data-flag-title="（三）RPC实现Netty网络通信" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<a id="more"></a>

<h1 id="1-BIO、NIO与AIO"><a href="#1-BIO、NIO与AIO" class="headerlink" title="1.BIO、NIO与AIO"></a>1.BIO、NIO与AIO</h1><p>用什么样的通道将数据发送给对方，BIO、NIO或者AIO，I/O模型在很大程度上决定了框架的性能</p>
<h2 id="1-1BIO模型介绍"><a href="#1-1BIO模型介绍" class="headerlink" title="1.1BIO模型介绍"></a>1.1BIO模型介绍</h2><p>在第一章中我们通过传统的 Socket 通信方式实现了基本的 RPC 框架，使用的 IO 方式为同步阻塞的 BIO 方式，也就是先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信。由于ServerSocket 的 accept（）方法是阻塞方法，也就是说  ServerSocket  在调用 accept（) 等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p>
<p>这种方式下有一个问题：每个请求都需要独立的线程完成数据read，业务处理，数据write的完整操作。 如下图所示：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\BIO.png" style="zoom:80%;">

<p><strong>问题：</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<p><strong>解决方式：</strong>因此我们创建了线程池，线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。</p>
<p>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的BIO模型的事实，因此无法从根本上解决问题。</p>
<p>为了解决上述的问题，Java 1.4 中引入了 NIO ，一种同步非阻塞的 I/O 模型。 </p>
<h2 id="1-2NIO模型介绍"><a href="#1-2NIO模型介绍" class="headerlink" title="1.2NIO模型介绍"></a>1.2NIO模型介绍</h2><p>NIO基于Reactor（事件驱动思想），当socket有流可读或可写入socket时，操作系统会相应的通知应用程序进行处理，应用再将流读取到缓冲区或写入操作系统。  也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>BIO与NIO一个比较重要的不同：<strong>我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，多个连接共用一个线程（也就是实现了线程的复用）。</strong></p>
<p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到<strong>多路复用器</strong>上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\NIO.png" style="zoom:80%;">

<p>但是这种模型下，当内核将数据准备好后，还是要客户端自行取得数据后，再对其进行处理。</p>
<h2 id="1-3AIO模型介绍"><a href="#1-3AIO模型介绍" class="headerlink" title="1.3AIO模型介绍"></a>1.3AIO模型介绍</h2><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 </p>
<p>相比于NIO，AIO才是完全的异步IO，因为只需要发送请求，当操作系统将数据拷贝到进程缓存后才向客户端发送信号，直接进行处理即可</p>
<h2 id="1-4三者比较"><a href="#1-4三者比较" class="headerlink" title="1.4三者比较"></a>1.4三者比较</h2><p>BIO：一个连接一个线程，[客户端]有连接请求时服务器端就需要启动一个线程进行处理。线程开销大。</p>
<p>伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。</p>
<p>NIO：一个请求一个线程，但[客户端]发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p>
<p>AIO：一个有效请求一个线程，[客户端]的I/O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理。</p>
<p><strong>但是由于使用同步非阻塞的I/O模型 NIO 来进行网络编程真的太麻烦了。因此选择使用基于 NIO 的网络编程框架 Netty 。</strong></p>
<h1 id="2-Netty-介绍（同步非阻塞）"><a href="#2-Netty-介绍（同步非阻塞）" class="headerlink" title="2.Netty 介绍（同步非阻塞）"></a>2.Netty 介绍（同步非阻塞）</h1><ol>
<li>Netty 是一个<strong>基于 NIO</strong> 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。 </li>
<li>它极大地简化并<strong>简化了 TCP 和 UDP 套接字服务器等网络编程</strong>,并且性能以及安全性等很多方面甚 至都要更好。</li>
<li><strong>支持多种协议</strong>如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。 </li>
</ol>
<p>用官方的总结就是：<strong>Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发，性能，稳定性和灵活性的方法。</strong></p>
<h1 id="3-Netty-特点"><a href="#3-Netty-特点" class="headerlink" title="3.Netty 特点"></a>3.Netty 特点</h1><ul>
<li>统一的 API，支持多种传输类型，阻塞和非阻塞的。 </li>
<li>简单而强大的线程模型。 </li>
<li>自带编解码器解决 TCP 粘包/拆包问题。 </li>
<li>自带各种协议栈。 </li>
<li>真正的无连接数据包套接字支持。</li>
<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。 </li>
<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。 </li>
<li>社区活跃。</li>
<li>成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty 比如我们经常接 触的 Dubbo、RocketMQ </li>
</ul>
<p>等等…..</p>
<h1 id="4-Netty-能做什么"><a href="#4-Netty-能做什么" class="headerlink" title="4.Netty 能做什么"></a>4.Netty 能做什么</h1><p>理论上 NIO 可以做的事情 ，使用 Netty 都可以做并且更好。</p>
<p>Netty 主要用来做网络通信：</p>
<ol>
<li><strong>作为 RPC 框架的网络通信工具 ：</strong> 我们在分布式系统中，不同服务节点之间经常需要相互调用， 这个时候就需要 RPC 框架了。不同服务之间的通信是如何做的呢？可以使用 Netty 来做。比如：我调用另外一个节点的方法的话，至少是要让对方知道我调用的是哪个类中的哪个方法以及相关参数吧！ </li>
<li><strong>实现一个自己的 HTTP 服务器 ：</strong>通过 Netty 我们可以自己实现一个简单的 HTTP 服务器，这个 大家应该不陌生。说到 HTTP 服务器的话，作为 Java 后端开发，我们一般使用 Tomcat 比较多。 一个最基本的 HTTP 服务器可要以处理常见的 HTTP Method 的请求，比如 POST 请求、GET 请 求等等。 </li>
<li><strong>实现一个即时通讯系统 ：</strong> 使用 Netty 我们可以实现一个可以聊天类似微信的即时通讯系统，这 方面的开源项目还蛮多的，可以自行去 Github 找一找。 </li>
<li><strong>消息推送系统 ：</strong>市面上有很多消息推送系统都是基于 Netty 来做的。 </li>
</ol>
<p>等等…..</p>
<h1 id="5-Netty-的核心组件"><a href="#5-Netty-的核心组件" class="headerlink" title="5.Netty 的核心组件"></a>5.Netty 的核心组件</h1><h2 id="5-1Channel"><a href="#5-1Channel" class="headerlink" title="5.1Channel"></a>5.1Channel</h2><p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，如 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 等。还包括了 Netty 框架相关的一些功能，如获取该 Channel 的 EventLoop。</p>
<p>比较常用的<code>Channel</code>接口实现类是<code>NioServerSocketChannel</code>（服务端）和<code>NioSocketChannel</code>（客户端），这两个 <code>Channel</code> 可以和 BIO 编程模型中的<code>ServerSocket</code>以及<code>Socket</code>两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 <code>API</code>，大大地降低了直接与 Socket 进行操作的复杂性。</p>
<h2 id="5-2EventLoop"><a href="#5-2EventLoop" class="headerlink" title="5.2EventLoop"></a>5.2EventLoop</h2><p>这么说吧！<code>EventLoop</code>（事件循环）接口可以说是 Netty 中最核心的概念了！</p>
<p>说白了，**<code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。**</p>
<p>为了说明Channel、EventLoop、Thread、EventLoopGroup之间的关系，我们可以看下图：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\eventloop.png" style="zoom:80%;">

<p>上图是一个服务端对 <code>EventLoopGroup</code> 使用的大致模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）。</p>
<p>从上图可以看出： 当客户端通过 <code>connect</code> 方法连接服务端时，<code>Boss EventloopGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>Worker EventloopGroup</code> 来处理，然后 <code>Worker EventloopGroup</code> 负责处理其 IO 相关操作。</p>
<p><strong>EventloopGroup 和 EventLoop 的关系：</strong></p>
<p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code></p>
<p><strong>EventLoop 和 Thread 的关系：</strong></p>
<p>每一个 <code>EventLoop</code> 通常内部包含一个线程，上面我们已经说了 <code>EventLoop</code> 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。 <code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 1 : 1 的关系，从而保证线程安全。</p>
<p><strong>那 Channel 和 EventLoop 的关系：</strong></p>
<p><code>Channel</code> 为 Netty 网络操作(读写等操作)抽象类，<code>EventLoop</code> 负责处理注册到其上的<code>Channel</code> 处理 I/O 操作，两者配合参与 I/O 操作。</p>
<ul>
<li>一个 Channel 在它的生命周期内只能注册与一个 EventLoop。</li>
<li>一个 EventLoop 可被分配至一个或多个 Channel 。</li>
</ul>
<p>当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。</p>
<h2 id="5-3ChannelFuture"><a href="#5-3ChannelFuture" class="headerlink" title="5.3ChannelFuture"></a>5.3ChannelFuture</h2><p>Netty 是异步非阻塞的，所有的 I/O 操作都为异步的。</p>
<p>因此，我们不能立刻得到操作是否执行成功，但是，你可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动触发返回结果。（异步）</p>
<p>并且，你还可以通过<code>ChannelFuture</code> 的 <code>channel()</code> 方法获取关联的<code>Channel</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; var1)</span></span>;</span><br><span class="line">     ......</span><br><span class="line"></span><br><span class="line">    <span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，我们还可以通过 <code>ChannelFuture</code> 接口的 <code>sync()</code>方法让异步的操作变成同步的。</p>
<h2 id="5-4ChannelHandler-和-ChannelPipeline"><a href="#5-4ChannelHandler-和-ChannelPipeline" class="headerlink" title="5.4ChannelHandler 和 ChannelPipeline"></a>5.4ChannelHandler 和 ChannelPipeline</h2><p><strong>ChannelHandler</strong> </p>
<p>ChannelHandler 是消息的具体处理器。他负责处理读写操作、客户端连接等事情。</p>
<p>ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</p>
<p>ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。</p>
<p><strong>ChannelPipeline</strong></p>
<p>ChannelPipeline 为 ChannelHandler 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。</p>
<p>我们可以在 ChannelPipeline 上通过 <code>addLast()</code> 方法添加一个或者多个 ChannelHandler ，因为一个数据或者事件可能会被多个 Handler 处理。当一个 ChannelHandler 处理完之后就将数据交给下一个 ChannelHandler 。</p>
<p>下面这段代码使用过 Netty 的小伙伴应该不会陌生，我们指定了序列化编解码器以及自定义的 <code>ChannelHandler</code> 处理消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.group(eventLoopGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoDecoder(kryoSerializer, RpcResponse.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> NettyKryoEncoder(kryoSerializer, RpcRequest.class));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> KryoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ChannelPipeline的工作流程如下图所示：</p>
<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\ChannelPipeline.png" style="zoom:80%;">

<p>当一个数据流进入 ChannlePipeline 时，它会从 ChannelPipeline 头部开始传给第一个 ChannelInboundHandler ，当第一个处理完后再传给下一个，一直传递到管道的尾部。与之相对应的是，当数据被写出时，它会从管道的尾部开始，先经过管道尾部的 “最后” 一个ChannelOutboundHandler，当它处理完成后会传递给前一个 ChannelOutboundHandler 。</p>
<p>当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，它代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。其中 ChannelHandler 添加到 ChannelPipeline 过程如下：</p>
<ol>
<li>一个 ChannelInitializer 的实现被注册到了 ServerBootStrap中</li>
<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler</li>
<li>ChannelInitializer 将它自己从 ChannelPipeline 中移除</li>
</ol>
<h2 id="5-5-Bootstrap-和-ServerBootstrap（不是核心组件）"><a href="#5-5-Bootstrap-和-ServerBootstrap（不是核心组件）" class="headerlink" title="5.5 Bootstrap 和 ServerBootstrap（不是核心组件）"></a>5.5 Bootstrap 和 ServerBootstrap（不是核心组件）</h2><p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，主要作用是配置整个Netty程序，串联各个组件。具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">//指定线程模型</span></span><br><span class="line">    b.group(group).</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// 尝试建立连接</span></span><br><span class="line">    ChannelFuture f = b.connect(host, port).sync();</span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 优雅关闭相关线程组资源</span></span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerBootstrap</code> 服务端的启动引导类/辅助类，具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">        ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">        b.group(bossGroup, workerGroup).</span><br><span class="line">               ......</span><br><span class="line">        <span class="comment">// 6.绑定端口</span></span><br><span class="line">        ChannelFuture f = b.bind(port).sync();</span><br><span class="line">        <span class="comment">// 等待连接关闭</span></span><br><span class="line">        f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//7.优雅关闭相关线程组资源</span></span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的示例中，我们可以看出：</p>
<ol>
<li><code>Bootstrap</code> 通常使用 <code>connet()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。另外，<code>Bootstrap</code> 也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端。</li>
<li><code>ServerBootstrap</code>通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接。</li>
<li><code>Bootstrap</code> 只需要配置一个线程组— <code>EventLoopGroup</code> ,而 <code>ServerBootstrap</code>需要配置两个线程组— <code>EventLoopGroup</code> ，一个用于接收连接，一个用于具体的处理。</li>
</ol>
<h1 id="6-NioEventLoopGroup-默认的构造函数会起多少线程"><a href="#6-NioEventLoopGroup-默认的构造函数会起多少线程" class="headerlink" title="6.NioEventLoopGroup 默认的构造函数会起多少线程"></a>6.NioEventLoopGroup 默认的构造函数会起多少线程</h1><p>NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的 EventLoopGroup 的实现用来处理不同传输协议。</p>
<p>回顾我们在上面写的服务器端的代码，服务端会创建两个线程组：</p>
<ol>
<li>bossGroup 用于接收连接</li>
<li>workerGroup 用于具体的处理</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>为了搞清楚<code>NioEventLoopGroup</code> 默认的构造函数 到底创建了多少个线程，我们来看一下它的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造函数。</span></span><br><span class="line"><span class="comment"> * nThreads:0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executor：null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继续调用下一个构造方法</span></span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间省略部分构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RejectedExecutionHandler（）：RejectedExecutionHandlers.reject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,<span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//开始调用父类的构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一直向下走下去的话，你会发现在 <code>MultithreadEventLoopGroup</code> 类中有相关的指定线程数的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从1，系统属性，CPU核心数*2 这三个值中取出一个最大的</span></span><br><span class="line"><span class="comment">//可以得出 DEFAULT_EVENT_LOOP_THREADS 的值为CPU核心数*2</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用的父类构造函数，NioEventLoopGroup 默认的构造函数会起多少线程的秘密所在</span></span><br><span class="line"><span class="comment">// 当指定的线程数nThreads为0时，使用默认的线程数DEFAULT_EVENT_LOOP_THREADS</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，我们发现 <code>NioEventLoopGroup</code> 默认的构造函数实际会起的线程数为 *<em>CPU核心数</em>2**。</p>
<p>另外，如果你继续深入下去看构造函数的话，你会发现每个<code>NioEventLoopGroup</code>对象内部都会分配一组<code>NioEventLoop</code>，其大小是 <code>nThreads</code>, 这样就构成了一个线程池， 一个<code>NIOEventLoop</code> 和一个线程相对应，这和我们上面说的 <code>EventloopGroup</code> 和 <code>EventLoop</code>关系这部分内容相对应。</p>
<h1 id="7-Netty-线程模型"><a href="#7-Netty-线程模型" class="headerlink" title="7.Netty 线程模型"></a>7.Netty 线程模型</h1><p>在 Netty 主要靠 <code>NioEventLoopGroup</code> 线程池来实现具体的线程模型的 。</p>
<p>我们实现服务端的时候，一般会初始化两个线程组：</p>
<ol>
<li><strong><code>bossGroup</code></strong> :接收连接。</li>
<li><strong><code>workerGroup</code></strong> ：负责具体的处理，交由对应的 Handler 处理。</li>
</ol>
<p>下面我们来详细看一下 Netty 中的线程模型吧！</p>
<p>1.<strong>单线程模型</strong> ：</p>
<p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。</p>
<p>对应到 Netty 代码是下面这样的</p>
<blockquote>
<p>使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。</span></span><br><span class="line">EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">          boobtstrap.group(eventGroup, eventGroup)</span><br><span class="line">          <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p>2.<strong>多线程模型</strong></p>
<p>一个 Acceptor 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p>
<p>对应到 Netty 代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\多线程模型.png" style="zoom:80%;">

<p><strong>3.主从多线程模型</strong></p>
<p>从一个 主线程 NIO 线程池中选择一个线程作为 Acceptor 线程，绑定监听端口，接收客户端连接的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">  ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">  <span class="comment">//3.给引导类配置两大线程组,确定了线程模型</span></span><br><span class="line">  b.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/03/%EF%BC%88%E4%B8%89%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Netty%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/GitHub\MyBlogs\source\_posts\2021-05-03-（三）RPC实现Netty网络通信\主从多线程模型.png" style="zoom:80%;">

<h1 id="8-Netty-实现网络通信"><a href="#8-Netty-实现网络通信" class="headerlink" title="8.Netty 实现网络通信"></a>8.Netty 实现网络通信</h1><h2 id="8-1在-pom-xml-中加入-Netty-依赖"><a href="#8-1在-pom-xml-中加入-Netty-依赖" class="headerlink" title="8.1在 pom.xml 中加入 Netty 依赖"></a>8.1在 pom.xml 中加入 Netty 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;netty-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-2-rpc-core-改写-Server-与-Client"><a href="#8-2-rpc-core-改写-Server-与-Client" class="headerlink" title="8.2 rpc-core 改写 Server 与 Client"></a>8.2 rpc-core 改写 Server 与 Client</h2><p>为了保证通用性，我们可以把 Server 和 Client 抽象成两个接口，分别是 RpcServer 和 RpcClient：</p>
<p><strong>RpcClient：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RpcServer：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketClient 实现 RpcClient 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClient.class);</span><br><span class="line">    <span class="comment">//客户端的地址和端口号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket(host, port)) &#123;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            objectOutputStream.writeObject(rpcRequest);</span><br><span class="line">            objectOutputStream.flush();</span><br><span class="line">            RpcResponse rpcResponse = (RpcResponse) objectInputStream.readObject();</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;服务调用失败，service：&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rpcResponse.getStatusCode() == <span class="keyword">null</span> || rpcResponse.getStatusCode() != ResponseCode.SUCCESS.getCode()) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;调用服务失败, service: &#123;&#125;, response:&#123;&#125;&quot;</span>, rpcRequest.getInterfaceName(), rpcResponse);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.SERVICE_INVOCATION_FAILURE, <span class="string">&quot; service:&quot;</span> + rpcRequest.getInterfaceName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;调用时有错误发生：&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;服务调用失败: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SocketServer 实现 RpcServer 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SocketServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLOCKING_QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService threadPool;</span><br><span class="line">    <span class="keyword">private</span> RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SocketServer</span><span class="params">(ServiceRegistry serviceRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(BLOCKING_QUEUE_CAPACITY);</span><br><span class="line">        ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br><span class="line">        threadPool = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workingQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器启动……&quot;</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span>((socket = serverSocket.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;消费者连接: &#123;&#125;:&#123;&#125;&quot;</span>, socket.getInetAddress(), socket.getPort());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> RequestHandlerThread(socket, requestHandler, serviceRegistry));</span><br><span class="line">            &#125;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;服务器启动时有错误发生:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一个改动，就是在 <code>DefaultServiceRegistry.java</code> 中，将包含注册信息的 serviceMap 和 registeredService 都改成了 static ，这样就能保证全局唯一的注册信息，并且在创建 RpcServer 时也就不需要传入了。==（为什么要变成静态的，跟原来的区别?）==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将属性serviceMap、registeredService变成静态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br><span class="line"><span class="comment">//变化后：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; serviceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; registeredService = ConcurrentHashMap.newKeySet();</span><br></pre></td></tr></table></figure>

<h2 id="8-3-rpc-core-实现-NettyServer"><a href="#8-3-rpc-core-实现-NettyServer" class="headerlink" title="8.3 rpc-core 实现 NettyServer"></a>8.3 rpc-core 实现 NettyServer</h2><p>1.首先创建了两个 <code>NioEventLoopGroup</code> 对象实例：<code>bossGroup</code> 和 <code>workerGroup</code>。</p>
<ul>
<li><code>bossGroup</code> : 用于处理客户端的 TCP 连接请求。</li>
<li><code>workerGroup</code> ： 负责每一条连接的具体读写数据的处理逻辑，真正负责 I/O 读写操作，交由对应的 Handler 处理。</li>
</ul>
<p>举个例子：我们把公司的老板当做 bossGroup，员工当做 workerGroup，bossGroup 在外面接完活之后，扔给 workerGroup 去处理。一般情况下我们会指定 bossGroup 的 线程数为 1（并发连接量不大的时候） ，workGroup 的线程数量为 <strong>CPU 核心数 *2</strong> 。另外，根据源码来看，使用 <code>NioEventLoopGroup</code> 类的无参构造函数设置线程数量的默认值就是 <strong>CPU 核心数 *2</strong> 。</p>
<p>2.接下来 我们创建了一个服务端启动引导/辅助类： <code>ServerBootstrap</code>，这个类将引导我们进行服务端的启动工作。</p>
<p>3.通过 <code>.group()</code> 方法给引导类 <code>ServerBootstrap</code> 配置两大线程组，确定了线程模型，这里我们使用的是多线程模型。</p>
<p>4.通过<code>channel()</code>方法给引导类 <code>ServerBootstrap</code>指定了 IO 模型为<code>NIO</code></p>
<ul>
<li><code>NioServerSocketChannel</code> ：指定服务端的 IO 模型为 NIO，与 BIO 编程模型中的<code>ServerSocket</code>对应</li>
<li><code>NioSocketChannel</code> : 指定客户端的 IO 模型为 NIO， 与 BIO 编程模型中的<code>Socket</code>对应</li>
</ul>
<p>5.通过调用<code>.childHandler()</code>方法给引导类创建一个<code>ChannelInitializer</code> ，然后指定了服务端消息的业务处理逻辑 <code>HelloServerHandler</code> 对象</p>
<p>Netty 中有一个很重要的设计模式——<strong>责任链模式</strong>，责任链上有多个处理器，每个处理器都会对数据进行加工，并将处理后的数据传给下一个处理器。代码中的 CommonEncoder、CommonDecoder和NettyServerHandler 分别就是编码器，解码器和数据处理器。因为数据从外部传入时需要解码，而传出时需要编码，类似计算机网络的分层模型，每一层向下层传递数据时都要加上该层的信息，而向上层传递时则需要对本层信息进行解码。</p>
<p>6.调用 <code>ServerBootstrap</code> 类的 <code>bind()</code>方法绑定端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">implements</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建两个线程组：bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//3.给引导类配置两大线程组,确定了线程模型（多线程模型）</span></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 4.指定 IO 模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// (非必备)打印日志</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    <span class="comment">//option()是提供给NioServerSocketChannel用来接收进来的连接</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">256</span>)</span><br><span class="line">                    .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//childOption()是提供给由父管道ServerChannel接收到的连接</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//5.可以自定义客户端消息的业务处理逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> CommonDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 6.绑定端口,调用 sync 方法阻塞直到绑定完成</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法)</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;启动服务器时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//8.优雅关闭相关线程组资源</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-rpc-core-实现-NettyClient"><a href="#8-4-rpc-core-实现-NettyClient" class="headerlink" title="8.4 rpc-core 实现 NettyClient"></a>8.4 rpc-core 实现 NettyClient</h2><p>客户端的创建流程：</p>
<p>1.创建一个 <code>NioEventLoopGroup</code> 对象实例</p>
<p>2.创建客户端启动的引导类是 <code>Bootstrap</code></p>
<p>3.通过 <code>.group()</code> 方法给引导类 <code>Bootstrap</code> 配置一个线程组</p>
<p>4.通过<code>channel()</code>方法给引导类 <code>Bootstrap</code>指定了 IO 模型为<code>NIO</code></p>
<p>5.通过 <code>.childHandler()</code>给引导类创建一个<code>ChannelInitializer</code> ，然后指定了客户端消息的业务处理逻辑 <code>HelloClientHandler</code> 对象</p>
<p>6.调用 <code>Bootstrap</code> 类的 <code>connect()</code>方法进行连接，这个方法需要指定两个参数：</p>
<ul>
<li><code>inetHost</code> : ip 地址</li>
<li><code>inetPort</code> : 端口号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.connect(InetSocketAddress.createUnresolved(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(SocketAddress remoteAddress)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(remoteAddress, <span class="string">&quot;remoteAddress&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.validate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doResolveAndConnect(remoteAddress, <span class="keyword">this</span>.config.localAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>connect</code> 方法返回的是一个 <code>Future</code> 类型的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFuture</span> <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功，进而打印出连接信息。具体做法很简单，只需要对代码进行以下改动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.connect(host, port).addListener(future -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).sync();</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">implements</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建一个 NioEventLoopGroup 对象实例</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动引导/辅助类：Bootstrap</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        <span class="comment">//3.指定线程组</span></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                <span class="comment">//4.指定 IO 模型</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">// 5.这里可以自定义消息的业务处理逻辑</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> CommonDecoder())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> CommonEncoder(<span class="keyword">new</span> JsonSerializer()))</span><br><span class="line">                                .addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6.尝试建立连接</span></span><br><span class="line">            ChannelFuture future = bootstrap.connect(host, port).sync();</span><br><span class="line">            logger.info(<span class="string">&quot;客户端连接到服务器 &#123;&#125;:&#123;&#125;&quot;</span>, host, port);</span><br><span class="line">            Channel channel = future.channel();</span><br><span class="line">            <span class="keyword">if</span>(channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.writeAndFlush(rpcRequest).addListener(future1 -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span>(future1.isSuccess()) &#123;</span><br><span class="line">                        logger.info(String.format(<span class="string">&quot;客户端发送消息: %s&quot;</span>, rpcRequest.toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, future1.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 7.等待连接关闭（阻塞，直到Channel关闭）</span></span><br><span class="line">                channel.closeFuture().sync();</span><br><span class="line">                AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">                RpcResponse rpcResponse = channel.attr(key).get();</span><br><span class="line">                <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送消息时有错误发生: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态代码块中就直接配置好了 Netty 客户端，等待发送数据时启动，channel 将 RpcRequest 对象写出，并且等待服务端返回的结果。注意这里的发送是非阻塞的，所以发送后会立刻返回，而无法得到结果。这里通过 AttributeKey 的方式阻塞获得返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">RpcResponse rpcResponse = channel.attr(key).get();</span><br></pre></td></tr></table></figure>

<p>通过这种方式获得全局可见的返回结果，在获得返回结果 RpcResponse 后，将这个对象以 key 为 rpcResponse 放入 ChannelHandlerContext 中，这里就可以立刻获得结果并返回，我们会在 NettyClientHandler 中看到放入的过程。</p>
<h2 id="8-5-rpc-core-自定义传输协议和编码、解码器"><a href="#8-5-rpc-core-自定义传输协议和编码、解码器" class="headerlink" title="8.5 rpc-core 自定义传输协议和编码、解码器"></a>8.5 rpc-core 自定义传输协议和编码、解码器</h2><p>在传输过程中，我们可以在发送的数据上加上各种必要的数据，形成自定义的协议，而自动加上这个数据就是编码器的工作，解析数据获得原始数据就是解码器的工作。</p>
<p>我们定义的协议是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|  Magic Number |  Package Type | Serializer Type | Data Length |</span><br><span class="line">|    4 bytes    |    4 bytes    |     4 bytes     |   4 bytes   |</span><br><span class="line">+---------------+---------------+-----------------+-------------+</span><br><span class="line">|                          Data Bytes                           |</span><br><span class="line">|                   Length: $&#123;Data Length&#125;                      |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>魔数（4 bytes）：</strong>魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li>
<li><strong>Package Type（4 bytes）：</strong>标明这是一个调用请求还是调用响应</li>
<li><strong>Serializer Type（4 bytes）：</strong>标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kyro 等序列化 方式。</li>
<li><strong>Data Length（4 bytes）：</strong>实际数据的长度，设置这个字段主要防止<strong>粘包</strong></li>
<li><strong>Data（Length: ${Data Length} ）：</strong>经过序列化后的实际数据，可能是 RpcRequest 也可能是 RpcResponse 经过序列化后的字节，取决于 Package Type。</li>
</ul>
<h2 id="8-6-rpc-core-编码器"><a href="#8-6-rpc-core-编码器" class="headerlink" title="8.6 rpc-core 编码器"></a>8.6 rpc-core 编码器</h2><p>CommonEncoder 继承了MessageToByteEncoder 类，见名知义，就是把 Message（实际要发送的对象）转化成 Byte 数组。CommonEncoder 的工作很简单，就是把 RpcRequest 或者 RpcResponse 包装成协议包。 根据上面提到的协议格式，将各个字段写到管道里就可以了，这里 serializer.getCode() 获取序列化器的编号，之后使用传入的序列化器将请求或响应包序列化为字节数组写入管道即可。</p>
<p><strong>CommonEncoder 编码器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CommonSerializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonEncoder</span><span class="params">(CommonSerializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.writeInt(MAGIC_NUMBER);</span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            out.writeInt(PackageType.REQUEST_PACK.getCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeInt(PackageType.RESPONSE_PACK.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        out.writeInt(serializer.getCode());</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serializer.serialize(msg);</span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-7-rpc-core-解码器"><a href="#8-7-rpc-core-解码器" class="headerlink" title="8.7 rpc-core 解码器"></a>8.7 rpc-core 解码器</h2><p>CommonDecoder 继承自 ReplayingDecoder ，与 MessageToByteEncoder 相反，它用于将收到的字节序列还原为实际对象。主要就是一些字段的校验，比较重要的就是取出序列化器的编号，以获得正确的反序列化方式，并且读入 length 字段来确定数据包的长度（防止粘包），最后读入正确大小的字节数组，反序列化成对应的对象。</p>
<p><strong>CommonDecoder 解码器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CommonDecoder.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAGIC_NUMBER = <span class="number">0xCAFEBABE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="keyword">if</span>(magic != MAGIC_NUMBER) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的协议包: &#123;&#125;&quot;</span>, magic);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PROTOCOL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> packageCode = in.readInt();</span><br><span class="line">        Class&lt;?&gt; packageClass;</span><br><span class="line">        <span class="keyword">if</span>(packageCode == PackageType.REQUEST_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcRequest.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;</span><br><span class="line">            packageClass = RpcResponse.class;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的数据包: &#123;&#125;&quot;</span>, packageCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_PACKAGE_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> serializerCode = in.readInt();</span><br><span class="line">        CommonSerializer serializer = CommonSerializer.getByCode(serializerCode);</span><br><span class="line">        <span class="keyword">if</span>(serializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;不识别的反序列化器: &#123;&#125;&quot;</span>, serializerCode);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcError.UNKNOWN_SERIALIZER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        Object obj = serializer.deserialize(bytes, packageClass);</span><br><span class="line">        out.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-8-rpc-core-序列化接口"><a href="#8-8-rpc-core-序列化接口" class="headerlink" title="8.8 rpc-core 序列化接口"></a>8.8 rpc-core 序列化接口</h2><p>序列化器接口（<code>CommonSerializer</code>）如下：</p>
<p>主要就是四个方法，序列化，反序列化，获得该序列化器的编号，已经根据编号获取序列化器，这里我已经写了一个示例的 JSON 序列化器，Kryo 序列化器会在后面讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(Object obj);</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CommonSerializer <span class="title">getByCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonSerializer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 的序列化器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerializer</span> <span class="keyword">implements</span> <span class="title">CommonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonSerializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.writeValueAsBytes(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object obj = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">                obj = handleRequest(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;反序列化时有错误发生: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里由于使用JSON序列化和反序列化Object数组，无法保证反序列化后仍然为原实例类型</span></span><br><span class="line"><span class="comment">        需要重新判断处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handleRequest</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将要反序列化的对象obj传入</span></span><br><span class="line">        RpcRequest rpcRequest = (RpcRequest) obj;</span><br><span class="line">        <span class="comment">//遍历参数的类型数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;</span><br><span class="line">            <span class="comment">//获取参数的类信息</span></span><br><span class="line">            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];</span><br><span class="line">            <span class="comment">//isAssignableFrom判断参数类型和反序列化后的参数类型是否匹配（不匹配说明反序列化有问题）</span></span><br><span class="line">            <span class="keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParameters()[i].getClass())) &#123;</span><br><span class="line">                <span class="comment">//把rpcRequest.getParameters()[i]转成json序列，并把结果输出成字节数组</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = objectMapper.writeValueAsBytes(rpcRequest.getParameters()[i]);</span><br><span class="line">                <span class="comment">//将不正确的参数，转换成 clazz 类的 Java 类型</span></span><br><span class="line">                rpcRequest.getParameters()[i] = objectMapper.readValue(bytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SerializerCode.valueOf(<span class="string">&quot;JSON&quot;</span>).getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 序列化工具我使用的是 Jackson，在 pom.xml 中添加依赖即可。序列化和反序列化都比较循规蹈矩，把对象翻译成字节数组，和根据字节数组和 Class 反序列化成对象。这里有一个需要注意的点，就是在 RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象，这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化，这就是 handleRequest() 方法的作用。</p>
<p>上面提到的这种情况不会在其他序列化方式中出现，因为其他序列化方式是转换成字节数组，会记录对象的信息，而 JSON 方式本质上只是转换成 JSON 字符串，会丢失对象的类型信息。</p>
<blockquote>
<p>注：isAssignableFrom方法</p>
<p>有两个Class类型的类象，一个是调用isAssignableFrom方法的类对象（后称对象a），以及方法中作为参数的这个类对象（称之为对象b），这两个对象如果满足以下条件则返回true，否则返回false：</p>
<ul>
<li>a对象所对应类信息是b对象所对应的类信息的父类或者是父接口，简单理解即a是b的父类或接口</li>
<li>a对象所对应类信息与b对象所对应的类信息相同，简单理解即a和b为同一个类或同一个接口</li>
</ul>
</blockquote>
<blockquote>
<p>注：ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。</p>
<p><strong>序列化：</strong>ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</p>
<ul>
<li>writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</li>
<li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</li>
<li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</li>
<li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</li>
</ul>
<p><strong>反序列化：</strong></p>
<ul>
<li><p>readValue() 方法：将 json 数据源转换成指定格式的 Java 类型</p>
<p>第一个参数是JSON数据源(字符串, 流或者文件), 第二个参数是解析目标Java类</p>
</li>
</ul>
</blockquote>
<h2 id="8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler"><a href="#8-9-rpc-core-创建-NettyServerHandler-和-NettyClientHandler" class="headerlink" title="8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler"></a>8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler</h2><p>NettyServerHandler 和 NettyClientHandler 都分别位于服务器端和客户端责任链的尾部，直接和 RpcServer 对象或 RpcClient 对象打交道，而无需关心字节序列的情况。</p>
<p><strong>NettyServerhandler</strong> 用于接收 RpcRequest，并且执行调用，将调用结果返回封装成 RpcResponse 发送出去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestHandler requestHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        requestHandler = <span class="keyword">new</span> RequestHandler();</span><br><span class="line">        serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;服务器接收到请求: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">            String interfaceName = msg.getInterfaceName();</span><br><span class="line">            Object service = serviceRegistry.getService(interfaceName);</span><br><span class="line">            Object result = requestHandler.handle(msg, service);</span><br><span class="line">            ChannelFuture future = ctx.writeAndFlush(RpcResponse.success(result));</span><br><span class="line">            future.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;处理过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler</strong> 用于接收 RpcResponse</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponse</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClientHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponse msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(String.format(<span class="string">&quot;客户端接收到消息: %s&quot;</span>, msg));</span><br><span class="line">            AttributeKey&lt;RpcResponse&gt; key = AttributeKey.valueOf(<span class="string">&quot;rpcResponse&quot;</span>);</span><br><span class="line">            ctx.channel().attr(key).set(msg);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;过程调用时有错误发生:&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-10-修改代理类-RpcClientProxy"><a href="#8-10-修改代理类-RpcClientProxy" class="headerlink" title="8.10 修改代理类 RpcClientProxy"></a>8.10 修改代理类 RpcClientProxy</h2><p>RpcClientProxy 通过传入不同的 Client（SocketClient、NettyClient）来切换客户端不同的发送方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClientProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RpcClientProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient client;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcClientProxy</span><span class="params">(RpcClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;调用方法: &#123;&#125;#&#123;&#125;&quot;</span>, method.getDeclaringClass().getName(), method.getName());</span><br><span class="line"></span><br><span class="line">        RpcRequest rpcRequest = <span class="keyword">new</span> RpcRequest(method.getDeclaringClass().getName(),</span><br><span class="line">                method.getName(), args, method.getParameterTypes());</span><br><span class="line">        <span class="keyword">return</span> client.sendRequest(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-11测试"><a href="#8-11测试" class="headerlink" title="8.11测试"></a>8.11测试</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>SocketTestClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketClient client = <span class="keyword">new</span> SocketClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = proxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyTestClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RpcClient client = <span class="keyword">new</span> NettyClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        RpcClientProxy rpcClientProxy = <span class="keyword">new</span> RpcClientProxy(client);</span><br><span class="line">        HelloService helloService = rpcClientProxy.getProxy(HelloService.class);</span><br><span class="line">        HelloObject object = <span class="keyword">new</span> HelloObject(<span class="number">12</span>, <span class="string">&quot;This is a message&quot;</span>);</span><br><span class="line">        String res = helloService.hello(object);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><strong>SocketTestServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry serviceRegistry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        serviceRegistry.register(helloService);</span><br><span class="line">        SocketServer socketServer = <span class="keyword">new</span> SocketServer(serviceRegistry);</span><br><span class="line">        socketServer.start(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyTestServer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        ServiceRegistry registry = <span class="keyword">new</span> DefaultServiceRegistry();</span><br><span class="line">        registry.register(helloService);</span><br><span class="line">        NettyServer server = <span class="keyword">new</span> NettyServer();</span><br><span class="line">        server.start(<span class="number">9999</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>


    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢阅读-------------</div>
    
</div>

  
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RPC%E9%A1%B9%E7%9B%AE/" rel="tag"><i class="fa fa-tag"></i>  RPC项目</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/03/%EF%BC%88%E4%BA%8C%EF%BC%89RPC%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1/" rel="prev" title="（二）RPC实现注册多个服务">
      <i class="fa fa-chevron-left"></i> （二）RPC实现注册多个服务
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/06/%EF%BC%88%E5%9B%9B%EF%BC%89RPC%E5%AE%9E%E7%8E%B0Kryo%E5%BA%8F%E5%88%97%E5%8C%96/" rel="next" title="（四）RPC实现Kryo序列化">
      （四）RPC实现Kryo序列化 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-BIO%E3%80%81NIO%E4%B8%8EAIO"><span class="nav-number">1.</span> <span class="nav-text">1.BIO、NIO与AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1BIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">1.1BIO模型介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2NIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.</span> <span class="nav-text">1.2NIO模型介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3AIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.</span> <span class="nav-text">1.3AIO模型介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4%E4%B8%89%E8%80%85%E6%AF%94%E8%BE%83"><span class="nav-number">1.4.</span> <span class="nav-text">1.4三者比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Netty-%E4%BB%8B%E7%BB%8D%EF%BC%88%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">2.Netty 介绍（同步非阻塞）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Netty-%E7%89%B9%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">3.Netty 特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Netty-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">4.</span> <span class="nav-text">4.Netty 能做什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Netty-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">5.Netty 的核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1Channel"><span class="nav-number">5.1.</span> <span class="nav-text">5.1Channel</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2EventLoop"><span class="nav-number">5.2.</span> <span class="nav-text">5.2EventLoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3ChannelFuture"><span class="nav-number">5.3.</span> <span class="nav-text">5.3ChannelFuture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4ChannelHandler-%E5%92%8C-ChannelPipeline"><span class="nav-number">5.4.</span> <span class="nav-text">5.4ChannelHandler 和 ChannelPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-Bootstrap-%E5%92%8C-ServerBootstrap%EF%BC%88%E4%B8%8D%E6%98%AF%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 Bootstrap 和 ServerBootstrap（不是核心组件）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-NioEventLoopGroup-%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BC%9A%E8%B5%B7%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">6.NioEventLoopGroup 默认的构造函数会起多少线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">7.Netty 线程模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Netty-%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-number">8.</span> <span class="nav-text">8.Netty 实现网络通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1%E5%9C%A8-pom-xml-%E4%B8%AD%E5%8A%A0%E5%85%A5-Netty-%E4%BE%9D%E8%B5%96"><span class="nav-number">8.1.</span> <span class="nav-text">8.1在 pom.xml 中加入 Netty 依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-rpc-core-%E6%94%B9%E5%86%99-Server-%E4%B8%8E-Client"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 rpc-core 改写 Server 与 Client</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-rpc-core-%E5%AE%9E%E7%8E%B0-NettyServer"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 rpc-core 实现 NettyServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-rpc-core-%E5%AE%9E%E7%8E%B0-NettyClient"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 rpc-core 实现 NettyClient</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-rpc-core-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%BC%96%E7%A0%81%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 rpc-core 自定义传输协议和编码、解码器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-rpc-core-%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 rpc-core 编码器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-rpc-core-%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">8.7.</span> <span class="nav-text">8.7 rpc-core 解码器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-8-rpc-core-%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.8.</span> <span class="nav-text">8.8 rpc-core 序列化接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-9-rpc-core-%E5%88%9B%E5%BB%BA-NettyServerHandler-%E5%92%8C-NettyClientHandler"><span class="nav-number">8.9.</span> <span class="nav-text">8.9 rpc-core 创建 NettyServerHandler 和 NettyClientHandler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-10-%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%90%86%E7%B1%BB-RpcClientProxy"><span class="nav-number">8.10.</span> <span class="nav-text">8.10 修改代理类 RpcClientProxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-11%E6%B5%8B%E8%AF%95"><span class="nav-number">8.11.</span> <span class="nav-text">8.11测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">8.11.1.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">8.11.2.</span> <span class="nav-text">服务端</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->
      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="老王家的小王呀"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">老王家的小王呀</p>
  <div class="site-description" itemprop="description">及时当勉励，岁月不待人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wangjin1996219" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangjin1996219" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:759161269@qq.com" title="E-Mail → mailto:759161269@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=569200212&auto=0&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王进</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">912k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:49</span>

</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
   本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-meta-divider">|</span>
<i class="fa fa-eye"></i><span id="busuanzi_container_site_pv">
        本站访问量:<span id="busuanzi_value_site_pv"></span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'pQCeFPCYCP9sz6YcISYlyUqk-gzGzoHsz',
      appKey     : 'RwrssV7QwO3le9kYtuScKNyD',
      placeholder: "评论一句，前排打call~",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"symbols_count_time":null,"symbols":true,"time":false,"total_symbols":true,"total_time":false,"log":false});</script></body>
</html>
<!-- ҳ������С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
